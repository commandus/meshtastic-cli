// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meshtastic/deviceonly.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fdeviceonly_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fdeviceonly_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "meshtastic/channel.pb.h"
#include "meshtastic/config.pb.h"
#include "meshtastic/localonly.pb.h"
#include "meshtastic/mesh.pb.h"
#include "meshtastic/telemetry.pb.h"
#include "nanopb.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_meshtastic_2fdeviceonly_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_meshtastic_2fdeviceonly_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_meshtastic_2fdeviceonly_2eproto;
namespace meshtastic {
class BackupPreferences;
struct BackupPreferencesDefaultTypeInternal;
extern BackupPreferencesDefaultTypeInternal _BackupPreferences_default_instance_;
class ChannelFile;
struct ChannelFileDefaultTypeInternal;
extern ChannelFileDefaultTypeInternal _ChannelFile_default_instance_;
class DeviceState;
struct DeviceStateDefaultTypeInternal;
extern DeviceStateDefaultTypeInternal _DeviceState_default_instance_;
class NodeDatabase;
struct NodeDatabaseDefaultTypeInternal;
extern NodeDatabaseDefaultTypeInternal _NodeDatabase_default_instance_;
class NodeInfoLite;
struct NodeInfoLiteDefaultTypeInternal;
extern NodeInfoLiteDefaultTypeInternal _NodeInfoLite_default_instance_;
class PositionLite;
struct PositionLiteDefaultTypeInternal;
extern PositionLiteDefaultTypeInternal _PositionLite_default_instance_;
class UserLite;
struct UserLiteDefaultTypeInternal;
extern UserLiteDefaultTypeInternal _UserLite_default_instance_;
}  // namespace meshtastic
PROTOBUF_NAMESPACE_OPEN
template<> ::meshtastic::BackupPreferences* Arena::CreateMaybeMessage<::meshtastic::BackupPreferences>(Arena*);
template<> ::meshtastic::ChannelFile* Arena::CreateMaybeMessage<::meshtastic::ChannelFile>(Arena*);
template<> ::meshtastic::DeviceState* Arena::CreateMaybeMessage<::meshtastic::DeviceState>(Arena*);
template<> ::meshtastic::NodeDatabase* Arena::CreateMaybeMessage<::meshtastic::NodeDatabase>(Arena*);
template<> ::meshtastic::NodeInfoLite* Arena::CreateMaybeMessage<::meshtastic::NodeInfoLite>(Arena*);
template<> ::meshtastic::PositionLite* Arena::CreateMaybeMessage<::meshtastic::PositionLite>(Arena*);
template<> ::meshtastic::UserLite* Arena::CreateMaybeMessage<::meshtastic::UserLite>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace meshtastic {

// ===================================================================

class PositionLite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.PositionLite) */ {
 public:
  inline PositionLite() : PositionLite(nullptr) {}
  ~PositionLite() override;
  explicit PROTOBUF_CONSTEXPR PositionLite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionLite(const PositionLite& from);
  PositionLite(PositionLite&& from) noexcept
    : PositionLite() {
    *this = ::std::move(from);
  }

  inline PositionLite& operator=(const PositionLite& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionLite& operator=(PositionLite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionLite& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionLite* internal_default_instance() {
    return reinterpret_cast<const PositionLite*>(
               &_PositionLite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PositionLite& a, PositionLite& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionLite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionLite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionLite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionLite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionLite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PositionLite& from) {
    PositionLite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionLite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.PositionLite";
  }
  protected:
  explicit PositionLite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeIFieldNumber = 1,
    kLongitudeIFieldNumber = 2,
    kAltitudeFieldNumber = 3,
    kTimeFieldNumber = 4,
    kLocationSourceFieldNumber = 5,
  };
  // sfixed32 latitude_i = 1;
  void clear_latitude_i();
  int32_t latitude_i() const;
  void set_latitude_i(int32_t value);
  private:
  int32_t _internal_latitude_i() const;
  void _internal_set_latitude_i(int32_t value);
  public:

  // sfixed32 longitude_i = 2;
  void clear_longitude_i();
  int32_t longitude_i() const;
  void set_longitude_i(int32_t value);
  private:
  int32_t _internal_longitude_i() const;
  void _internal_set_longitude_i(int32_t value);
  public:

  // int32 altitude = 3;
  void clear_altitude();
  int32_t altitude() const;
  void set_altitude(int32_t value);
  private:
  int32_t _internal_altitude() const;
  void _internal_set_altitude(int32_t value);
  public:

  // fixed32 time = 4;
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // .meshtastic.Position.LocSource location_source = 5;
  void clear_location_source();
  ::meshtastic::Position_LocSource location_source() const;
  void set_location_source(::meshtastic::Position_LocSource value);
  private:
  ::meshtastic::Position_LocSource _internal_location_source() const;
  void _internal_set_location_source(::meshtastic::Position_LocSource value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.PositionLite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t latitude_i_;
    int32_t longitude_i_;
    int32_t altitude_;
    uint32_t time_;
    int location_source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};
// -------------------------------------------------------------------

class UserLite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.UserLite) */ {
 public:
  inline UserLite() : UserLite(nullptr) {}
  ~UserLite() override;
  explicit PROTOBUF_CONSTEXPR UserLite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLite(const UserLite& from);
  UserLite(UserLite&& from) noexcept
    : UserLite() {
    *this = ::std::move(from);
  }

  inline UserLite& operator=(const UserLite& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLite& operator=(UserLite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLite& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLite* internal_default_instance() {
    return reinterpret_cast<const UserLite*>(
               &_UserLite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserLite& a, UserLite& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLite& from) {
    UserLite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.UserLite";
  }
  protected:
  explicit UserLite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacaddrFieldNumber = 1,
    kLongNameFieldNumber = 2,
    kShortNameFieldNumber = 3,
    kPublicKeyFieldNumber = 7,
    kHwModelFieldNumber = 4,
    kRoleFieldNumber = 6,
    kIsLicensedFieldNumber = 5,
    kIsUnmessagableFieldNumber = 9,
  };
  // bytes macaddr = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_macaddr();
  PROTOBUF_DEPRECATED const std::string& macaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_macaddr(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_macaddr();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_macaddr();
  PROTOBUF_DEPRECATED void set_allocated_macaddr(std::string* macaddr);
  private:
  const std::string& _internal_macaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_macaddr(const std::string& value);
  std::string* _internal_mutable_macaddr();
  public:

  // string long_name = 2;
  void clear_long_name();
  const std::string& long_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_long_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_long_name();
  PROTOBUF_NODISCARD std::string* release_long_name();
  void set_allocated_long_name(std::string* long_name);
  private:
  const std::string& _internal_long_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_long_name(const std::string& value);
  std::string* _internal_mutable_long_name();
  public:

  // string short_name = 3;
  void clear_short_name();
  const std::string& short_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_short_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_short_name();
  PROTOBUF_NODISCARD std::string* release_short_name();
  void set_allocated_short_name(std::string* short_name);
  private:
  const std::string& _internal_short_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_short_name(const std::string& value);
  std::string* _internal_mutable_short_name();
  public:

  // bytes public_key = 7;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // .meshtastic.HardwareModel hw_model = 4;
  void clear_hw_model();
  ::meshtastic::HardwareModel hw_model() const;
  void set_hw_model(::meshtastic::HardwareModel value);
  private:
  ::meshtastic::HardwareModel _internal_hw_model() const;
  void _internal_set_hw_model(::meshtastic::HardwareModel value);
  public:

  // .meshtastic.Config.DeviceConfig.Role role = 6;
  void clear_role();
  ::meshtastic::Config_DeviceConfig_Role role() const;
  void set_role(::meshtastic::Config_DeviceConfig_Role value);
  private:
  ::meshtastic::Config_DeviceConfig_Role _internal_role() const;
  void _internal_set_role(::meshtastic::Config_DeviceConfig_Role value);
  public:

  // bool is_licensed = 5;
  void clear_is_licensed();
  bool is_licensed() const;
  void set_is_licensed(bool value);
  private:
  bool _internal_is_licensed() const;
  void _internal_set_is_licensed(bool value);
  public:

  // optional bool is_unmessagable = 9;
  bool has_is_unmessagable() const;
  private:
  bool _internal_has_is_unmessagable() const;
  public:
  void clear_is_unmessagable();
  bool is_unmessagable() const;
  void set_is_unmessagable(bool value);
  private:
  bool _internal_is_unmessagable() const;
  void _internal_set_is_unmessagable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.UserLite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macaddr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr long_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr short_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    int hw_model_;
    int role_;
    bool is_licensed_;
    bool is_unmessagable_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};
// -------------------------------------------------------------------

class NodeInfoLite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.NodeInfoLite) */ {
 public:
  inline NodeInfoLite() : NodeInfoLite(nullptr) {}
  ~NodeInfoLite() override;
  explicit PROTOBUF_CONSTEXPR NodeInfoLite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfoLite(const NodeInfoLite& from);
  NodeInfoLite(NodeInfoLite&& from) noexcept
    : NodeInfoLite() {
    *this = ::std::move(from);
  }

  inline NodeInfoLite& operator=(const NodeInfoLite& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoLite& operator=(NodeInfoLite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfoLite& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfoLite* internal_default_instance() {
    return reinterpret_cast<const NodeInfoLite*>(
               &_NodeInfoLite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NodeInfoLite& a, NodeInfoLite& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfoLite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoLite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfoLite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfoLite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfoLite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeInfoLite& from) {
    NodeInfoLite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfoLite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.NodeInfoLite";
  }
  protected:
  explicit NodeInfoLite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 2,
    kPositionFieldNumber = 3,
    kDeviceMetricsFieldNumber = 6,
    kNumFieldNumber = 1,
    kSnrFieldNumber = 4,
    kLastHeardFieldNumber = 5,
    kChannelFieldNumber = 7,
    kHopsAwayFieldNumber = 9,
    kViaMqttFieldNumber = 8,
    kIsFavoriteFieldNumber = 10,
    kIsIgnoredFieldNumber = 11,
    kNextHopFieldNumber = 12,
    kBitfieldFieldNumber = 13,
  };
  // .meshtastic.UserLite user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::meshtastic::UserLite& user() const;
  PROTOBUF_NODISCARD ::meshtastic::UserLite* release_user();
  ::meshtastic::UserLite* mutable_user();
  void set_allocated_user(::meshtastic::UserLite* user);
  private:
  const ::meshtastic::UserLite& _internal_user() const;
  ::meshtastic::UserLite* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::meshtastic::UserLite* user);
  ::meshtastic::UserLite* unsafe_arena_release_user();

  // .meshtastic.PositionLite position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::meshtastic::PositionLite& position() const;
  PROTOBUF_NODISCARD ::meshtastic::PositionLite* release_position();
  ::meshtastic::PositionLite* mutable_position();
  void set_allocated_position(::meshtastic::PositionLite* position);
  private:
  const ::meshtastic::PositionLite& _internal_position() const;
  ::meshtastic::PositionLite* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::meshtastic::PositionLite* position);
  ::meshtastic::PositionLite* unsafe_arena_release_position();

  // .meshtastic.DeviceMetrics device_metrics = 6;
  bool has_device_metrics() const;
  private:
  bool _internal_has_device_metrics() const;
  public:
  void clear_device_metrics();
  const ::meshtastic::DeviceMetrics& device_metrics() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceMetrics* release_device_metrics();
  ::meshtastic::DeviceMetrics* mutable_device_metrics();
  void set_allocated_device_metrics(::meshtastic::DeviceMetrics* device_metrics);
  private:
  const ::meshtastic::DeviceMetrics& _internal_device_metrics() const;
  ::meshtastic::DeviceMetrics* _internal_mutable_device_metrics();
  public:
  void unsafe_arena_set_allocated_device_metrics(
      ::meshtastic::DeviceMetrics* device_metrics);
  ::meshtastic::DeviceMetrics* unsafe_arena_release_device_metrics();

  // uint32 num = 1;
  void clear_num();
  uint32_t num() const;
  void set_num(uint32_t value);
  private:
  uint32_t _internal_num() const;
  void _internal_set_num(uint32_t value);
  public:

  // float snr = 4;
  void clear_snr();
  float snr() const;
  void set_snr(float value);
  private:
  float _internal_snr() const;
  void _internal_set_snr(float value);
  public:

  // fixed32 last_heard = 5;
  void clear_last_heard();
  uint32_t last_heard() const;
  void set_last_heard(uint32_t value);
  private:
  uint32_t _internal_last_heard() const;
  void _internal_set_last_heard(uint32_t value);
  public:

  // uint32 channel = 7;
  void clear_channel();
  uint32_t channel() const;
  void set_channel(uint32_t value);
  private:
  uint32_t _internal_channel() const;
  void _internal_set_channel(uint32_t value);
  public:

  // optional uint32 hops_away = 9;
  bool has_hops_away() const;
  private:
  bool _internal_has_hops_away() const;
  public:
  void clear_hops_away();
  uint32_t hops_away() const;
  void set_hops_away(uint32_t value);
  private:
  uint32_t _internal_hops_away() const;
  void _internal_set_hops_away(uint32_t value);
  public:

  // bool via_mqtt = 8;
  void clear_via_mqtt();
  bool via_mqtt() const;
  void set_via_mqtt(bool value);
  private:
  bool _internal_via_mqtt() const;
  void _internal_set_via_mqtt(bool value);
  public:

  // bool is_favorite = 10;
  void clear_is_favorite();
  bool is_favorite() const;
  void set_is_favorite(bool value);
  private:
  bool _internal_is_favorite() const;
  void _internal_set_is_favorite(bool value);
  public:

  // bool is_ignored = 11;
  void clear_is_ignored();
  bool is_ignored() const;
  void set_is_ignored(bool value);
  private:
  bool _internal_is_ignored() const;
  void _internal_set_is_ignored(bool value);
  public:

  // uint32 next_hop = 12;
  void clear_next_hop();
  uint32_t next_hop() const;
  void set_next_hop(uint32_t value);
  private:
  uint32_t _internal_next_hop() const;
  void _internal_set_next_hop(uint32_t value);
  public:

  // uint32 bitfield = 13;
  void clear_bitfield();
  uint32_t bitfield() const;
  void set_bitfield(uint32_t value);
  private:
  uint32_t _internal_bitfield() const;
  void _internal_set_bitfield(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.NodeInfoLite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::meshtastic::UserLite* user_;
    ::meshtastic::PositionLite* position_;
    ::meshtastic::DeviceMetrics* device_metrics_;
    uint32_t num_;
    float snr_;
    uint32_t last_heard_;
    uint32_t channel_;
    uint32_t hops_away_;
    bool via_mqtt_;
    bool is_favorite_;
    bool is_ignored_;
    uint32_t next_hop_;
    uint32_t bitfield_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};
// -------------------------------------------------------------------

class DeviceState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.DeviceState) */ {
 public:
  inline DeviceState() : DeviceState(nullptr) {}
  ~DeviceState() override;
  explicit PROTOBUF_CONSTEXPR DeviceState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceState(const DeviceState& from);
  DeviceState(DeviceState&& from) noexcept
    : DeviceState() {
    *this = ::std::move(from);
  }

  inline DeviceState& operator=(const DeviceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceState& operator=(DeviceState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceState& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceState* internal_default_instance() {
    return reinterpret_cast<const DeviceState*>(
               &_DeviceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeviceState& a, DeviceState& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceState& from) {
    DeviceState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.DeviceState";
  }
  protected:
  explicit DeviceState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiveQueueFieldNumber = 5,
    kNodeRemoteHardwarePinsFieldNumber = 13,
    kMyNodeFieldNumber = 2,
    kOwnerFieldNumber = 3,
    kRxTextMessageFieldNumber = 7,
    kRxWaypointFieldNumber = 12,
    kVersionFieldNumber = 8,
    kNoSaveFieldNumber = 9,
    kDidGpsResetFieldNumber = 11,
  };
  // repeated .meshtastic.MeshPacket receive_queue = 5;
  int receive_queue_size() const;
  private:
  int _internal_receive_queue_size() const;
  public:
  void clear_receive_queue();
  ::meshtastic::MeshPacket* mutable_receive_queue(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::MeshPacket >*
      mutable_receive_queue();
  private:
  const ::meshtastic::MeshPacket& _internal_receive_queue(int index) const;
  ::meshtastic::MeshPacket* _internal_add_receive_queue();
  public:
  const ::meshtastic::MeshPacket& receive_queue(int index) const;
  ::meshtastic::MeshPacket* add_receive_queue();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::MeshPacket >&
      receive_queue() const;

  // repeated .meshtastic.NodeRemoteHardwarePin node_remote_hardware_pins = 13;
  int node_remote_hardware_pins_size() const;
  private:
  int _internal_node_remote_hardware_pins_size() const;
  public:
  void clear_node_remote_hardware_pins();
  ::meshtastic::NodeRemoteHardwarePin* mutable_node_remote_hardware_pins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin >*
      mutable_node_remote_hardware_pins();
  private:
  const ::meshtastic::NodeRemoteHardwarePin& _internal_node_remote_hardware_pins(int index) const;
  ::meshtastic::NodeRemoteHardwarePin* _internal_add_node_remote_hardware_pins();
  public:
  const ::meshtastic::NodeRemoteHardwarePin& node_remote_hardware_pins(int index) const;
  ::meshtastic::NodeRemoteHardwarePin* add_node_remote_hardware_pins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin >&
      node_remote_hardware_pins() const;

  // .meshtastic.MyNodeInfo my_node = 2;
  bool has_my_node() const;
  private:
  bool _internal_has_my_node() const;
  public:
  void clear_my_node();
  const ::meshtastic::MyNodeInfo& my_node() const;
  PROTOBUF_NODISCARD ::meshtastic::MyNodeInfo* release_my_node();
  ::meshtastic::MyNodeInfo* mutable_my_node();
  void set_allocated_my_node(::meshtastic::MyNodeInfo* my_node);
  private:
  const ::meshtastic::MyNodeInfo& _internal_my_node() const;
  ::meshtastic::MyNodeInfo* _internal_mutable_my_node();
  public:
  void unsafe_arena_set_allocated_my_node(
      ::meshtastic::MyNodeInfo* my_node);
  ::meshtastic::MyNodeInfo* unsafe_arena_release_my_node();

  // .meshtastic.User owner = 3;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const ::meshtastic::User& owner() const;
  PROTOBUF_NODISCARD ::meshtastic::User* release_owner();
  ::meshtastic::User* mutable_owner();
  void set_allocated_owner(::meshtastic::User* owner);
  private:
  const ::meshtastic::User& _internal_owner() const;
  ::meshtastic::User* _internal_mutable_owner();
  public:
  void unsafe_arena_set_allocated_owner(
      ::meshtastic::User* owner);
  ::meshtastic::User* unsafe_arena_release_owner();

  // .meshtastic.MeshPacket rx_text_message = 7;
  bool has_rx_text_message() const;
  private:
  bool _internal_has_rx_text_message() const;
  public:
  void clear_rx_text_message();
  const ::meshtastic::MeshPacket& rx_text_message() const;
  PROTOBUF_NODISCARD ::meshtastic::MeshPacket* release_rx_text_message();
  ::meshtastic::MeshPacket* mutable_rx_text_message();
  void set_allocated_rx_text_message(::meshtastic::MeshPacket* rx_text_message);
  private:
  const ::meshtastic::MeshPacket& _internal_rx_text_message() const;
  ::meshtastic::MeshPacket* _internal_mutable_rx_text_message();
  public:
  void unsafe_arena_set_allocated_rx_text_message(
      ::meshtastic::MeshPacket* rx_text_message);
  ::meshtastic::MeshPacket* unsafe_arena_release_rx_text_message();

  // .meshtastic.MeshPacket rx_waypoint = 12;
  bool has_rx_waypoint() const;
  private:
  bool _internal_has_rx_waypoint() const;
  public:
  void clear_rx_waypoint();
  const ::meshtastic::MeshPacket& rx_waypoint() const;
  PROTOBUF_NODISCARD ::meshtastic::MeshPacket* release_rx_waypoint();
  ::meshtastic::MeshPacket* mutable_rx_waypoint();
  void set_allocated_rx_waypoint(::meshtastic::MeshPacket* rx_waypoint);
  private:
  const ::meshtastic::MeshPacket& _internal_rx_waypoint() const;
  ::meshtastic::MeshPacket* _internal_mutable_rx_waypoint();
  public:
  void unsafe_arena_set_allocated_rx_waypoint(
      ::meshtastic::MeshPacket* rx_waypoint);
  ::meshtastic::MeshPacket* unsafe_arena_release_rx_waypoint();

  // uint32 version = 8;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // bool no_save = 9 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_no_save();
  PROTOBUF_DEPRECATED bool no_save() const;
  PROTOBUF_DEPRECATED void set_no_save(bool value);
  private:
  bool _internal_no_save() const;
  void _internal_set_no_save(bool value);
  public:

  // bool did_gps_reset = 11 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_did_gps_reset();
  PROTOBUF_DEPRECATED bool did_gps_reset() const;
  PROTOBUF_DEPRECATED void set_did_gps_reset(bool value);
  private:
  bool _internal_did_gps_reset() const;
  void _internal_set_did_gps_reset(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.DeviceState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::MeshPacket > receive_queue_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin > node_remote_hardware_pins_;
    ::meshtastic::MyNodeInfo* my_node_;
    ::meshtastic::User* owner_;
    ::meshtastic::MeshPacket* rx_text_message_;
    ::meshtastic::MeshPacket* rx_waypoint_;
    uint32_t version_;
    bool no_save_;
    bool did_gps_reset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};
// -------------------------------------------------------------------

class NodeDatabase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.NodeDatabase) */ {
 public:
  inline NodeDatabase() : NodeDatabase(nullptr) {}
  ~NodeDatabase() override;
  explicit PROTOBUF_CONSTEXPR NodeDatabase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeDatabase(const NodeDatabase& from);
  NodeDatabase(NodeDatabase&& from) noexcept
    : NodeDatabase() {
    *this = ::std::move(from);
  }

  inline NodeDatabase& operator=(const NodeDatabase& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeDatabase& operator=(NodeDatabase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeDatabase& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeDatabase* internal_default_instance() {
    return reinterpret_cast<const NodeDatabase*>(
               &_NodeDatabase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NodeDatabase& a, NodeDatabase& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeDatabase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeDatabase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeDatabase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeDatabase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeDatabase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeDatabase& from) {
    NodeDatabase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeDatabase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.NodeDatabase";
  }
  protected:
  explicit NodeDatabase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // repeated .meshtastic.NodeInfoLite nodes = 2 [(.nanopb) = {
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::meshtastic::NodeInfoLite* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeInfoLite >*
      mutable_nodes();
  private:
  const ::meshtastic::NodeInfoLite& _internal_nodes(int index) const;
  ::meshtastic::NodeInfoLite* _internal_add_nodes();
  public:
  const ::meshtastic::NodeInfoLite& nodes(int index) const;
  ::meshtastic::NodeInfoLite* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeInfoLite >&
      nodes() const;

  // uint32 version = 1;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.NodeDatabase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeInfoLite > nodes_;
    uint32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};
// -------------------------------------------------------------------

class ChannelFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ChannelFile) */ {
 public:
  inline ChannelFile() : ChannelFile(nullptr) {}
  ~ChannelFile() override;
  explicit PROTOBUF_CONSTEXPR ChannelFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChannelFile(const ChannelFile& from);
  ChannelFile(ChannelFile&& from) noexcept
    : ChannelFile() {
    *this = ::std::move(from);
  }

  inline ChannelFile& operator=(const ChannelFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelFile& operator=(ChannelFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelFile* internal_default_instance() {
    return reinterpret_cast<const ChannelFile*>(
               &_ChannelFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChannelFile& a, ChannelFile& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChannelFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChannelFile& from) {
    ChannelFile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ChannelFile";
  }
  protected:
  explicit ChannelFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // repeated .meshtastic.Channel channels = 1;
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  ::meshtastic::Channel* mutable_channels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::Channel >*
      mutable_channels();
  private:
  const ::meshtastic::Channel& _internal_channels(int index) const;
  ::meshtastic::Channel* _internal_add_channels();
  public:
  const ::meshtastic::Channel& channels(int index) const;
  ::meshtastic::Channel* add_channels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::Channel >&
      channels() const;

  // uint32 version = 2;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ChannelFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::Channel > channels_;
    uint32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};
// -------------------------------------------------------------------

class BackupPreferences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.BackupPreferences) */ {
 public:
  inline BackupPreferences() : BackupPreferences(nullptr) {}
  ~BackupPreferences() override;
  explicit PROTOBUF_CONSTEXPR BackupPreferences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BackupPreferences(const BackupPreferences& from);
  BackupPreferences(BackupPreferences&& from) noexcept
    : BackupPreferences() {
    *this = ::std::move(from);
  }

  inline BackupPreferences& operator=(const BackupPreferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackupPreferences& operator=(BackupPreferences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackupPreferences& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackupPreferences* internal_default_instance() {
    return reinterpret_cast<const BackupPreferences*>(
               &_BackupPreferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BackupPreferences& a, BackupPreferences& b) {
    a.Swap(&b);
  }
  inline void Swap(BackupPreferences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackupPreferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackupPreferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BackupPreferences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BackupPreferences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BackupPreferences& from) {
    BackupPreferences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BackupPreferences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.BackupPreferences";
  }
  protected:
  explicit BackupPreferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 3,
    kModuleConfigFieldNumber = 4,
    kChannelsFieldNumber = 5,
    kOwnerFieldNumber = 6,
    kVersionFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // .meshtastic.LocalConfig config = 3;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::meshtastic::LocalConfig& config() const;
  PROTOBUF_NODISCARD ::meshtastic::LocalConfig* release_config();
  ::meshtastic::LocalConfig* mutable_config();
  void set_allocated_config(::meshtastic::LocalConfig* config);
  private:
  const ::meshtastic::LocalConfig& _internal_config() const;
  ::meshtastic::LocalConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::meshtastic::LocalConfig* config);
  ::meshtastic::LocalConfig* unsafe_arena_release_config();

  // .meshtastic.LocalModuleConfig module_config = 4;
  bool has_module_config() const;
  private:
  bool _internal_has_module_config() const;
  public:
  void clear_module_config();
  const ::meshtastic::LocalModuleConfig& module_config() const;
  PROTOBUF_NODISCARD ::meshtastic::LocalModuleConfig* release_module_config();
  ::meshtastic::LocalModuleConfig* mutable_module_config();
  void set_allocated_module_config(::meshtastic::LocalModuleConfig* module_config);
  private:
  const ::meshtastic::LocalModuleConfig& _internal_module_config() const;
  ::meshtastic::LocalModuleConfig* _internal_mutable_module_config();
  public:
  void unsafe_arena_set_allocated_module_config(
      ::meshtastic::LocalModuleConfig* module_config);
  ::meshtastic::LocalModuleConfig* unsafe_arena_release_module_config();

  // .meshtastic.ChannelFile channels = 5;
  bool has_channels() const;
  private:
  bool _internal_has_channels() const;
  public:
  void clear_channels();
  const ::meshtastic::ChannelFile& channels() const;
  PROTOBUF_NODISCARD ::meshtastic::ChannelFile* release_channels();
  ::meshtastic::ChannelFile* mutable_channels();
  void set_allocated_channels(::meshtastic::ChannelFile* channels);
  private:
  const ::meshtastic::ChannelFile& _internal_channels() const;
  ::meshtastic::ChannelFile* _internal_mutable_channels();
  public:
  void unsafe_arena_set_allocated_channels(
      ::meshtastic::ChannelFile* channels);
  ::meshtastic::ChannelFile* unsafe_arena_release_channels();

  // .meshtastic.User owner = 6;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const ::meshtastic::User& owner() const;
  PROTOBUF_NODISCARD ::meshtastic::User* release_owner();
  ::meshtastic::User* mutable_owner();
  void set_allocated_owner(::meshtastic::User* owner);
  private:
  const ::meshtastic::User& _internal_owner() const;
  ::meshtastic::User* _internal_mutable_owner();
  public:
  void unsafe_arena_set_allocated_owner(
      ::meshtastic::User* owner);
  ::meshtastic::User* unsafe_arena_release_owner();

  // uint32 version = 1;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // fixed32 timestamp = 2;
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.BackupPreferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::meshtastic::LocalConfig* config_;
    ::meshtastic::LocalModuleConfig* module_config_;
    ::meshtastic::ChannelFile* channels_;
    ::meshtastic::User* owner_;
    uint32_t version_;
    uint32_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PositionLite

// sfixed32 latitude_i = 1;
inline void PositionLite::clear_latitude_i() {
  _impl_.latitude_i_ = 0;
}
inline int32_t PositionLite::_internal_latitude_i() const {
  return _impl_.latitude_i_;
}
inline int32_t PositionLite::latitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.PositionLite.latitude_i)
  return _internal_latitude_i();
}
inline void PositionLite::_internal_set_latitude_i(int32_t value) {
  
  _impl_.latitude_i_ = value;
}
inline void PositionLite::set_latitude_i(int32_t value) {
  _internal_set_latitude_i(value);
  // @@protoc_insertion_point(field_set:meshtastic.PositionLite.latitude_i)
}

// sfixed32 longitude_i = 2;
inline void PositionLite::clear_longitude_i() {
  _impl_.longitude_i_ = 0;
}
inline int32_t PositionLite::_internal_longitude_i() const {
  return _impl_.longitude_i_;
}
inline int32_t PositionLite::longitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.PositionLite.longitude_i)
  return _internal_longitude_i();
}
inline void PositionLite::_internal_set_longitude_i(int32_t value) {
  
  _impl_.longitude_i_ = value;
}
inline void PositionLite::set_longitude_i(int32_t value) {
  _internal_set_longitude_i(value);
  // @@protoc_insertion_point(field_set:meshtastic.PositionLite.longitude_i)
}

// int32 altitude = 3;
inline void PositionLite::clear_altitude() {
  _impl_.altitude_ = 0;
}
inline int32_t PositionLite::_internal_altitude() const {
  return _impl_.altitude_;
}
inline int32_t PositionLite::altitude() const {
  // @@protoc_insertion_point(field_get:meshtastic.PositionLite.altitude)
  return _internal_altitude();
}
inline void PositionLite::_internal_set_altitude(int32_t value) {
  
  _impl_.altitude_ = value;
}
inline void PositionLite::set_altitude(int32_t value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:meshtastic.PositionLite.altitude)
}

// fixed32 time = 4;
inline void PositionLite::clear_time() {
  _impl_.time_ = 0u;
}
inline uint32_t PositionLite::_internal_time() const {
  return _impl_.time_;
}
inline uint32_t PositionLite::time() const {
  // @@protoc_insertion_point(field_get:meshtastic.PositionLite.time)
  return _internal_time();
}
inline void PositionLite::_internal_set_time(uint32_t value) {
  
  _impl_.time_ = value;
}
inline void PositionLite::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.PositionLite.time)
}

// .meshtastic.Position.LocSource location_source = 5;
inline void PositionLite::clear_location_source() {
  _impl_.location_source_ = 0;
}
inline ::meshtastic::Position_LocSource PositionLite::_internal_location_source() const {
  return static_cast< ::meshtastic::Position_LocSource >(_impl_.location_source_);
}
inline ::meshtastic::Position_LocSource PositionLite::location_source() const {
  // @@protoc_insertion_point(field_get:meshtastic.PositionLite.location_source)
  return _internal_location_source();
}
inline void PositionLite::_internal_set_location_source(::meshtastic::Position_LocSource value) {
  
  _impl_.location_source_ = value;
}
inline void PositionLite::set_location_source(::meshtastic::Position_LocSource value) {
  _internal_set_location_source(value);
  // @@protoc_insertion_point(field_set:meshtastic.PositionLite.location_source)
}

// -------------------------------------------------------------------

// UserLite

// bytes macaddr = 1 [deprecated = true];
inline void UserLite::clear_macaddr() {
  _impl_.macaddr_.ClearToEmpty();
}
inline const std::string& UserLite::macaddr() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.macaddr)
  return _internal_macaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLite::set_macaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.macaddr_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.macaddr)
}
inline std::string* UserLite::mutable_macaddr() {
  std::string* _s = _internal_mutable_macaddr();
  // @@protoc_insertion_point(field_mutable:meshtastic.UserLite.macaddr)
  return _s;
}
inline const std::string& UserLite::_internal_macaddr() const {
  return _impl_.macaddr_.Get();
}
inline void UserLite::_internal_set_macaddr(const std::string& value) {
  
  _impl_.macaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLite::_internal_mutable_macaddr() {
  
  return _impl_.macaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLite::release_macaddr() {
  // @@protoc_insertion_point(field_release:meshtastic.UserLite.macaddr)
  return _impl_.macaddr_.Release();
}
inline void UserLite::set_allocated_macaddr(std::string* macaddr) {
  if (macaddr != nullptr) {
    
  } else {
    
  }
  _impl_.macaddr_.SetAllocated(macaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.macaddr_.IsDefault()) {
    _impl_.macaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.UserLite.macaddr)
}

// string long_name = 2;
inline void UserLite::clear_long_name() {
  _impl_.long_name_.ClearToEmpty();
}
inline const std::string& UserLite::long_name() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.long_name)
  return _internal_long_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLite::set_long_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.long_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.long_name)
}
inline std::string* UserLite::mutable_long_name() {
  std::string* _s = _internal_mutable_long_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.UserLite.long_name)
  return _s;
}
inline const std::string& UserLite::_internal_long_name() const {
  return _impl_.long_name_.Get();
}
inline void UserLite::_internal_set_long_name(const std::string& value) {
  
  _impl_.long_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLite::_internal_mutable_long_name() {
  
  return _impl_.long_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLite::release_long_name() {
  // @@protoc_insertion_point(field_release:meshtastic.UserLite.long_name)
  return _impl_.long_name_.Release();
}
inline void UserLite::set_allocated_long_name(std::string* long_name) {
  if (long_name != nullptr) {
    
  } else {
    
  }
  _impl_.long_name_.SetAllocated(long_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.long_name_.IsDefault()) {
    _impl_.long_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.UserLite.long_name)
}

// string short_name = 3;
inline void UserLite::clear_short_name() {
  _impl_.short_name_.ClearToEmpty();
}
inline const std::string& UserLite::short_name() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.short_name)
  return _internal_short_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLite::set_short_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.short_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.short_name)
}
inline std::string* UserLite::mutable_short_name() {
  std::string* _s = _internal_mutable_short_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.UserLite.short_name)
  return _s;
}
inline const std::string& UserLite::_internal_short_name() const {
  return _impl_.short_name_.Get();
}
inline void UserLite::_internal_set_short_name(const std::string& value) {
  
  _impl_.short_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLite::_internal_mutable_short_name() {
  
  return _impl_.short_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLite::release_short_name() {
  // @@protoc_insertion_point(field_release:meshtastic.UserLite.short_name)
  return _impl_.short_name_.Release();
}
inline void UserLite::set_allocated_short_name(std::string* short_name) {
  if (short_name != nullptr) {
    
  } else {
    
  }
  _impl_.short_name_.SetAllocated(short_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.short_name_.IsDefault()) {
    _impl_.short_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.UserLite.short_name)
}

// .meshtastic.HardwareModel hw_model = 4;
inline void UserLite::clear_hw_model() {
  _impl_.hw_model_ = 0;
}
inline ::meshtastic::HardwareModel UserLite::_internal_hw_model() const {
  return static_cast< ::meshtastic::HardwareModel >(_impl_.hw_model_);
}
inline ::meshtastic::HardwareModel UserLite::hw_model() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.hw_model)
  return _internal_hw_model();
}
inline void UserLite::_internal_set_hw_model(::meshtastic::HardwareModel value) {
  
  _impl_.hw_model_ = value;
}
inline void UserLite::set_hw_model(::meshtastic::HardwareModel value) {
  _internal_set_hw_model(value);
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.hw_model)
}

// bool is_licensed = 5;
inline void UserLite::clear_is_licensed() {
  _impl_.is_licensed_ = false;
}
inline bool UserLite::_internal_is_licensed() const {
  return _impl_.is_licensed_;
}
inline bool UserLite::is_licensed() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.is_licensed)
  return _internal_is_licensed();
}
inline void UserLite::_internal_set_is_licensed(bool value) {
  
  _impl_.is_licensed_ = value;
}
inline void UserLite::set_is_licensed(bool value) {
  _internal_set_is_licensed(value);
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.is_licensed)
}

// .meshtastic.Config.DeviceConfig.Role role = 6;
inline void UserLite::clear_role() {
  _impl_.role_ = 0;
}
inline ::meshtastic::Config_DeviceConfig_Role UserLite::_internal_role() const {
  return static_cast< ::meshtastic::Config_DeviceConfig_Role >(_impl_.role_);
}
inline ::meshtastic::Config_DeviceConfig_Role UserLite::role() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.role)
  return _internal_role();
}
inline void UserLite::_internal_set_role(::meshtastic::Config_DeviceConfig_Role value) {
  
  _impl_.role_ = value;
}
inline void UserLite::set_role(::meshtastic::Config_DeviceConfig_Role value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.role)
}

// bytes public_key = 7;
inline void UserLite::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& UserLite::public_key() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLite::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.public_key)
}
inline std::string* UserLite::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.UserLite.public_key)
  return _s;
}
inline const std::string& UserLite::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void UserLite::_internal_set_public_key(const std::string& value) {
  
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLite::_internal_mutable_public_key() {
  
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLite::release_public_key() {
  // @@protoc_insertion_point(field_release:meshtastic.UserLite.public_key)
  return _impl_.public_key_.Release();
}
inline void UserLite::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.UserLite.public_key)
}

// optional bool is_unmessagable = 9;
inline bool UserLite::_internal_has_is_unmessagable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserLite::has_is_unmessagable() const {
  return _internal_has_is_unmessagable();
}
inline void UserLite::clear_is_unmessagable() {
  _impl_.is_unmessagable_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool UserLite::_internal_is_unmessagable() const {
  return _impl_.is_unmessagable_;
}
inline bool UserLite::is_unmessagable() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.is_unmessagable)
  return _internal_is_unmessagable();
}
inline void UserLite::_internal_set_is_unmessagable(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.is_unmessagable_ = value;
}
inline void UserLite::set_is_unmessagable(bool value) {
  _internal_set_is_unmessagable(value);
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.is_unmessagable)
}

// -------------------------------------------------------------------

// NodeInfoLite

// uint32 num = 1;
inline void NodeInfoLite::clear_num() {
  _impl_.num_ = 0u;
}
inline uint32_t NodeInfoLite::_internal_num() const {
  return _impl_.num_;
}
inline uint32_t NodeInfoLite::num() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.num)
  return _internal_num();
}
inline void NodeInfoLite::_internal_set_num(uint32_t value) {
  
  _impl_.num_ = value;
}
inline void NodeInfoLite::set_num(uint32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.num)
}

// .meshtastic.UserLite user = 2;
inline bool NodeInfoLite::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool NodeInfoLite::has_user() const {
  return _internal_has_user();
}
inline void NodeInfoLite::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::meshtastic::UserLite& NodeInfoLite::_internal_user() const {
  const ::meshtastic::UserLite* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::UserLite&>(
      ::meshtastic::_UserLite_default_instance_);
}
inline const ::meshtastic::UserLite& NodeInfoLite::user() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.user)
  return _internal_user();
}
inline void NodeInfoLite::unsafe_arena_set_allocated_user(
    ::meshtastic::UserLite* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfoLite.user)
}
inline ::meshtastic::UserLite* NodeInfoLite::release_user() {
  
  ::meshtastic::UserLite* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::UserLite* NodeInfoLite::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfoLite.user)
  
  ::meshtastic::UserLite* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::meshtastic::UserLite* NodeInfoLite::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::UserLite>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::meshtastic::UserLite* NodeInfoLite::mutable_user() {
  ::meshtastic::UserLite* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfoLite.user)
  return _msg;
}
inline void NodeInfoLite::set_allocated_user(::meshtastic::UserLite* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfoLite.user)
}

// .meshtastic.PositionLite position = 3;
inline bool NodeInfoLite::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool NodeInfoLite::has_position() const {
  return _internal_has_position();
}
inline void NodeInfoLite::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::meshtastic::PositionLite& NodeInfoLite::_internal_position() const {
  const ::meshtastic::PositionLite* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::PositionLite&>(
      ::meshtastic::_PositionLite_default_instance_);
}
inline const ::meshtastic::PositionLite& NodeInfoLite::position() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.position)
  return _internal_position();
}
inline void NodeInfoLite::unsafe_arena_set_allocated_position(
    ::meshtastic::PositionLite* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfoLite.position)
}
inline ::meshtastic::PositionLite* NodeInfoLite::release_position() {
  
  ::meshtastic::PositionLite* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::PositionLite* NodeInfoLite::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfoLite.position)
  
  ::meshtastic::PositionLite* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::meshtastic::PositionLite* NodeInfoLite::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::PositionLite>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::meshtastic::PositionLite* NodeInfoLite::mutable_position() {
  ::meshtastic::PositionLite* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfoLite.position)
  return _msg;
}
inline void NodeInfoLite::set_allocated_position(::meshtastic::PositionLite* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfoLite.position)
}

// float snr = 4;
inline void NodeInfoLite::clear_snr() {
  _impl_.snr_ = 0;
}
inline float NodeInfoLite::_internal_snr() const {
  return _impl_.snr_;
}
inline float NodeInfoLite::snr() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.snr)
  return _internal_snr();
}
inline void NodeInfoLite::_internal_set_snr(float value) {
  
  _impl_.snr_ = value;
}
inline void NodeInfoLite::set_snr(float value) {
  _internal_set_snr(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.snr)
}

// fixed32 last_heard = 5;
inline void NodeInfoLite::clear_last_heard() {
  _impl_.last_heard_ = 0u;
}
inline uint32_t NodeInfoLite::_internal_last_heard() const {
  return _impl_.last_heard_;
}
inline uint32_t NodeInfoLite::last_heard() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.last_heard)
  return _internal_last_heard();
}
inline void NodeInfoLite::_internal_set_last_heard(uint32_t value) {
  
  _impl_.last_heard_ = value;
}
inline void NodeInfoLite::set_last_heard(uint32_t value) {
  _internal_set_last_heard(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.last_heard)
}

// .meshtastic.DeviceMetrics device_metrics = 6;
inline bool NodeInfoLite::_internal_has_device_metrics() const {
  return this != internal_default_instance() && _impl_.device_metrics_ != nullptr;
}
inline bool NodeInfoLite::has_device_metrics() const {
  return _internal_has_device_metrics();
}
inline const ::meshtastic::DeviceMetrics& NodeInfoLite::_internal_device_metrics() const {
  const ::meshtastic::DeviceMetrics* p = _impl_.device_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::DeviceMetrics&>(
      ::meshtastic::_DeviceMetrics_default_instance_);
}
inline const ::meshtastic::DeviceMetrics& NodeInfoLite::device_metrics() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.device_metrics)
  return _internal_device_metrics();
}
inline void NodeInfoLite::unsafe_arena_set_allocated_device_metrics(
    ::meshtastic::DeviceMetrics* device_metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_metrics_);
  }
  _impl_.device_metrics_ = device_metrics;
  if (device_metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfoLite.device_metrics)
}
inline ::meshtastic::DeviceMetrics* NodeInfoLite::release_device_metrics() {
  
  ::meshtastic::DeviceMetrics* temp = _impl_.device_metrics_;
  _impl_.device_metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::DeviceMetrics* NodeInfoLite::unsafe_arena_release_device_metrics() {
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfoLite.device_metrics)
  
  ::meshtastic::DeviceMetrics* temp = _impl_.device_metrics_;
  _impl_.device_metrics_ = nullptr;
  return temp;
}
inline ::meshtastic::DeviceMetrics* NodeInfoLite::_internal_mutable_device_metrics() {
  
  if (_impl_.device_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::DeviceMetrics>(GetArenaForAllocation());
    _impl_.device_metrics_ = p;
  }
  return _impl_.device_metrics_;
}
inline ::meshtastic::DeviceMetrics* NodeInfoLite::mutable_device_metrics() {
  ::meshtastic::DeviceMetrics* _msg = _internal_mutable_device_metrics();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfoLite.device_metrics)
  return _msg;
}
inline void NodeInfoLite::set_allocated_device_metrics(::meshtastic::DeviceMetrics* device_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_metrics_);
  }
  if (device_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_metrics));
    if (message_arena != submessage_arena) {
      device_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_metrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_metrics_ = device_metrics;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfoLite.device_metrics)
}

// uint32 channel = 7;
inline void NodeInfoLite::clear_channel() {
  _impl_.channel_ = 0u;
}
inline uint32_t NodeInfoLite::_internal_channel() const {
  return _impl_.channel_;
}
inline uint32_t NodeInfoLite::channel() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.channel)
  return _internal_channel();
}
inline void NodeInfoLite::_internal_set_channel(uint32_t value) {
  
  _impl_.channel_ = value;
}
inline void NodeInfoLite::set_channel(uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.channel)
}

// bool via_mqtt = 8;
inline void NodeInfoLite::clear_via_mqtt() {
  _impl_.via_mqtt_ = false;
}
inline bool NodeInfoLite::_internal_via_mqtt() const {
  return _impl_.via_mqtt_;
}
inline bool NodeInfoLite::via_mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.via_mqtt)
  return _internal_via_mqtt();
}
inline void NodeInfoLite::_internal_set_via_mqtt(bool value) {
  
  _impl_.via_mqtt_ = value;
}
inline void NodeInfoLite::set_via_mqtt(bool value) {
  _internal_set_via_mqtt(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.via_mqtt)
}

// optional uint32 hops_away = 9;
inline bool NodeInfoLite::_internal_has_hops_away() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NodeInfoLite::has_hops_away() const {
  return _internal_has_hops_away();
}
inline void NodeInfoLite::clear_hops_away() {
  _impl_.hops_away_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t NodeInfoLite::_internal_hops_away() const {
  return _impl_.hops_away_;
}
inline uint32_t NodeInfoLite::hops_away() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.hops_away)
  return _internal_hops_away();
}
inline void NodeInfoLite::_internal_set_hops_away(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hops_away_ = value;
}
inline void NodeInfoLite::set_hops_away(uint32_t value) {
  _internal_set_hops_away(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.hops_away)
}

// bool is_favorite = 10;
inline void NodeInfoLite::clear_is_favorite() {
  _impl_.is_favorite_ = false;
}
inline bool NodeInfoLite::_internal_is_favorite() const {
  return _impl_.is_favorite_;
}
inline bool NodeInfoLite::is_favorite() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.is_favorite)
  return _internal_is_favorite();
}
inline void NodeInfoLite::_internal_set_is_favorite(bool value) {
  
  _impl_.is_favorite_ = value;
}
inline void NodeInfoLite::set_is_favorite(bool value) {
  _internal_set_is_favorite(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.is_favorite)
}

// bool is_ignored = 11;
inline void NodeInfoLite::clear_is_ignored() {
  _impl_.is_ignored_ = false;
}
inline bool NodeInfoLite::_internal_is_ignored() const {
  return _impl_.is_ignored_;
}
inline bool NodeInfoLite::is_ignored() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.is_ignored)
  return _internal_is_ignored();
}
inline void NodeInfoLite::_internal_set_is_ignored(bool value) {
  
  _impl_.is_ignored_ = value;
}
inline void NodeInfoLite::set_is_ignored(bool value) {
  _internal_set_is_ignored(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.is_ignored)
}

// uint32 next_hop = 12;
inline void NodeInfoLite::clear_next_hop() {
  _impl_.next_hop_ = 0u;
}
inline uint32_t NodeInfoLite::_internal_next_hop() const {
  return _impl_.next_hop_;
}
inline uint32_t NodeInfoLite::next_hop() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.next_hop)
  return _internal_next_hop();
}
inline void NodeInfoLite::_internal_set_next_hop(uint32_t value) {
  
  _impl_.next_hop_ = value;
}
inline void NodeInfoLite::set_next_hop(uint32_t value) {
  _internal_set_next_hop(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.next_hop)
}

// uint32 bitfield = 13;
inline void NodeInfoLite::clear_bitfield() {
  _impl_.bitfield_ = 0u;
}
inline uint32_t NodeInfoLite::_internal_bitfield() const {
  return _impl_.bitfield_;
}
inline uint32_t NodeInfoLite::bitfield() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.bitfield)
  return _internal_bitfield();
}
inline void NodeInfoLite::_internal_set_bitfield(uint32_t value) {
  
  _impl_.bitfield_ = value;
}
inline void NodeInfoLite::set_bitfield(uint32_t value) {
  _internal_set_bitfield(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.bitfield)
}

// -------------------------------------------------------------------

// DeviceState

// .meshtastic.MyNodeInfo my_node = 2;
inline bool DeviceState::_internal_has_my_node() const {
  return this != internal_default_instance() && _impl_.my_node_ != nullptr;
}
inline bool DeviceState::has_my_node() const {
  return _internal_has_my_node();
}
inline const ::meshtastic::MyNodeInfo& DeviceState::_internal_my_node() const {
  const ::meshtastic::MyNodeInfo* p = _impl_.my_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::MyNodeInfo&>(
      ::meshtastic::_MyNodeInfo_default_instance_);
}
inline const ::meshtastic::MyNodeInfo& DeviceState::my_node() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.my_node)
  return _internal_my_node();
}
inline void DeviceState::unsafe_arena_set_allocated_my_node(
    ::meshtastic::MyNodeInfo* my_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.my_node_);
  }
  _impl_.my_node_ = my_node;
  if (my_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.DeviceState.my_node)
}
inline ::meshtastic::MyNodeInfo* DeviceState::release_my_node() {
  
  ::meshtastic::MyNodeInfo* temp = _impl_.my_node_;
  _impl_.my_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::MyNodeInfo* DeviceState::unsafe_arena_release_my_node() {
  // @@protoc_insertion_point(field_release:meshtastic.DeviceState.my_node)
  
  ::meshtastic::MyNodeInfo* temp = _impl_.my_node_;
  _impl_.my_node_ = nullptr;
  return temp;
}
inline ::meshtastic::MyNodeInfo* DeviceState::_internal_mutable_my_node() {
  
  if (_impl_.my_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::MyNodeInfo>(GetArenaForAllocation());
    _impl_.my_node_ = p;
  }
  return _impl_.my_node_;
}
inline ::meshtastic::MyNodeInfo* DeviceState::mutable_my_node() {
  ::meshtastic::MyNodeInfo* _msg = _internal_mutable_my_node();
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.my_node)
  return _msg;
}
inline void DeviceState::set_allocated_my_node(::meshtastic::MyNodeInfo* my_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.my_node_);
  }
  if (my_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(my_node));
    if (message_arena != submessage_arena) {
      my_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, my_node, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.my_node_ = my_node;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.DeviceState.my_node)
}

// .meshtastic.User owner = 3;
inline bool DeviceState::_internal_has_owner() const {
  return this != internal_default_instance() && _impl_.owner_ != nullptr;
}
inline bool DeviceState::has_owner() const {
  return _internal_has_owner();
}
inline const ::meshtastic::User& DeviceState::_internal_owner() const {
  const ::meshtastic::User* p = _impl_.owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::User&>(
      ::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& DeviceState::owner() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.owner)
  return _internal_owner();
}
inline void DeviceState::unsafe_arena_set_allocated_owner(
    ::meshtastic::User* owner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.owner_);
  }
  _impl_.owner_ = owner;
  if (owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.DeviceState.owner)
}
inline ::meshtastic::User* DeviceState::release_owner() {
  
  ::meshtastic::User* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::User* DeviceState::unsafe_arena_release_owner() {
  // @@protoc_insertion_point(field_release:meshtastic.DeviceState.owner)
  
  ::meshtastic::User* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
  return temp;
}
inline ::meshtastic::User* DeviceState::_internal_mutable_owner() {
  
  if (_impl_.owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::User>(GetArenaForAllocation());
    _impl_.owner_ = p;
  }
  return _impl_.owner_;
}
inline ::meshtastic::User* DeviceState::mutable_owner() {
  ::meshtastic::User* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.owner)
  return _msg;
}
inline void DeviceState::set_allocated_owner(::meshtastic::User* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.owner_);
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner));
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.DeviceState.owner)
}

// repeated .meshtastic.MeshPacket receive_queue = 5;
inline int DeviceState::_internal_receive_queue_size() const {
  return _impl_.receive_queue_.size();
}
inline int DeviceState::receive_queue_size() const {
  return _internal_receive_queue_size();
}
inline ::meshtastic::MeshPacket* DeviceState::mutable_receive_queue(int index) {
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.receive_queue)
  return _impl_.receive_queue_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::MeshPacket >*
DeviceState::mutable_receive_queue() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.DeviceState.receive_queue)
  return &_impl_.receive_queue_;
}
inline const ::meshtastic::MeshPacket& DeviceState::_internal_receive_queue(int index) const {
  return _impl_.receive_queue_.Get(index);
}
inline const ::meshtastic::MeshPacket& DeviceState::receive_queue(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.receive_queue)
  return _internal_receive_queue(index);
}
inline ::meshtastic::MeshPacket* DeviceState::_internal_add_receive_queue() {
  return _impl_.receive_queue_.Add();
}
inline ::meshtastic::MeshPacket* DeviceState::add_receive_queue() {
  ::meshtastic::MeshPacket* _add = _internal_add_receive_queue();
  // @@protoc_insertion_point(field_add:meshtastic.DeviceState.receive_queue)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::MeshPacket >&
DeviceState::receive_queue() const {
  // @@protoc_insertion_point(field_list:meshtastic.DeviceState.receive_queue)
  return _impl_.receive_queue_;
}

// uint32 version = 8;
inline void DeviceState::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t DeviceState::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t DeviceState::version() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.version)
  return _internal_version();
}
inline void DeviceState::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void DeviceState::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceState.version)
}

// .meshtastic.MeshPacket rx_text_message = 7;
inline bool DeviceState::_internal_has_rx_text_message() const {
  return this != internal_default_instance() && _impl_.rx_text_message_ != nullptr;
}
inline bool DeviceState::has_rx_text_message() const {
  return _internal_has_rx_text_message();
}
inline const ::meshtastic::MeshPacket& DeviceState::_internal_rx_text_message() const {
  const ::meshtastic::MeshPacket* p = _impl_.rx_text_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::MeshPacket&>(
      ::meshtastic::_MeshPacket_default_instance_);
}
inline const ::meshtastic::MeshPacket& DeviceState::rx_text_message() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.rx_text_message)
  return _internal_rx_text_message();
}
inline void DeviceState::unsafe_arena_set_allocated_rx_text_message(
    ::meshtastic::MeshPacket* rx_text_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rx_text_message_);
  }
  _impl_.rx_text_message_ = rx_text_message;
  if (rx_text_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.DeviceState.rx_text_message)
}
inline ::meshtastic::MeshPacket* DeviceState::release_rx_text_message() {
  
  ::meshtastic::MeshPacket* temp = _impl_.rx_text_message_;
  _impl_.rx_text_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::MeshPacket* DeviceState::unsafe_arena_release_rx_text_message() {
  // @@protoc_insertion_point(field_release:meshtastic.DeviceState.rx_text_message)
  
  ::meshtastic::MeshPacket* temp = _impl_.rx_text_message_;
  _impl_.rx_text_message_ = nullptr;
  return temp;
}
inline ::meshtastic::MeshPacket* DeviceState::_internal_mutable_rx_text_message() {
  
  if (_impl_.rx_text_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::MeshPacket>(GetArenaForAllocation());
    _impl_.rx_text_message_ = p;
  }
  return _impl_.rx_text_message_;
}
inline ::meshtastic::MeshPacket* DeviceState::mutable_rx_text_message() {
  ::meshtastic::MeshPacket* _msg = _internal_mutable_rx_text_message();
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.rx_text_message)
  return _msg;
}
inline void DeviceState::set_allocated_rx_text_message(::meshtastic::MeshPacket* rx_text_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rx_text_message_);
  }
  if (rx_text_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rx_text_message));
    if (message_arena != submessage_arena) {
      rx_text_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rx_text_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rx_text_message_ = rx_text_message;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.DeviceState.rx_text_message)
}

// bool no_save = 9 [deprecated = true];
inline void DeviceState::clear_no_save() {
  _impl_.no_save_ = false;
}
inline bool DeviceState::_internal_no_save() const {
  return _impl_.no_save_;
}
inline bool DeviceState::no_save() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.no_save)
  return _internal_no_save();
}
inline void DeviceState::_internal_set_no_save(bool value) {
  
  _impl_.no_save_ = value;
}
inline void DeviceState::set_no_save(bool value) {
  _internal_set_no_save(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceState.no_save)
}

// bool did_gps_reset = 11 [deprecated = true];
inline void DeviceState::clear_did_gps_reset() {
  _impl_.did_gps_reset_ = false;
}
inline bool DeviceState::_internal_did_gps_reset() const {
  return _impl_.did_gps_reset_;
}
inline bool DeviceState::did_gps_reset() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.did_gps_reset)
  return _internal_did_gps_reset();
}
inline void DeviceState::_internal_set_did_gps_reset(bool value) {
  
  _impl_.did_gps_reset_ = value;
}
inline void DeviceState::set_did_gps_reset(bool value) {
  _internal_set_did_gps_reset(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceState.did_gps_reset)
}

// .meshtastic.MeshPacket rx_waypoint = 12;
inline bool DeviceState::_internal_has_rx_waypoint() const {
  return this != internal_default_instance() && _impl_.rx_waypoint_ != nullptr;
}
inline bool DeviceState::has_rx_waypoint() const {
  return _internal_has_rx_waypoint();
}
inline const ::meshtastic::MeshPacket& DeviceState::_internal_rx_waypoint() const {
  const ::meshtastic::MeshPacket* p = _impl_.rx_waypoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::MeshPacket&>(
      ::meshtastic::_MeshPacket_default_instance_);
}
inline const ::meshtastic::MeshPacket& DeviceState::rx_waypoint() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.rx_waypoint)
  return _internal_rx_waypoint();
}
inline void DeviceState::unsafe_arena_set_allocated_rx_waypoint(
    ::meshtastic::MeshPacket* rx_waypoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rx_waypoint_);
  }
  _impl_.rx_waypoint_ = rx_waypoint;
  if (rx_waypoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.DeviceState.rx_waypoint)
}
inline ::meshtastic::MeshPacket* DeviceState::release_rx_waypoint() {
  
  ::meshtastic::MeshPacket* temp = _impl_.rx_waypoint_;
  _impl_.rx_waypoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::MeshPacket* DeviceState::unsafe_arena_release_rx_waypoint() {
  // @@protoc_insertion_point(field_release:meshtastic.DeviceState.rx_waypoint)
  
  ::meshtastic::MeshPacket* temp = _impl_.rx_waypoint_;
  _impl_.rx_waypoint_ = nullptr;
  return temp;
}
inline ::meshtastic::MeshPacket* DeviceState::_internal_mutable_rx_waypoint() {
  
  if (_impl_.rx_waypoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::MeshPacket>(GetArenaForAllocation());
    _impl_.rx_waypoint_ = p;
  }
  return _impl_.rx_waypoint_;
}
inline ::meshtastic::MeshPacket* DeviceState::mutable_rx_waypoint() {
  ::meshtastic::MeshPacket* _msg = _internal_mutable_rx_waypoint();
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.rx_waypoint)
  return _msg;
}
inline void DeviceState::set_allocated_rx_waypoint(::meshtastic::MeshPacket* rx_waypoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rx_waypoint_);
  }
  if (rx_waypoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rx_waypoint));
    if (message_arena != submessage_arena) {
      rx_waypoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rx_waypoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rx_waypoint_ = rx_waypoint;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.DeviceState.rx_waypoint)
}

// repeated .meshtastic.NodeRemoteHardwarePin node_remote_hardware_pins = 13;
inline int DeviceState::_internal_node_remote_hardware_pins_size() const {
  return _impl_.node_remote_hardware_pins_.size();
}
inline int DeviceState::node_remote_hardware_pins_size() const {
  return _internal_node_remote_hardware_pins_size();
}
inline ::meshtastic::NodeRemoteHardwarePin* DeviceState::mutable_node_remote_hardware_pins(int index) {
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.node_remote_hardware_pins)
  return _impl_.node_remote_hardware_pins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin >*
DeviceState::mutable_node_remote_hardware_pins() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.DeviceState.node_remote_hardware_pins)
  return &_impl_.node_remote_hardware_pins_;
}
inline const ::meshtastic::NodeRemoteHardwarePin& DeviceState::_internal_node_remote_hardware_pins(int index) const {
  return _impl_.node_remote_hardware_pins_.Get(index);
}
inline const ::meshtastic::NodeRemoteHardwarePin& DeviceState::node_remote_hardware_pins(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.node_remote_hardware_pins)
  return _internal_node_remote_hardware_pins(index);
}
inline ::meshtastic::NodeRemoteHardwarePin* DeviceState::_internal_add_node_remote_hardware_pins() {
  return _impl_.node_remote_hardware_pins_.Add();
}
inline ::meshtastic::NodeRemoteHardwarePin* DeviceState::add_node_remote_hardware_pins() {
  ::meshtastic::NodeRemoteHardwarePin* _add = _internal_add_node_remote_hardware_pins();
  // @@protoc_insertion_point(field_add:meshtastic.DeviceState.node_remote_hardware_pins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin >&
DeviceState::node_remote_hardware_pins() const {
  // @@protoc_insertion_point(field_list:meshtastic.DeviceState.node_remote_hardware_pins)
  return _impl_.node_remote_hardware_pins_;
}

// -------------------------------------------------------------------

// NodeDatabase

// uint32 version = 1;
inline void NodeDatabase::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t NodeDatabase::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t NodeDatabase::version() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeDatabase.version)
  return _internal_version();
}
inline void NodeDatabase::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void NodeDatabase::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeDatabase.version)
}

// repeated .meshtastic.NodeInfoLite nodes = 2 [(.nanopb) = {
inline int NodeDatabase::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int NodeDatabase::nodes_size() const {
  return _internal_nodes_size();
}
inline void NodeDatabase::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::meshtastic::NodeInfoLite* NodeDatabase::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeDatabase.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeInfoLite >*
NodeDatabase::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.NodeDatabase.nodes)
  return &_impl_.nodes_;
}
inline const ::meshtastic::NodeInfoLite& NodeDatabase::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::meshtastic::NodeInfoLite& NodeDatabase::nodes(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeDatabase.nodes)
  return _internal_nodes(index);
}
inline ::meshtastic::NodeInfoLite* NodeDatabase::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::meshtastic::NodeInfoLite* NodeDatabase::add_nodes() {
  ::meshtastic::NodeInfoLite* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:meshtastic.NodeDatabase.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeInfoLite >&
NodeDatabase::nodes() const {
  // @@protoc_insertion_point(field_list:meshtastic.NodeDatabase.nodes)
  return _impl_.nodes_;
}

// -------------------------------------------------------------------

// ChannelFile

// repeated .meshtastic.Channel channels = 1;
inline int ChannelFile::_internal_channels_size() const {
  return _impl_.channels_.size();
}
inline int ChannelFile::channels_size() const {
  return _internal_channels_size();
}
inline ::meshtastic::Channel* ChannelFile::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:meshtastic.ChannelFile.channels)
  return _impl_.channels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::Channel >*
ChannelFile::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.ChannelFile.channels)
  return &_impl_.channels_;
}
inline const ::meshtastic::Channel& ChannelFile::_internal_channels(int index) const {
  return _impl_.channels_.Get(index);
}
inline const ::meshtastic::Channel& ChannelFile::channels(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.ChannelFile.channels)
  return _internal_channels(index);
}
inline ::meshtastic::Channel* ChannelFile::_internal_add_channels() {
  return _impl_.channels_.Add();
}
inline ::meshtastic::Channel* ChannelFile::add_channels() {
  ::meshtastic::Channel* _add = _internal_add_channels();
  // @@protoc_insertion_point(field_add:meshtastic.ChannelFile.channels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::Channel >&
ChannelFile::channels() const {
  // @@protoc_insertion_point(field_list:meshtastic.ChannelFile.channels)
  return _impl_.channels_;
}

// uint32 version = 2;
inline void ChannelFile::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t ChannelFile::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t ChannelFile::version() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChannelFile.version)
  return _internal_version();
}
inline void ChannelFile::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void ChannelFile::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:meshtastic.ChannelFile.version)
}

// -------------------------------------------------------------------

// BackupPreferences

// uint32 version = 1;
inline void BackupPreferences::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t BackupPreferences::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t BackupPreferences::version() const {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.version)
  return _internal_version();
}
inline void BackupPreferences::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void BackupPreferences::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:meshtastic.BackupPreferences.version)
}

// fixed32 timestamp = 2;
inline void BackupPreferences::clear_timestamp() {
  _impl_.timestamp_ = 0u;
}
inline uint32_t BackupPreferences::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t BackupPreferences::timestamp() const {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.timestamp)
  return _internal_timestamp();
}
inline void BackupPreferences::_internal_set_timestamp(uint32_t value) {
  
  _impl_.timestamp_ = value;
}
inline void BackupPreferences::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:meshtastic.BackupPreferences.timestamp)
}

// .meshtastic.LocalConfig config = 3;
inline bool BackupPreferences::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool BackupPreferences::has_config() const {
  return _internal_has_config();
}
inline const ::meshtastic::LocalConfig& BackupPreferences::_internal_config() const {
  const ::meshtastic::LocalConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::LocalConfig&>(
      ::meshtastic::_LocalConfig_default_instance_);
}
inline const ::meshtastic::LocalConfig& BackupPreferences::config() const {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.config)
  return _internal_config();
}
inline void BackupPreferences::unsafe_arena_set_allocated_config(
    ::meshtastic::LocalConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.BackupPreferences.config)
}
inline ::meshtastic::LocalConfig* BackupPreferences::release_config() {
  
  ::meshtastic::LocalConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::LocalConfig* BackupPreferences::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:meshtastic.BackupPreferences.config)
  
  ::meshtastic::LocalConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::meshtastic::LocalConfig* BackupPreferences::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::LocalConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::meshtastic::LocalConfig* BackupPreferences::mutable_config() {
  ::meshtastic::LocalConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.BackupPreferences.config)
  return _msg;
}
inline void BackupPreferences::set_allocated_config(::meshtastic::LocalConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.BackupPreferences.config)
}

// .meshtastic.LocalModuleConfig module_config = 4;
inline bool BackupPreferences::_internal_has_module_config() const {
  return this != internal_default_instance() && _impl_.module_config_ != nullptr;
}
inline bool BackupPreferences::has_module_config() const {
  return _internal_has_module_config();
}
inline const ::meshtastic::LocalModuleConfig& BackupPreferences::_internal_module_config() const {
  const ::meshtastic::LocalModuleConfig* p = _impl_.module_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::LocalModuleConfig&>(
      ::meshtastic::_LocalModuleConfig_default_instance_);
}
inline const ::meshtastic::LocalModuleConfig& BackupPreferences::module_config() const {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.module_config)
  return _internal_module_config();
}
inline void BackupPreferences::unsafe_arena_set_allocated_module_config(
    ::meshtastic::LocalModuleConfig* module_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.module_config_);
  }
  _impl_.module_config_ = module_config;
  if (module_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.BackupPreferences.module_config)
}
inline ::meshtastic::LocalModuleConfig* BackupPreferences::release_module_config() {
  
  ::meshtastic::LocalModuleConfig* temp = _impl_.module_config_;
  _impl_.module_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::LocalModuleConfig* BackupPreferences::unsafe_arena_release_module_config() {
  // @@protoc_insertion_point(field_release:meshtastic.BackupPreferences.module_config)
  
  ::meshtastic::LocalModuleConfig* temp = _impl_.module_config_;
  _impl_.module_config_ = nullptr;
  return temp;
}
inline ::meshtastic::LocalModuleConfig* BackupPreferences::_internal_mutable_module_config() {
  
  if (_impl_.module_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::LocalModuleConfig>(GetArenaForAllocation());
    _impl_.module_config_ = p;
  }
  return _impl_.module_config_;
}
inline ::meshtastic::LocalModuleConfig* BackupPreferences::mutable_module_config() {
  ::meshtastic::LocalModuleConfig* _msg = _internal_mutable_module_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.BackupPreferences.module_config)
  return _msg;
}
inline void BackupPreferences::set_allocated_module_config(::meshtastic::LocalModuleConfig* module_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.module_config_);
  }
  if (module_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_config));
    if (message_arena != submessage_arena) {
      module_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.module_config_ = module_config;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.BackupPreferences.module_config)
}

// .meshtastic.ChannelFile channels = 5;
inline bool BackupPreferences::_internal_has_channels() const {
  return this != internal_default_instance() && _impl_.channels_ != nullptr;
}
inline bool BackupPreferences::has_channels() const {
  return _internal_has_channels();
}
inline void BackupPreferences::clear_channels() {
  if (GetArenaForAllocation() == nullptr && _impl_.channels_ != nullptr) {
    delete _impl_.channels_;
  }
  _impl_.channels_ = nullptr;
}
inline const ::meshtastic::ChannelFile& BackupPreferences::_internal_channels() const {
  const ::meshtastic::ChannelFile* p = _impl_.channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ChannelFile&>(
      ::meshtastic::_ChannelFile_default_instance_);
}
inline const ::meshtastic::ChannelFile& BackupPreferences::channels() const {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.channels)
  return _internal_channels();
}
inline void BackupPreferences::unsafe_arena_set_allocated_channels(
    ::meshtastic::ChannelFile* channels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.channels_);
  }
  _impl_.channels_ = channels;
  if (channels) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.BackupPreferences.channels)
}
inline ::meshtastic::ChannelFile* BackupPreferences::release_channels() {
  
  ::meshtastic::ChannelFile* temp = _impl_.channels_;
  _impl_.channels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ChannelFile* BackupPreferences::unsafe_arena_release_channels() {
  // @@protoc_insertion_point(field_release:meshtastic.BackupPreferences.channels)
  
  ::meshtastic::ChannelFile* temp = _impl_.channels_;
  _impl_.channels_ = nullptr;
  return temp;
}
inline ::meshtastic::ChannelFile* BackupPreferences::_internal_mutable_channels() {
  
  if (_impl_.channels_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ChannelFile>(GetArenaForAllocation());
    _impl_.channels_ = p;
  }
  return _impl_.channels_;
}
inline ::meshtastic::ChannelFile* BackupPreferences::mutable_channels() {
  ::meshtastic::ChannelFile* _msg = _internal_mutable_channels();
  // @@protoc_insertion_point(field_mutable:meshtastic.BackupPreferences.channels)
  return _msg;
}
inline void BackupPreferences::set_allocated_channels(::meshtastic::ChannelFile* channels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.channels_;
  }
  if (channels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(channels);
    if (message_arena != submessage_arena) {
      channels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, channels, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.channels_ = channels;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.BackupPreferences.channels)
}

// .meshtastic.User owner = 6;
inline bool BackupPreferences::_internal_has_owner() const {
  return this != internal_default_instance() && _impl_.owner_ != nullptr;
}
inline bool BackupPreferences::has_owner() const {
  return _internal_has_owner();
}
inline const ::meshtastic::User& BackupPreferences::_internal_owner() const {
  const ::meshtastic::User* p = _impl_.owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::User&>(
      ::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& BackupPreferences::owner() const {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.owner)
  return _internal_owner();
}
inline void BackupPreferences::unsafe_arena_set_allocated_owner(
    ::meshtastic::User* owner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.owner_);
  }
  _impl_.owner_ = owner;
  if (owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.BackupPreferences.owner)
}
inline ::meshtastic::User* BackupPreferences::release_owner() {
  
  ::meshtastic::User* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::User* BackupPreferences::unsafe_arena_release_owner() {
  // @@protoc_insertion_point(field_release:meshtastic.BackupPreferences.owner)
  
  ::meshtastic::User* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
  return temp;
}
inline ::meshtastic::User* BackupPreferences::_internal_mutable_owner() {
  
  if (_impl_.owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::User>(GetArenaForAllocation());
    _impl_.owner_ = p;
  }
  return _impl_.owner_;
}
inline ::meshtastic::User* BackupPreferences::mutable_owner() {
  ::meshtastic::User* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:meshtastic.BackupPreferences.owner)
  return _msg;
}
inline void BackupPreferences::set_allocated_owner(::meshtastic::User* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.owner_);
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner));
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.BackupPreferences.owner)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meshtastic

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fdeviceonly_2eproto
