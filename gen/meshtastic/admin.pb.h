// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: meshtastic/admin.proto
// Protobuf C++ Version: 5.29.5

#ifndef meshtastic_2fadmin_2eproto_2epb_2eh
#define meshtastic_2fadmin_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "meshtastic/channel.pb.h"
#include "meshtastic/config.pb.h"
#include "meshtastic/connection_status.pb.h"
#include "meshtastic/device_ui.pb.h"
#include "meshtastic/mesh.pb.h"
#include "meshtastic/module_config.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_meshtastic_2fadmin_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_meshtastic_2fadmin_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_meshtastic_2fadmin_2eproto;
namespace meshtastic {
class AdminMessage;
struct AdminMessageDefaultTypeInternal;
extern AdminMessageDefaultTypeInternal _AdminMessage_default_instance_;
class AdminMessage_InputEvent;
struct AdminMessage_InputEventDefaultTypeInternal;
extern AdminMessage_InputEventDefaultTypeInternal _AdminMessage_InputEvent_default_instance_;
class HamParameters;
struct HamParametersDefaultTypeInternal;
extern HamParametersDefaultTypeInternal _HamParameters_default_instance_;
class KeyVerificationAdmin;
struct KeyVerificationAdminDefaultTypeInternal;
extern KeyVerificationAdminDefaultTypeInternal _KeyVerificationAdmin_default_instance_;
class NodeRemoteHardwarePinsResponse;
struct NodeRemoteHardwarePinsResponseDefaultTypeInternal;
extern NodeRemoteHardwarePinsResponseDefaultTypeInternal _NodeRemoteHardwarePinsResponse_default_instance_;
class SharedContact;
struct SharedContactDefaultTypeInternal;
extern SharedContactDefaultTypeInternal _SharedContact_default_instance_;
}  // namespace meshtastic
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace meshtastic {
enum AdminMessage_ConfigType : int {
  AdminMessage_ConfigType_DEVICE_CONFIG = 0,
  AdminMessage_ConfigType_POSITION_CONFIG = 1,
  AdminMessage_ConfigType_POWER_CONFIG = 2,
  AdminMessage_ConfigType_NETWORK_CONFIG = 3,
  AdminMessage_ConfigType_DISPLAY_CONFIG = 4,
  AdminMessage_ConfigType_LORA_CONFIG = 5,
  AdminMessage_ConfigType_BLUETOOTH_CONFIG = 6,
  AdminMessage_ConfigType_SECURITY_CONFIG = 7,
  AdminMessage_ConfigType_SESSIONKEY_CONFIG = 8,
  AdminMessage_ConfigType_DEVICEUI_CONFIG = 9,
  AdminMessage_ConfigType_AdminMessage_ConfigType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AdminMessage_ConfigType_AdminMessage_ConfigType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AdminMessage_ConfigType_IsValid(int value);
extern const uint32_t AdminMessage_ConfigType_internal_data_[];
constexpr AdminMessage_ConfigType AdminMessage_ConfigType_ConfigType_MIN = static_cast<AdminMessage_ConfigType>(0);
constexpr AdminMessage_ConfigType AdminMessage_ConfigType_ConfigType_MAX = static_cast<AdminMessage_ConfigType>(9);
constexpr int AdminMessage_ConfigType_ConfigType_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
AdminMessage_ConfigType_descriptor();
template <typename T>
const std::string& AdminMessage_ConfigType_Name(T value) {
  static_assert(std::is_same<T, AdminMessage_ConfigType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ConfigType_Name().");
  return AdminMessage_ConfigType_Name(static_cast<AdminMessage_ConfigType>(value));
}
template <>
inline const std::string& AdminMessage_ConfigType_Name(AdminMessage_ConfigType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AdminMessage_ConfigType_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool AdminMessage_ConfigType_Parse(absl::string_view name, AdminMessage_ConfigType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdminMessage_ConfigType>(
      AdminMessage_ConfigType_descriptor(), name, value);
}
enum AdminMessage_ModuleConfigType : int {
  AdminMessage_ModuleConfigType_MQTT_CONFIG = 0,
  AdminMessage_ModuleConfigType_SERIAL_CONFIG = 1,
  AdminMessage_ModuleConfigType_EXTNOTIF_CONFIG = 2,
  AdminMessage_ModuleConfigType_STOREFORWARD_CONFIG = 3,
  AdminMessage_ModuleConfigType_RANGETEST_CONFIG = 4,
  AdminMessage_ModuleConfigType_TELEMETRY_CONFIG = 5,
  AdminMessage_ModuleConfigType_CANNEDMSG_CONFIG = 6,
  AdminMessage_ModuleConfigType_AUDIO_CONFIG = 7,
  AdminMessage_ModuleConfigType_REMOTEHARDWARE_CONFIG = 8,
  AdminMessage_ModuleConfigType_NEIGHBORINFO_CONFIG = 9,
  AdminMessage_ModuleConfigType_AMBIENTLIGHTING_CONFIG = 10,
  AdminMessage_ModuleConfigType_DETECTIONSENSOR_CONFIG = 11,
  AdminMessage_ModuleConfigType_PAXCOUNTER_CONFIG = 12,
  AdminMessage_ModuleConfigType_AdminMessage_ModuleConfigType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AdminMessage_ModuleConfigType_AdminMessage_ModuleConfigType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AdminMessage_ModuleConfigType_IsValid(int value);
extern const uint32_t AdminMessage_ModuleConfigType_internal_data_[];
constexpr AdminMessage_ModuleConfigType AdminMessage_ModuleConfigType_ModuleConfigType_MIN = static_cast<AdminMessage_ModuleConfigType>(0);
constexpr AdminMessage_ModuleConfigType AdminMessage_ModuleConfigType_ModuleConfigType_MAX = static_cast<AdminMessage_ModuleConfigType>(12);
constexpr int AdminMessage_ModuleConfigType_ModuleConfigType_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
AdminMessage_ModuleConfigType_descriptor();
template <typename T>
const std::string& AdminMessage_ModuleConfigType_Name(T value) {
  static_assert(std::is_same<T, AdminMessage_ModuleConfigType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ModuleConfigType_Name().");
  return AdminMessage_ModuleConfigType_Name(static_cast<AdminMessage_ModuleConfigType>(value));
}
template <>
inline const std::string& AdminMessage_ModuleConfigType_Name(AdminMessage_ModuleConfigType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AdminMessage_ModuleConfigType_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool AdminMessage_ModuleConfigType_Parse(absl::string_view name, AdminMessage_ModuleConfigType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdminMessage_ModuleConfigType>(
      AdminMessage_ModuleConfigType_descriptor(), name, value);
}
enum AdminMessage_BackupLocation : int {
  AdminMessage_BackupLocation_FLASH = 0,
  AdminMessage_BackupLocation_SD = 1,
  AdminMessage_BackupLocation_AdminMessage_BackupLocation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AdminMessage_BackupLocation_AdminMessage_BackupLocation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AdminMessage_BackupLocation_IsValid(int value);
extern const uint32_t AdminMessage_BackupLocation_internal_data_[];
constexpr AdminMessage_BackupLocation AdminMessage_BackupLocation_BackupLocation_MIN = static_cast<AdminMessage_BackupLocation>(0);
constexpr AdminMessage_BackupLocation AdminMessage_BackupLocation_BackupLocation_MAX = static_cast<AdminMessage_BackupLocation>(1);
constexpr int AdminMessage_BackupLocation_BackupLocation_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AdminMessage_BackupLocation_descriptor();
template <typename T>
const std::string& AdminMessage_BackupLocation_Name(T value) {
  static_assert(std::is_same<T, AdminMessage_BackupLocation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BackupLocation_Name().");
  return AdminMessage_BackupLocation_Name(static_cast<AdminMessage_BackupLocation>(value));
}
template <>
inline const std::string& AdminMessage_BackupLocation_Name(AdminMessage_BackupLocation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AdminMessage_BackupLocation_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AdminMessage_BackupLocation_Parse(absl::string_view name, AdminMessage_BackupLocation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdminMessage_BackupLocation>(
      AdminMessage_BackupLocation_descriptor(), name, value);
}
enum KeyVerificationAdmin_MessageType : int {
  KeyVerificationAdmin_MessageType_INITIATE_VERIFICATION = 0,
  KeyVerificationAdmin_MessageType_PROVIDE_SECURITY_NUMBER = 1,
  KeyVerificationAdmin_MessageType_DO_VERIFY = 2,
  KeyVerificationAdmin_MessageType_DO_NOT_VERIFY = 3,
  KeyVerificationAdmin_MessageType_KeyVerificationAdmin_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  KeyVerificationAdmin_MessageType_KeyVerificationAdmin_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool KeyVerificationAdmin_MessageType_IsValid(int value);
extern const uint32_t KeyVerificationAdmin_MessageType_internal_data_[];
constexpr KeyVerificationAdmin_MessageType KeyVerificationAdmin_MessageType_MessageType_MIN = static_cast<KeyVerificationAdmin_MessageType>(0);
constexpr KeyVerificationAdmin_MessageType KeyVerificationAdmin_MessageType_MessageType_MAX = static_cast<KeyVerificationAdmin_MessageType>(3);
constexpr int KeyVerificationAdmin_MessageType_MessageType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
KeyVerificationAdmin_MessageType_descriptor();
template <typename T>
const std::string& KeyVerificationAdmin_MessageType_Name(T value) {
  static_assert(std::is_same<T, KeyVerificationAdmin_MessageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MessageType_Name().");
  return KeyVerificationAdmin_MessageType_Name(static_cast<KeyVerificationAdmin_MessageType>(value));
}
template <>
inline const std::string& KeyVerificationAdmin_MessageType_Name(KeyVerificationAdmin_MessageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<KeyVerificationAdmin_MessageType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool KeyVerificationAdmin_MessageType_Parse(absl::string_view name, KeyVerificationAdmin_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyVerificationAdmin_MessageType>(
      KeyVerificationAdmin_MessageType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class KeyVerificationAdmin final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.KeyVerificationAdmin) */ {
 public:
  inline KeyVerificationAdmin() : KeyVerificationAdmin(nullptr) {}
  ~KeyVerificationAdmin() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KeyVerificationAdmin* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KeyVerificationAdmin));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyVerificationAdmin(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyVerificationAdmin(const KeyVerificationAdmin& from) : KeyVerificationAdmin(nullptr, from) {}
  inline KeyVerificationAdmin(KeyVerificationAdmin&& from) noexcept
      : KeyVerificationAdmin(nullptr, std::move(from)) {}
  inline KeyVerificationAdmin& operator=(const KeyVerificationAdmin& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyVerificationAdmin& operator=(KeyVerificationAdmin&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyVerificationAdmin& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyVerificationAdmin* internal_default_instance() {
    return reinterpret_cast<const KeyVerificationAdmin*>(
        &_KeyVerificationAdmin_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(KeyVerificationAdmin& a, KeyVerificationAdmin& b) { a.Swap(&b); }
  inline void Swap(KeyVerificationAdmin* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyVerificationAdmin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyVerificationAdmin* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KeyVerificationAdmin>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyVerificationAdmin& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyVerificationAdmin& from) { KeyVerificationAdmin::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KeyVerificationAdmin* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.KeyVerificationAdmin"; }

 protected:
  explicit KeyVerificationAdmin(::google::protobuf::Arena* arena);
  KeyVerificationAdmin(::google::protobuf::Arena* arena, const KeyVerificationAdmin& from);
  KeyVerificationAdmin(::google::protobuf::Arena* arena, KeyVerificationAdmin&& from) noexcept
      : KeyVerificationAdmin(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MessageType = KeyVerificationAdmin_MessageType;
  static constexpr MessageType INITIATE_VERIFICATION = KeyVerificationAdmin_MessageType_INITIATE_VERIFICATION;
  static constexpr MessageType PROVIDE_SECURITY_NUMBER = KeyVerificationAdmin_MessageType_PROVIDE_SECURITY_NUMBER;
  static constexpr MessageType DO_VERIFY = KeyVerificationAdmin_MessageType_DO_VERIFY;
  static constexpr MessageType DO_NOT_VERIFY = KeyVerificationAdmin_MessageType_DO_NOT_VERIFY;
  static inline bool MessageType_IsValid(int value) {
    return KeyVerificationAdmin_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN = KeyVerificationAdmin_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX = KeyVerificationAdmin_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE = KeyVerificationAdmin_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
    return KeyVerificationAdmin_MessageType_descriptor();
  }
  template <typename T>
  static inline const std::string& MessageType_Name(T value) {
    return KeyVerificationAdmin_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(absl::string_view name, MessageType* value) {
    return KeyVerificationAdmin_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageTypeFieldNumber = 1,
    kRemoteNodenumFieldNumber = 2,
    kNonceFieldNumber = 3,
    kSecurityNumberFieldNumber = 4,
  };
  // .meshtastic.KeyVerificationAdmin.MessageType message_type = 1;
  void clear_message_type() ;
  ::meshtastic::KeyVerificationAdmin_MessageType message_type() const;
  void set_message_type(::meshtastic::KeyVerificationAdmin_MessageType value);

  private:
  ::meshtastic::KeyVerificationAdmin_MessageType _internal_message_type() const;
  void _internal_set_message_type(::meshtastic::KeyVerificationAdmin_MessageType value);

  public:
  // uint32 remote_nodenum = 2;
  void clear_remote_nodenum() ;
  ::uint32_t remote_nodenum() const;
  void set_remote_nodenum(::uint32_t value);

  private:
  ::uint32_t _internal_remote_nodenum() const;
  void _internal_set_remote_nodenum(::uint32_t value);

  public:
  // uint64 nonce = 3;
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // optional uint32 security_number = 4;
  bool has_security_number() const;
  void clear_security_number() ;
  ::uint32_t security_number() const;
  void set_security_number(::uint32_t value);

  private:
  ::uint32_t _internal_security_number() const;
  void _internal_set_security_number(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.KeyVerificationAdmin)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyVerificationAdmin& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int message_type_;
    ::uint32_t remote_nodenum_;
    ::uint64_t nonce_;
    ::uint32_t security_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};
// -------------------------------------------------------------------

class HamParameters final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.HamParameters) */ {
 public:
  inline HamParameters() : HamParameters(nullptr) {}
  ~HamParameters() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HamParameters* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HamParameters));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HamParameters(
      ::google::protobuf::internal::ConstantInitialized);

  inline HamParameters(const HamParameters& from) : HamParameters(nullptr, from) {}
  inline HamParameters(HamParameters&& from) noexcept
      : HamParameters(nullptr, std::move(from)) {}
  inline HamParameters& operator=(const HamParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline HamParameters& operator=(HamParameters&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HamParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const HamParameters* internal_default_instance() {
    return reinterpret_cast<const HamParameters*>(
        &_HamParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(HamParameters& a, HamParameters& b) { a.Swap(&b); }
  inline void Swap(HamParameters* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HamParameters* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HamParameters* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HamParameters>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HamParameters& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HamParameters& from) { HamParameters::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HamParameters* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.HamParameters"; }

 protected:
  explicit HamParameters(::google::protobuf::Arena* arena);
  HamParameters(::google::protobuf::Arena* arena, const HamParameters& from);
  HamParameters(::google::protobuf::Arena* arena, HamParameters&& from) noexcept
      : HamParameters(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCallSignFieldNumber = 1,
    kShortNameFieldNumber = 4,
    kTxPowerFieldNumber = 2,
    kFrequencyFieldNumber = 3,
  };
  // string call_sign = 1;
  void clear_call_sign() ;
  const std::string& call_sign() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_call_sign(Arg_&& arg, Args_... args);
  std::string* mutable_call_sign();
  PROTOBUF_NODISCARD std::string* release_call_sign();
  void set_allocated_call_sign(std::string* value);

  private:
  const std::string& _internal_call_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_sign(
      const std::string& value);
  std::string* _internal_mutable_call_sign();

  public:
  // string short_name = 4;
  void clear_short_name() ;
  const std::string& short_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_short_name(Arg_&& arg, Args_... args);
  std::string* mutable_short_name();
  PROTOBUF_NODISCARD std::string* release_short_name();
  void set_allocated_short_name(std::string* value);

  private:
  const std::string& _internal_short_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_short_name(
      const std::string& value);
  std::string* _internal_mutable_short_name();

  public:
  // int32 tx_power = 2;
  void clear_tx_power() ;
  ::int32_t tx_power() const;
  void set_tx_power(::int32_t value);

  private:
  ::int32_t _internal_tx_power() const;
  void _internal_set_tx_power(::int32_t value);

  public:
  // float frequency = 3;
  void clear_frequency() ;
  float frequency() const;
  void set_frequency(float value);

  private:
  float _internal_frequency() const;
  void _internal_set_frequency(float value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.HamParameters)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      52, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HamParameters& from_msg);
    ::google::protobuf::internal::ArenaStringPtr call_sign_;
    ::google::protobuf::internal::ArenaStringPtr short_name_;
    ::int32_t tx_power_;
    float frequency_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};
// -------------------------------------------------------------------

class AdminMessage_InputEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.AdminMessage.InputEvent) */ {
 public:
  inline AdminMessage_InputEvent() : AdminMessage_InputEvent(nullptr) {}
  ~AdminMessage_InputEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AdminMessage_InputEvent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AdminMessage_InputEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AdminMessage_InputEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline AdminMessage_InputEvent(const AdminMessage_InputEvent& from) : AdminMessage_InputEvent(nullptr, from) {}
  inline AdminMessage_InputEvent(AdminMessage_InputEvent&& from) noexcept
      : AdminMessage_InputEvent(nullptr, std::move(from)) {}
  inline AdminMessage_InputEvent& operator=(const AdminMessage_InputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminMessage_InputEvent& operator=(AdminMessage_InputEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminMessage_InputEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminMessage_InputEvent* internal_default_instance() {
    return reinterpret_cast<const AdminMessage_InputEvent*>(
        &_AdminMessage_InputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(AdminMessage_InputEvent& a, AdminMessage_InputEvent& b) { a.Swap(&b); }
  inline void Swap(AdminMessage_InputEvent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminMessage_InputEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminMessage_InputEvent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AdminMessage_InputEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AdminMessage_InputEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AdminMessage_InputEvent& from) { AdminMessage_InputEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AdminMessage_InputEvent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.AdminMessage.InputEvent"; }

 protected:
  explicit AdminMessage_InputEvent(::google::protobuf::Arena* arena);
  AdminMessage_InputEvent(::google::protobuf::Arena* arena, const AdminMessage_InputEvent& from);
  AdminMessage_InputEvent(::google::protobuf::Arena* arena, AdminMessage_InputEvent&& from) noexcept
      : AdminMessage_InputEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventCodeFieldNumber = 1,
    kKbCharFieldNumber = 2,
    kTouchXFieldNumber = 3,
    kTouchYFieldNumber = 4,
  };
  // uint32 event_code = 1;
  void clear_event_code() ;
  ::uint32_t event_code() const;
  void set_event_code(::uint32_t value);

  private:
  ::uint32_t _internal_event_code() const;
  void _internal_set_event_code(::uint32_t value);

  public:
  // uint32 kb_char = 2;
  void clear_kb_char() ;
  ::uint32_t kb_char() const;
  void set_kb_char(::uint32_t value);

  private:
  ::uint32_t _internal_kb_char() const;
  void _internal_set_kb_char(::uint32_t value);

  public:
  // uint32 touch_x = 3;
  void clear_touch_x() ;
  ::uint32_t touch_x() const;
  void set_touch_x(::uint32_t value);

  private:
  ::uint32_t _internal_touch_x() const;
  void _internal_set_touch_x(::uint32_t value);

  public:
  // uint32 touch_y = 4;
  void clear_touch_y() ;
  ::uint32_t touch_y() const;
  void set_touch_y(::uint32_t value);

  private:
  ::uint32_t _internal_touch_y() const;
  void _internal_set_touch_y(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.AdminMessage.InputEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AdminMessage_InputEvent& from_msg);
    ::uint32_t event_code_;
    ::uint32_t kb_char_;
    ::uint32_t touch_x_;
    ::uint32_t touch_y_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};
// -------------------------------------------------------------------

class SharedContact final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.SharedContact) */ {
 public:
  inline SharedContact() : SharedContact(nullptr) {}
  ~SharedContact() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SharedContact* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SharedContact));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SharedContact(
      ::google::protobuf::internal::ConstantInitialized);

  inline SharedContact(const SharedContact& from) : SharedContact(nullptr, from) {}
  inline SharedContact(SharedContact&& from) noexcept
      : SharedContact(nullptr, std::move(from)) {}
  inline SharedContact& operator=(const SharedContact& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharedContact& operator=(SharedContact&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SharedContact& default_instance() {
    return *internal_default_instance();
  }
  static inline const SharedContact* internal_default_instance() {
    return reinterpret_cast<const SharedContact*>(
        &_SharedContact_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SharedContact& a, SharedContact& b) { a.Swap(&b); }
  inline void Swap(SharedContact* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharedContact* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SharedContact* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SharedContact>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SharedContact& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SharedContact& from) { SharedContact::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SharedContact* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.SharedContact"; }

 protected:
  explicit SharedContact(::google::protobuf::Arena* arena);
  SharedContact(::google::protobuf::Arena* arena, const SharedContact& from);
  SharedContact(::google::protobuf::Arena* arena, SharedContact&& from) noexcept
      : SharedContact(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 2,
    kNodeNumFieldNumber = 1,
    kShouldIgnoreFieldNumber = 3,
  };
  // .meshtastic.User user = 2;
  bool has_user() const;
  void clear_user() ;
  const ::meshtastic::User& user() const;
  PROTOBUF_NODISCARD ::meshtastic::User* release_user();
  ::meshtastic::User* mutable_user();
  void set_allocated_user(::meshtastic::User* value);
  void unsafe_arena_set_allocated_user(::meshtastic::User* value);
  ::meshtastic::User* unsafe_arena_release_user();

  private:
  const ::meshtastic::User& _internal_user() const;
  ::meshtastic::User* _internal_mutable_user();

  public:
  // uint32 node_num = 1;
  void clear_node_num() ;
  ::uint32_t node_num() const;
  void set_node_num(::uint32_t value);

  private:
  ::uint32_t _internal_node_num() const;
  void _internal_set_node_num(::uint32_t value);

  public:
  // bool should_ignore = 3;
  void clear_should_ignore() ;
  bool should_ignore() const;
  void set_should_ignore(bool value);

  private:
  bool _internal_should_ignore() const;
  void _internal_set_should_ignore(bool value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.SharedContact)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SharedContact& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::meshtastic::User* user_;
    ::uint32_t node_num_;
    bool should_ignore_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};
// -------------------------------------------------------------------

class NodeRemoteHardwarePinsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.NodeRemoteHardwarePinsResponse) */ {
 public:
  inline NodeRemoteHardwarePinsResponse() : NodeRemoteHardwarePinsResponse(nullptr) {}
  ~NodeRemoteHardwarePinsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeRemoteHardwarePinsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeRemoteHardwarePinsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeRemoteHardwarePinsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeRemoteHardwarePinsResponse(const NodeRemoteHardwarePinsResponse& from) : NodeRemoteHardwarePinsResponse(nullptr, from) {}
  inline NodeRemoteHardwarePinsResponse(NodeRemoteHardwarePinsResponse&& from) noexcept
      : NodeRemoteHardwarePinsResponse(nullptr, std::move(from)) {}
  inline NodeRemoteHardwarePinsResponse& operator=(const NodeRemoteHardwarePinsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRemoteHardwarePinsResponse& operator=(NodeRemoteHardwarePinsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRemoteHardwarePinsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRemoteHardwarePinsResponse* internal_default_instance() {
    return reinterpret_cast<const NodeRemoteHardwarePinsResponse*>(
        &_NodeRemoteHardwarePinsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(NodeRemoteHardwarePinsResponse& a, NodeRemoteHardwarePinsResponse& b) { a.Swap(&b); }
  inline void Swap(NodeRemoteHardwarePinsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRemoteHardwarePinsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRemoteHardwarePinsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeRemoteHardwarePinsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeRemoteHardwarePinsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeRemoteHardwarePinsResponse& from) { NodeRemoteHardwarePinsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeRemoteHardwarePinsResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.NodeRemoteHardwarePinsResponse"; }

 protected:
  explicit NodeRemoteHardwarePinsResponse(::google::protobuf::Arena* arena);
  NodeRemoteHardwarePinsResponse(::google::protobuf::Arena* arena, const NodeRemoteHardwarePinsResponse& from);
  NodeRemoteHardwarePinsResponse(::google::protobuf::Arena* arena, NodeRemoteHardwarePinsResponse&& from) noexcept
      : NodeRemoteHardwarePinsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeRemoteHardwarePinsFieldNumber = 1,
  };
  // repeated .meshtastic.NodeRemoteHardwarePin node_remote_hardware_pins = 1;
  int node_remote_hardware_pins_size() const;
  private:
  int _internal_node_remote_hardware_pins_size() const;

  public:
  void clear_node_remote_hardware_pins() ;
  ::meshtastic::NodeRemoteHardwarePin* mutable_node_remote_hardware_pins(int index);
  ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>* mutable_node_remote_hardware_pins();

  private:
  const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>& _internal_node_remote_hardware_pins() const;
  ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>* _internal_mutable_node_remote_hardware_pins();
  public:
  const ::meshtastic::NodeRemoteHardwarePin& node_remote_hardware_pins(int index) const;
  ::meshtastic::NodeRemoteHardwarePin* add_node_remote_hardware_pins();
  const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>& node_remote_hardware_pins() const;
  // @@protoc_insertion_point(class_scope:meshtastic.NodeRemoteHardwarePinsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeRemoteHardwarePinsResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin > node_remote_hardware_pins_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};
// -------------------------------------------------------------------

class AdminMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.AdminMessage) */ {
 public:
  inline AdminMessage() : AdminMessage(nullptr) {}
  ~AdminMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AdminMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AdminMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AdminMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline AdminMessage(const AdminMessage& from) : AdminMessage(nullptr, from) {}
  inline AdminMessage(AdminMessage&& from) noexcept
      : AdminMessage(nullptr, std::move(from)) {}
  inline AdminMessage& operator=(const AdminMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminMessage& operator=(AdminMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kGetChannelRequest = 1,
    kGetChannelResponse = 2,
    kGetOwnerRequest = 3,
    kGetOwnerResponse = 4,
    kGetConfigRequest = 5,
    kGetConfigResponse = 6,
    kGetModuleConfigRequest = 7,
    kGetModuleConfigResponse = 8,
    kGetCannedMessageModuleMessagesRequest = 10,
    kGetCannedMessageModuleMessagesResponse = 11,
    kGetDeviceMetadataRequest = 12,
    kGetDeviceMetadataResponse = 13,
    kGetRingtoneRequest = 14,
    kGetRingtoneResponse = 15,
    kGetDeviceConnectionStatusRequest = 16,
    kGetDeviceConnectionStatusResponse = 17,
    kSetHamMode = 18,
    kGetNodeRemoteHardwarePinsRequest = 19,
    kGetNodeRemoteHardwarePinsResponse = 20,
    kEnterDfuModeRequest = 21,
    kDeleteFileRequest = 22,
    kSetScale = 23,
    kBackupPreferences = 24,
    kRestorePreferences = 25,
    kRemoveBackupPreferences = 26,
    kSendInputEvent = 27,
    kSetOwner = 32,
    kSetChannel = 33,
    kSetConfig = 34,
    kSetModuleConfig = 35,
    kSetCannedMessageModuleMessages = 36,
    kSetRingtoneMessage = 37,
    kRemoveByNodenum = 38,
    kSetFavoriteNode = 39,
    kRemoveFavoriteNode = 40,
    kSetFixedPosition = 41,
    kRemoveFixedPosition = 42,
    kSetTimeOnly = 43,
    kGetUiConfigRequest = 44,
    kGetUiConfigResponse = 45,
    kStoreUiConfig = 46,
    kSetIgnoredNode = 47,
    kRemoveIgnoredNode = 48,
    kBeginEditSettings = 64,
    kCommitEditSettings = 65,
    kAddContact = 66,
    kKeyVerification = 67,
    kFactoryResetDevice = 94,
    kRebootOtaSeconds = 95,
    kExitSimulator = 96,
    kRebootSeconds = 97,
    kShutdownSeconds = 98,
    kFactoryResetConfig = 99,
    kNodedbReset = 100,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };
  static inline const AdminMessage* internal_default_instance() {
    return reinterpret_cast<const AdminMessage*>(
        &_AdminMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(AdminMessage& a, AdminMessage& b) { a.Swap(&b); }
  inline void Swap(AdminMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AdminMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AdminMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AdminMessage& from) { AdminMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AdminMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.AdminMessage"; }

 protected:
  explicit AdminMessage(::google::protobuf::Arena* arena);
  AdminMessage(::google::protobuf::Arena* arena, const AdminMessage& from);
  AdminMessage(::google::protobuf::Arena* arena, AdminMessage&& from) noexcept
      : AdminMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using InputEvent = AdminMessage_InputEvent;
  using ConfigType = AdminMessage_ConfigType;
  static constexpr ConfigType DEVICE_CONFIG = AdminMessage_ConfigType_DEVICE_CONFIG;
  static constexpr ConfigType POSITION_CONFIG = AdminMessage_ConfigType_POSITION_CONFIG;
  static constexpr ConfigType POWER_CONFIG = AdminMessage_ConfigType_POWER_CONFIG;
  static constexpr ConfigType NETWORK_CONFIG = AdminMessage_ConfigType_NETWORK_CONFIG;
  static constexpr ConfigType DISPLAY_CONFIG = AdminMessage_ConfigType_DISPLAY_CONFIG;
  static constexpr ConfigType LORA_CONFIG = AdminMessage_ConfigType_LORA_CONFIG;
  static constexpr ConfigType BLUETOOTH_CONFIG = AdminMessage_ConfigType_BLUETOOTH_CONFIG;
  static constexpr ConfigType SECURITY_CONFIG = AdminMessage_ConfigType_SECURITY_CONFIG;
  static constexpr ConfigType SESSIONKEY_CONFIG = AdminMessage_ConfigType_SESSIONKEY_CONFIG;
  static constexpr ConfigType DEVICEUI_CONFIG = AdminMessage_ConfigType_DEVICEUI_CONFIG;
  static inline bool ConfigType_IsValid(int value) {
    return AdminMessage_ConfigType_IsValid(value);
  }
  static constexpr ConfigType ConfigType_MIN = AdminMessage_ConfigType_ConfigType_MIN;
  static constexpr ConfigType ConfigType_MAX = AdminMessage_ConfigType_ConfigType_MAX;
  static constexpr int ConfigType_ARRAYSIZE = AdminMessage_ConfigType_ConfigType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ConfigType_descriptor() {
    return AdminMessage_ConfigType_descriptor();
  }
  template <typename T>
  static inline const std::string& ConfigType_Name(T value) {
    return AdminMessage_ConfigType_Name(value);
  }
  static inline bool ConfigType_Parse(absl::string_view name, ConfigType* value) {
    return AdminMessage_ConfigType_Parse(name, value);
  }
  using ModuleConfigType = AdminMessage_ModuleConfigType;
  static constexpr ModuleConfigType MQTT_CONFIG = AdminMessage_ModuleConfigType_MQTT_CONFIG;
  static constexpr ModuleConfigType SERIAL_CONFIG = AdminMessage_ModuleConfigType_SERIAL_CONFIG;
  static constexpr ModuleConfigType EXTNOTIF_CONFIG = AdminMessage_ModuleConfigType_EXTNOTIF_CONFIG;
  static constexpr ModuleConfigType STOREFORWARD_CONFIG = AdminMessage_ModuleConfigType_STOREFORWARD_CONFIG;
  static constexpr ModuleConfigType RANGETEST_CONFIG = AdminMessage_ModuleConfigType_RANGETEST_CONFIG;
  static constexpr ModuleConfigType TELEMETRY_CONFIG = AdminMessage_ModuleConfigType_TELEMETRY_CONFIG;
  static constexpr ModuleConfigType CANNEDMSG_CONFIG = AdminMessage_ModuleConfigType_CANNEDMSG_CONFIG;
  static constexpr ModuleConfigType AUDIO_CONFIG = AdminMessage_ModuleConfigType_AUDIO_CONFIG;
  static constexpr ModuleConfigType REMOTEHARDWARE_CONFIG = AdminMessage_ModuleConfigType_REMOTEHARDWARE_CONFIG;
  static constexpr ModuleConfigType NEIGHBORINFO_CONFIG = AdminMessage_ModuleConfigType_NEIGHBORINFO_CONFIG;
  static constexpr ModuleConfigType AMBIENTLIGHTING_CONFIG = AdminMessage_ModuleConfigType_AMBIENTLIGHTING_CONFIG;
  static constexpr ModuleConfigType DETECTIONSENSOR_CONFIG = AdminMessage_ModuleConfigType_DETECTIONSENSOR_CONFIG;
  static constexpr ModuleConfigType PAXCOUNTER_CONFIG = AdminMessage_ModuleConfigType_PAXCOUNTER_CONFIG;
  static inline bool ModuleConfigType_IsValid(int value) {
    return AdminMessage_ModuleConfigType_IsValid(value);
  }
  static constexpr ModuleConfigType ModuleConfigType_MIN = AdminMessage_ModuleConfigType_ModuleConfigType_MIN;
  static constexpr ModuleConfigType ModuleConfigType_MAX = AdminMessage_ModuleConfigType_ModuleConfigType_MAX;
  static constexpr int ModuleConfigType_ARRAYSIZE = AdminMessage_ModuleConfigType_ModuleConfigType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ModuleConfigType_descriptor() {
    return AdminMessage_ModuleConfigType_descriptor();
  }
  template <typename T>
  static inline const std::string& ModuleConfigType_Name(T value) {
    return AdminMessage_ModuleConfigType_Name(value);
  }
  static inline bool ModuleConfigType_Parse(absl::string_view name, ModuleConfigType* value) {
    return AdminMessage_ModuleConfigType_Parse(name, value);
  }
  using BackupLocation = AdminMessage_BackupLocation;
  static constexpr BackupLocation FLASH = AdminMessage_BackupLocation_FLASH;
  static constexpr BackupLocation SD = AdminMessage_BackupLocation_SD;
  static inline bool BackupLocation_IsValid(int value) {
    return AdminMessage_BackupLocation_IsValid(value);
  }
  static constexpr BackupLocation BackupLocation_MIN = AdminMessage_BackupLocation_BackupLocation_MIN;
  static constexpr BackupLocation BackupLocation_MAX = AdminMessage_BackupLocation_BackupLocation_MAX;
  static constexpr int BackupLocation_ARRAYSIZE = AdminMessage_BackupLocation_BackupLocation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BackupLocation_descriptor() {
    return AdminMessage_BackupLocation_descriptor();
  }
  template <typename T>
  static inline const std::string& BackupLocation_Name(T value) {
    return AdminMessage_BackupLocation_Name(value);
  }
  static inline bool BackupLocation_Parse(absl::string_view name, BackupLocation* value) {
    return AdminMessage_BackupLocation_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kSessionPasskeyFieldNumber = 101,
    kGetChannelRequestFieldNumber = 1,
    kGetChannelResponseFieldNumber = 2,
    kGetOwnerRequestFieldNumber = 3,
    kGetOwnerResponseFieldNumber = 4,
    kGetConfigRequestFieldNumber = 5,
    kGetConfigResponseFieldNumber = 6,
    kGetModuleConfigRequestFieldNumber = 7,
    kGetModuleConfigResponseFieldNumber = 8,
    kGetCannedMessageModuleMessagesRequestFieldNumber = 10,
    kGetCannedMessageModuleMessagesResponseFieldNumber = 11,
    kGetDeviceMetadataRequestFieldNumber = 12,
    kGetDeviceMetadataResponseFieldNumber = 13,
    kGetRingtoneRequestFieldNumber = 14,
    kGetRingtoneResponseFieldNumber = 15,
    kGetDeviceConnectionStatusRequestFieldNumber = 16,
    kGetDeviceConnectionStatusResponseFieldNumber = 17,
    kSetHamModeFieldNumber = 18,
    kGetNodeRemoteHardwarePinsRequestFieldNumber = 19,
    kGetNodeRemoteHardwarePinsResponseFieldNumber = 20,
    kEnterDfuModeRequestFieldNumber = 21,
    kDeleteFileRequestFieldNumber = 22,
    kSetScaleFieldNumber = 23,
    kBackupPreferencesFieldNumber = 24,
    kRestorePreferencesFieldNumber = 25,
    kRemoveBackupPreferencesFieldNumber = 26,
    kSendInputEventFieldNumber = 27,
    kSetOwnerFieldNumber = 32,
    kSetChannelFieldNumber = 33,
    kSetConfigFieldNumber = 34,
    kSetModuleConfigFieldNumber = 35,
    kSetCannedMessageModuleMessagesFieldNumber = 36,
    kSetRingtoneMessageFieldNumber = 37,
    kRemoveByNodenumFieldNumber = 38,
    kSetFavoriteNodeFieldNumber = 39,
    kRemoveFavoriteNodeFieldNumber = 40,
    kSetFixedPositionFieldNumber = 41,
    kRemoveFixedPositionFieldNumber = 42,
    kSetTimeOnlyFieldNumber = 43,
    kGetUiConfigRequestFieldNumber = 44,
    kGetUiConfigResponseFieldNumber = 45,
    kStoreUiConfigFieldNumber = 46,
    kSetIgnoredNodeFieldNumber = 47,
    kRemoveIgnoredNodeFieldNumber = 48,
    kBeginEditSettingsFieldNumber = 64,
    kCommitEditSettingsFieldNumber = 65,
    kAddContactFieldNumber = 66,
    kKeyVerificationFieldNumber = 67,
    kFactoryResetDeviceFieldNumber = 94,
    kRebootOtaSecondsFieldNumber = 95,
    kExitSimulatorFieldNumber = 96,
    kRebootSecondsFieldNumber = 97,
    kShutdownSecondsFieldNumber = 98,
    kFactoryResetConfigFieldNumber = 99,
    kNodedbResetFieldNumber = 100,
  };
  // bytes session_passkey = 101;
  void clear_session_passkey() ;
  const std::string& session_passkey() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_passkey(Arg_&& arg, Args_... args);
  std::string* mutable_session_passkey();
  PROTOBUF_NODISCARD std::string* release_session_passkey();
  void set_allocated_session_passkey(std::string* value);

  private:
  const std::string& _internal_session_passkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_passkey(
      const std::string& value);
  std::string* _internal_mutable_session_passkey();

  public:
  // uint32 get_channel_request = 1;
  bool has_get_channel_request() const;
  void clear_get_channel_request() ;
  ::uint32_t get_channel_request() const;
  void set_get_channel_request(::uint32_t value);

  private:
  ::uint32_t _internal_get_channel_request() const;
  void _internal_set_get_channel_request(::uint32_t value);

  public:
  // .meshtastic.Channel get_channel_response = 2;
  bool has_get_channel_response() const;
  private:
  bool _internal_has_get_channel_response() const;

  public:
  void clear_get_channel_response() ;
  const ::meshtastic::Channel& get_channel_response() const;
  PROTOBUF_NODISCARD ::meshtastic::Channel* release_get_channel_response();
  ::meshtastic::Channel* mutable_get_channel_response();
  void set_allocated_get_channel_response(::meshtastic::Channel* value);
  void unsafe_arena_set_allocated_get_channel_response(::meshtastic::Channel* value);
  ::meshtastic::Channel* unsafe_arena_release_get_channel_response();

  private:
  const ::meshtastic::Channel& _internal_get_channel_response() const;
  ::meshtastic::Channel* _internal_mutable_get_channel_response();

  public:
  // bool get_owner_request = 3;
  bool has_get_owner_request() const;
  void clear_get_owner_request() ;
  bool get_owner_request() const;
  void set_get_owner_request(bool value);

  private:
  bool _internal_get_owner_request() const;
  void _internal_set_get_owner_request(bool value);

  public:
  // .meshtastic.User get_owner_response = 4;
  bool has_get_owner_response() const;
  private:
  bool _internal_has_get_owner_response() const;

  public:
  void clear_get_owner_response() ;
  const ::meshtastic::User& get_owner_response() const;
  PROTOBUF_NODISCARD ::meshtastic::User* release_get_owner_response();
  ::meshtastic::User* mutable_get_owner_response();
  void set_allocated_get_owner_response(::meshtastic::User* value);
  void unsafe_arena_set_allocated_get_owner_response(::meshtastic::User* value);
  ::meshtastic::User* unsafe_arena_release_get_owner_response();

  private:
  const ::meshtastic::User& _internal_get_owner_response() const;
  ::meshtastic::User* _internal_mutable_get_owner_response();

  public:
  // .meshtastic.AdminMessage.ConfigType get_config_request = 5;
  bool has_get_config_request() const;
  void clear_get_config_request() ;
  ::meshtastic::AdminMessage_ConfigType get_config_request() const;
  void set_get_config_request(::meshtastic::AdminMessage_ConfigType value);

  private:
  ::meshtastic::AdminMessage_ConfigType _internal_get_config_request() const;
  void _internal_set_get_config_request(::meshtastic::AdminMessage_ConfigType value);

  public:
  // .meshtastic.Config get_config_response = 6;
  bool has_get_config_response() const;
  private:
  bool _internal_has_get_config_response() const;

  public:
  void clear_get_config_response() ;
  const ::meshtastic::Config& get_config_response() const;
  PROTOBUF_NODISCARD ::meshtastic::Config* release_get_config_response();
  ::meshtastic::Config* mutable_get_config_response();
  void set_allocated_get_config_response(::meshtastic::Config* value);
  void unsafe_arena_set_allocated_get_config_response(::meshtastic::Config* value);
  ::meshtastic::Config* unsafe_arena_release_get_config_response();

  private:
  const ::meshtastic::Config& _internal_get_config_response() const;
  ::meshtastic::Config* _internal_mutable_get_config_response();

  public:
  // .meshtastic.AdminMessage.ModuleConfigType get_module_config_request = 7;
  bool has_get_module_config_request() const;
  void clear_get_module_config_request() ;
  ::meshtastic::AdminMessage_ModuleConfigType get_module_config_request() const;
  void set_get_module_config_request(::meshtastic::AdminMessage_ModuleConfigType value);

  private:
  ::meshtastic::AdminMessage_ModuleConfigType _internal_get_module_config_request() const;
  void _internal_set_get_module_config_request(::meshtastic::AdminMessage_ModuleConfigType value);

  public:
  // .meshtastic.ModuleConfig get_module_config_response = 8;
  bool has_get_module_config_response() const;
  private:
  bool _internal_has_get_module_config_response() const;

  public:
  void clear_get_module_config_response() ;
  const ::meshtastic::ModuleConfig& get_module_config_response() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig* release_get_module_config_response();
  ::meshtastic::ModuleConfig* mutable_get_module_config_response();
  void set_allocated_get_module_config_response(::meshtastic::ModuleConfig* value);
  void unsafe_arena_set_allocated_get_module_config_response(::meshtastic::ModuleConfig* value);
  ::meshtastic::ModuleConfig* unsafe_arena_release_get_module_config_response();

  private:
  const ::meshtastic::ModuleConfig& _internal_get_module_config_response() const;
  ::meshtastic::ModuleConfig* _internal_mutable_get_module_config_response();

  public:
  // bool get_canned_message_module_messages_request = 10;
  bool has_get_canned_message_module_messages_request() const;
  void clear_get_canned_message_module_messages_request() ;
  bool get_canned_message_module_messages_request() const;
  void set_get_canned_message_module_messages_request(bool value);

  private:
  bool _internal_get_canned_message_module_messages_request() const;
  void _internal_set_get_canned_message_module_messages_request(bool value);

  public:
  // string get_canned_message_module_messages_response = 11;
  bool has_get_canned_message_module_messages_response() const;
  void clear_get_canned_message_module_messages_response() ;
  const std::string& get_canned_message_module_messages_response() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_get_canned_message_module_messages_response(Arg_&& arg, Args_... args);
  std::string* mutable_get_canned_message_module_messages_response();
  PROTOBUF_NODISCARD std::string* release_get_canned_message_module_messages_response();
  void set_allocated_get_canned_message_module_messages_response(std::string* value);

  private:
  const std::string& _internal_get_canned_message_module_messages_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_get_canned_message_module_messages_response(
      const std::string& value);
  std::string* _internal_mutable_get_canned_message_module_messages_response();

  public:
  // bool get_device_metadata_request = 12;
  bool has_get_device_metadata_request() const;
  void clear_get_device_metadata_request() ;
  bool get_device_metadata_request() const;
  void set_get_device_metadata_request(bool value);

  private:
  bool _internal_get_device_metadata_request() const;
  void _internal_set_get_device_metadata_request(bool value);

  public:
  // .meshtastic.DeviceMetadata get_device_metadata_response = 13;
  bool has_get_device_metadata_response() const;
  private:
  bool _internal_has_get_device_metadata_response() const;

  public:
  void clear_get_device_metadata_response() ;
  const ::meshtastic::DeviceMetadata& get_device_metadata_response() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceMetadata* release_get_device_metadata_response();
  ::meshtastic::DeviceMetadata* mutable_get_device_metadata_response();
  void set_allocated_get_device_metadata_response(::meshtastic::DeviceMetadata* value);
  void unsafe_arena_set_allocated_get_device_metadata_response(::meshtastic::DeviceMetadata* value);
  ::meshtastic::DeviceMetadata* unsafe_arena_release_get_device_metadata_response();

  private:
  const ::meshtastic::DeviceMetadata& _internal_get_device_metadata_response() const;
  ::meshtastic::DeviceMetadata* _internal_mutable_get_device_metadata_response();

  public:
  // bool get_ringtone_request = 14;
  bool has_get_ringtone_request() const;
  void clear_get_ringtone_request() ;
  bool get_ringtone_request() const;
  void set_get_ringtone_request(bool value);

  private:
  bool _internal_get_ringtone_request() const;
  void _internal_set_get_ringtone_request(bool value);

  public:
  // string get_ringtone_response = 15;
  bool has_get_ringtone_response() const;
  void clear_get_ringtone_response() ;
  const std::string& get_ringtone_response() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_get_ringtone_response(Arg_&& arg, Args_... args);
  std::string* mutable_get_ringtone_response();
  PROTOBUF_NODISCARD std::string* release_get_ringtone_response();
  void set_allocated_get_ringtone_response(std::string* value);

  private:
  const std::string& _internal_get_ringtone_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_get_ringtone_response(
      const std::string& value);
  std::string* _internal_mutable_get_ringtone_response();

  public:
  // bool get_device_connection_status_request = 16;
  bool has_get_device_connection_status_request() const;
  void clear_get_device_connection_status_request() ;
  bool get_device_connection_status_request() const;
  void set_get_device_connection_status_request(bool value);

  private:
  bool _internal_get_device_connection_status_request() const;
  void _internal_set_get_device_connection_status_request(bool value);

  public:
  // .meshtastic.DeviceConnectionStatus get_device_connection_status_response = 17;
  bool has_get_device_connection_status_response() const;
  private:
  bool _internal_has_get_device_connection_status_response() const;

  public:
  void clear_get_device_connection_status_response() ;
  const ::meshtastic::DeviceConnectionStatus& get_device_connection_status_response() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceConnectionStatus* release_get_device_connection_status_response();
  ::meshtastic::DeviceConnectionStatus* mutable_get_device_connection_status_response();
  void set_allocated_get_device_connection_status_response(::meshtastic::DeviceConnectionStatus* value);
  void unsafe_arena_set_allocated_get_device_connection_status_response(::meshtastic::DeviceConnectionStatus* value);
  ::meshtastic::DeviceConnectionStatus* unsafe_arena_release_get_device_connection_status_response();

  private:
  const ::meshtastic::DeviceConnectionStatus& _internal_get_device_connection_status_response() const;
  ::meshtastic::DeviceConnectionStatus* _internal_mutable_get_device_connection_status_response();

  public:
  // .meshtastic.HamParameters set_ham_mode = 18;
  bool has_set_ham_mode() const;
  private:
  bool _internal_has_set_ham_mode() const;

  public:
  void clear_set_ham_mode() ;
  const ::meshtastic::HamParameters& set_ham_mode() const;
  PROTOBUF_NODISCARD ::meshtastic::HamParameters* release_set_ham_mode();
  ::meshtastic::HamParameters* mutable_set_ham_mode();
  void set_allocated_set_ham_mode(::meshtastic::HamParameters* value);
  void unsafe_arena_set_allocated_set_ham_mode(::meshtastic::HamParameters* value);
  ::meshtastic::HamParameters* unsafe_arena_release_set_ham_mode();

  private:
  const ::meshtastic::HamParameters& _internal_set_ham_mode() const;
  ::meshtastic::HamParameters* _internal_mutable_set_ham_mode();

  public:
  // bool get_node_remote_hardware_pins_request = 19;
  bool has_get_node_remote_hardware_pins_request() const;
  void clear_get_node_remote_hardware_pins_request() ;
  bool get_node_remote_hardware_pins_request() const;
  void set_get_node_remote_hardware_pins_request(bool value);

  private:
  bool _internal_get_node_remote_hardware_pins_request() const;
  void _internal_set_get_node_remote_hardware_pins_request(bool value);

  public:
  // .meshtastic.NodeRemoteHardwarePinsResponse get_node_remote_hardware_pins_response = 20;
  bool has_get_node_remote_hardware_pins_response() const;
  private:
  bool _internal_has_get_node_remote_hardware_pins_response() const;

  public:
  void clear_get_node_remote_hardware_pins_response() ;
  const ::meshtastic::NodeRemoteHardwarePinsResponse& get_node_remote_hardware_pins_response() const;
  PROTOBUF_NODISCARD ::meshtastic::NodeRemoteHardwarePinsResponse* release_get_node_remote_hardware_pins_response();
  ::meshtastic::NodeRemoteHardwarePinsResponse* mutable_get_node_remote_hardware_pins_response();
  void set_allocated_get_node_remote_hardware_pins_response(::meshtastic::NodeRemoteHardwarePinsResponse* value);
  void unsafe_arena_set_allocated_get_node_remote_hardware_pins_response(::meshtastic::NodeRemoteHardwarePinsResponse* value);
  ::meshtastic::NodeRemoteHardwarePinsResponse* unsafe_arena_release_get_node_remote_hardware_pins_response();

  private:
  const ::meshtastic::NodeRemoteHardwarePinsResponse& _internal_get_node_remote_hardware_pins_response() const;
  ::meshtastic::NodeRemoteHardwarePinsResponse* _internal_mutable_get_node_remote_hardware_pins_response();

  public:
  // bool enter_dfu_mode_request = 21;
  bool has_enter_dfu_mode_request() const;
  void clear_enter_dfu_mode_request() ;
  bool enter_dfu_mode_request() const;
  void set_enter_dfu_mode_request(bool value);

  private:
  bool _internal_enter_dfu_mode_request() const;
  void _internal_set_enter_dfu_mode_request(bool value);

  public:
  // string delete_file_request = 22;
  bool has_delete_file_request() const;
  void clear_delete_file_request() ;
  const std::string& delete_file_request() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delete_file_request(Arg_&& arg, Args_... args);
  std::string* mutable_delete_file_request();
  PROTOBUF_NODISCARD std::string* release_delete_file_request();
  void set_allocated_delete_file_request(std::string* value);

  private:
  const std::string& _internal_delete_file_request() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delete_file_request(
      const std::string& value);
  std::string* _internal_mutable_delete_file_request();

  public:
  // uint32 set_scale = 23;
  bool has_set_scale() const;
  void clear_set_scale() ;
  ::uint32_t set_scale() const;
  void set_set_scale(::uint32_t value);

  private:
  ::uint32_t _internal_set_scale() const;
  void _internal_set_set_scale(::uint32_t value);

  public:
  // .meshtastic.AdminMessage.BackupLocation backup_preferences = 24;
  bool has_backup_preferences() const;
  void clear_backup_preferences() ;
  ::meshtastic::AdminMessage_BackupLocation backup_preferences() const;
  void set_backup_preferences(::meshtastic::AdminMessage_BackupLocation value);

  private:
  ::meshtastic::AdminMessage_BackupLocation _internal_backup_preferences() const;
  void _internal_set_backup_preferences(::meshtastic::AdminMessage_BackupLocation value);

  public:
  // .meshtastic.AdminMessage.BackupLocation restore_preferences = 25;
  bool has_restore_preferences() const;
  void clear_restore_preferences() ;
  ::meshtastic::AdminMessage_BackupLocation restore_preferences() const;
  void set_restore_preferences(::meshtastic::AdminMessage_BackupLocation value);

  private:
  ::meshtastic::AdminMessage_BackupLocation _internal_restore_preferences() const;
  void _internal_set_restore_preferences(::meshtastic::AdminMessage_BackupLocation value);

  public:
  // .meshtastic.AdminMessage.BackupLocation remove_backup_preferences = 26;
  bool has_remove_backup_preferences() const;
  void clear_remove_backup_preferences() ;
  ::meshtastic::AdminMessage_BackupLocation remove_backup_preferences() const;
  void set_remove_backup_preferences(::meshtastic::AdminMessage_BackupLocation value);

  private:
  ::meshtastic::AdminMessage_BackupLocation _internal_remove_backup_preferences() const;
  void _internal_set_remove_backup_preferences(::meshtastic::AdminMessage_BackupLocation value);

  public:
  // .meshtastic.AdminMessage.InputEvent send_input_event = 27;
  bool has_send_input_event() const;
  private:
  bool _internal_has_send_input_event() const;

  public:
  void clear_send_input_event() ;
  const ::meshtastic::AdminMessage_InputEvent& send_input_event() const;
  PROTOBUF_NODISCARD ::meshtastic::AdminMessage_InputEvent* release_send_input_event();
  ::meshtastic::AdminMessage_InputEvent* mutable_send_input_event();
  void set_allocated_send_input_event(::meshtastic::AdminMessage_InputEvent* value);
  void unsafe_arena_set_allocated_send_input_event(::meshtastic::AdminMessage_InputEvent* value);
  ::meshtastic::AdminMessage_InputEvent* unsafe_arena_release_send_input_event();

  private:
  const ::meshtastic::AdminMessage_InputEvent& _internal_send_input_event() const;
  ::meshtastic::AdminMessage_InputEvent* _internal_mutable_send_input_event();

  public:
  // .meshtastic.User set_owner = 32;
  bool has_set_owner() const;
  private:
  bool _internal_has_set_owner() const;

  public:
  void clear_set_owner() ;
  const ::meshtastic::User& set_owner() const;
  PROTOBUF_NODISCARD ::meshtastic::User* release_set_owner();
  ::meshtastic::User* mutable_set_owner();
  void set_allocated_set_owner(::meshtastic::User* value);
  void unsafe_arena_set_allocated_set_owner(::meshtastic::User* value);
  ::meshtastic::User* unsafe_arena_release_set_owner();

  private:
  const ::meshtastic::User& _internal_set_owner() const;
  ::meshtastic::User* _internal_mutable_set_owner();

  public:
  // .meshtastic.Channel set_channel = 33;
  bool has_set_channel() const;
  private:
  bool _internal_has_set_channel() const;

  public:
  void clear_set_channel() ;
  const ::meshtastic::Channel& set_channel() const;
  PROTOBUF_NODISCARD ::meshtastic::Channel* release_set_channel();
  ::meshtastic::Channel* mutable_set_channel();
  void set_allocated_set_channel(::meshtastic::Channel* value);
  void unsafe_arena_set_allocated_set_channel(::meshtastic::Channel* value);
  ::meshtastic::Channel* unsafe_arena_release_set_channel();

  private:
  const ::meshtastic::Channel& _internal_set_channel() const;
  ::meshtastic::Channel* _internal_mutable_set_channel();

  public:
  // .meshtastic.Config set_config = 34;
  bool has_set_config() const;
  private:
  bool _internal_has_set_config() const;

  public:
  void clear_set_config() ;
  const ::meshtastic::Config& set_config() const;
  PROTOBUF_NODISCARD ::meshtastic::Config* release_set_config();
  ::meshtastic::Config* mutable_set_config();
  void set_allocated_set_config(::meshtastic::Config* value);
  void unsafe_arena_set_allocated_set_config(::meshtastic::Config* value);
  ::meshtastic::Config* unsafe_arena_release_set_config();

  private:
  const ::meshtastic::Config& _internal_set_config() const;
  ::meshtastic::Config* _internal_mutable_set_config();

  public:
  // .meshtastic.ModuleConfig set_module_config = 35;
  bool has_set_module_config() const;
  private:
  bool _internal_has_set_module_config() const;

  public:
  void clear_set_module_config() ;
  const ::meshtastic::ModuleConfig& set_module_config() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig* release_set_module_config();
  ::meshtastic::ModuleConfig* mutable_set_module_config();
  void set_allocated_set_module_config(::meshtastic::ModuleConfig* value);
  void unsafe_arena_set_allocated_set_module_config(::meshtastic::ModuleConfig* value);
  ::meshtastic::ModuleConfig* unsafe_arena_release_set_module_config();

  private:
  const ::meshtastic::ModuleConfig& _internal_set_module_config() const;
  ::meshtastic::ModuleConfig* _internal_mutable_set_module_config();

  public:
  // string set_canned_message_module_messages = 36;
  bool has_set_canned_message_module_messages() const;
  void clear_set_canned_message_module_messages() ;
  const std::string& set_canned_message_module_messages() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_set_canned_message_module_messages(Arg_&& arg, Args_... args);
  std::string* mutable_set_canned_message_module_messages();
  PROTOBUF_NODISCARD std::string* release_set_canned_message_module_messages();
  void set_allocated_set_canned_message_module_messages(std::string* value);

  private:
  const std::string& _internal_set_canned_message_module_messages() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_canned_message_module_messages(
      const std::string& value);
  std::string* _internal_mutable_set_canned_message_module_messages();

  public:
  // string set_ringtone_message = 37;
  bool has_set_ringtone_message() const;
  void clear_set_ringtone_message() ;
  const std::string& set_ringtone_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_set_ringtone_message(Arg_&& arg, Args_... args);
  std::string* mutable_set_ringtone_message();
  PROTOBUF_NODISCARD std::string* release_set_ringtone_message();
  void set_allocated_set_ringtone_message(std::string* value);

  private:
  const std::string& _internal_set_ringtone_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_ringtone_message(
      const std::string& value);
  std::string* _internal_mutable_set_ringtone_message();

  public:
  // uint32 remove_by_nodenum = 38;
  bool has_remove_by_nodenum() const;
  void clear_remove_by_nodenum() ;
  ::uint32_t remove_by_nodenum() const;
  void set_remove_by_nodenum(::uint32_t value);

  private:
  ::uint32_t _internal_remove_by_nodenum() const;
  void _internal_set_remove_by_nodenum(::uint32_t value);

  public:
  // uint32 set_favorite_node = 39;
  bool has_set_favorite_node() const;
  void clear_set_favorite_node() ;
  ::uint32_t set_favorite_node() const;
  void set_set_favorite_node(::uint32_t value);

  private:
  ::uint32_t _internal_set_favorite_node() const;
  void _internal_set_set_favorite_node(::uint32_t value);

  public:
  // uint32 remove_favorite_node = 40;
  bool has_remove_favorite_node() const;
  void clear_remove_favorite_node() ;
  ::uint32_t remove_favorite_node() const;
  void set_remove_favorite_node(::uint32_t value);

  private:
  ::uint32_t _internal_remove_favorite_node() const;
  void _internal_set_remove_favorite_node(::uint32_t value);

  public:
  // .meshtastic.Position set_fixed_position = 41;
  bool has_set_fixed_position() const;
  private:
  bool _internal_has_set_fixed_position() const;

  public:
  void clear_set_fixed_position() ;
  const ::meshtastic::Position& set_fixed_position() const;
  PROTOBUF_NODISCARD ::meshtastic::Position* release_set_fixed_position();
  ::meshtastic::Position* mutable_set_fixed_position();
  void set_allocated_set_fixed_position(::meshtastic::Position* value);
  void unsafe_arena_set_allocated_set_fixed_position(::meshtastic::Position* value);
  ::meshtastic::Position* unsafe_arena_release_set_fixed_position();

  private:
  const ::meshtastic::Position& _internal_set_fixed_position() const;
  ::meshtastic::Position* _internal_mutable_set_fixed_position();

  public:
  // bool remove_fixed_position = 42;
  bool has_remove_fixed_position() const;
  void clear_remove_fixed_position() ;
  bool remove_fixed_position() const;
  void set_remove_fixed_position(bool value);

  private:
  bool _internal_remove_fixed_position() const;
  void _internal_set_remove_fixed_position(bool value);

  public:
  // fixed32 set_time_only = 43;
  bool has_set_time_only() const;
  void clear_set_time_only() ;
  ::uint32_t set_time_only() const;
  void set_set_time_only(::uint32_t value);

  private:
  ::uint32_t _internal_set_time_only() const;
  void _internal_set_set_time_only(::uint32_t value);

  public:
  // bool get_ui_config_request = 44;
  bool has_get_ui_config_request() const;
  void clear_get_ui_config_request() ;
  bool get_ui_config_request() const;
  void set_get_ui_config_request(bool value);

  private:
  bool _internal_get_ui_config_request() const;
  void _internal_set_get_ui_config_request(bool value);

  public:
  // .meshtastic.DeviceUIConfig get_ui_config_response = 45;
  bool has_get_ui_config_response() const;
  private:
  bool _internal_has_get_ui_config_response() const;

  public:
  void clear_get_ui_config_response() ;
  const ::meshtastic::DeviceUIConfig& get_ui_config_response() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceUIConfig* release_get_ui_config_response();
  ::meshtastic::DeviceUIConfig* mutable_get_ui_config_response();
  void set_allocated_get_ui_config_response(::meshtastic::DeviceUIConfig* value);
  void unsafe_arena_set_allocated_get_ui_config_response(::meshtastic::DeviceUIConfig* value);
  ::meshtastic::DeviceUIConfig* unsafe_arena_release_get_ui_config_response();

  private:
  const ::meshtastic::DeviceUIConfig& _internal_get_ui_config_response() const;
  ::meshtastic::DeviceUIConfig* _internal_mutable_get_ui_config_response();

  public:
  // .meshtastic.DeviceUIConfig store_ui_config = 46;
  bool has_store_ui_config() const;
  private:
  bool _internal_has_store_ui_config() const;

  public:
  void clear_store_ui_config() ;
  const ::meshtastic::DeviceUIConfig& store_ui_config() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceUIConfig* release_store_ui_config();
  ::meshtastic::DeviceUIConfig* mutable_store_ui_config();
  void set_allocated_store_ui_config(::meshtastic::DeviceUIConfig* value);
  void unsafe_arena_set_allocated_store_ui_config(::meshtastic::DeviceUIConfig* value);
  ::meshtastic::DeviceUIConfig* unsafe_arena_release_store_ui_config();

  private:
  const ::meshtastic::DeviceUIConfig& _internal_store_ui_config() const;
  ::meshtastic::DeviceUIConfig* _internal_mutable_store_ui_config();

  public:
  // uint32 set_ignored_node = 47;
  bool has_set_ignored_node() const;
  void clear_set_ignored_node() ;
  ::uint32_t set_ignored_node() const;
  void set_set_ignored_node(::uint32_t value);

  private:
  ::uint32_t _internal_set_ignored_node() const;
  void _internal_set_set_ignored_node(::uint32_t value);

  public:
  // uint32 remove_ignored_node = 48;
  bool has_remove_ignored_node() const;
  void clear_remove_ignored_node() ;
  ::uint32_t remove_ignored_node() const;
  void set_remove_ignored_node(::uint32_t value);

  private:
  ::uint32_t _internal_remove_ignored_node() const;
  void _internal_set_remove_ignored_node(::uint32_t value);

  public:
  // bool begin_edit_settings = 64;
  bool has_begin_edit_settings() const;
  void clear_begin_edit_settings() ;
  bool begin_edit_settings() const;
  void set_begin_edit_settings(bool value);

  private:
  bool _internal_begin_edit_settings() const;
  void _internal_set_begin_edit_settings(bool value);

  public:
  // bool commit_edit_settings = 65;
  bool has_commit_edit_settings() const;
  void clear_commit_edit_settings() ;
  bool commit_edit_settings() const;
  void set_commit_edit_settings(bool value);

  private:
  bool _internal_commit_edit_settings() const;
  void _internal_set_commit_edit_settings(bool value);

  public:
  // .meshtastic.SharedContact add_contact = 66;
  bool has_add_contact() const;
  private:
  bool _internal_has_add_contact() const;

  public:
  void clear_add_contact() ;
  const ::meshtastic::SharedContact& add_contact() const;
  PROTOBUF_NODISCARD ::meshtastic::SharedContact* release_add_contact();
  ::meshtastic::SharedContact* mutable_add_contact();
  void set_allocated_add_contact(::meshtastic::SharedContact* value);
  void unsafe_arena_set_allocated_add_contact(::meshtastic::SharedContact* value);
  ::meshtastic::SharedContact* unsafe_arena_release_add_contact();

  private:
  const ::meshtastic::SharedContact& _internal_add_contact() const;
  ::meshtastic::SharedContact* _internal_mutable_add_contact();

  public:
  // .meshtastic.KeyVerificationAdmin key_verification = 67;
  bool has_key_verification() const;
  private:
  bool _internal_has_key_verification() const;

  public:
  void clear_key_verification() ;
  const ::meshtastic::KeyVerificationAdmin& key_verification() const;
  PROTOBUF_NODISCARD ::meshtastic::KeyVerificationAdmin* release_key_verification();
  ::meshtastic::KeyVerificationAdmin* mutable_key_verification();
  void set_allocated_key_verification(::meshtastic::KeyVerificationAdmin* value);
  void unsafe_arena_set_allocated_key_verification(::meshtastic::KeyVerificationAdmin* value);
  ::meshtastic::KeyVerificationAdmin* unsafe_arena_release_key_verification();

  private:
  const ::meshtastic::KeyVerificationAdmin& _internal_key_verification() const;
  ::meshtastic::KeyVerificationAdmin* _internal_mutable_key_verification();

  public:
  // int32 factory_reset_device = 94;
  bool has_factory_reset_device() const;
  void clear_factory_reset_device() ;
  ::int32_t factory_reset_device() const;
  void set_factory_reset_device(::int32_t value);

  private:
  ::int32_t _internal_factory_reset_device() const;
  void _internal_set_factory_reset_device(::int32_t value);

  public:
  // int32 reboot_ota_seconds = 95;
  bool has_reboot_ota_seconds() const;
  void clear_reboot_ota_seconds() ;
  ::int32_t reboot_ota_seconds() const;
  void set_reboot_ota_seconds(::int32_t value);

  private:
  ::int32_t _internal_reboot_ota_seconds() const;
  void _internal_set_reboot_ota_seconds(::int32_t value);

  public:
  // bool exit_simulator = 96;
  bool has_exit_simulator() const;
  void clear_exit_simulator() ;
  bool exit_simulator() const;
  void set_exit_simulator(bool value);

  private:
  bool _internal_exit_simulator() const;
  void _internal_set_exit_simulator(bool value);

  public:
  // int32 reboot_seconds = 97;
  bool has_reboot_seconds() const;
  void clear_reboot_seconds() ;
  ::int32_t reboot_seconds() const;
  void set_reboot_seconds(::int32_t value);

  private:
  ::int32_t _internal_reboot_seconds() const;
  void _internal_set_reboot_seconds(::int32_t value);

  public:
  // int32 shutdown_seconds = 98;
  bool has_shutdown_seconds() const;
  void clear_shutdown_seconds() ;
  ::int32_t shutdown_seconds() const;
  void set_shutdown_seconds(::int32_t value);

  private:
  ::int32_t _internal_shutdown_seconds() const;
  void _internal_set_shutdown_seconds(::int32_t value);

  public:
  // int32 factory_reset_config = 99;
  bool has_factory_reset_config() const;
  void clear_factory_reset_config() ;
  ::int32_t factory_reset_config() const;
  void set_factory_reset_config(::int32_t value);

  private:
  ::int32_t _internal_factory_reset_config() const;
  void _internal_set_factory_reset_config(::int32_t value);

  public:
  // int32 nodedb_reset = 100;
  bool has_nodedb_reset() const;
  void clear_nodedb_reset() ;
  ::int32_t nodedb_reset() const;
  void set_nodedb_reset(::int32_t value);

  private:
  ::int32_t _internal_nodedb_reset() const;
  void _internal_set_nodedb_reset(::int32_t value);

  public:
  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.AdminMessage)
 private:
  class _Internal;
  void set_has_get_channel_request();
  void set_has_get_channel_response();
  void set_has_get_owner_request();
  void set_has_get_owner_response();
  void set_has_get_config_request();
  void set_has_get_config_response();
  void set_has_get_module_config_request();
  void set_has_get_module_config_response();
  void set_has_get_canned_message_module_messages_request();
  void set_has_get_canned_message_module_messages_response();
  void set_has_get_device_metadata_request();
  void set_has_get_device_metadata_response();
  void set_has_get_ringtone_request();
  void set_has_get_ringtone_response();
  void set_has_get_device_connection_status_request();
  void set_has_get_device_connection_status_response();
  void set_has_set_ham_mode();
  void set_has_get_node_remote_hardware_pins_request();
  void set_has_get_node_remote_hardware_pins_response();
  void set_has_enter_dfu_mode_request();
  void set_has_delete_file_request();
  void set_has_set_scale();
  void set_has_backup_preferences();
  void set_has_restore_preferences();
  void set_has_remove_backup_preferences();
  void set_has_send_input_event();
  void set_has_set_owner();
  void set_has_set_channel();
  void set_has_set_config();
  void set_has_set_module_config();
  void set_has_set_canned_message_module_messages();
  void set_has_set_ringtone_message();
  void set_has_remove_by_nodenum();
  void set_has_set_favorite_node();
  void set_has_remove_favorite_node();
  void set_has_set_fixed_position();
  void set_has_remove_fixed_position();
  void set_has_set_time_only();
  void set_has_get_ui_config_request();
  void set_has_get_ui_config_response();
  void set_has_store_ui_config();
  void set_has_set_ignored_node();
  void set_has_remove_ignored_node();
  void set_has_begin_edit_settings();
  void set_has_commit_edit_settings();
  void set_has_add_contact();
  void set_has_key_verification();
  void set_has_factory_reset_device();
  void set_has_reboot_ota_seconds();
  void set_has_exit_simulator();
  void set_has_reboot_seconds();
  void set_has_shutdown_seconds();
  void set_has_factory_reset_config();
  void set_has_nodedb_reset();
  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 55, 18,
      217, 15>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AdminMessage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_passkey_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t get_channel_request_;
      ::meshtastic::Channel* get_channel_response_;
      bool get_owner_request_;
      ::meshtastic::User* get_owner_response_;
      int get_config_request_;
      ::meshtastic::Config* get_config_response_;
      int get_module_config_request_;
      ::meshtastic::ModuleConfig* get_module_config_response_;
      bool get_canned_message_module_messages_request_;
      ::google::protobuf::internal::ArenaStringPtr get_canned_message_module_messages_response_;
      bool get_device_metadata_request_;
      ::meshtastic::DeviceMetadata* get_device_metadata_response_;
      bool get_ringtone_request_;
      ::google::protobuf::internal::ArenaStringPtr get_ringtone_response_;
      bool get_device_connection_status_request_;
      ::meshtastic::DeviceConnectionStatus* get_device_connection_status_response_;
      ::meshtastic::HamParameters* set_ham_mode_;
      bool get_node_remote_hardware_pins_request_;
      ::meshtastic::NodeRemoteHardwarePinsResponse* get_node_remote_hardware_pins_response_;
      bool enter_dfu_mode_request_;
      ::google::protobuf::internal::ArenaStringPtr delete_file_request_;
      ::uint32_t set_scale_;
      int backup_preferences_;
      int restore_preferences_;
      int remove_backup_preferences_;
      ::meshtastic::AdminMessage_InputEvent* send_input_event_;
      ::meshtastic::User* set_owner_;
      ::meshtastic::Channel* set_channel_;
      ::meshtastic::Config* set_config_;
      ::meshtastic::ModuleConfig* set_module_config_;
      ::google::protobuf::internal::ArenaStringPtr set_canned_message_module_messages_;
      ::google::protobuf::internal::ArenaStringPtr set_ringtone_message_;
      ::uint32_t remove_by_nodenum_;
      ::uint32_t set_favorite_node_;
      ::uint32_t remove_favorite_node_;
      ::meshtastic::Position* set_fixed_position_;
      bool remove_fixed_position_;
      ::uint32_t set_time_only_;
      bool get_ui_config_request_;
      ::meshtastic::DeviceUIConfig* get_ui_config_response_;
      ::meshtastic::DeviceUIConfig* store_ui_config_;
      ::uint32_t set_ignored_node_;
      ::uint32_t remove_ignored_node_;
      bool begin_edit_settings_;
      bool commit_edit_settings_;
      ::meshtastic::SharedContact* add_contact_;
      ::meshtastic::KeyVerificationAdmin* key_verification_;
      ::int32_t factory_reset_device_;
      ::int32_t reboot_ota_seconds_;
      bool exit_simulator_;
      ::int32_t reboot_seconds_;
      ::int32_t shutdown_seconds_;
      ::int32_t factory_reset_config_;
      ::int32_t nodedb_reset_;
    } payload_variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AdminMessage_InputEvent

// uint32 event_code = 1;
inline void AdminMessage_InputEvent::clear_event_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_code_ = 0u;
}
inline ::uint32_t AdminMessage_InputEvent::event_code() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.InputEvent.event_code)
  return _internal_event_code();
}
inline void AdminMessage_InputEvent::set_event_code(::uint32_t value) {
  _internal_set_event_code(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.InputEvent.event_code)
}
inline ::uint32_t AdminMessage_InputEvent::_internal_event_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.event_code_;
}
inline void AdminMessage_InputEvent::_internal_set_event_code(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_code_ = value;
}

// uint32 kb_char = 2;
inline void AdminMessage_InputEvent::clear_kb_char() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kb_char_ = 0u;
}
inline ::uint32_t AdminMessage_InputEvent::kb_char() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.InputEvent.kb_char)
  return _internal_kb_char();
}
inline void AdminMessage_InputEvent::set_kb_char(::uint32_t value) {
  _internal_set_kb_char(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.InputEvent.kb_char)
}
inline ::uint32_t AdminMessage_InputEvent::_internal_kb_char() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.kb_char_;
}
inline void AdminMessage_InputEvent::_internal_set_kb_char(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kb_char_ = value;
}

// uint32 touch_x = 3;
inline void AdminMessage_InputEvent::clear_touch_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.touch_x_ = 0u;
}
inline ::uint32_t AdminMessage_InputEvent::touch_x() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.InputEvent.touch_x)
  return _internal_touch_x();
}
inline void AdminMessage_InputEvent::set_touch_x(::uint32_t value) {
  _internal_set_touch_x(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.InputEvent.touch_x)
}
inline ::uint32_t AdminMessage_InputEvent::_internal_touch_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.touch_x_;
}
inline void AdminMessage_InputEvent::_internal_set_touch_x(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.touch_x_ = value;
}

// uint32 touch_y = 4;
inline void AdminMessage_InputEvent::clear_touch_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.touch_y_ = 0u;
}
inline ::uint32_t AdminMessage_InputEvent::touch_y() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.InputEvent.touch_y)
  return _internal_touch_y();
}
inline void AdminMessage_InputEvent::set_touch_y(::uint32_t value) {
  _internal_set_touch_y(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.InputEvent.touch_y)
}
inline ::uint32_t AdminMessage_InputEvent::_internal_touch_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.touch_y_;
}
inline void AdminMessage_InputEvent::_internal_set_touch_y(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.touch_y_ = value;
}

// -------------------------------------------------------------------

// AdminMessage

// bytes session_passkey = 101;
inline void AdminMessage::clear_session_passkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_passkey_.ClearToEmpty();
}
inline const std::string& AdminMessage::session_passkey() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.session_passkey)
  return _internal_session_passkey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdminMessage::set_session_passkey(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_passkey_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.session_passkey)
}
inline std::string* AdminMessage::mutable_session_passkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_passkey();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.session_passkey)
  return _s;
}
inline const std::string& AdminMessage::_internal_session_passkey() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_passkey_.Get();
}
inline void AdminMessage::_internal_set_session_passkey(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_passkey_.Set(value, GetArena());
}
inline std::string* AdminMessage::_internal_mutable_session_passkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_passkey_.Mutable( GetArena());
}
inline std::string* AdminMessage::release_session_passkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.session_passkey)
  return _impl_.session_passkey_.Release();
}
inline void AdminMessage::set_allocated_session_passkey(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_passkey_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.session_passkey_.IsDefault()) {
    _impl_.session_passkey_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.session_passkey)
}

// uint32 get_channel_request = 1;
inline bool AdminMessage::has_get_channel_request() const {
  return payload_variant_case() == kGetChannelRequest;
}
inline void AdminMessage::set_has_get_channel_request() {
  _impl_._oneof_case_[0] = kGetChannelRequest;
}
inline void AdminMessage::clear_get_channel_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetChannelRequest) {
    _impl_.payload_variant_.get_channel_request_ = 0u;
    clear_has_payload_variant();
  }
}
inline ::uint32_t AdminMessage::get_channel_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_channel_request)
  return _internal_get_channel_request();
}
inline void AdminMessage::set_get_channel_request(::uint32_t value) {
  if (payload_variant_case() != kGetChannelRequest) {
    clear_payload_variant();
    set_has_get_channel_request();
  }
  _impl_.payload_variant_.get_channel_request_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_channel_request)
}
inline ::uint32_t AdminMessage::_internal_get_channel_request() const {
  if (payload_variant_case() == kGetChannelRequest) {
    return _impl_.payload_variant_.get_channel_request_;
  }
  return 0u;
}

// .meshtastic.Channel get_channel_response = 2;
inline bool AdminMessage::has_get_channel_response() const {
  return payload_variant_case() == kGetChannelResponse;
}
inline bool AdminMessage::_internal_has_get_channel_response() const {
  return payload_variant_case() == kGetChannelResponse;
}
inline void AdminMessage::set_has_get_channel_response() {
  _impl_._oneof_case_[0] = kGetChannelResponse;
}
inline ::meshtastic::Channel* AdminMessage::release_get_channel_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_channel_response)
  if (payload_variant_case() == kGetChannelResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_channel_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_channel_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Channel& AdminMessage::_internal_get_channel_response() const {
  return payload_variant_case() == kGetChannelResponse ? *_impl_.payload_variant_.get_channel_response_ : reinterpret_cast<::meshtastic::Channel&>(::meshtastic::_Channel_default_instance_);
}
inline const ::meshtastic::Channel& AdminMessage::get_channel_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_channel_response)
  return _internal_get_channel_response();
}
inline ::meshtastic::Channel* AdminMessage::unsafe_arena_release_get_channel_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_channel_response)
  if (payload_variant_case() == kGetChannelResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_channel_response_;
    _impl_.payload_variant_.get_channel_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_channel_response(::meshtastic::Channel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_get_channel_response();
    _impl_.payload_variant_.get_channel_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_channel_response)
}
inline ::meshtastic::Channel* AdminMessage::_internal_mutable_get_channel_response() {
  if (payload_variant_case() != kGetChannelResponse) {
    clear_payload_variant();
    set_has_get_channel_response();
    _impl_.payload_variant_.get_channel_response_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Channel>(GetArena());
  }
  return _impl_.payload_variant_.get_channel_response_;
}
inline ::meshtastic::Channel* AdminMessage::mutable_get_channel_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Channel* _msg = _internal_mutable_get_channel_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_channel_response)
  return _msg;
}

// bool get_owner_request = 3;
inline bool AdminMessage::has_get_owner_request() const {
  return payload_variant_case() == kGetOwnerRequest;
}
inline void AdminMessage::set_has_get_owner_request() {
  _impl_._oneof_case_[0] = kGetOwnerRequest;
}
inline void AdminMessage::clear_get_owner_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetOwnerRequest) {
    _impl_.payload_variant_.get_owner_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::get_owner_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_owner_request)
  return _internal_get_owner_request();
}
inline void AdminMessage::set_get_owner_request(bool value) {
  if (payload_variant_case() != kGetOwnerRequest) {
    clear_payload_variant();
    set_has_get_owner_request();
  }
  _impl_.payload_variant_.get_owner_request_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_owner_request)
}
inline bool AdminMessage::_internal_get_owner_request() const {
  if (payload_variant_case() == kGetOwnerRequest) {
    return _impl_.payload_variant_.get_owner_request_;
  }
  return false;
}

// .meshtastic.User get_owner_response = 4;
inline bool AdminMessage::has_get_owner_response() const {
  return payload_variant_case() == kGetOwnerResponse;
}
inline bool AdminMessage::_internal_has_get_owner_response() const {
  return payload_variant_case() == kGetOwnerResponse;
}
inline void AdminMessage::set_has_get_owner_response() {
  _impl_._oneof_case_[0] = kGetOwnerResponse;
}
inline ::meshtastic::User* AdminMessage::release_get_owner_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_owner_response)
  if (payload_variant_case() == kGetOwnerResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_owner_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_owner_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::User& AdminMessage::_internal_get_owner_response() const {
  return payload_variant_case() == kGetOwnerResponse ? *_impl_.payload_variant_.get_owner_response_ : reinterpret_cast<::meshtastic::User&>(::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& AdminMessage::get_owner_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_owner_response)
  return _internal_get_owner_response();
}
inline ::meshtastic::User* AdminMessage::unsafe_arena_release_get_owner_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_owner_response)
  if (payload_variant_case() == kGetOwnerResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_owner_response_;
    _impl_.payload_variant_.get_owner_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_owner_response(::meshtastic::User* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_get_owner_response();
    _impl_.payload_variant_.get_owner_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_owner_response)
}
inline ::meshtastic::User* AdminMessage::_internal_mutable_get_owner_response() {
  if (payload_variant_case() != kGetOwnerResponse) {
    clear_payload_variant();
    set_has_get_owner_response();
    _impl_.payload_variant_.get_owner_response_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::User>(GetArena());
  }
  return _impl_.payload_variant_.get_owner_response_;
}
inline ::meshtastic::User* AdminMessage::mutable_get_owner_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::User* _msg = _internal_mutable_get_owner_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_owner_response)
  return _msg;
}

// .meshtastic.AdminMessage.ConfigType get_config_request = 5;
inline bool AdminMessage::has_get_config_request() const {
  return payload_variant_case() == kGetConfigRequest;
}
inline void AdminMessage::set_has_get_config_request() {
  _impl_._oneof_case_[0] = kGetConfigRequest;
}
inline void AdminMessage::clear_get_config_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetConfigRequest) {
    _impl_.payload_variant_.get_config_request_ = 0;
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_ConfigType AdminMessage::get_config_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_config_request)
  return _internal_get_config_request();
}
inline void AdminMessage::set_get_config_request(::meshtastic::AdminMessage_ConfigType value) {
  if (payload_variant_case() != kGetConfigRequest) {
    clear_payload_variant();
    set_has_get_config_request();
  }
  _impl_.payload_variant_.get_config_request_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_config_request)
}
inline ::meshtastic::AdminMessage_ConfigType AdminMessage::_internal_get_config_request() const {
  if (payload_variant_case() == kGetConfigRequest) {
    return static_cast<::meshtastic::AdminMessage_ConfigType>(_impl_.payload_variant_.get_config_request_);
  }
  return static_cast<::meshtastic::AdminMessage_ConfigType>(0);
}

// .meshtastic.Config get_config_response = 6;
inline bool AdminMessage::has_get_config_response() const {
  return payload_variant_case() == kGetConfigResponse;
}
inline bool AdminMessage::_internal_has_get_config_response() const {
  return payload_variant_case() == kGetConfigResponse;
}
inline void AdminMessage::set_has_get_config_response() {
  _impl_._oneof_case_[0] = kGetConfigResponse;
}
inline ::meshtastic::Config* AdminMessage::release_get_config_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_config_response)
  if (payload_variant_case() == kGetConfigResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_config_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config& AdminMessage::_internal_get_config_response() const {
  return payload_variant_case() == kGetConfigResponse ? *_impl_.payload_variant_.get_config_response_ : reinterpret_cast<::meshtastic::Config&>(::meshtastic::_Config_default_instance_);
}
inline const ::meshtastic::Config& AdminMessage::get_config_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_config_response)
  return _internal_get_config_response();
}
inline ::meshtastic::Config* AdminMessage::unsafe_arena_release_get_config_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_config_response)
  if (payload_variant_case() == kGetConfigResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_config_response_;
    _impl_.payload_variant_.get_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_config_response(::meshtastic::Config* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_get_config_response();
    _impl_.payload_variant_.get_config_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_config_response)
}
inline ::meshtastic::Config* AdminMessage::_internal_mutable_get_config_response() {
  if (payload_variant_case() != kGetConfigResponse) {
    clear_payload_variant();
    set_has_get_config_response();
    _impl_.payload_variant_.get_config_response_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config>(GetArena());
  }
  return _impl_.payload_variant_.get_config_response_;
}
inline ::meshtastic::Config* AdminMessage::mutable_get_config_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config* _msg = _internal_mutable_get_config_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_config_response)
  return _msg;
}

// .meshtastic.AdminMessage.ModuleConfigType get_module_config_request = 7;
inline bool AdminMessage::has_get_module_config_request() const {
  return payload_variant_case() == kGetModuleConfigRequest;
}
inline void AdminMessage::set_has_get_module_config_request() {
  _impl_._oneof_case_[0] = kGetModuleConfigRequest;
}
inline void AdminMessage::clear_get_module_config_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetModuleConfigRequest) {
    _impl_.payload_variant_.get_module_config_request_ = 0;
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_ModuleConfigType AdminMessage::get_module_config_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_module_config_request)
  return _internal_get_module_config_request();
}
inline void AdminMessage::set_get_module_config_request(::meshtastic::AdminMessage_ModuleConfigType value) {
  if (payload_variant_case() != kGetModuleConfigRequest) {
    clear_payload_variant();
    set_has_get_module_config_request();
  }
  _impl_.payload_variant_.get_module_config_request_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_module_config_request)
}
inline ::meshtastic::AdminMessage_ModuleConfigType AdminMessage::_internal_get_module_config_request() const {
  if (payload_variant_case() == kGetModuleConfigRequest) {
    return static_cast<::meshtastic::AdminMessage_ModuleConfigType>(_impl_.payload_variant_.get_module_config_request_);
  }
  return static_cast<::meshtastic::AdminMessage_ModuleConfigType>(0);
}

// .meshtastic.ModuleConfig get_module_config_response = 8;
inline bool AdminMessage::has_get_module_config_response() const {
  return payload_variant_case() == kGetModuleConfigResponse;
}
inline bool AdminMessage::_internal_has_get_module_config_response() const {
  return payload_variant_case() == kGetModuleConfigResponse;
}
inline void AdminMessage::set_has_get_module_config_response() {
  _impl_._oneof_case_[0] = kGetModuleConfigResponse;
}
inline ::meshtastic::ModuleConfig* AdminMessage::release_get_module_config_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_module_config_response)
  if (payload_variant_case() == kGetModuleConfigResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_module_config_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_module_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig& AdminMessage::_internal_get_module_config_response() const {
  return payload_variant_case() == kGetModuleConfigResponse ? *_impl_.payload_variant_.get_module_config_response_ : reinterpret_cast<::meshtastic::ModuleConfig&>(::meshtastic::_ModuleConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig& AdminMessage::get_module_config_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_module_config_response)
  return _internal_get_module_config_response();
}
inline ::meshtastic::ModuleConfig* AdminMessage::unsafe_arena_release_get_module_config_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_module_config_response)
  if (payload_variant_case() == kGetModuleConfigResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_module_config_response_;
    _impl_.payload_variant_.get_module_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_module_config_response(::meshtastic::ModuleConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_get_module_config_response();
    _impl_.payload_variant_.get_module_config_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_module_config_response)
}
inline ::meshtastic::ModuleConfig* AdminMessage::_internal_mutable_get_module_config_response() {
  if (payload_variant_case() != kGetModuleConfigResponse) {
    clear_payload_variant();
    set_has_get_module_config_response();
    _impl_.payload_variant_.get_module_config_response_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::ModuleConfig>(GetArena());
  }
  return _impl_.payload_variant_.get_module_config_response_;
}
inline ::meshtastic::ModuleConfig* AdminMessage::mutable_get_module_config_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::ModuleConfig* _msg = _internal_mutable_get_module_config_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_module_config_response)
  return _msg;
}

// bool get_canned_message_module_messages_request = 10;
inline bool AdminMessage::has_get_canned_message_module_messages_request() const {
  return payload_variant_case() == kGetCannedMessageModuleMessagesRequest;
}
inline void AdminMessage::set_has_get_canned_message_module_messages_request() {
  _impl_._oneof_case_[0] = kGetCannedMessageModuleMessagesRequest;
}
inline void AdminMessage::clear_get_canned_message_module_messages_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetCannedMessageModuleMessagesRequest) {
    _impl_.payload_variant_.get_canned_message_module_messages_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::get_canned_message_module_messages_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_canned_message_module_messages_request)
  return _internal_get_canned_message_module_messages_request();
}
inline void AdminMessage::set_get_canned_message_module_messages_request(bool value) {
  if (payload_variant_case() != kGetCannedMessageModuleMessagesRequest) {
    clear_payload_variant();
    set_has_get_canned_message_module_messages_request();
  }
  _impl_.payload_variant_.get_canned_message_module_messages_request_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_canned_message_module_messages_request)
}
inline bool AdminMessage::_internal_get_canned_message_module_messages_request() const {
  if (payload_variant_case() == kGetCannedMessageModuleMessagesRequest) {
    return _impl_.payload_variant_.get_canned_message_module_messages_request_;
  }
  return false;
}

// string get_canned_message_module_messages_response = 11;
inline bool AdminMessage::has_get_canned_message_module_messages_response() const {
  return payload_variant_case() == kGetCannedMessageModuleMessagesResponse;
}
inline void AdminMessage::set_has_get_canned_message_module_messages_response() {
  _impl_._oneof_case_[0] = kGetCannedMessageModuleMessagesResponse;
}
inline void AdminMessage::clear_get_canned_message_module_messages_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetCannedMessageModuleMessagesResponse) {
    _impl_.payload_variant_.get_canned_message_module_messages_response_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& AdminMessage::get_canned_message_module_messages_response() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_canned_message_module_messages_response)
  return _internal_get_canned_message_module_messages_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdminMessage::set_get_canned_message_module_messages_response(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kGetCannedMessageModuleMessagesResponse) {
    clear_payload_variant();

    set_has_get_canned_message_module_messages_response();
    _impl_.payload_variant_.get_canned_message_module_messages_response_.InitDefault();
  }
  _impl_.payload_variant_.get_canned_message_module_messages_response_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_canned_message_module_messages_response)
}
inline std::string* AdminMessage::mutable_get_canned_message_module_messages_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_get_canned_message_module_messages_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_canned_message_module_messages_response)
  return _s;
}
inline const std::string& AdminMessage::_internal_get_canned_message_module_messages_response() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (payload_variant_case() != kGetCannedMessageModuleMessagesResponse) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.payload_variant_.get_canned_message_module_messages_response_.Get();
}
inline void AdminMessage::_internal_set_get_canned_message_module_messages_response(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kGetCannedMessageModuleMessagesResponse) {
    clear_payload_variant();

    set_has_get_canned_message_module_messages_response();
    _impl_.payload_variant_.get_canned_message_module_messages_response_.InitDefault();
  }
  _impl_.payload_variant_.get_canned_message_module_messages_response_.Set(value, GetArena());
}
inline std::string* AdminMessage::_internal_mutable_get_canned_message_module_messages_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kGetCannedMessageModuleMessagesResponse) {
    clear_payload_variant();

    set_has_get_canned_message_module_messages_response();
    _impl_.payload_variant_.get_canned_message_module_messages_response_.InitDefault();
  }
  return _impl_.payload_variant_.get_canned_message_module_messages_response_.Mutable( GetArena());
}
inline std::string* AdminMessage::release_get_canned_message_module_messages_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_canned_message_module_messages_response)
  if (payload_variant_case() != kGetCannedMessageModuleMessagesResponse) {
    return nullptr;
  }
  clear_has_payload_variant();
  return _impl_.payload_variant_.get_canned_message_module_messages_response_.Release();
}
inline void AdminMessage::set_allocated_get_canned_message_module_messages_response(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (value != nullptr) {
    set_has_get_canned_message_module_messages_response();
    _impl_.payload_variant_.get_canned_message_module_messages_response_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.get_canned_message_module_messages_response)
}

// bool get_device_metadata_request = 12;
inline bool AdminMessage::has_get_device_metadata_request() const {
  return payload_variant_case() == kGetDeviceMetadataRequest;
}
inline void AdminMessage::set_has_get_device_metadata_request() {
  _impl_._oneof_case_[0] = kGetDeviceMetadataRequest;
}
inline void AdminMessage::clear_get_device_metadata_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetDeviceMetadataRequest) {
    _impl_.payload_variant_.get_device_metadata_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::get_device_metadata_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_device_metadata_request)
  return _internal_get_device_metadata_request();
}
inline void AdminMessage::set_get_device_metadata_request(bool value) {
  if (payload_variant_case() != kGetDeviceMetadataRequest) {
    clear_payload_variant();
    set_has_get_device_metadata_request();
  }
  _impl_.payload_variant_.get_device_metadata_request_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_device_metadata_request)
}
inline bool AdminMessage::_internal_get_device_metadata_request() const {
  if (payload_variant_case() == kGetDeviceMetadataRequest) {
    return _impl_.payload_variant_.get_device_metadata_request_;
  }
  return false;
}

// .meshtastic.DeviceMetadata get_device_metadata_response = 13;
inline bool AdminMessage::has_get_device_metadata_response() const {
  return payload_variant_case() == kGetDeviceMetadataResponse;
}
inline bool AdminMessage::_internal_has_get_device_metadata_response() const {
  return payload_variant_case() == kGetDeviceMetadataResponse;
}
inline void AdminMessage::set_has_get_device_metadata_response() {
  _impl_._oneof_case_[0] = kGetDeviceMetadataResponse;
}
inline ::meshtastic::DeviceMetadata* AdminMessage::release_get_device_metadata_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_device_metadata_response)
  if (payload_variant_case() == kGetDeviceMetadataResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_device_metadata_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_device_metadata_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceMetadata& AdminMessage::_internal_get_device_metadata_response() const {
  return payload_variant_case() == kGetDeviceMetadataResponse ? *_impl_.payload_variant_.get_device_metadata_response_ : reinterpret_cast<::meshtastic::DeviceMetadata&>(::meshtastic::_DeviceMetadata_default_instance_);
}
inline const ::meshtastic::DeviceMetadata& AdminMessage::get_device_metadata_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_device_metadata_response)
  return _internal_get_device_metadata_response();
}
inline ::meshtastic::DeviceMetadata* AdminMessage::unsafe_arena_release_get_device_metadata_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_device_metadata_response)
  if (payload_variant_case() == kGetDeviceMetadataResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_device_metadata_response_;
    _impl_.payload_variant_.get_device_metadata_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_device_metadata_response(::meshtastic::DeviceMetadata* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_get_device_metadata_response();
    _impl_.payload_variant_.get_device_metadata_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_device_metadata_response)
}
inline ::meshtastic::DeviceMetadata* AdminMessage::_internal_mutable_get_device_metadata_response() {
  if (payload_variant_case() != kGetDeviceMetadataResponse) {
    clear_payload_variant();
    set_has_get_device_metadata_response();
    _impl_.payload_variant_.get_device_metadata_response_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::DeviceMetadata>(GetArena());
  }
  return _impl_.payload_variant_.get_device_metadata_response_;
}
inline ::meshtastic::DeviceMetadata* AdminMessage::mutable_get_device_metadata_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::DeviceMetadata* _msg = _internal_mutable_get_device_metadata_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_device_metadata_response)
  return _msg;
}

// bool get_ringtone_request = 14;
inline bool AdminMessage::has_get_ringtone_request() const {
  return payload_variant_case() == kGetRingtoneRequest;
}
inline void AdminMessage::set_has_get_ringtone_request() {
  _impl_._oneof_case_[0] = kGetRingtoneRequest;
}
inline void AdminMessage::clear_get_ringtone_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetRingtoneRequest) {
    _impl_.payload_variant_.get_ringtone_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::get_ringtone_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_ringtone_request)
  return _internal_get_ringtone_request();
}
inline void AdminMessage::set_get_ringtone_request(bool value) {
  if (payload_variant_case() != kGetRingtoneRequest) {
    clear_payload_variant();
    set_has_get_ringtone_request();
  }
  _impl_.payload_variant_.get_ringtone_request_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_ringtone_request)
}
inline bool AdminMessage::_internal_get_ringtone_request() const {
  if (payload_variant_case() == kGetRingtoneRequest) {
    return _impl_.payload_variant_.get_ringtone_request_;
  }
  return false;
}

// string get_ringtone_response = 15;
inline bool AdminMessage::has_get_ringtone_response() const {
  return payload_variant_case() == kGetRingtoneResponse;
}
inline void AdminMessage::set_has_get_ringtone_response() {
  _impl_._oneof_case_[0] = kGetRingtoneResponse;
}
inline void AdminMessage::clear_get_ringtone_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetRingtoneResponse) {
    _impl_.payload_variant_.get_ringtone_response_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& AdminMessage::get_ringtone_response() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_ringtone_response)
  return _internal_get_ringtone_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdminMessage::set_get_ringtone_response(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kGetRingtoneResponse) {
    clear_payload_variant();

    set_has_get_ringtone_response();
    _impl_.payload_variant_.get_ringtone_response_.InitDefault();
  }
  _impl_.payload_variant_.get_ringtone_response_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_ringtone_response)
}
inline std::string* AdminMessage::mutable_get_ringtone_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_get_ringtone_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_ringtone_response)
  return _s;
}
inline const std::string& AdminMessage::_internal_get_ringtone_response() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (payload_variant_case() != kGetRingtoneResponse) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.payload_variant_.get_ringtone_response_.Get();
}
inline void AdminMessage::_internal_set_get_ringtone_response(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kGetRingtoneResponse) {
    clear_payload_variant();

    set_has_get_ringtone_response();
    _impl_.payload_variant_.get_ringtone_response_.InitDefault();
  }
  _impl_.payload_variant_.get_ringtone_response_.Set(value, GetArena());
}
inline std::string* AdminMessage::_internal_mutable_get_ringtone_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kGetRingtoneResponse) {
    clear_payload_variant();

    set_has_get_ringtone_response();
    _impl_.payload_variant_.get_ringtone_response_.InitDefault();
  }
  return _impl_.payload_variant_.get_ringtone_response_.Mutable( GetArena());
}
inline std::string* AdminMessage::release_get_ringtone_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_ringtone_response)
  if (payload_variant_case() != kGetRingtoneResponse) {
    return nullptr;
  }
  clear_has_payload_variant();
  return _impl_.payload_variant_.get_ringtone_response_.Release();
}
inline void AdminMessage::set_allocated_get_ringtone_response(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (value != nullptr) {
    set_has_get_ringtone_response();
    _impl_.payload_variant_.get_ringtone_response_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.get_ringtone_response)
}

// bool get_device_connection_status_request = 16;
inline bool AdminMessage::has_get_device_connection_status_request() const {
  return payload_variant_case() == kGetDeviceConnectionStatusRequest;
}
inline void AdminMessage::set_has_get_device_connection_status_request() {
  _impl_._oneof_case_[0] = kGetDeviceConnectionStatusRequest;
}
inline void AdminMessage::clear_get_device_connection_status_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetDeviceConnectionStatusRequest) {
    _impl_.payload_variant_.get_device_connection_status_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::get_device_connection_status_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_device_connection_status_request)
  return _internal_get_device_connection_status_request();
}
inline void AdminMessage::set_get_device_connection_status_request(bool value) {
  if (payload_variant_case() != kGetDeviceConnectionStatusRequest) {
    clear_payload_variant();
    set_has_get_device_connection_status_request();
  }
  _impl_.payload_variant_.get_device_connection_status_request_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_device_connection_status_request)
}
inline bool AdminMessage::_internal_get_device_connection_status_request() const {
  if (payload_variant_case() == kGetDeviceConnectionStatusRequest) {
    return _impl_.payload_variant_.get_device_connection_status_request_;
  }
  return false;
}

// .meshtastic.DeviceConnectionStatus get_device_connection_status_response = 17;
inline bool AdminMessage::has_get_device_connection_status_response() const {
  return payload_variant_case() == kGetDeviceConnectionStatusResponse;
}
inline bool AdminMessage::_internal_has_get_device_connection_status_response() const {
  return payload_variant_case() == kGetDeviceConnectionStatusResponse;
}
inline void AdminMessage::set_has_get_device_connection_status_response() {
  _impl_._oneof_case_[0] = kGetDeviceConnectionStatusResponse;
}
inline ::meshtastic::DeviceConnectionStatus* AdminMessage::release_get_device_connection_status_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_device_connection_status_response)
  if (payload_variant_case() == kGetDeviceConnectionStatusResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_device_connection_status_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_device_connection_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceConnectionStatus& AdminMessage::_internal_get_device_connection_status_response() const {
  return payload_variant_case() == kGetDeviceConnectionStatusResponse ? *_impl_.payload_variant_.get_device_connection_status_response_ : reinterpret_cast<::meshtastic::DeviceConnectionStatus&>(::meshtastic::_DeviceConnectionStatus_default_instance_);
}
inline const ::meshtastic::DeviceConnectionStatus& AdminMessage::get_device_connection_status_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_device_connection_status_response)
  return _internal_get_device_connection_status_response();
}
inline ::meshtastic::DeviceConnectionStatus* AdminMessage::unsafe_arena_release_get_device_connection_status_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_device_connection_status_response)
  if (payload_variant_case() == kGetDeviceConnectionStatusResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_device_connection_status_response_;
    _impl_.payload_variant_.get_device_connection_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_device_connection_status_response(::meshtastic::DeviceConnectionStatus* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_get_device_connection_status_response();
    _impl_.payload_variant_.get_device_connection_status_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_device_connection_status_response)
}
inline ::meshtastic::DeviceConnectionStatus* AdminMessage::_internal_mutable_get_device_connection_status_response() {
  if (payload_variant_case() != kGetDeviceConnectionStatusResponse) {
    clear_payload_variant();
    set_has_get_device_connection_status_response();
    _impl_.payload_variant_.get_device_connection_status_response_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::DeviceConnectionStatus>(GetArena());
  }
  return _impl_.payload_variant_.get_device_connection_status_response_;
}
inline ::meshtastic::DeviceConnectionStatus* AdminMessage::mutable_get_device_connection_status_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::DeviceConnectionStatus* _msg = _internal_mutable_get_device_connection_status_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_device_connection_status_response)
  return _msg;
}

// .meshtastic.HamParameters set_ham_mode = 18;
inline bool AdminMessage::has_set_ham_mode() const {
  return payload_variant_case() == kSetHamMode;
}
inline bool AdminMessage::_internal_has_set_ham_mode() const {
  return payload_variant_case() == kSetHamMode;
}
inline void AdminMessage::set_has_set_ham_mode() {
  _impl_._oneof_case_[0] = kSetHamMode;
}
inline void AdminMessage::clear_set_ham_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kSetHamMode) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.set_ham_mode_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.set_ham_mode_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::HamParameters* AdminMessage::release_set_ham_mode() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_ham_mode)
  if (payload_variant_case() == kSetHamMode) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_ham_mode_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_ham_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::HamParameters& AdminMessage::_internal_set_ham_mode() const {
  return payload_variant_case() == kSetHamMode ? *_impl_.payload_variant_.set_ham_mode_ : reinterpret_cast<::meshtastic::HamParameters&>(::meshtastic::_HamParameters_default_instance_);
}
inline const ::meshtastic::HamParameters& AdminMessage::set_ham_mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_ham_mode)
  return _internal_set_ham_mode();
}
inline ::meshtastic::HamParameters* AdminMessage::unsafe_arena_release_set_ham_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_ham_mode)
  if (payload_variant_case() == kSetHamMode) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_ham_mode_;
    _impl_.payload_variant_.set_ham_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_ham_mode(::meshtastic::HamParameters* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_set_ham_mode();
    _impl_.payload_variant_.set_ham_mode_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_ham_mode)
}
inline ::meshtastic::HamParameters* AdminMessage::_internal_mutable_set_ham_mode() {
  if (payload_variant_case() != kSetHamMode) {
    clear_payload_variant();
    set_has_set_ham_mode();
    _impl_.payload_variant_.set_ham_mode_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::HamParameters>(GetArena());
  }
  return _impl_.payload_variant_.set_ham_mode_;
}
inline ::meshtastic::HamParameters* AdminMessage::mutable_set_ham_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::HamParameters* _msg = _internal_mutable_set_ham_mode();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_ham_mode)
  return _msg;
}

// bool get_node_remote_hardware_pins_request = 19;
inline bool AdminMessage::has_get_node_remote_hardware_pins_request() const {
  return payload_variant_case() == kGetNodeRemoteHardwarePinsRequest;
}
inline void AdminMessage::set_has_get_node_remote_hardware_pins_request() {
  _impl_._oneof_case_[0] = kGetNodeRemoteHardwarePinsRequest;
}
inline void AdminMessage::clear_get_node_remote_hardware_pins_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetNodeRemoteHardwarePinsRequest) {
    _impl_.payload_variant_.get_node_remote_hardware_pins_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::get_node_remote_hardware_pins_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_node_remote_hardware_pins_request)
  return _internal_get_node_remote_hardware_pins_request();
}
inline void AdminMessage::set_get_node_remote_hardware_pins_request(bool value) {
  if (payload_variant_case() != kGetNodeRemoteHardwarePinsRequest) {
    clear_payload_variant();
    set_has_get_node_remote_hardware_pins_request();
  }
  _impl_.payload_variant_.get_node_remote_hardware_pins_request_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_node_remote_hardware_pins_request)
}
inline bool AdminMessage::_internal_get_node_remote_hardware_pins_request() const {
  if (payload_variant_case() == kGetNodeRemoteHardwarePinsRequest) {
    return _impl_.payload_variant_.get_node_remote_hardware_pins_request_;
  }
  return false;
}

// .meshtastic.NodeRemoteHardwarePinsResponse get_node_remote_hardware_pins_response = 20;
inline bool AdminMessage::has_get_node_remote_hardware_pins_response() const {
  return payload_variant_case() == kGetNodeRemoteHardwarePinsResponse;
}
inline bool AdminMessage::_internal_has_get_node_remote_hardware_pins_response() const {
  return payload_variant_case() == kGetNodeRemoteHardwarePinsResponse;
}
inline void AdminMessage::set_has_get_node_remote_hardware_pins_response() {
  _impl_._oneof_case_[0] = kGetNodeRemoteHardwarePinsResponse;
}
inline void AdminMessage::clear_get_node_remote_hardware_pins_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetNodeRemoteHardwarePinsResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.get_node_remote_hardware_pins_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.get_node_remote_hardware_pins_response_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::NodeRemoteHardwarePinsResponse* AdminMessage::release_get_node_remote_hardware_pins_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_node_remote_hardware_pins_response)
  if (payload_variant_case() == kGetNodeRemoteHardwarePinsResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_node_remote_hardware_pins_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_node_remote_hardware_pins_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::NodeRemoteHardwarePinsResponse& AdminMessage::_internal_get_node_remote_hardware_pins_response() const {
  return payload_variant_case() == kGetNodeRemoteHardwarePinsResponse ? *_impl_.payload_variant_.get_node_remote_hardware_pins_response_ : reinterpret_cast<::meshtastic::NodeRemoteHardwarePinsResponse&>(::meshtastic::_NodeRemoteHardwarePinsResponse_default_instance_);
}
inline const ::meshtastic::NodeRemoteHardwarePinsResponse& AdminMessage::get_node_remote_hardware_pins_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_node_remote_hardware_pins_response)
  return _internal_get_node_remote_hardware_pins_response();
}
inline ::meshtastic::NodeRemoteHardwarePinsResponse* AdminMessage::unsafe_arena_release_get_node_remote_hardware_pins_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_node_remote_hardware_pins_response)
  if (payload_variant_case() == kGetNodeRemoteHardwarePinsResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_node_remote_hardware_pins_response_;
    _impl_.payload_variant_.get_node_remote_hardware_pins_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_node_remote_hardware_pins_response(::meshtastic::NodeRemoteHardwarePinsResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_get_node_remote_hardware_pins_response();
    _impl_.payload_variant_.get_node_remote_hardware_pins_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_node_remote_hardware_pins_response)
}
inline ::meshtastic::NodeRemoteHardwarePinsResponse* AdminMessage::_internal_mutable_get_node_remote_hardware_pins_response() {
  if (payload_variant_case() != kGetNodeRemoteHardwarePinsResponse) {
    clear_payload_variant();
    set_has_get_node_remote_hardware_pins_response();
    _impl_.payload_variant_.get_node_remote_hardware_pins_response_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::NodeRemoteHardwarePinsResponse>(GetArena());
  }
  return _impl_.payload_variant_.get_node_remote_hardware_pins_response_;
}
inline ::meshtastic::NodeRemoteHardwarePinsResponse* AdminMessage::mutable_get_node_remote_hardware_pins_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::NodeRemoteHardwarePinsResponse* _msg = _internal_mutable_get_node_remote_hardware_pins_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_node_remote_hardware_pins_response)
  return _msg;
}

// bool enter_dfu_mode_request = 21;
inline bool AdminMessage::has_enter_dfu_mode_request() const {
  return payload_variant_case() == kEnterDfuModeRequest;
}
inline void AdminMessage::set_has_enter_dfu_mode_request() {
  _impl_._oneof_case_[0] = kEnterDfuModeRequest;
}
inline void AdminMessage::clear_enter_dfu_mode_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kEnterDfuModeRequest) {
    _impl_.payload_variant_.enter_dfu_mode_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::enter_dfu_mode_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.enter_dfu_mode_request)
  return _internal_enter_dfu_mode_request();
}
inline void AdminMessage::set_enter_dfu_mode_request(bool value) {
  if (payload_variant_case() != kEnterDfuModeRequest) {
    clear_payload_variant();
    set_has_enter_dfu_mode_request();
  }
  _impl_.payload_variant_.enter_dfu_mode_request_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.enter_dfu_mode_request)
}
inline bool AdminMessage::_internal_enter_dfu_mode_request() const {
  if (payload_variant_case() == kEnterDfuModeRequest) {
    return _impl_.payload_variant_.enter_dfu_mode_request_;
  }
  return false;
}

// string delete_file_request = 22;
inline bool AdminMessage::has_delete_file_request() const {
  return payload_variant_case() == kDeleteFileRequest;
}
inline void AdminMessage::set_has_delete_file_request() {
  _impl_._oneof_case_[0] = kDeleteFileRequest;
}
inline void AdminMessage::clear_delete_file_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kDeleteFileRequest) {
    _impl_.payload_variant_.delete_file_request_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& AdminMessage::delete_file_request() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.delete_file_request)
  return _internal_delete_file_request();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdminMessage::set_delete_file_request(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kDeleteFileRequest) {
    clear_payload_variant();

    set_has_delete_file_request();
    _impl_.payload_variant_.delete_file_request_.InitDefault();
  }
  _impl_.payload_variant_.delete_file_request_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.delete_file_request)
}
inline std::string* AdminMessage::mutable_delete_file_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_delete_file_request();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.delete_file_request)
  return _s;
}
inline const std::string& AdminMessage::_internal_delete_file_request() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (payload_variant_case() != kDeleteFileRequest) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.payload_variant_.delete_file_request_.Get();
}
inline void AdminMessage::_internal_set_delete_file_request(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kDeleteFileRequest) {
    clear_payload_variant();

    set_has_delete_file_request();
    _impl_.payload_variant_.delete_file_request_.InitDefault();
  }
  _impl_.payload_variant_.delete_file_request_.Set(value, GetArena());
}
inline std::string* AdminMessage::_internal_mutable_delete_file_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kDeleteFileRequest) {
    clear_payload_variant();

    set_has_delete_file_request();
    _impl_.payload_variant_.delete_file_request_.InitDefault();
  }
  return _impl_.payload_variant_.delete_file_request_.Mutable( GetArena());
}
inline std::string* AdminMessage::release_delete_file_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.delete_file_request)
  if (payload_variant_case() != kDeleteFileRequest) {
    return nullptr;
  }
  clear_has_payload_variant();
  return _impl_.payload_variant_.delete_file_request_.Release();
}
inline void AdminMessage::set_allocated_delete_file_request(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (value != nullptr) {
    set_has_delete_file_request();
    _impl_.payload_variant_.delete_file_request_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.delete_file_request)
}

// uint32 set_scale = 23;
inline bool AdminMessage::has_set_scale() const {
  return payload_variant_case() == kSetScale;
}
inline void AdminMessage::set_has_set_scale() {
  _impl_._oneof_case_[0] = kSetScale;
}
inline void AdminMessage::clear_set_scale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kSetScale) {
    _impl_.payload_variant_.set_scale_ = 0u;
    clear_has_payload_variant();
  }
}
inline ::uint32_t AdminMessage::set_scale() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_scale)
  return _internal_set_scale();
}
inline void AdminMessage::set_set_scale(::uint32_t value) {
  if (payload_variant_case() != kSetScale) {
    clear_payload_variant();
    set_has_set_scale();
  }
  _impl_.payload_variant_.set_scale_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_scale)
}
inline ::uint32_t AdminMessage::_internal_set_scale() const {
  if (payload_variant_case() == kSetScale) {
    return _impl_.payload_variant_.set_scale_;
  }
  return 0u;
}

// .meshtastic.AdminMessage.BackupLocation backup_preferences = 24;
inline bool AdminMessage::has_backup_preferences() const {
  return payload_variant_case() == kBackupPreferences;
}
inline void AdminMessage::set_has_backup_preferences() {
  _impl_._oneof_case_[0] = kBackupPreferences;
}
inline void AdminMessage::clear_backup_preferences() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kBackupPreferences) {
    _impl_.payload_variant_.backup_preferences_ = 0;
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::backup_preferences() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.backup_preferences)
  return _internal_backup_preferences();
}
inline void AdminMessage::set_backup_preferences(::meshtastic::AdminMessage_BackupLocation value) {
  if (payload_variant_case() != kBackupPreferences) {
    clear_payload_variant();
    set_has_backup_preferences();
  }
  _impl_.payload_variant_.backup_preferences_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.backup_preferences)
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::_internal_backup_preferences() const {
  if (payload_variant_case() == kBackupPreferences) {
    return static_cast<::meshtastic::AdminMessage_BackupLocation>(_impl_.payload_variant_.backup_preferences_);
  }
  return static_cast<::meshtastic::AdminMessage_BackupLocation>(0);
}

// .meshtastic.AdminMessage.BackupLocation restore_preferences = 25;
inline bool AdminMessage::has_restore_preferences() const {
  return payload_variant_case() == kRestorePreferences;
}
inline void AdminMessage::set_has_restore_preferences() {
  _impl_._oneof_case_[0] = kRestorePreferences;
}
inline void AdminMessage::clear_restore_preferences() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kRestorePreferences) {
    _impl_.payload_variant_.restore_preferences_ = 0;
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::restore_preferences() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.restore_preferences)
  return _internal_restore_preferences();
}
inline void AdminMessage::set_restore_preferences(::meshtastic::AdminMessage_BackupLocation value) {
  if (payload_variant_case() != kRestorePreferences) {
    clear_payload_variant();
    set_has_restore_preferences();
  }
  _impl_.payload_variant_.restore_preferences_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.restore_preferences)
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::_internal_restore_preferences() const {
  if (payload_variant_case() == kRestorePreferences) {
    return static_cast<::meshtastic::AdminMessage_BackupLocation>(_impl_.payload_variant_.restore_preferences_);
  }
  return static_cast<::meshtastic::AdminMessage_BackupLocation>(0);
}

// .meshtastic.AdminMessage.BackupLocation remove_backup_preferences = 26;
inline bool AdminMessage::has_remove_backup_preferences() const {
  return payload_variant_case() == kRemoveBackupPreferences;
}
inline void AdminMessage::set_has_remove_backup_preferences() {
  _impl_._oneof_case_[0] = kRemoveBackupPreferences;
}
inline void AdminMessage::clear_remove_backup_preferences() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kRemoveBackupPreferences) {
    _impl_.payload_variant_.remove_backup_preferences_ = 0;
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::remove_backup_preferences() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.remove_backup_preferences)
  return _internal_remove_backup_preferences();
}
inline void AdminMessage::set_remove_backup_preferences(::meshtastic::AdminMessage_BackupLocation value) {
  if (payload_variant_case() != kRemoveBackupPreferences) {
    clear_payload_variant();
    set_has_remove_backup_preferences();
  }
  _impl_.payload_variant_.remove_backup_preferences_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.remove_backup_preferences)
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::_internal_remove_backup_preferences() const {
  if (payload_variant_case() == kRemoveBackupPreferences) {
    return static_cast<::meshtastic::AdminMessage_BackupLocation>(_impl_.payload_variant_.remove_backup_preferences_);
  }
  return static_cast<::meshtastic::AdminMessage_BackupLocation>(0);
}

// .meshtastic.AdminMessage.InputEvent send_input_event = 27;
inline bool AdminMessage::has_send_input_event() const {
  return payload_variant_case() == kSendInputEvent;
}
inline bool AdminMessage::_internal_has_send_input_event() const {
  return payload_variant_case() == kSendInputEvent;
}
inline void AdminMessage::set_has_send_input_event() {
  _impl_._oneof_case_[0] = kSendInputEvent;
}
inline void AdminMessage::clear_send_input_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kSendInputEvent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.send_input_event_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.send_input_event_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_InputEvent* AdminMessage::release_send_input_event() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.send_input_event)
  if (payload_variant_case() == kSendInputEvent) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.send_input_event_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.send_input_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::AdminMessage_InputEvent& AdminMessage::_internal_send_input_event() const {
  return payload_variant_case() == kSendInputEvent ? *_impl_.payload_variant_.send_input_event_ : reinterpret_cast<::meshtastic::AdminMessage_InputEvent&>(::meshtastic::_AdminMessage_InputEvent_default_instance_);
}
inline const ::meshtastic::AdminMessage_InputEvent& AdminMessage::send_input_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.send_input_event)
  return _internal_send_input_event();
}
inline ::meshtastic::AdminMessage_InputEvent* AdminMessage::unsafe_arena_release_send_input_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.send_input_event)
  if (payload_variant_case() == kSendInputEvent) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.send_input_event_;
    _impl_.payload_variant_.send_input_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_send_input_event(::meshtastic::AdminMessage_InputEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_send_input_event();
    _impl_.payload_variant_.send_input_event_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.send_input_event)
}
inline ::meshtastic::AdminMessage_InputEvent* AdminMessage::_internal_mutable_send_input_event() {
  if (payload_variant_case() != kSendInputEvent) {
    clear_payload_variant();
    set_has_send_input_event();
    _impl_.payload_variant_.send_input_event_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::AdminMessage_InputEvent>(GetArena());
  }
  return _impl_.payload_variant_.send_input_event_;
}
inline ::meshtastic::AdminMessage_InputEvent* AdminMessage::mutable_send_input_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::AdminMessage_InputEvent* _msg = _internal_mutable_send_input_event();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.send_input_event)
  return _msg;
}

// .meshtastic.User set_owner = 32;
inline bool AdminMessage::has_set_owner() const {
  return payload_variant_case() == kSetOwner;
}
inline bool AdminMessage::_internal_has_set_owner() const {
  return payload_variant_case() == kSetOwner;
}
inline void AdminMessage::set_has_set_owner() {
  _impl_._oneof_case_[0] = kSetOwner;
}
inline ::meshtastic::User* AdminMessage::release_set_owner() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_owner)
  if (payload_variant_case() == kSetOwner) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_owner_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_owner_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::User& AdminMessage::_internal_set_owner() const {
  return payload_variant_case() == kSetOwner ? *_impl_.payload_variant_.set_owner_ : reinterpret_cast<::meshtastic::User&>(::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& AdminMessage::set_owner() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_owner)
  return _internal_set_owner();
}
inline ::meshtastic::User* AdminMessage::unsafe_arena_release_set_owner() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_owner)
  if (payload_variant_case() == kSetOwner) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_owner_;
    _impl_.payload_variant_.set_owner_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_owner(::meshtastic::User* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_set_owner();
    _impl_.payload_variant_.set_owner_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_owner)
}
inline ::meshtastic::User* AdminMessage::_internal_mutable_set_owner() {
  if (payload_variant_case() != kSetOwner) {
    clear_payload_variant();
    set_has_set_owner();
    _impl_.payload_variant_.set_owner_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::User>(GetArena());
  }
  return _impl_.payload_variant_.set_owner_;
}
inline ::meshtastic::User* AdminMessage::mutable_set_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::User* _msg = _internal_mutable_set_owner();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_owner)
  return _msg;
}

// .meshtastic.Channel set_channel = 33;
inline bool AdminMessage::has_set_channel() const {
  return payload_variant_case() == kSetChannel;
}
inline bool AdminMessage::_internal_has_set_channel() const {
  return payload_variant_case() == kSetChannel;
}
inline void AdminMessage::set_has_set_channel() {
  _impl_._oneof_case_[0] = kSetChannel;
}
inline ::meshtastic::Channel* AdminMessage::release_set_channel() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_channel)
  if (payload_variant_case() == kSetChannel) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_channel_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Channel& AdminMessage::_internal_set_channel() const {
  return payload_variant_case() == kSetChannel ? *_impl_.payload_variant_.set_channel_ : reinterpret_cast<::meshtastic::Channel&>(::meshtastic::_Channel_default_instance_);
}
inline const ::meshtastic::Channel& AdminMessage::set_channel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_channel)
  return _internal_set_channel();
}
inline ::meshtastic::Channel* AdminMessage::unsafe_arena_release_set_channel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_channel)
  if (payload_variant_case() == kSetChannel) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_channel_;
    _impl_.payload_variant_.set_channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_channel(::meshtastic::Channel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_set_channel();
    _impl_.payload_variant_.set_channel_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_channel)
}
inline ::meshtastic::Channel* AdminMessage::_internal_mutable_set_channel() {
  if (payload_variant_case() != kSetChannel) {
    clear_payload_variant();
    set_has_set_channel();
    _impl_.payload_variant_.set_channel_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Channel>(GetArena());
  }
  return _impl_.payload_variant_.set_channel_;
}
inline ::meshtastic::Channel* AdminMessage::mutable_set_channel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Channel* _msg = _internal_mutable_set_channel();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_channel)
  return _msg;
}

// .meshtastic.Config set_config = 34;
inline bool AdminMessage::has_set_config() const {
  return payload_variant_case() == kSetConfig;
}
inline bool AdminMessage::_internal_has_set_config() const {
  return payload_variant_case() == kSetConfig;
}
inline void AdminMessage::set_has_set_config() {
  _impl_._oneof_case_[0] = kSetConfig;
}
inline ::meshtastic::Config* AdminMessage::release_set_config() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_config)
  if (payload_variant_case() == kSetConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_config_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config& AdminMessage::_internal_set_config() const {
  return payload_variant_case() == kSetConfig ? *_impl_.payload_variant_.set_config_ : reinterpret_cast<::meshtastic::Config&>(::meshtastic::_Config_default_instance_);
}
inline const ::meshtastic::Config& AdminMessage::set_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_config)
  return _internal_set_config();
}
inline ::meshtastic::Config* AdminMessage::unsafe_arena_release_set_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_config)
  if (payload_variant_case() == kSetConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_config_;
    _impl_.payload_variant_.set_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_config(::meshtastic::Config* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_set_config();
    _impl_.payload_variant_.set_config_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_config)
}
inline ::meshtastic::Config* AdminMessage::_internal_mutable_set_config() {
  if (payload_variant_case() != kSetConfig) {
    clear_payload_variant();
    set_has_set_config();
    _impl_.payload_variant_.set_config_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config>(GetArena());
  }
  return _impl_.payload_variant_.set_config_;
}
inline ::meshtastic::Config* AdminMessage::mutable_set_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config* _msg = _internal_mutable_set_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_config)
  return _msg;
}

// .meshtastic.ModuleConfig set_module_config = 35;
inline bool AdminMessage::has_set_module_config() const {
  return payload_variant_case() == kSetModuleConfig;
}
inline bool AdminMessage::_internal_has_set_module_config() const {
  return payload_variant_case() == kSetModuleConfig;
}
inline void AdminMessage::set_has_set_module_config() {
  _impl_._oneof_case_[0] = kSetModuleConfig;
}
inline ::meshtastic::ModuleConfig* AdminMessage::release_set_module_config() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_module_config)
  if (payload_variant_case() == kSetModuleConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_module_config_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_module_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig& AdminMessage::_internal_set_module_config() const {
  return payload_variant_case() == kSetModuleConfig ? *_impl_.payload_variant_.set_module_config_ : reinterpret_cast<::meshtastic::ModuleConfig&>(::meshtastic::_ModuleConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig& AdminMessage::set_module_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_module_config)
  return _internal_set_module_config();
}
inline ::meshtastic::ModuleConfig* AdminMessage::unsafe_arena_release_set_module_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_module_config)
  if (payload_variant_case() == kSetModuleConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_module_config_;
    _impl_.payload_variant_.set_module_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_module_config(::meshtastic::ModuleConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_set_module_config();
    _impl_.payload_variant_.set_module_config_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_module_config)
}
inline ::meshtastic::ModuleConfig* AdminMessage::_internal_mutable_set_module_config() {
  if (payload_variant_case() != kSetModuleConfig) {
    clear_payload_variant();
    set_has_set_module_config();
    _impl_.payload_variant_.set_module_config_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::ModuleConfig>(GetArena());
  }
  return _impl_.payload_variant_.set_module_config_;
}
inline ::meshtastic::ModuleConfig* AdminMessage::mutable_set_module_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::ModuleConfig* _msg = _internal_mutable_set_module_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_module_config)
  return _msg;
}

// string set_canned_message_module_messages = 36;
inline bool AdminMessage::has_set_canned_message_module_messages() const {
  return payload_variant_case() == kSetCannedMessageModuleMessages;
}
inline void AdminMessage::set_has_set_canned_message_module_messages() {
  _impl_._oneof_case_[0] = kSetCannedMessageModuleMessages;
}
inline void AdminMessage::clear_set_canned_message_module_messages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kSetCannedMessageModuleMessages) {
    _impl_.payload_variant_.set_canned_message_module_messages_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& AdminMessage::set_canned_message_module_messages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_canned_message_module_messages)
  return _internal_set_canned_message_module_messages();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdminMessage::set_set_canned_message_module_messages(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kSetCannedMessageModuleMessages) {
    clear_payload_variant();

    set_has_set_canned_message_module_messages();
    _impl_.payload_variant_.set_canned_message_module_messages_.InitDefault();
  }
  _impl_.payload_variant_.set_canned_message_module_messages_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_canned_message_module_messages)
}
inline std::string* AdminMessage::mutable_set_canned_message_module_messages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_set_canned_message_module_messages();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_canned_message_module_messages)
  return _s;
}
inline const std::string& AdminMessage::_internal_set_canned_message_module_messages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (payload_variant_case() != kSetCannedMessageModuleMessages) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.payload_variant_.set_canned_message_module_messages_.Get();
}
inline void AdminMessage::_internal_set_set_canned_message_module_messages(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kSetCannedMessageModuleMessages) {
    clear_payload_variant();

    set_has_set_canned_message_module_messages();
    _impl_.payload_variant_.set_canned_message_module_messages_.InitDefault();
  }
  _impl_.payload_variant_.set_canned_message_module_messages_.Set(value, GetArena());
}
inline std::string* AdminMessage::_internal_mutable_set_canned_message_module_messages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kSetCannedMessageModuleMessages) {
    clear_payload_variant();

    set_has_set_canned_message_module_messages();
    _impl_.payload_variant_.set_canned_message_module_messages_.InitDefault();
  }
  return _impl_.payload_variant_.set_canned_message_module_messages_.Mutable( GetArena());
}
inline std::string* AdminMessage::release_set_canned_message_module_messages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_canned_message_module_messages)
  if (payload_variant_case() != kSetCannedMessageModuleMessages) {
    return nullptr;
  }
  clear_has_payload_variant();
  return _impl_.payload_variant_.set_canned_message_module_messages_.Release();
}
inline void AdminMessage::set_allocated_set_canned_message_module_messages(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (value != nullptr) {
    set_has_set_canned_message_module_messages();
    _impl_.payload_variant_.set_canned_message_module_messages_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.set_canned_message_module_messages)
}

// string set_ringtone_message = 37;
inline bool AdminMessage::has_set_ringtone_message() const {
  return payload_variant_case() == kSetRingtoneMessage;
}
inline void AdminMessage::set_has_set_ringtone_message() {
  _impl_._oneof_case_[0] = kSetRingtoneMessage;
}
inline void AdminMessage::clear_set_ringtone_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kSetRingtoneMessage) {
    _impl_.payload_variant_.set_ringtone_message_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& AdminMessage::set_ringtone_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_ringtone_message)
  return _internal_set_ringtone_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdminMessage::set_set_ringtone_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kSetRingtoneMessage) {
    clear_payload_variant();

    set_has_set_ringtone_message();
    _impl_.payload_variant_.set_ringtone_message_.InitDefault();
  }
  _impl_.payload_variant_.set_ringtone_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_ringtone_message)
}
inline std::string* AdminMessage::mutable_set_ringtone_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_set_ringtone_message();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_ringtone_message)
  return _s;
}
inline const std::string& AdminMessage::_internal_set_ringtone_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (payload_variant_case() != kSetRingtoneMessage) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.payload_variant_.set_ringtone_message_.Get();
}
inline void AdminMessage::_internal_set_set_ringtone_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kSetRingtoneMessage) {
    clear_payload_variant();

    set_has_set_ringtone_message();
    _impl_.payload_variant_.set_ringtone_message_.InitDefault();
  }
  _impl_.payload_variant_.set_ringtone_message_.Set(value, GetArena());
}
inline std::string* AdminMessage::_internal_mutable_set_ringtone_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kSetRingtoneMessage) {
    clear_payload_variant();

    set_has_set_ringtone_message();
    _impl_.payload_variant_.set_ringtone_message_.InitDefault();
  }
  return _impl_.payload_variant_.set_ringtone_message_.Mutable( GetArena());
}
inline std::string* AdminMessage::release_set_ringtone_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_ringtone_message)
  if (payload_variant_case() != kSetRingtoneMessage) {
    return nullptr;
  }
  clear_has_payload_variant();
  return _impl_.payload_variant_.set_ringtone_message_.Release();
}
inline void AdminMessage::set_allocated_set_ringtone_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (value != nullptr) {
    set_has_set_ringtone_message();
    _impl_.payload_variant_.set_ringtone_message_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.set_ringtone_message)
}

// uint32 remove_by_nodenum = 38;
inline bool AdminMessage::has_remove_by_nodenum() const {
  return payload_variant_case() == kRemoveByNodenum;
}
inline void AdminMessage::set_has_remove_by_nodenum() {
  _impl_._oneof_case_[0] = kRemoveByNodenum;
}
inline void AdminMessage::clear_remove_by_nodenum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kRemoveByNodenum) {
    _impl_.payload_variant_.remove_by_nodenum_ = 0u;
    clear_has_payload_variant();
  }
}
inline ::uint32_t AdminMessage::remove_by_nodenum() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.remove_by_nodenum)
  return _internal_remove_by_nodenum();
}
inline void AdminMessage::set_remove_by_nodenum(::uint32_t value) {
  if (payload_variant_case() != kRemoveByNodenum) {
    clear_payload_variant();
    set_has_remove_by_nodenum();
  }
  _impl_.payload_variant_.remove_by_nodenum_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.remove_by_nodenum)
}
inline ::uint32_t AdminMessage::_internal_remove_by_nodenum() const {
  if (payload_variant_case() == kRemoveByNodenum) {
    return _impl_.payload_variant_.remove_by_nodenum_;
  }
  return 0u;
}

// uint32 set_favorite_node = 39;
inline bool AdminMessage::has_set_favorite_node() const {
  return payload_variant_case() == kSetFavoriteNode;
}
inline void AdminMessage::set_has_set_favorite_node() {
  _impl_._oneof_case_[0] = kSetFavoriteNode;
}
inline void AdminMessage::clear_set_favorite_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kSetFavoriteNode) {
    _impl_.payload_variant_.set_favorite_node_ = 0u;
    clear_has_payload_variant();
  }
}
inline ::uint32_t AdminMessage::set_favorite_node() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_favorite_node)
  return _internal_set_favorite_node();
}
inline void AdminMessage::set_set_favorite_node(::uint32_t value) {
  if (payload_variant_case() != kSetFavoriteNode) {
    clear_payload_variant();
    set_has_set_favorite_node();
  }
  _impl_.payload_variant_.set_favorite_node_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_favorite_node)
}
inline ::uint32_t AdminMessage::_internal_set_favorite_node() const {
  if (payload_variant_case() == kSetFavoriteNode) {
    return _impl_.payload_variant_.set_favorite_node_;
  }
  return 0u;
}

// uint32 remove_favorite_node = 40;
inline bool AdminMessage::has_remove_favorite_node() const {
  return payload_variant_case() == kRemoveFavoriteNode;
}
inline void AdminMessage::set_has_remove_favorite_node() {
  _impl_._oneof_case_[0] = kRemoveFavoriteNode;
}
inline void AdminMessage::clear_remove_favorite_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kRemoveFavoriteNode) {
    _impl_.payload_variant_.remove_favorite_node_ = 0u;
    clear_has_payload_variant();
  }
}
inline ::uint32_t AdminMessage::remove_favorite_node() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.remove_favorite_node)
  return _internal_remove_favorite_node();
}
inline void AdminMessage::set_remove_favorite_node(::uint32_t value) {
  if (payload_variant_case() != kRemoveFavoriteNode) {
    clear_payload_variant();
    set_has_remove_favorite_node();
  }
  _impl_.payload_variant_.remove_favorite_node_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.remove_favorite_node)
}
inline ::uint32_t AdminMessage::_internal_remove_favorite_node() const {
  if (payload_variant_case() == kRemoveFavoriteNode) {
    return _impl_.payload_variant_.remove_favorite_node_;
  }
  return 0u;
}

// .meshtastic.Position set_fixed_position = 41;
inline bool AdminMessage::has_set_fixed_position() const {
  return payload_variant_case() == kSetFixedPosition;
}
inline bool AdminMessage::_internal_has_set_fixed_position() const {
  return payload_variant_case() == kSetFixedPosition;
}
inline void AdminMessage::set_has_set_fixed_position() {
  _impl_._oneof_case_[0] = kSetFixedPosition;
}
inline ::meshtastic::Position* AdminMessage::release_set_fixed_position() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_fixed_position)
  if (payload_variant_case() == kSetFixedPosition) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_fixed_position_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_fixed_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Position& AdminMessage::_internal_set_fixed_position() const {
  return payload_variant_case() == kSetFixedPosition ? *_impl_.payload_variant_.set_fixed_position_ : reinterpret_cast<::meshtastic::Position&>(::meshtastic::_Position_default_instance_);
}
inline const ::meshtastic::Position& AdminMessage::set_fixed_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_fixed_position)
  return _internal_set_fixed_position();
}
inline ::meshtastic::Position* AdminMessage::unsafe_arena_release_set_fixed_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_fixed_position)
  if (payload_variant_case() == kSetFixedPosition) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.set_fixed_position_;
    _impl_.payload_variant_.set_fixed_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_fixed_position(::meshtastic::Position* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_set_fixed_position();
    _impl_.payload_variant_.set_fixed_position_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_fixed_position)
}
inline ::meshtastic::Position* AdminMessage::_internal_mutable_set_fixed_position() {
  if (payload_variant_case() != kSetFixedPosition) {
    clear_payload_variant();
    set_has_set_fixed_position();
    _impl_.payload_variant_.set_fixed_position_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Position>(GetArena());
  }
  return _impl_.payload_variant_.set_fixed_position_;
}
inline ::meshtastic::Position* AdminMessage::mutable_set_fixed_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Position* _msg = _internal_mutable_set_fixed_position();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_fixed_position)
  return _msg;
}

// bool remove_fixed_position = 42;
inline bool AdminMessage::has_remove_fixed_position() const {
  return payload_variant_case() == kRemoveFixedPosition;
}
inline void AdminMessage::set_has_remove_fixed_position() {
  _impl_._oneof_case_[0] = kRemoveFixedPosition;
}
inline void AdminMessage::clear_remove_fixed_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kRemoveFixedPosition) {
    _impl_.payload_variant_.remove_fixed_position_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::remove_fixed_position() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.remove_fixed_position)
  return _internal_remove_fixed_position();
}
inline void AdminMessage::set_remove_fixed_position(bool value) {
  if (payload_variant_case() != kRemoveFixedPosition) {
    clear_payload_variant();
    set_has_remove_fixed_position();
  }
  _impl_.payload_variant_.remove_fixed_position_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.remove_fixed_position)
}
inline bool AdminMessage::_internal_remove_fixed_position() const {
  if (payload_variant_case() == kRemoveFixedPosition) {
    return _impl_.payload_variant_.remove_fixed_position_;
  }
  return false;
}

// fixed32 set_time_only = 43;
inline bool AdminMessage::has_set_time_only() const {
  return payload_variant_case() == kSetTimeOnly;
}
inline void AdminMessage::set_has_set_time_only() {
  _impl_._oneof_case_[0] = kSetTimeOnly;
}
inline void AdminMessage::clear_set_time_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kSetTimeOnly) {
    _impl_.payload_variant_.set_time_only_ = 0u;
    clear_has_payload_variant();
  }
}
inline ::uint32_t AdminMessage::set_time_only() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_time_only)
  return _internal_set_time_only();
}
inline void AdminMessage::set_set_time_only(::uint32_t value) {
  if (payload_variant_case() != kSetTimeOnly) {
    clear_payload_variant();
    set_has_set_time_only();
  }
  _impl_.payload_variant_.set_time_only_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_time_only)
}
inline ::uint32_t AdminMessage::_internal_set_time_only() const {
  if (payload_variant_case() == kSetTimeOnly) {
    return _impl_.payload_variant_.set_time_only_;
  }
  return 0u;
}

// bool get_ui_config_request = 44;
inline bool AdminMessage::has_get_ui_config_request() const {
  return payload_variant_case() == kGetUiConfigRequest;
}
inline void AdminMessage::set_has_get_ui_config_request() {
  _impl_._oneof_case_[0] = kGetUiConfigRequest;
}
inline void AdminMessage::clear_get_ui_config_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kGetUiConfigRequest) {
    _impl_.payload_variant_.get_ui_config_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::get_ui_config_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_ui_config_request)
  return _internal_get_ui_config_request();
}
inline void AdminMessage::set_get_ui_config_request(bool value) {
  if (payload_variant_case() != kGetUiConfigRequest) {
    clear_payload_variant();
    set_has_get_ui_config_request();
  }
  _impl_.payload_variant_.get_ui_config_request_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_ui_config_request)
}
inline bool AdminMessage::_internal_get_ui_config_request() const {
  if (payload_variant_case() == kGetUiConfigRequest) {
    return _impl_.payload_variant_.get_ui_config_request_;
  }
  return false;
}

// .meshtastic.DeviceUIConfig get_ui_config_response = 45;
inline bool AdminMessage::has_get_ui_config_response() const {
  return payload_variant_case() == kGetUiConfigResponse;
}
inline bool AdminMessage::_internal_has_get_ui_config_response() const {
  return payload_variant_case() == kGetUiConfigResponse;
}
inline void AdminMessage::set_has_get_ui_config_response() {
  _impl_._oneof_case_[0] = kGetUiConfigResponse;
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::release_get_ui_config_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_ui_config_response)
  if (payload_variant_case() == kGetUiConfigResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_ui_config_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_ui_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceUIConfig& AdminMessage::_internal_get_ui_config_response() const {
  return payload_variant_case() == kGetUiConfigResponse ? *_impl_.payload_variant_.get_ui_config_response_ : reinterpret_cast<::meshtastic::DeviceUIConfig&>(::meshtastic::_DeviceUIConfig_default_instance_);
}
inline const ::meshtastic::DeviceUIConfig& AdminMessage::get_ui_config_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_ui_config_response)
  return _internal_get_ui_config_response();
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::unsafe_arena_release_get_ui_config_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_ui_config_response)
  if (payload_variant_case() == kGetUiConfigResponse) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.get_ui_config_response_;
    _impl_.payload_variant_.get_ui_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_ui_config_response(::meshtastic::DeviceUIConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_get_ui_config_response();
    _impl_.payload_variant_.get_ui_config_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_ui_config_response)
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::_internal_mutable_get_ui_config_response() {
  if (payload_variant_case() != kGetUiConfigResponse) {
    clear_payload_variant();
    set_has_get_ui_config_response();
    _impl_.payload_variant_.get_ui_config_response_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::DeviceUIConfig>(GetArena());
  }
  return _impl_.payload_variant_.get_ui_config_response_;
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::mutable_get_ui_config_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::DeviceUIConfig* _msg = _internal_mutable_get_ui_config_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_ui_config_response)
  return _msg;
}

// .meshtastic.DeviceUIConfig store_ui_config = 46;
inline bool AdminMessage::has_store_ui_config() const {
  return payload_variant_case() == kStoreUiConfig;
}
inline bool AdminMessage::_internal_has_store_ui_config() const {
  return payload_variant_case() == kStoreUiConfig;
}
inline void AdminMessage::set_has_store_ui_config() {
  _impl_._oneof_case_[0] = kStoreUiConfig;
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::release_store_ui_config() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.store_ui_config)
  if (payload_variant_case() == kStoreUiConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.store_ui_config_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.store_ui_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceUIConfig& AdminMessage::_internal_store_ui_config() const {
  return payload_variant_case() == kStoreUiConfig ? *_impl_.payload_variant_.store_ui_config_ : reinterpret_cast<::meshtastic::DeviceUIConfig&>(::meshtastic::_DeviceUIConfig_default_instance_);
}
inline const ::meshtastic::DeviceUIConfig& AdminMessage::store_ui_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.store_ui_config)
  return _internal_store_ui_config();
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::unsafe_arena_release_store_ui_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.store_ui_config)
  if (payload_variant_case() == kStoreUiConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.store_ui_config_;
    _impl_.payload_variant_.store_ui_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_store_ui_config(::meshtastic::DeviceUIConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_store_ui_config();
    _impl_.payload_variant_.store_ui_config_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.store_ui_config)
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::_internal_mutable_store_ui_config() {
  if (payload_variant_case() != kStoreUiConfig) {
    clear_payload_variant();
    set_has_store_ui_config();
    _impl_.payload_variant_.store_ui_config_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::DeviceUIConfig>(GetArena());
  }
  return _impl_.payload_variant_.store_ui_config_;
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::mutable_store_ui_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::DeviceUIConfig* _msg = _internal_mutable_store_ui_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.store_ui_config)
  return _msg;
}

// uint32 set_ignored_node = 47;
inline bool AdminMessage::has_set_ignored_node() const {
  return payload_variant_case() == kSetIgnoredNode;
}
inline void AdminMessage::set_has_set_ignored_node() {
  _impl_._oneof_case_[0] = kSetIgnoredNode;
}
inline void AdminMessage::clear_set_ignored_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kSetIgnoredNode) {
    _impl_.payload_variant_.set_ignored_node_ = 0u;
    clear_has_payload_variant();
  }
}
inline ::uint32_t AdminMessage::set_ignored_node() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_ignored_node)
  return _internal_set_ignored_node();
}
inline void AdminMessage::set_set_ignored_node(::uint32_t value) {
  if (payload_variant_case() != kSetIgnoredNode) {
    clear_payload_variant();
    set_has_set_ignored_node();
  }
  _impl_.payload_variant_.set_ignored_node_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_ignored_node)
}
inline ::uint32_t AdminMessage::_internal_set_ignored_node() const {
  if (payload_variant_case() == kSetIgnoredNode) {
    return _impl_.payload_variant_.set_ignored_node_;
  }
  return 0u;
}

// uint32 remove_ignored_node = 48;
inline bool AdminMessage::has_remove_ignored_node() const {
  return payload_variant_case() == kRemoveIgnoredNode;
}
inline void AdminMessage::set_has_remove_ignored_node() {
  _impl_._oneof_case_[0] = kRemoveIgnoredNode;
}
inline void AdminMessage::clear_remove_ignored_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kRemoveIgnoredNode) {
    _impl_.payload_variant_.remove_ignored_node_ = 0u;
    clear_has_payload_variant();
  }
}
inline ::uint32_t AdminMessage::remove_ignored_node() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.remove_ignored_node)
  return _internal_remove_ignored_node();
}
inline void AdminMessage::set_remove_ignored_node(::uint32_t value) {
  if (payload_variant_case() != kRemoveIgnoredNode) {
    clear_payload_variant();
    set_has_remove_ignored_node();
  }
  _impl_.payload_variant_.remove_ignored_node_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.remove_ignored_node)
}
inline ::uint32_t AdminMessage::_internal_remove_ignored_node() const {
  if (payload_variant_case() == kRemoveIgnoredNode) {
    return _impl_.payload_variant_.remove_ignored_node_;
  }
  return 0u;
}

// bool begin_edit_settings = 64;
inline bool AdminMessage::has_begin_edit_settings() const {
  return payload_variant_case() == kBeginEditSettings;
}
inline void AdminMessage::set_has_begin_edit_settings() {
  _impl_._oneof_case_[0] = kBeginEditSettings;
}
inline void AdminMessage::clear_begin_edit_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kBeginEditSettings) {
    _impl_.payload_variant_.begin_edit_settings_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::begin_edit_settings() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.begin_edit_settings)
  return _internal_begin_edit_settings();
}
inline void AdminMessage::set_begin_edit_settings(bool value) {
  if (payload_variant_case() != kBeginEditSettings) {
    clear_payload_variant();
    set_has_begin_edit_settings();
  }
  _impl_.payload_variant_.begin_edit_settings_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.begin_edit_settings)
}
inline bool AdminMessage::_internal_begin_edit_settings() const {
  if (payload_variant_case() == kBeginEditSettings) {
    return _impl_.payload_variant_.begin_edit_settings_;
  }
  return false;
}

// bool commit_edit_settings = 65;
inline bool AdminMessage::has_commit_edit_settings() const {
  return payload_variant_case() == kCommitEditSettings;
}
inline void AdminMessage::set_has_commit_edit_settings() {
  _impl_._oneof_case_[0] = kCommitEditSettings;
}
inline void AdminMessage::clear_commit_edit_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kCommitEditSettings) {
    _impl_.payload_variant_.commit_edit_settings_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::commit_edit_settings() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.commit_edit_settings)
  return _internal_commit_edit_settings();
}
inline void AdminMessage::set_commit_edit_settings(bool value) {
  if (payload_variant_case() != kCommitEditSettings) {
    clear_payload_variant();
    set_has_commit_edit_settings();
  }
  _impl_.payload_variant_.commit_edit_settings_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.commit_edit_settings)
}
inline bool AdminMessage::_internal_commit_edit_settings() const {
  if (payload_variant_case() == kCommitEditSettings) {
    return _impl_.payload_variant_.commit_edit_settings_;
  }
  return false;
}

// .meshtastic.SharedContact add_contact = 66;
inline bool AdminMessage::has_add_contact() const {
  return payload_variant_case() == kAddContact;
}
inline bool AdminMessage::_internal_has_add_contact() const {
  return payload_variant_case() == kAddContact;
}
inline void AdminMessage::set_has_add_contact() {
  _impl_._oneof_case_[0] = kAddContact;
}
inline void AdminMessage::clear_add_contact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kAddContact) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.add_contact_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.add_contact_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::SharedContact* AdminMessage::release_add_contact() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.add_contact)
  if (payload_variant_case() == kAddContact) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.add_contact_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.add_contact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::SharedContact& AdminMessage::_internal_add_contact() const {
  return payload_variant_case() == kAddContact ? *_impl_.payload_variant_.add_contact_ : reinterpret_cast<::meshtastic::SharedContact&>(::meshtastic::_SharedContact_default_instance_);
}
inline const ::meshtastic::SharedContact& AdminMessage::add_contact() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.add_contact)
  return _internal_add_contact();
}
inline ::meshtastic::SharedContact* AdminMessage::unsafe_arena_release_add_contact() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.add_contact)
  if (payload_variant_case() == kAddContact) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.add_contact_;
    _impl_.payload_variant_.add_contact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_add_contact(::meshtastic::SharedContact* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_add_contact();
    _impl_.payload_variant_.add_contact_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.add_contact)
}
inline ::meshtastic::SharedContact* AdminMessage::_internal_mutable_add_contact() {
  if (payload_variant_case() != kAddContact) {
    clear_payload_variant();
    set_has_add_contact();
    _impl_.payload_variant_.add_contact_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::SharedContact>(GetArena());
  }
  return _impl_.payload_variant_.add_contact_;
}
inline ::meshtastic::SharedContact* AdminMessage::mutable_add_contact() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::SharedContact* _msg = _internal_mutable_add_contact();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.add_contact)
  return _msg;
}

// .meshtastic.KeyVerificationAdmin key_verification = 67;
inline bool AdminMessage::has_key_verification() const {
  return payload_variant_case() == kKeyVerification;
}
inline bool AdminMessage::_internal_has_key_verification() const {
  return payload_variant_case() == kKeyVerification;
}
inline void AdminMessage::set_has_key_verification() {
  _impl_._oneof_case_[0] = kKeyVerification;
}
inline void AdminMessage::clear_key_verification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kKeyVerification) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.key_verification_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.key_verification_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::KeyVerificationAdmin* AdminMessage::release_key_verification() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.key_verification)
  if (payload_variant_case() == kKeyVerification) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.key_verification_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.key_verification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::KeyVerificationAdmin& AdminMessage::_internal_key_verification() const {
  return payload_variant_case() == kKeyVerification ? *_impl_.payload_variant_.key_verification_ : reinterpret_cast<::meshtastic::KeyVerificationAdmin&>(::meshtastic::_KeyVerificationAdmin_default_instance_);
}
inline const ::meshtastic::KeyVerificationAdmin& AdminMessage::key_verification() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.key_verification)
  return _internal_key_verification();
}
inline ::meshtastic::KeyVerificationAdmin* AdminMessage::unsafe_arena_release_key_verification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.key_verification)
  if (payload_variant_case() == kKeyVerification) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.key_verification_;
    _impl_.payload_variant_.key_verification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_key_verification(::meshtastic::KeyVerificationAdmin* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_key_verification();
    _impl_.payload_variant_.key_verification_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.key_verification)
}
inline ::meshtastic::KeyVerificationAdmin* AdminMessage::_internal_mutable_key_verification() {
  if (payload_variant_case() != kKeyVerification) {
    clear_payload_variant();
    set_has_key_verification();
    _impl_.payload_variant_.key_verification_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::KeyVerificationAdmin>(GetArena());
  }
  return _impl_.payload_variant_.key_verification_;
}
inline ::meshtastic::KeyVerificationAdmin* AdminMessage::mutable_key_verification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::KeyVerificationAdmin* _msg = _internal_mutable_key_verification();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.key_verification)
  return _msg;
}

// int32 factory_reset_device = 94;
inline bool AdminMessage::has_factory_reset_device() const {
  return payload_variant_case() == kFactoryResetDevice;
}
inline void AdminMessage::set_has_factory_reset_device() {
  _impl_._oneof_case_[0] = kFactoryResetDevice;
}
inline void AdminMessage::clear_factory_reset_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kFactoryResetDevice) {
    _impl_.payload_variant_.factory_reset_device_ = 0;
    clear_has_payload_variant();
  }
}
inline ::int32_t AdminMessage::factory_reset_device() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.factory_reset_device)
  return _internal_factory_reset_device();
}
inline void AdminMessage::set_factory_reset_device(::int32_t value) {
  if (payload_variant_case() != kFactoryResetDevice) {
    clear_payload_variant();
    set_has_factory_reset_device();
  }
  _impl_.payload_variant_.factory_reset_device_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.factory_reset_device)
}
inline ::int32_t AdminMessage::_internal_factory_reset_device() const {
  if (payload_variant_case() == kFactoryResetDevice) {
    return _impl_.payload_variant_.factory_reset_device_;
  }
  return 0;
}

// int32 reboot_ota_seconds = 95;
inline bool AdminMessage::has_reboot_ota_seconds() const {
  return payload_variant_case() == kRebootOtaSeconds;
}
inline void AdminMessage::set_has_reboot_ota_seconds() {
  _impl_._oneof_case_[0] = kRebootOtaSeconds;
}
inline void AdminMessage::clear_reboot_ota_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kRebootOtaSeconds) {
    _impl_.payload_variant_.reboot_ota_seconds_ = 0;
    clear_has_payload_variant();
  }
}
inline ::int32_t AdminMessage::reboot_ota_seconds() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.reboot_ota_seconds)
  return _internal_reboot_ota_seconds();
}
inline void AdminMessage::set_reboot_ota_seconds(::int32_t value) {
  if (payload_variant_case() != kRebootOtaSeconds) {
    clear_payload_variant();
    set_has_reboot_ota_seconds();
  }
  _impl_.payload_variant_.reboot_ota_seconds_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.reboot_ota_seconds)
}
inline ::int32_t AdminMessage::_internal_reboot_ota_seconds() const {
  if (payload_variant_case() == kRebootOtaSeconds) {
    return _impl_.payload_variant_.reboot_ota_seconds_;
  }
  return 0;
}

// bool exit_simulator = 96;
inline bool AdminMessage::has_exit_simulator() const {
  return payload_variant_case() == kExitSimulator;
}
inline void AdminMessage::set_has_exit_simulator() {
  _impl_._oneof_case_[0] = kExitSimulator;
}
inline void AdminMessage::clear_exit_simulator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kExitSimulator) {
    _impl_.payload_variant_.exit_simulator_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::exit_simulator() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.exit_simulator)
  return _internal_exit_simulator();
}
inline void AdminMessage::set_exit_simulator(bool value) {
  if (payload_variant_case() != kExitSimulator) {
    clear_payload_variant();
    set_has_exit_simulator();
  }
  _impl_.payload_variant_.exit_simulator_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.exit_simulator)
}
inline bool AdminMessage::_internal_exit_simulator() const {
  if (payload_variant_case() == kExitSimulator) {
    return _impl_.payload_variant_.exit_simulator_;
  }
  return false;
}

// int32 reboot_seconds = 97;
inline bool AdminMessage::has_reboot_seconds() const {
  return payload_variant_case() == kRebootSeconds;
}
inline void AdminMessage::set_has_reboot_seconds() {
  _impl_._oneof_case_[0] = kRebootSeconds;
}
inline void AdminMessage::clear_reboot_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kRebootSeconds) {
    _impl_.payload_variant_.reboot_seconds_ = 0;
    clear_has_payload_variant();
  }
}
inline ::int32_t AdminMessage::reboot_seconds() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.reboot_seconds)
  return _internal_reboot_seconds();
}
inline void AdminMessage::set_reboot_seconds(::int32_t value) {
  if (payload_variant_case() != kRebootSeconds) {
    clear_payload_variant();
    set_has_reboot_seconds();
  }
  _impl_.payload_variant_.reboot_seconds_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.reboot_seconds)
}
inline ::int32_t AdminMessage::_internal_reboot_seconds() const {
  if (payload_variant_case() == kRebootSeconds) {
    return _impl_.payload_variant_.reboot_seconds_;
  }
  return 0;
}

// int32 shutdown_seconds = 98;
inline bool AdminMessage::has_shutdown_seconds() const {
  return payload_variant_case() == kShutdownSeconds;
}
inline void AdminMessage::set_has_shutdown_seconds() {
  _impl_._oneof_case_[0] = kShutdownSeconds;
}
inline void AdminMessage::clear_shutdown_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kShutdownSeconds) {
    _impl_.payload_variant_.shutdown_seconds_ = 0;
    clear_has_payload_variant();
  }
}
inline ::int32_t AdminMessage::shutdown_seconds() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.shutdown_seconds)
  return _internal_shutdown_seconds();
}
inline void AdminMessage::set_shutdown_seconds(::int32_t value) {
  if (payload_variant_case() != kShutdownSeconds) {
    clear_payload_variant();
    set_has_shutdown_seconds();
  }
  _impl_.payload_variant_.shutdown_seconds_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.shutdown_seconds)
}
inline ::int32_t AdminMessage::_internal_shutdown_seconds() const {
  if (payload_variant_case() == kShutdownSeconds) {
    return _impl_.payload_variant_.shutdown_seconds_;
  }
  return 0;
}

// int32 factory_reset_config = 99;
inline bool AdminMessage::has_factory_reset_config() const {
  return payload_variant_case() == kFactoryResetConfig;
}
inline void AdminMessage::set_has_factory_reset_config() {
  _impl_._oneof_case_[0] = kFactoryResetConfig;
}
inline void AdminMessage::clear_factory_reset_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kFactoryResetConfig) {
    _impl_.payload_variant_.factory_reset_config_ = 0;
    clear_has_payload_variant();
  }
}
inline ::int32_t AdminMessage::factory_reset_config() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.factory_reset_config)
  return _internal_factory_reset_config();
}
inline void AdminMessage::set_factory_reset_config(::int32_t value) {
  if (payload_variant_case() != kFactoryResetConfig) {
    clear_payload_variant();
    set_has_factory_reset_config();
  }
  _impl_.payload_variant_.factory_reset_config_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.factory_reset_config)
}
inline ::int32_t AdminMessage::_internal_factory_reset_config() const {
  if (payload_variant_case() == kFactoryResetConfig) {
    return _impl_.payload_variant_.factory_reset_config_;
  }
  return 0;
}

// int32 nodedb_reset = 100;
inline bool AdminMessage::has_nodedb_reset() const {
  return payload_variant_case() == kNodedbReset;
}
inline void AdminMessage::set_has_nodedb_reset() {
  _impl_._oneof_case_[0] = kNodedbReset;
}
inline void AdminMessage::clear_nodedb_reset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kNodedbReset) {
    _impl_.payload_variant_.nodedb_reset_ = 0;
    clear_has_payload_variant();
  }
}
inline ::int32_t AdminMessage::nodedb_reset() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.nodedb_reset)
  return _internal_nodedb_reset();
}
inline void AdminMessage::set_nodedb_reset(::int32_t value) {
  if (payload_variant_case() != kNodedbReset) {
    clear_payload_variant();
    set_has_nodedb_reset();
  }
  _impl_.payload_variant_.nodedb_reset_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.nodedb_reset)
}
inline ::int32_t AdminMessage::_internal_nodedb_reset() const {
  if (payload_variant_case() == kNodedbReset) {
    return _impl_.payload_variant_.nodedb_reset_;
  }
  return 0;
}

inline bool AdminMessage::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void AdminMessage::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline AdminMessage::PayloadVariantCase AdminMessage::payload_variant_case() const {
  return AdminMessage::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// HamParameters

// string call_sign = 1;
inline void HamParameters::clear_call_sign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.call_sign_.ClearToEmpty();
}
inline const std::string& HamParameters::call_sign() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.HamParameters.call_sign)
  return _internal_call_sign();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HamParameters::set_call_sign(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.call_sign_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.HamParameters.call_sign)
}
inline std::string* HamParameters::mutable_call_sign() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_call_sign();
  // @@protoc_insertion_point(field_mutable:meshtastic.HamParameters.call_sign)
  return _s;
}
inline const std::string& HamParameters::_internal_call_sign() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.call_sign_.Get();
}
inline void HamParameters::_internal_set_call_sign(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.call_sign_.Set(value, GetArena());
}
inline std::string* HamParameters::_internal_mutable_call_sign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.call_sign_.Mutable( GetArena());
}
inline std::string* HamParameters::release_call_sign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.HamParameters.call_sign)
  return _impl_.call_sign_.Release();
}
inline void HamParameters::set_allocated_call_sign(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.call_sign_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.call_sign_.IsDefault()) {
    _impl_.call_sign_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.HamParameters.call_sign)
}

// int32 tx_power = 2;
inline void HamParameters::clear_tx_power() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_power_ = 0;
}
inline ::int32_t HamParameters::tx_power() const {
  // @@protoc_insertion_point(field_get:meshtastic.HamParameters.tx_power)
  return _internal_tx_power();
}
inline void HamParameters::set_tx_power(::int32_t value) {
  _internal_set_tx_power(value);
  // @@protoc_insertion_point(field_set:meshtastic.HamParameters.tx_power)
}
inline ::int32_t HamParameters::_internal_tx_power() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tx_power_;
}
inline void HamParameters::_internal_set_tx_power(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_power_ = value;
}

// float frequency = 3;
inline void HamParameters::clear_frequency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frequency_ = 0;
}
inline float HamParameters::frequency() const {
  // @@protoc_insertion_point(field_get:meshtastic.HamParameters.frequency)
  return _internal_frequency();
}
inline void HamParameters::set_frequency(float value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:meshtastic.HamParameters.frequency)
}
inline float HamParameters::_internal_frequency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frequency_;
}
inline void HamParameters::_internal_set_frequency(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frequency_ = value;
}

// string short_name = 4;
inline void HamParameters::clear_short_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.short_name_.ClearToEmpty();
}
inline const std::string& HamParameters::short_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.HamParameters.short_name)
  return _internal_short_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HamParameters::set_short_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.short_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.HamParameters.short_name)
}
inline std::string* HamParameters::mutable_short_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_short_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.HamParameters.short_name)
  return _s;
}
inline const std::string& HamParameters::_internal_short_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.short_name_.Get();
}
inline void HamParameters::_internal_set_short_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.short_name_.Set(value, GetArena());
}
inline std::string* HamParameters::_internal_mutable_short_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.short_name_.Mutable( GetArena());
}
inline std::string* HamParameters::release_short_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.HamParameters.short_name)
  return _impl_.short_name_.Release();
}
inline void HamParameters::set_allocated_short_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.short_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.short_name_.IsDefault()) {
    _impl_.short_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.HamParameters.short_name)
}

// -------------------------------------------------------------------

// NodeRemoteHardwarePinsResponse

// repeated .meshtastic.NodeRemoteHardwarePin node_remote_hardware_pins = 1;
inline int NodeRemoteHardwarePinsResponse::_internal_node_remote_hardware_pins_size() const {
  return _internal_node_remote_hardware_pins().size();
}
inline int NodeRemoteHardwarePinsResponse::node_remote_hardware_pins_size() const {
  return _internal_node_remote_hardware_pins_size();
}
inline ::meshtastic::NodeRemoteHardwarePin* NodeRemoteHardwarePinsResponse::mutable_node_remote_hardware_pins(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeRemoteHardwarePinsResponse.node_remote_hardware_pins)
  return _internal_mutable_node_remote_hardware_pins()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>* NodeRemoteHardwarePinsResponse::mutable_node_remote_hardware_pins()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.NodeRemoteHardwarePinsResponse.node_remote_hardware_pins)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_node_remote_hardware_pins();
}
inline const ::meshtastic::NodeRemoteHardwarePin& NodeRemoteHardwarePinsResponse::node_remote_hardware_pins(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.NodeRemoteHardwarePinsResponse.node_remote_hardware_pins)
  return _internal_node_remote_hardware_pins().Get(index);
}
inline ::meshtastic::NodeRemoteHardwarePin* NodeRemoteHardwarePinsResponse::add_node_remote_hardware_pins() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::meshtastic::NodeRemoteHardwarePin* _add = _internal_mutable_node_remote_hardware_pins()->Add();
  // @@protoc_insertion_point(field_add:meshtastic.NodeRemoteHardwarePinsResponse.node_remote_hardware_pins)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>& NodeRemoteHardwarePinsResponse::node_remote_hardware_pins() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.NodeRemoteHardwarePinsResponse.node_remote_hardware_pins)
  return _internal_node_remote_hardware_pins();
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>&
NodeRemoteHardwarePinsResponse::_internal_node_remote_hardware_pins() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_remote_hardware_pins_;
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>*
NodeRemoteHardwarePinsResponse::_internal_mutable_node_remote_hardware_pins() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.node_remote_hardware_pins_;
}

// -------------------------------------------------------------------

// SharedContact

// uint32 node_num = 1;
inline void SharedContact::clear_node_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_num_ = 0u;
}
inline ::uint32_t SharedContact::node_num() const {
  // @@protoc_insertion_point(field_get:meshtastic.SharedContact.node_num)
  return _internal_node_num();
}
inline void SharedContact::set_node_num(::uint32_t value) {
  _internal_set_node_num(value);
  // @@protoc_insertion_point(field_set:meshtastic.SharedContact.node_num)
}
inline ::uint32_t SharedContact::_internal_node_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_num_;
}
inline void SharedContact::_internal_set_node_num(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_num_ = value;
}

// .meshtastic.User user = 2;
inline bool SharedContact::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline const ::meshtastic::User& SharedContact::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::User&>(::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& SharedContact::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.SharedContact.user)
  return _internal_user();
}
inline void SharedContact::unsafe_arena_set_allocated_user(::meshtastic::User* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::meshtastic::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.SharedContact.user)
}
inline ::meshtastic::User* SharedContact::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::meshtastic::User* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::User* SharedContact::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.SharedContact.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::meshtastic::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::meshtastic::User* SharedContact::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::User>(GetArena());
    _impl_.user_ = reinterpret_cast<::meshtastic::User*>(p);
  }
  return _impl_.user_;
}
inline ::meshtastic::User* SharedContact::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::meshtastic::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:meshtastic.SharedContact.user)
  return _msg;
}
inline void SharedContact::set_allocated_user(::meshtastic::User* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::meshtastic::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.SharedContact.user)
}

// bool should_ignore = 3;
inline void SharedContact::clear_should_ignore() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.should_ignore_ = false;
}
inline bool SharedContact::should_ignore() const {
  // @@protoc_insertion_point(field_get:meshtastic.SharedContact.should_ignore)
  return _internal_should_ignore();
}
inline void SharedContact::set_should_ignore(bool value) {
  _internal_set_should_ignore(value);
  // @@protoc_insertion_point(field_set:meshtastic.SharedContact.should_ignore)
}
inline bool SharedContact::_internal_should_ignore() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.should_ignore_;
}
inline void SharedContact::_internal_set_should_ignore(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.should_ignore_ = value;
}

// -------------------------------------------------------------------

// KeyVerificationAdmin

// .meshtastic.KeyVerificationAdmin.MessageType message_type = 1;
inline void KeyVerificationAdmin::clear_message_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_type_ = 0;
}
inline ::meshtastic::KeyVerificationAdmin_MessageType KeyVerificationAdmin::message_type() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationAdmin.message_type)
  return _internal_message_type();
}
inline void KeyVerificationAdmin::set_message_type(::meshtastic::KeyVerificationAdmin_MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationAdmin.message_type)
}
inline ::meshtastic::KeyVerificationAdmin_MessageType KeyVerificationAdmin::_internal_message_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::KeyVerificationAdmin_MessageType>(_impl_.message_type_);
}
inline void KeyVerificationAdmin::_internal_set_message_type(::meshtastic::KeyVerificationAdmin_MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_type_ = value;
}

// uint32 remote_nodenum = 2;
inline void KeyVerificationAdmin::clear_remote_nodenum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_nodenum_ = 0u;
}
inline ::uint32_t KeyVerificationAdmin::remote_nodenum() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationAdmin.remote_nodenum)
  return _internal_remote_nodenum();
}
inline void KeyVerificationAdmin::set_remote_nodenum(::uint32_t value) {
  _internal_set_remote_nodenum(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationAdmin.remote_nodenum)
}
inline ::uint32_t KeyVerificationAdmin::_internal_remote_nodenum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remote_nodenum_;
}
inline void KeyVerificationAdmin::_internal_set_remote_nodenum(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_nodenum_ = value;
}

// uint64 nonce = 3;
inline void KeyVerificationAdmin::clear_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t KeyVerificationAdmin::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationAdmin.nonce)
  return _internal_nonce();
}
inline void KeyVerificationAdmin::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationAdmin.nonce)
}
inline ::uint64_t KeyVerificationAdmin::_internal_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nonce_;
}
inline void KeyVerificationAdmin::_internal_set_nonce(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = value;
}

// optional uint32 security_number = 4;
inline bool KeyVerificationAdmin::has_security_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KeyVerificationAdmin::clear_security_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.security_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t KeyVerificationAdmin::security_number() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationAdmin.security_number)
  return _internal_security_number();
}
inline void KeyVerificationAdmin::set_security_number(::uint32_t value) {
  _internal_set_security_number(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationAdmin.security_number)
}
inline ::uint32_t KeyVerificationAdmin::_internal_security_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.security_number_;
}
inline void KeyVerificationAdmin::_internal_set_security_number(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.security_number_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace meshtastic


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::meshtastic::AdminMessage_ConfigType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::AdminMessage_ConfigType>() {
  return ::meshtastic::AdminMessage_ConfigType_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::AdminMessage_ModuleConfigType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::AdminMessage_ModuleConfigType>() {
  return ::meshtastic::AdminMessage_ModuleConfigType_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::AdminMessage_BackupLocation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::AdminMessage_BackupLocation>() {
  return ::meshtastic::AdminMessage_BackupLocation_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::KeyVerificationAdmin_MessageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::KeyVerificationAdmin_MessageType>() {
  return ::meshtastic::KeyVerificationAdmin_MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // meshtastic_2fadmin_2eproto_2epb_2eh
