// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meshtastic/admin.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fadmin_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fadmin_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "meshtastic/channel.pb.h"
#include "meshtastic/config.pb.h"
#include "meshtastic/connection_status.pb.h"
#include "meshtastic/device_ui.pb.h"
#include "meshtastic/mesh.pb.h"
#include "meshtastic/module_config.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_meshtastic_2fadmin_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_meshtastic_2fadmin_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_meshtastic_2fadmin_2eproto;
namespace meshtastic {
class AdminMessage;
struct AdminMessageDefaultTypeInternal;
extern AdminMessageDefaultTypeInternal _AdminMessage_default_instance_;
class AdminMessage_InputEvent;
struct AdminMessage_InputEventDefaultTypeInternal;
extern AdminMessage_InputEventDefaultTypeInternal _AdminMessage_InputEvent_default_instance_;
class HamParameters;
struct HamParametersDefaultTypeInternal;
extern HamParametersDefaultTypeInternal _HamParameters_default_instance_;
class KeyVerificationAdmin;
struct KeyVerificationAdminDefaultTypeInternal;
extern KeyVerificationAdminDefaultTypeInternal _KeyVerificationAdmin_default_instance_;
class NodeRemoteHardwarePinsResponse;
struct NodeRemoteHardwarePinsResponseDefaultTypeInternal;
extern NodeRemoteHardwarePinsResponseDefaultTypeInternal _NodeRemoteHardwarePinsResponse_default_instance_;
class SharedContact;
struct SharedContactDefaultTypeInternal;
extern SharedContactDefaultTypeInternal _SharedContact_default_instance_;
}  // namespace meshtastic
PROTOBUF_NAMESPACE_OPEN
template<> ::meshtastic::AdminMessage* Arena::CreateMaybeMessage<::meshtastic::AdminMessage>(Arena*);
template<> ::meshtastic::AdminMessage_InputEvent* Arena::CreateMaybeMessage<::meshtastic::AdminMessage_InputEvent>(Arena*);
template<> ::meshtastic::HamParameters* Arena::CreateMaybeMessage<::meshtastic::HamParameters>(Arena*);
template<> ::meshtastic::KeyVerificationAdmin* Arena::CreateMaybeMessage<::meshtastic::KeyVerificationAdmin>(Arena*);
template<> ::meshtastic::NodeRemoteHardwarePinsResponse* Arena::CreateMaybeMessage<::meshtastic::NodeRemoteHardwarePinsResponse>(Arena*);
template<> ::meshtastic::SharedContact* Arena::CreateMaybeMessage<::meshtastic::SharedContact>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace meshtastic {

enum AdminMessage_ConfigType : int {
  AdminMessage_ConfigType_DEVICE_CONFIG = 0,
  AdminMessage_ConfigType_POSITION_CONFIG = 1,
  AdminMessage_ConfigType_POWER_CONFIG = 2,
  AdminMessage_ConfigType_NETWORK_CONFIG = 3,
  AdminMessage_ConfigType_DISPLAY_CONFIG = 4,
  AdminMessage_ConfigType_LORA_CONFIG = 5,
  AdminMessage_ConfigType_BLUETOOTH_CONFIG = 6,
  AdminMessage_ConfigType_SECURITY_CONFIG = 7,
  AdminMessage_ConfigType_SESSIONKEY_CONFIG = 8,
  AdminMessage_ConfigType_DEVICEUI_CONFIG = 9,
  AdminMessage_ConfigType_AdminMessage_ConfigType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AdminMessage_ConfigType_AdminMessage_ConfigType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AdminMessage_ConfigType_IsValid(int value);
constexpr AdminMessage_ConfigType AdminMessage_ConfigType_ConfigType_MIN = AdminMessage_ConfigType_DEVICE_CONFIG;
constexpr AdminMessage_ConfigType AdminMessage_ConfigType_ConfigType_MAX = AdminMessage_ConfigType_DEVICEUI_CONFIG;
constexpr int AdminMessage_ConfigType_ConfigType_ARRAYSIZE = AdminMessage_ConfigType_ConfigType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdminMessage_ConfigType_descriptor();
template<typename T>
inline const std::string& AdminMessage_ConfigType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdminMessage_ConfigType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdminMessage_ConfigType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AdminMessage_ConfigType_descriptor(), enum_t_value);
}
inline bool AdminMessage_ConfigType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdminMessage_ConfigType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AdminMessage_ConfigType>(
    AdminMessage_ConfigType_descriptor(), name, value);
}
enum AdminMessage_ModuleConfigType : int {
  AdminMessage_ModuleConfigType_MQTT_CONFIG = 0,
  AdminMessage_ModuleConfigType_SERIAL_CONFIG = 1,
  AdminMessage_ModuleConfigType_EXTNOTIF_CONFIG = 2,
  AdminMessage_ModuleConfigType_STOREFORWARD_CONFIG = 3,
  AdminMessage_ModuleConfigType_RANGETEST_CONFIG = 4,
  AdminMessage_ModuleConfigType_TELEMETRY_CONFIG = 5,
  AdminMessage_ModuleConfigType_CANNEDMSG_CONFIG = 6,
  AdminMessage_ModuleConfigType_AUDIO_CONFIG = 7,
  AdminMessage_ModuleConfigType_REMOTEHARDWARE_CONFIG = 8,
  AdminMessage_ModuleConfigType_NEIGHBORINFO_CONFIG = 9,
  AdminMessage_ModuleConfigType_AMBIENTLIGHTING_CONFIG = 10,
  AdminMessage_ModuleConfigType_DETECTIONSENSOR_CONFIG = 11,
  AdminMessage_ModuleConfigType_PAXCOUNTER_CONFIG = 12,
  AdminMessage_ModuleConfigType_AdminMessage_ModuleConfigType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AdminMessage_ModuleConfigType_AdminMessage_ModuleConfigType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AdminMessage_ModuleConfigType_IsValid(int value);
constexpr AdminMessage_ModuleConfigType AdminMessage_ModuleConfigType_ModuleConfigType_MIN = AdminMessage_ModuleConfigType_MQTT_CONFIG;
constexpr AdminMessage_ModuleConfigType AdminMessage_ModuleConfigType_ModuleConfigType_MAX = AdminMessage_ModuleConfigType_PAXCOUNTER_CONFIG;
constexpr int AdminMessage_ModuleConfigType_ModuleConfigType_ARRAYSIZE = AdminMessage_ModuleConfigType_ModuleConfigType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdminMessage_ModuleConfigType_descriptor();
template<typename T>
inline const std::string& AdminMessage_ModuleConfigType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdminMessage_ModuleConfigType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdminMessage_ModuleConfigType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AdminMessage_ModuleConfigType_descriptor(), enum_t_value);
}
inline bool AdminMessage_ModuleConfigType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdminMessage_ModuleConfigType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AdminMessage_ModuleConfigType>(
    AdminMessage_ModuleConfigType_descriptor(), name, value);
}
enum AdminMessage_BackupLocation : int {
  AdminMessage_BackupLocation_FLASH = 0,
  AdminMessage_BackupLocation_SD = 1,
  AdminMessage_BackupLocation_AdminMessage_BackupLocation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AdminMessage_BackupLocation_AdminMessage_BackupLocation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AdminMessage_BackupLocation_IsValid(int value);
constexpr AdminMessage_BackupLocation AdminMessage_BackupLocation_BackupLocation_MIN = AdminMessage_BackupLocation_FLASH;
constexpr AdminMessage_BackupLocation AdminMessage_BackupLocation_BackupLocation_MAX = AdminMessage_BackupLocation_SD;
constexpr int AdminMessage_BackupLocation_BackupLocation_ARRAYSIZE = AdminMessage_BackupLocation_BackupLocation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdminMessage_BackupLocation_descriptor();
template<typename T>
inline const std::string& AdminMessage_BackupLocation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdminMessage_BackupLocation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdminMessage_BackupLocation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AdminMessage_BackupLocation_descriptor(), enum_t_value);
}
inline bool AdminMessage_BackupLocation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdminMessage_BackupLocation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AdminMessage_BackupLocation>(
    AdminMessage_BackupLocation_descriptor(), name, value);
}
enum KeyVerificationAdmin_MessageType : int {
  KeyVerificationAdmin_MessageType_INITIATE_VERIFICATION = 0,
  KeyVerificationAdmin_MessageType_PROVIDE_SECURITY_NUMBER = 1,
  KeyVerificationAdmin_MessageType_DO_VERIFY = 2,
  KeyVerificationAdmin_MessageType_DO_NOT_VERIFY = 3,
  KeyVerificationAdmin_MessageType_KeyVerificationAdmin_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  KeyVerificationAdmin_MessageType_KeyVerificationAdmin_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool KeyVerificationAdmin_MessageType_IsValid(int value);
constexpr KeyVerificationAdmin_MessageType KeyVerificationAdmin_MessageType_MessageType_MIN = KeyVerificationAdmin_MessageType_INITIATE_VERIFICATION;
constexpr KeyVerificationAdmin_MessageType KeyVerificationAdmin_MessageType_MessageType_MAX = KeyVerificationAdmin_MessageType_DO_NOT_VERIFY;
constexpr int KeyVerificationAdmin_MessageType_MessageType_ARRAYSIZE = KeyVerificationAdmin_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyVerificationAdmin_MessageType_descriptor();
template<typename T>
inline const std::string& KeyVerificationAdmin_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyVerificationAdmin_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyVerificationAdmin_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyVerificationAdmin_MessageType_descriptor(), enum_t_value);
}
inline bool KeyVerificationAdmin_MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyVerificationAdmin_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyVerificationAdmin_MessageType>(
    KeyVerificationAdmin_MessageType_descriptor(), name, value);
}
// ===================================================================

class AdminMessage_InputEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.AdminMessage.InputEvent) */ {
 public:
  inline AdminMessage_InputEvent() : AdminMessage_InputEvent(nullptr) {}
  ~AdminMessage_InputEvent() override;
  explicit PROTOBUF_CONSTEXPR AdminMessage_InputEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminMessage_InputEvent(const AdminMessage_InputEvent& from);
  AdminMessage_InputEvent(AdminMessage_InputEvent&& from) noexcept
    : AdminMessage_InputEvent() {
    *this = ::std::move(from);
  }

  inline AdminMessage_InputEvent& operator=(const AdminMessage_InputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminMessage_InputEvent& operator=(AdminMessage_InputEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminMessage_InputEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminMessage_InputEvent* internal_default_instance() {
    return reinterpret_cast<const AdminMessage_InputEvent*>(
               &_AdminMessage_InputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AdminMessage_InputEvent& a, AdminMessage_InputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminMessage_InputEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminMessage_InputEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminMessage_InputEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminMessage_InputEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminMessage_InputEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminMessage_InputEvent& from) {
    AdminMessage_InputEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminMessage_InputEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.AdminMessage.InputEvent";
  }
  protected:
  explicit AdminMessage_InputEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventCodeFieldNumber = 1,
    kKbCharFieldNumber = 2,
    kTouchXFieldNumber = 3,
    kTouchYFieldNumber = 4,
  };
  // uint32 event_code = 1;
  void clear_event_code();
  uint32_t event_code() const;
  void set_event_code(uint32_t value);
  private:
  uint32_t _internal_event_code() const;
  void _internal_set_event_code(uint32_t value);
  public:

  // uint32 kb_char = 2;
  void clear_kb_char();
  uint32_t kb_char() const;
  void set_kb_char(uint32_t value);
  private:
  uint32_t _internal_kb_char() const;
  void _internal_set_kb_char(uint32_t value);
  public:

  // uint32 touch_x = 3;
  void clear_touch_x();
  uint32_t touch_x() const;
  void set_touch_x(uint32_t value);
  private:
  uint32_t _internal_touch_x() const;
  void _internal_set_touch_x(uint32_t value);
  public:

  // uint32 touch_y = 4;
  void clear_touch_y();
  uint32_t touch_y() const;
  void set_touch_y(uint32_t value);
  private:
  uint32_t _internal_touch_y() const;
  void _internal_set_touch_y(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.AdminMessage.InputEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t event_code_;
    uint32_t kb_char_;
    uint32_t touch_x_;
    uint32_t touch_y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};
// -------------------------------------------------------------------

class AdminMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.AdminMessage) */ {
 public:
  inline AdminMessage() : AdminMessage(nullptr) {}
  ~AdminMessage() override;
  explicit PROTOBUF_CONSTEXPR AdminMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminMessage(const AdminMessage& from);
  AdminMessage(AdminMessage&& from) noexcept
    : AdminMessage() {
    *this = ::std::move(from);
  }

  inline AdminMessage& operator=(const AdminMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminMessage& operator=(AdminMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kGetChannelRequest = 1,
    kGetChannelResponse = 2,
    kGetOwnerRequest = 3,
    kGetOwnerResponse = 4,
    kGetConfigRequest = 5,
    kGetConfigResponse = 6,
    kGetModuleConfigRequest = 7,
    kGetModuleConfigResponse = 8,
    kGetCannedMessageModuleMessagesRequest = 10,
    kGetCannedMessageModuleMessagesResponse = 11,
    kGetDeviceMetadataRequest = 12,
    kGetDeviceMetadataResponse = 13,
    kGetRingtoneRequest = 14,
    kGetRingtoneResponse = 15,
    kGetDeviceConnectionStatusRequest = 16,
    kGetDeviceConnectionStatusResponse = 17,
    kSetHamMode = 18,
    kGetNodeRemoteHardwarePinsRequest = 19,
    kGetNodeRemoteHardwarePinsResponse = 20,
    kEnterDfuModeRequest = 21,
    kDeleteFileRequest = 22,
    kSetScale = 23,
    kBackupPreferences = 24,
    kRestorePreferences = 25,
    kRemoveBackupPreferences = 26,
    kSendInputEvent = 27,
    kSetOwner = 32,
    kSetChannel = 33,
    kSetConfig = 34,
    kSetModuleConfig = 35,
    kSetCannedMessageModuleMessages = 36,
    kSetRingtoneMessage = 37,
    kRemoveByNodenum = 38,
    kSetFavoriteNode = 39,
    kRemoveFavoriteNode = 40,
    kSetFixedPosition = 41,
    kRemoveFixedPosition = 42,
    kSetTimeOnly = 43,
    kGetUiConfigRequest = 44,
    kGetUiConfigResponse = 45,
    kStoreUiConfig = 46,
    kSetIgnoredNode = 47,
    kRemoveIgnoredNode = 48,
    kBeginEditSettings = 64,
    kCommitEditSettings = 65,
    kAddContact = 66,
    kKeyVerification = 67,
    kFactoryResetDevice = 94,
    kRebootOtaSeconds = 95,
    kExitSimulator = 96,
    kRebootSeconds = 97,
    kShutdownSeconds = 98,
    kFactoryResetConfig = 99,
    kNodedbReset = 100,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };

  static inline const AdminMessage* internal_default_instance() {
    return reinterpret_cast<const AdminMessage*>(
               &_AdminMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AdminMessage& a, AdminMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminMessage& from) {
    AdminMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.AdminMessage";
  }
  protected:
  explicit AdminMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AdminMessage_InputEvent InputEvent;

  typedef AdminMessage_ConfigType ConfigType;
  static constexpr ConfigType DEVICE_CONFIG =
    AdminMessage_ConfigType_DEVICE_CONFIG;
  static constexpr ConfigType POSITION_CONFIG =
    AdminMessage_ConfigType_POSITION_CONFIG;
  static constexpr ConfigType POWER_CONFIG =
    AdminMessage_ConfigType_POWER_CONFIG;
  static constexpr ConfigType NETWORK_CONFIG =
    AdminMessage_ConfigType_NETWORK_CONFIG;
  static constexpr ConfigType DISPLAY_CONFIG =
    AdminMessage_ConfigType_DISPLAY_CONFIG;
  static constexpr ConfigType LORA_CONFIG =
    AdminMessage_ConfigType_LORA_CONFIG;
  static constexpr ConfigType BLUETOOTH_CONFIG =
    AdminMessage_ConfigType_BLUETOOTH_CONFIG;
  static constexpr ConfigType SECURITY_CONFIG =
    AdminMessage_ConfigType_SECURITY_CONFIG;
  static constexpr ConfigType SESSIONKEY_CONFIG =
    AdminMessage_ConfigType_SESSIONKEY_CONFIG;
  static constexpr ConfigType DEVICEUI_CONFIG =
    AdminMessage_ConfigType_DEVICEUI_CONFIG;
  static inline bool ConfigType_IsValid(int value) {
    return AdminMessage_ConfigType_IsValid(value);
  }
  static constexpr ConfigType ConfigType_MIN =
    AdminMessage_ConfigType_ConfigType_MIN;
  static constexpr ConfigType ConfigType_MAX =
    AdminMessage_ConfigType_ConfigType_MAX;
  static constexpr int ConfigType_ARRAYSIZE =
    AdminMessage_ConfigType_ConfigType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ConfigType_descriptor() {
    return AdminMessage_ConfigType_descriptor();
  }
  template<typename T>
  static inline const std::string& ConfigType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConfigType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConfigType_Name.");
    return AdminMessage_ConfigType_Name(enum_t_value);
  }
  static inline bool ConfigType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConfigType* value) {
    return AdminMessage_ConfigType_Parse(name, value);
  }

  typedef AdminMessage_ModuleConfigType ModuleConfigType;
  static constexpr ModuleConfigType MQTT_CONFIG =
    AdminMessage_ModuleConfigType_MQTT_CONFIG;
  static constexpr ModuleConfigType SERIAL_CONFIG =
    AdminMessage_ModuleConfigType_SERIAL_CONFIG;
  static constexpr ModuleConfigType EXTNOTIF_CONFIG =
    AdminMessage_ModuleConfigType_EXTNOTIF_CONFIG;
  static constexpr ModuleConfigType STOREFORWARD_CONFIG =
    AdminMessage_ModuleConfigType_STOREFORWARD_CONFIG;
  static constexpr ModuleConfigType RANGETEST_CONFIG =
    AdminMessage_ModuleConfigType_RANGETEST_CONFIG;
  static constexpr ModuleConfigType TELEMETRY_CONFIG =
    AdminMessage_ModuleConfigType_TELEMETRY_CONFIG;
  static constexpr ModuleConfigType CANNEDMSG_CONFIG =
    AdminMessage_ModuleConfigType_CANNEDMSG_CONFIG;
  static constexpr ModuleConfigType AUDIO_CONFIG =
    AdminMessage_ModuleConfigType_AUDIO_CONFIG;
  static constexpr ModuleConfigType REMOTEHARDWARE_CONFIG =
    AdminMessage_ModuleConfigType_REMOTEHARDWARE_CONFIG;
  static constexpr ModuleConfigType NEIGHBORINFO_CONFIG =
    AdminMessage_ModuleConfigType_NEIGHBORINFO_CONFIG;
  static constexpr ModuleConfigType AMBIENTLIGHTING_CONFIG =
    AdminMessage_ModuleConfigType_AMBIENTLIGHTING_CONFIG;
  static constexpr ModuleConfigType DETECTIONSENSOR_CONFIG =
    AdminMessage_ModuleConfigType_DETECTIONSENSOR_CONFIG;
  static constexpr ModuleConfigType PAXCOUNTER_CONFIG =
    AdminMessage_ModuleConfigType_PAXCOUNTER_CONFIG;
  static inline bool ModuleConfigType_IsValid(int value) {
    return AdminMessage_ModuleConfigType_IsValid(value);
  }
  static constexpr ModuleConfigType ModuleConfigType_MIN =
    AdminMessage_ModuleConfigType_ModuleConfigType_MIN;
  static constexpr ModuleConfigType ModuleConfigType_MAX =
    AdminMessage_ModuleConfigType_ModuleConfigType_MAX;
  static constexpr int ModuleConfigType_ARRAYSIZE =
    AdminMessage_ModuleConfigType_ModuleConfigType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ModuleConfigType_descriptor() {
    return AdminMessage_ModuleConfigType_descriptor();
  }
  template<typename T>
  static inline const std::string& ModuleConfigType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ModuleConfigType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ModuleConfigType_Name.");
    return AdminMessage_ModuleConfigType_Name(enum_t_value);
  }
  static inline bool ModuleConfigType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ModuleConfigType* value) {
    return AdminMessage_ModuleConfigType_Parse(name, value);
  }

  typedef AdminMessage_BackupLocation BackupLocation;
  static constexpr BackupLocation FLASH =
    AdminMessage_BackupLocation_FLASH;
  static constexpr BackupLocation SD =
    AdminMessage_BackupLocation_SD;
  static inline bool BackupLocation_IsValid(int value) {
    return AdminMessage_BackupLocation_IsValid(value);
  }
  static constexpr BackupLocation BackupLocation_MIN =
    AdminMessage_BackupLocation_BackupLocation_MIN;
  static constexpr BackupLocation BackupLocation_MAX =
    AdminMessage_BackupLocation_BackupLocation_MAX;
  static constexpr int BackupLocation_ARRAYSIZE =
    AdminMessage_BackupLocation_BackupLocation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BackupLocation_descriptor() {
    return AdminMessage_BackupLocation_descriptor();
  }
  template<typename T>
  static inline const std::string& BackupLocation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BackupLocation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BackupLocation_Name.");
    return AdminMessage_BackupLocation_Name(enum_t_value);
  }
  static inline bool BackupLocation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BackupLocation* value) {
    return AdminMessage_BackupLocation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSessionPasskeyFieldNumber = 101,
    kGetChannelRequestFieldNumber = 1,
    kGetChannelResponseFieldNumber = 2,
    kGetOwnerRequestFieldNumber = 3,
    kGetOwnerResponseFieldNumber = 4,
    kGetConfigRequestFieldNumber = 5,
    kGetConfigResponseFieldNumber = 6,
    kGetModuleConfigRequestFieldNumber = 7,
    kGetModuleConfigResponseFieldNumber = 8,
    kGetCannedMessageModuleMessagesRequestFieldNumber = 10,
    kGetCannedMessageModuleMessagesResponseFieldNumber = 11,
    kGetDeviceMetadataRequestFieldNumber = 12,
    kGetDeviceMetadataResponseFieldNumber = 13,
    kGetRingtoneRequestFieldNumber = 14,
    kGetRingtoneResponseFieldNumber = 15,
    kGetDeviceConnectionStatusRequestFieldNumber = 16,
    kGetDeviceConnectionStatusResponseFieldNumber = 17,
    kSetHamModeFieldNumber = 18,
    kGetNodeRemoteHardwarePinsRequestFieldNumber = 19,
    kGetNodeRemoteHardwarePinsResponseFieldNumber = 20,
    kEnterDfuModeRequestFieldNumber = 21,
    kDeleteFileRequestFieldNumber = 22,
    kSetScaleFieldNumber = 23,
    kBackupPreferencesFieldNumber = 24,
    kRestorePreferencesFieldNumber = 25,
    kRemoveBackupPreferencesFieldNumber = 26,
    kSendInputEventFieldNumber = 27,
    kSetOwnerFieldNumber = 32,
    kSetChannelFieldNumber = 33,
    kSetConfigFieldNumber = 34,
    kSetModuleConfigFieldNumber = 35,
    kSetCannedMessageModuleMessagesFieldNumber = 36,
    kSetRingtoneMessageFieldNumber = 37,
    kRemoveByNodenumFieldNumber = 38,
    kSetFavoriteNodeFieldNumber = 39,
    kRemoveFavoriteNodeFieldNumber = 40,
    kSetFixedPositionFieldNumber = 41,
    kRemoveFixedPositionFieldNumber = 42,
    kSetTimeOnlyFieldNumber = 43,
    kGetUiConfigRequestFieldNumber = 44,
    kGetUiConfigResponseFieldNumber = 45,
    kStoreUiConfigFieldNumber = 46,
    kSetIgnoredNodeFieldNumber = 47,
    kRemoveIgnoredNodeFieldNumber = 48,
    kBeginEditSettingsFieldNumber = 64,
    kCommitEditSettingsFieldNumber = 65,
    kAddContactFieldNumber = 66,
    kKeyVerificationFieldNumber = 67,
    kFactoryResetDeviceFieldNumber = 94,
    kRebootOtaSecondsFieldNumber = 95,
    kExitSimulatorFieldNumber = 96,
    kRebootSecondsFieldNumber = 97,
    kShutdownSecondsFieldNumber = 98,
    kFactoryResetConfigFieldNumber = 99,
    kNodedbResetFieldNumber = 100,
  };
  // bytes session_passkey = 101;
  void clear_session_passkey();
  const std::string& session_passkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_passkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_passkey();
  PROTOBUF_NODISCARD std::string* release_session_passkey();
  void set_allocated_session_passkey(std::string* session_passkey);
  private:
  const std::string& _internal_session_passkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_passkey(const std::string& value);
  std::string* _internal_mutable_session_passkey();
  public:

  // uint32 get_channel_request = 1;
  bool has_get_channel_request() const;
  private:
  bool _internal_has_get_channel_request() const;
  public:
  void clear_get_channel_request();
  uint32_t get_channel_request() const;
  void set_get_channel_request(uint32_t value);
  private:
  uint32_t _internal_get_channel_request() const;
  void _internal_set_get_channel_request(uint32_t value);
  public:

  // .meshtastic.Channel get_channel_response = 2;
  bool has_get_channel_response() const;
  private:
  bool _internal_has_get_channel_response() const;
  public:
  void clear_get_channel_response();
  const ::meshtastic::Channel& get_channel_response() const;
  PROTOBUF_NODISCARD ::meshtastic::Channel* release_get_channel_response();
  ::meshtastic::Channel* mutable_get_channel_response();
  void set_allocated_get_channel_response(::meshtastic::Channel* get_channel_response);
  private:
  const ::meshtastic::Channel& _internal_get_channel_response() const;
  ::meshtastic::Channel* _internal_mutable_get_channel_response();
  public:
  void unsafe_arena_set_allocated_get_channel_response(
      ::meshtastic::Channel* get_channel_response);
  ::meshtastic::Channel* unsafe_arena_release_get_channel_response();

  // bool get_owner_request = 3;
  bool has_get_owner_request() const;
  private:
  bool _internal_has_get_owner_request() const;
  public:
  void clear_get_owner_request();
  bool get_owner_request() const;
  void set_get_owner_request(bool value);
  private:
  bool _internal_get_owner_request() const;
  void _internal_set_get_owner_request(bool value);
  public:

  // .meshtastic.User get_owner_response = 4;
  bool has_get_owner_response() const;
  private:
  bool _internal_has_get_owner_response() const;
  public:
  void clear_get_owner_response();
  const ::meshtastic::User& get_owner_response() const;
  PROTOBUF_NODISCARD ::meshtastic::User* release_get_owner_response();
  ::meshtastic::User* mutable_get_owner_response();
  void set_allocated_get_owner_response(::meshtastic::User* get_owner_response);
  private:
  const ::meshtastic::User& _internal_get_owner_response() const;
  ::meshtastic::User* _internal_mutable_get_owner_response();
  public:
  void unsafe_arena_set_allocated_get_owner_response(
      ::meshtastic::User* get_owner_response);
  ::meshtastic::User* unsafe_arena_release_get_owner_response();

  // .meshtastic.AdminMessage.ConfigType get_config_request = 5;
  bool has_get_config_request() const;
  private:
  bool _internal_has_get_config_request() const;
  public:
  void clear_get_config_request();
  ::meshtastic::AdminMessage_ConfigType get_config_request() const;
  void set_get_config_request(::meshtastic::AdminMessage_ConfigType value);
  private:
  ::meshtastic::AdminMessage_ConfigType _internal_get_config_request() const;
  void _internal_set_get_config_request(::meshtastic::AdminMessage_ConfigType value);
  public:

  // .meshtastic.Config get_config_response = 6;
  bool has_get_config_response() const;
  private:
  bool _internal_has_get_config_response() const;
  public:
  void clear_get_config_response();
  const ::meshtastic::Config& get_config_response() const;
  PROTOBUF_NODISCARD ::meshtastic::Config* release_get_config_response();
  ::meshtastic::Config* mutable_get_config_response();
  void set_allocated_get_config_response(::meshtastic::Config* get_config_response);
  private:
  const ::meshtastic::Config& _internal_get_config_response() const;
  ::meshtastic::Config* _internal_mutable_get_config_response();
  public:
  void unsafe_arena_set_allocated_get_config_response(
      ::meshtastic::Config* get_config_response);
  ::meshtastic::Config* unsafe_arena_release_get_config_response();

  // .meshtastic.AdminMessage.ModuleConfigType get_module_config_request = 7;
  bool has_get_module_config_request() const;
  private:
  bool _internal_has_get_module_config_request() const;
  public:
  void clear_get_module_config_request();
  ::meshtastic::AdminMessage_ModuleConfigType get_module_config_request() const;
  void set_get_module_config_request(::meshtastic::AdminMessage_ModuleConfigType value);
  private:
  ::meshtastic::AdminMessage_ModuleConfigType _internal_get_module_config_request() const;
  void _internal_set_get_module_config_request(::meshtastic::AdminMessage_ModuleConfigType value);
  public:

  // .meshtastic.ModuleConfig get_module_config_response = 8;
  bool has_get_module_config_response() const;
  private:
  bool _internal_has_get_module_config_response() const;
  public:
  void clear_get_module_config_response();
  const ::meshtastic::ModuleConfig& get_module_config_response() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig* release_get_module_config_response();
  ::meshtastic::ModuleConfig* mutable_get_module_config_response();
  void set_allocated_get_module_config_response(::meshtastic::ModuleConfig* get_module_config_response);
  private:
  const ::meshtastic::ModuleConfig& _internal_get_module_config_response() const;
  ::meshtastic::ModuleConfig* _internal_mutable_get_module_config_response();
  public:
  void unsafe_arena_set_allocated_get_module_config_response(
      ::meshtastic::ModuleConfig* get_module_config_response);
  ::meshtastic::ModuleConfig* unsafe_arena_release_get_module_config_response();

  // bool get_canned_message_module_messages_request = 10;
  bool has_get_canned_message_module_messages_request() const;
  private:
  bool _internal_has_get_canned_message_module_messages_request() const;
  public:
  void clear_get_canned_message_module_messages_request();
  bool get_canned_message_module_messages_request() const;
  void set_get_canned_message_module_messages_request(bool value);
  private:
  bool _internal_get_canned_message_module_messages_request() const;
  void _internal_set_get_canned_message_module_messages_request(bool value);
  public:

  // string get_canned_message_module_messages_response = 11;
  bool has_get_canned_message_module_messages_response() const;
  private:
  bool _internal_has_get_canned_message_module_messages_response() const;
  public:
  void clear_get_canned_message_module_messages_response();
  const std::string& get_canned_message_module_messages_response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_get_canned_message_module_messages_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_get_canned_message_module_messages_response();
  PROTOBUF_NODISCARD std::string* release_get_canned_message_module_messages_response();
  void set_allocated_get_canned_message_module_messages_response(std::string* get_canned_message_module_messages_response);
  private:
  const std::string& _internal_get_canned_message_module_messages_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_get_canned_message_module_messages_response(const std::string& value);
  std::string* _internal_mutable_get_canned_message_module_messages_response();
  public:

  // bool get_device_metadata_request = 12;
  bool has_get_device_metadata_request() const;
  private:
  bool _internal_has_get_device_metadata_request() const;
  public:
  void clear_get_device_metadata_request();
  bool get_device_metadata_request() const;
  void set_get_device_metadata_request(bool value);
  private:
  bool _internal_get_device_metadata_request() const;
  void _internal_set_get_device_metadata_request(bool value);
  public:

  // .meshtastic.DeviceMetadata get_device_metadata_response = 13;
  bool has_get_device_metadata_response() const;
  private:
  bool _internal_has_get_device_metadata_response() const;
  public:
  void clear_get_device_metadata_response();
  const ::meshtastic::DeviceMetadata& get_device_metadata_response() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceMetadata* release_get_device_metadata_response();
  ::meshtastic::DeviceMetadata* mutable_get_device_metadata_response();
  void set_allocated_get_device_metadata_response(::meshtastic::DeviceMetadata* get_device_metadata_response);
  private:
  const ::meshtastic::DeviceMetadata& _internal_get_device_metadata_response() const;
  ::meshtastic::DeviceMetadata* _internal_mutable_get_device_metadata_response();
  public:
  void unsafe_arena_set_allocated_get_device_metadata_response(
      ::meshtastic::DeviceMetadata* get_device_metadata_response);
  ::meshtastic::DeviceMetadata* unsafe_arena_release_get_device_metadata_response();

  // bool get_ringtone_request = 14;
  bool has_get_ringtone_request() const;
  private:
  bool _internal_has_get_ringtone_request() const;
  public:
  void clear_get_ringtone_request();
  bool get_ringtone_request() const;
  void set_get_ringtone_request(bool value);
  private:
  bool _internal_get_ringtone_request() const;
  void _internal_set_get_ringtone_request(bool value);
  public:

  // string get_ringtone_response = 15;
  bool has_get_ringtone_response() const;
  private:
  bool _internal_has_get_ringtone_response() const;
  public:
  void clear_get_ringtone_response();
  const std::string& get_ringtone_response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_get_ringtone_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_get_ringtone_response();
  PROTOBUF_NODISCARD std::string* release_get_ringtone_response();
  void set_allocated_get_ringtone_response(std::string* get_ringtone_response);
  private:
  const std::string& _internal_get_ringtone_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_get_ringtone_response(const std::string& value);
  std::string* _internal_mutable_get_ringtone_response();
  public:

  // bool get_device_connection_status_request = 16;
  bool has_get_device_connection_status_request() const;
  private:
  bool _internal_has_get_device_connection_status_request() const;
  public:
  void clear_get_device_connection_status_request();
  bool get_device_connection_status_request() const;
  void set_get_device_connection_status_request(bool value);
  private:
  bool _internal_get_device_connection_status_request() const;
  void _internal_set_get_device_connection_status_request(bool value);
  public:

  // .meshtastic.DeviceConnectionStatus get_device_connection_status_response = 17;
  bool has_get_device_connection_status_response() const;
  private:
  bool _internal_has_get_device_connection_status_response() const;
  public:
  void clear_get_device_connection_status_response();
  const ::meshtastic::DeviceConnectionStatus& get_device_connection_status_response() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceConnectionStatus* release_get_device_connection_status_response();
  ::meshtastic::DeviceConnectionStatus* mutable_get_device_connection_status_response();
  void set_allocated_get_device_connection_status_response(::meshtastic::DeviceConnectionStatus* get_device_connection_status_response);
  private:
  const ::meshtastic::DeviceConnectionStatus& _internal_get_device_connection_status_response() const;
  ::meshtastic::DeviceConnectionStatus* _internal_mutable_get_device_connection_status_response();
  public:
  void unsafe_arena_set_allocated_get_device_connection_status_response(
      ::meshtastic::DeviceConnectionStatus* get_device_connection_status_response);
  ::meshtastic::DeviceConnectionStatus* unsafe_arena_release_get_device_connection_status_response();

  // .meshtastic.HamParameters set_ham_mode = 18;
  bool has_set_ham_mode() const;
  private:
  bool _internal_has_set_ham_mode() const;
  public:
  void clear_set_ham_mode();
  const ::meshtastic::HamParameters& set_ham_mode() const;
  PROTOBUF_NODISCARD ::meshtastic::HamParameters* release_set_ham_mode();
  ::meshtastic::HamParameters* mutable_set_ham_mode();
  void set_allocated_set_ham_mode(::meshtastic::HamParameters* set_ham_mode);
  private:
  const ::meshtastic::HamParameters& _internal_set_ham_mode() const;
  ::meshtastic::HamParameters* _internal_mutable_set_ham_mode();
  public:
  void unsafe_arena_set_allocated_set_ham_mode(
      ::meshtastic::HamParameters* set_ham_mode);
  ::meshtastic::HamParameters* unsafe_arena_release_set_ham_mode();

  // bool get_node_remote_hardware_pins_request = 19;
  bool has_get_node_remote_hardware_pins_request() const;
  private:
  bool _internal_has_get_node_remote_hardware_pins_request() const;
  public:
  void clear_get_node_remote_hardware_pins_request();
  bool get_node_remote_hardware_pins_request() const;
  void set_get_node_remote_hardware_pins_request(bool value);
  private:
  bool _internal_get_node_remote_hardware_pins_request() const;
  void _internal_set_get_node_remote_hardware_pins_request(bool value);
  public:

  // .meshtastic.NodeRemoteHardwarePinsResponse get_node_remote_hardware_pins_response = 20;
  bool has_get_node_remote_hardware_pins_response() const;
  private:
  bool _internal_has_get_node_remote_hardware_pins_response() const;
  public:
  void clear_get_node_remote_hardware_pins_response();
  const ::meshtastic::NodeRemoteHardwarePinsResponse& get_node_remote_hardware_pins_response() const;
  PROTOBUF_NODISCARD ::meshtastic::NodeRemoteHardwarePinsResponse* release_get_node_remote_hardware_pins_response();
  ::meshtastic::NodeRemoteHardwarePinsResponse* mutable_get_node_remote_hardware_pins_response();
  void set_allocated_get_node_remote_hardware_pins_response(::meshtastic::NodeRemoteHardwarePinsResponse* get_node_remote_hardware_pins_response);
  private:
  const ::meshtastic::NodeRemoteHardwarePinsResponse& _internal_get_node_remote_hardware_pins_response() const;
  ::meshtastic::NodeRemoteHardwarePinsResponse* _internal_mutable_get_node_remote_hardware_pins_response();
  public:
  void unsafe_arena_set_allocated_get_node_remote_hardware_pins_response(
      ::meshtastic::NodeRemoteHardwarePinsResponse* get_node_remote_hardware_pins_response);
  ::meshtastic::NodeRemoteHardwarePinsResponse* unsafe_arena_release_get_node_remote_hardware_pins_response();

  // bool enter_dfu_mode_request = 21;
  bool has_enter_dfu_mode_request() const;
  private:
  bool _internal_has_enter_dfu_mode_request() const;
  public:
  void clear_enter_dfu_mode_request();
  bool enter_dfu_mode_request() const;
  void set_enter_dfu_mode_request(bool value);
  private:
  bool _internal_enter_dfu_mode_request() const;
  void _internal_set_enter_dfu_mode_request(bool value);
  public:

  // string delete_file_request = 22;
  bool has_delete_file_request() const;
  private:
  bool _internal_has_delete_file_request() const;
  public:
  void clear_delete_file_request();
  const std::string& delete_file_request() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_delete_file_request(ArgT0&& arg0, ArgT... args);
  std::string* mutable_delete_file_request();
  PROTOBUF_NODISCARD std::string* release_delete_file_request();
  void set_allocated_delete_file_request(std::string* delete_file_request);
  private:
  const std::string& _internal_delete_file_request() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delete_file_request(const std::string& value);
  std::string* _internal_mutable_delete_file_request();
  public:

  // uint32 set_scale = 23;
  bool has_set_scale() const;
  private:
  bool _internal_has_set_scale() const;
  public:
  void clear_set_scale();
  uint32_t set_scale() const;
  void set_set_scale(uint32_t value);
  private:
  uint32_t _internal_set_scale() const;
  void _internal_set_set_scale(uint32_t value);
  public:

  // .meshtastic.AdminMessage.BackupLocation backup_preferences = 24;
  bool has_backup_preferences() const;
  private:
  bool _internal_has_backup_preferences() const;
  public:
  void clear_backup_preferences();
  ::meshtastic::AdminMessage_BackupLocation backup_preferences() const;
  void set_backup_preferences(::meshtastic::AdminMessage_BackupLocation value);
  private:
  ::meshtastic::AdminMessage_BackupLocation _internal_backup_preferences() const;
  void _internal_set_backup_preferences(::meshtastic::AdminMessage_BackupLocation value);
  public:

  // .meshtastic.AdminMessage.BackupLocation restore_preferences = 25;
  bool has_restore_preferences() const;
  private:
  bool _internal_has_restore_preferences() const;
  public:
  void clear_restore_preferences();
  ::meshtastic::AdminMessage_BackupLocation restore_preferences() const;
  void set_restore_preferences(::meshtastic::AdminMessage_BackupLocation value);
  private:
  ::meshtastic::AdminMessage_BackupLocation _internal_restore_preferences() const;
  void _internal_set_restore_preferences(::meshtastic::AdminMessage_BackupLocation value);
  public:

  // .meshtastic.AdminMessage.BackupLocation remove_backup_preferences = 26;
  bool has_remove_backup_preferences() const;
  private:
  bool _internal_has_remove_backup_preferences() const;
  public:
  void clear_remove_backup_preferences();
  ::meshtastic::AdminMessage_BackupLocation remove_backup_preferences() const;
  void set_remove_backup_preferences(::meshtastic::AdminMessage_BackupLocation value);
  private:
  ::meshtastic::AdminMessage_BackupLocation _internal_remove_backup_preferences() const;
  void _internal_set_remove_backup_preferences(::meshtastic::AdminMessage_BackupLocation value);
  public:

  // .meshtastic.AdminMessage.InputEvent send_input_event = 27;
  bool has_send_input_event() const;
  private:
  bool _internal_has_send_input_event() const;
  public:
  void clear_send_input_event();
  const ::meshtastic::AdminMessage_InputEvent& send_input_event() const;
  PROTOBUF_NODISCARD ::meshtastic::AdminMessage_InputEvent* release_send_input_event();
  ::meshtastic::AdminMessage_InputEvent* mutable_send_input_event();
  void set_allocated_send_input_event(::meshtastic::AdminMessage_InputEvent* send_input_event);
  private:
  const ::meshtastic::AdminMessage_InputEvent& _internal_send_input_event() const;
  ::meshtastic::AdminMessage_InputEvent* _internal_mutable_send_input_event();
  public:
  void unsafe_arena_set_allocated_send_input_event(
      ::meshtastic::AdminMessage_InputEvent* send_input_event);
  ::meshtastic::AdminMessage_InputEvent* unsafe_arena_release_send_input_event();

  // .meshtastic.User set_owner = 32;
  bool has_set_owner() const;
  private:
  bool _internal_has_set_owner() const;
  public:
  void clear_set_owner();
  const ::meshtastic::User& set_owner() const;
  PROTOBUF_NODISCARD ::meshtastic::User* release_set_owner();
  ::meshtastic::User* mutable_set_owner();
  void set_allocated_set_owner(::meshtastic::User* set_owner);
  private:
  const ::meshtastic::User& _internal_set_owner() const;
  ::meshtastic::User* _internal_mutable_set_owner();
  public:
  void unsafe_arena_set_allocated_set_owner(
      ::meshtastic::User* set_owner);
  ::meshtastic::User* unsafe_arena_release_set_owner();

  // .meshtastic.Channel set_channel = 33;
  bool has_set_channel() const;
  private:
  bool _internal_has_set_channel() const;
  public:
  void clear_set_channel();
  const ::meshtastic::Channel& set_channel() const;
  PROTOBUF_NODISCARD ::meshtastic::Channel* release_set_channel();
  ::meshtastic::Channel* mutable_set_channel();
  void set_allocated_set_channel(::meshtastic::Channel* set_channel);
  private:
  const ::meshtastic::Channel& _internal_set_channel() const;
  ::meshtastic::Channel* _internal_mutable_set_channel();
  public:
  void unsafe_arena_set_allocated_set_channel(
      ::meshtastic::Channel* set_channel);
  ::meshtastic::Channel* unsafe_arena_release_set_channel();

  // .meshtastic.Config set_config = 34;
  bool has_set_config() const;
  private:
  bool _internal_has_set_config() const;
  public:
  void clear_set_config();
  const ::meshtastic::Config& set_config() const;
  PROTOBUF_NODISCARD ::meshtastic::Config* release_set_config();
  ::meshtastic::Config* mutable_set_config();
  void set_allocated_set_config(::meshtastic::Config* set_config);
  private:
  const ::meshtastic::Config& _internal_set_config() const;
  ::meshtastic::Config* _internal_mutable_set_config();
  public:
  void unsafe_arena_set_allocated_set_config(
      ::meshtastic::Config* set_config);
  ::meshtastic::Config* unsafe_arena_release_set_config();

  // .meshtastic.ModuleConfig set_module_config = 35;
  bool has_set_module_config() const;
  private:
  bool _internal_has_set_module_config() const;
  public:
  void clear_set_module_config();
  const ::meshtastic::ModuleConfig& set_module_config() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig* release_set_module_config();
  ::meshtastic::ModuleConfig* mutable_set_module_config();
  void set_allocated_set_module_config(::meshtastic::ModuleConfig* set_module_config);
  private:
  const ::meshtastic::ModuleConfig& _internal_set_module_config() const;
  ::meshtastic::ModuleConfig* _internal_mutable_set_module_config();
  public:
  void unsafe_arena_set_allocated_set_module_config(
      ::meshtastic::ModuleConfig* set_module_config);
  ::meshtastic::ModuleConfig* unsafe_arena_release_set_module_config();

  // string set_canned_message_module_messages = 36;
  bool has_set_canned_message_module_messages() const;
  private:
  bool _internal_has_set_canned_message_module_messages() const;
  public:
  void clear_set_canned_message_module_messages();
  const std::string& set_canned_message_module_messages() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_set_canned_message_module_messages(ArgT0&& arg0, ArgT... args);
  std::string* mutable_set_canned_message_module_messages();
  PROTOBUF_NODISCARD std::string* release_set_canned_message_module_messages();
  void set_allocated_set_canned_message_module_messages(std::string* set_canned_message_module_messages);
  private:
  const std::string& _internal_set_canned_message_module_messages() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_canned_message_module_messages(const std::string& value);
  std::string* _internal_mutable_set_canned_message_module_messages();
  public:

  // string set_ringtone_message = 37;
  bool has_set_ringtone_message() const;
  private:
  bool _internal_has_set_ringtone_message() const;
  public:
  void clear_set_ringtone_message();
  const std::string& set_ringtone_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_set_ringtone_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_set_ringtone_message();
  PROTOBUF_NODISCARD std::string* release_set_ringtone_message();
  void set_allocated_set_ringtone_message(std::string* set_ringtone_message);
  private:
  const std::string& _internal_set_ringtone_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_ringtone_message(const std::string& value);
  std::string* _internal_mutable_set_ringtone_message();
  public:

  // uint32 remove_by_nodenum = 38;
  bool has_remove_by_nodenum() const;
  private:
  bool _internal_has_remove_by_nodenum() const;
  public:
  void clear_remove_by_nodenum();
  uint32_t remove_by_nodenum() const;
  void set_remove_by_nodenum(uint32_t value);
  private:
  uint32_t _internal_remove_by_nodenum() const;
  void _internal_set_remove_by_nodenum(uint32_t value);
  public:

  // uint32 set_favorite_node = 39;
  bool has_set_favorite_node() const;
  private:
  bool _internal_has_set_favorite_node() const;
  public:
  void clear_set_favorite_node();
  uint32_t set_favorite_node() const;
  void set_set_favorite_node(uint32_t value);
  private:
  uint32_t _internal_set_favorite_node() const;
  void _internal_set_set_favorite_node(uint32_t value);
  public:

  // uint32 remove_favorite_node = 40;
  bool has_remove_favorite_node() const;
  private:
  bool _internal_has_remove_favorite_node() const;
  public:
  void clear_remove_favorite_node();
  uint32_t remove_favorite_node() const;
  void set_remove_favorite_node(uint32_t value);
  private:
  uint32_t _internal_remove_favorite_node() const;
  void _internal_set_remove_favorite_node(uint32_t value);
  public:

  // .meshtastic.Position set_fixed_position = 41;
  bool has_set_fixed_position() const;
  private:
  bool _internal_has_set_fixed_position() const;
  public:
  void clear_set_fixed_position();
  const ::meshtastic::Position& set_fixed_position() const;
  PROTOBUF_NODISCARD ::meshtastic::Position* release_set_fixed_position();
  ::meshtastic::Position* mutable_set_fixed_position();
  void set_allocated_set_fixed_position(::meshtastic::Position* set_fixed_position);
  private:
  const ::meshtastic::Position& _internal_set_fixed_position() const;
  ::meshtastic::Position* _internal_mutable_set_fixed_position();
  public:
  void unsafe_arena_set_allocated_set_fixed_position(
      ::meshtastic::Position* set_fixed_position);
  ::meshtastic::Position* unsafe_arena_release_set_fixed_position();

  // bool remove_fixed_position = 42;
  bool has_remove_fixed_position() const;
  private:
  bool _internal_has_remove_fixed_position() const;
  public:
  void clear_remove_fixed_position();
  bool remove_fixed_position() const;
  void set_remove_fixed_position(bool value);
  private:
  bool _internal_remove_fixed_position() const;
  void _internal_set_remove_fixed_position(bool value);
  public:

  // fixed32 set_time_only = 43;
  bool has_set_time_only() const;
  private:
  bool _internal_has_set_time_only() const;
  public:
  void clear_set_time_only();
  uint32_t set_time_only() const;
  void set_set_time_only(uint32_t value);
  private:
  uint32_t _internal_set_time_only() const;
  void _internal_set_set_time_only(uint32_t value);
  public:

  // bool get_ui_config_request = 44;
  bool has_get_ui_config_request() const;
  private:
  bool _internal_has_get_ui_config_request() const;
  public:
  void clear_get_ui_config_request();
  bool get_ui_config_request() const;
  void set_get_ui_config_request(bool value);
  private:
  bool _internal_get_ui_config_request() const;
  void _internal_set_get_ui_config_request(bool value);
  public:

  // .meshtastic.DeviceUIConfig get_ui_config_response = 45;
  bool has_get_ui_config_response() const;
  private:
  bool _internal_has_get_ui_config_response() const;
  public:
  void clear_get_ui_config_response();
  const ::meshtastic::DeviceUIConfig& get_ui_config_response() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceUIConfig* release_get_ui_config_response();
  ::meshtastic::DeviceUIConfig* mutable_get_ui_config_response();
  void set_allocated_get_ui_config_response(::meshtastic::DeviceUIConfig* get_ui_config_response);
  private:
  const ::meshtastic::DeviceUIConfig& _internal_get_ui_config_response() const;
  ::meshtastic::DeviceUIConfig* _internal_mutable_get_ui_config_response();
  public:
  void unsafe_arena_set_allocated_get_ui_config_response(
      ::meshtastic::DeviceUIConfig* get_ui_config_response);
  ::meshtastic::DeviceUIConfig* unsafe_arena_release_get_ui_config_response();

  // .meshtastic.DeviceUIConfig store_ui_config = 46;
  bool has_store_ui_config() const;
  private:
  bool _internal_has_store_ui_config() const;
  public:
  void clear_store_ui_config();
  const ::meshtastic::DeviceUIConfig& store_ui_config() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceUIConfig* release_store_ui_config();
  ::meshtastic::DeviceUIConfig* mutable_store_ui_config();
  void set_allocated_store_ui_config(::meshtastic::DeviceUIConfig* store_ui_config);
  private:
  const ::meshtastic::DeviceUIConfig& _internal_store_ui_config() const;
  ::meshtastic::DeviceUIConfig* _internal_mutable_store_ui_config();
  public:
  void unsafe_arena_set_allocated_store_ui_config(
      ::meshtastic::DeviceUIConfig* store_ui_config);
  ::meshtastic::DeviceUIConfig* unsafe_arena_release_store_ui_config();

  // uint32 set_ignored_node = 47;
  bool has_set_ignored_node() const;
  private:
  bool _internal_has_set_ignored_node() const;
  public:
  void clear_set_ignored_node();
  uint32_t set_ignored_node() const;
  void set_set_ignored_node(uint32_t value);
  private:
  uint32_t _internal_set_ignored_node() const;
  void _internal_set_set_ignored_node(uint32_t value);
  public:

  // uint32 remove_ignored_node = 48;
  bool has_remove_ignored_node() const;
  private:
  bool _internal_has_remove_ignored_node() const;
  public:
  void clear_remove_ignored_node();
  uint32_t remove_ignored_node() const;
  void set_remove_ignored_node(uint32_t value);
  private:
  uint32_t _internal_remove_ignored_node() const;
  void _internal_set_remove_ignored_node(uint32_t value);
  public:

  // bool begin_edit_settings = 64;
  bool has_begin_edit_settings() const;
  private:
  bool _internal_has_begin_edit_settings() const;
  public:
  void clear_begin_edit_settings();
  bool begin_edit_settings() const;
  void set_begin_edit_settings(bool value);
  private:
  bool _internal_begin_edit_settings() const;
  void _internal_set_begin_edit_settings(bool value);
  public:

  // bool commit_edit_settings = 65;
  bool has_commit_edit_settings() const;
  private:
  bool _internal_has_commit_edit_settings() const;
  public:
  void clear_commit_edit_settings();
  bool commit_edit_settings() const;
  void set_commit_edit_settings(bool value);
  private:
  bool _internal_commit_edit_settings() const;
  void _internal_set_commit_edit_settings(bool value);
  public:

  // .meshtastic.SharedContact add_contact = 66;
  bool has_add_contact() const;
  private:
  bool _internal_has_add_contact() const;
  public:
  void clear_add_contact();
  const ::meshtastic::SharedContact& add_contact() const;
  PROTOBUF_NODISCARD ::meshtastic::SharedContact* release_add_contact();
  ::meshtastic::SharedContact* mutable_add_contact();
  void set_allocated_add_contact(::meshtastic::SharedContact* add_contact);
  private:
  const ::meshtastic::SharedContact& _internal_add_contact() const;
  ::meshtastic::SharedContact* _internal_mutable_add_contact();
  public:
  void unsafe_arena_set_allocated_add_contact(
      ::meshtastic::SharedContact* add_contact);
  ::meshtastic::SharedContact* unsafe_arena_release_add_contact();

  // .meshtastic.KeyVerificationAdmin key_verification = 67;
  bool has_key_verification() const;
  private:
  bool _internal_has_key_verification() const;
  public:
  void clear_key_verification();
  const ::meshtastic::KeyVerificationAdmin& key_verification() const;
  PROTOBUF_NODISCARD ::meshtastic::KeyVerificationAdmin* release_key_verification();
  ::meshtastic::KeyVerificationAdmin* mutable_key_verification();
  void set_allocated_key_verification(::meshtastic::KeyVerificationAdmin* key_verification);
  private:
  const ::meshtastic::KeyVerificationAdmin& _internal_key_verification() const;
  ::meshtastic::KeyVerificationAdmin* _internal_mutable_key_verification();
  public:
  void unsafe_arena_set_allocated_key_verification(
      ::meshtastic::KeyVerificationAdmin* key_verification);
  ::meshtastic::KeyVerificationAdmin* unsafe_arena_release_key_verification();

  // int32 factory_reset_device = 94;
  bool has_factory_reset_device() const;
  private:
  bool _internal_has_factory_reset_device() const;
  public:
  void clear_factory_reset_device();
  int32_t factory_reset_device() const;
  void set_factory_reset_device(int32_t value);
  private:
  int32_t _internal_factory_reset_device() const;
  void _internal_set_factory_reset_device(int32_t value);
  public:

  // int32 reboot_ota_seconds = 95;
  bool has_reboot_ota_seconds() const;
  private:
  bool _internal_has_reboot_ota_seconds() const;
  public:
  void clear_reboot_ota_seconds();
  int32_t reboot_ota_seconds() const;
  void set_reboot_ota_seconds(int32_t value);
  private:
  int32_t _internal_reboot_ota_seconds() const;
  void _internal_set_reboot_ota_seconds(int32_t value);
  public:

  // bool exit_simulator = 96;
  bool has_exit_simulator() const;
  private:
  bool _internal_has_exit_simulator() const;
  public:
  void clear_exit_simulator();
  bool exit_simulator() const;
  void set_exit_simulator(bool value);
  private:
  bool _internal_exit_simulator() const;
  void _internal_set_exit_simulator(bool value);
  public:

  // int32 reboot_seconds = 97;
  bool has_reboot_seconds() const;
  private:
  bool _internal_has_reboot_seconds() const;
  public:
  void clear_reboot_seconds();
  int32_t reboot_seconds() const;
  void set_reboot_seconds(int32_t value);
  private:
  int32_t _internal_reboot_seconds() const;
  void _internal_set_reboot_seconds(int32_t value);
  public:

  // int32 shutdown_seconds = 98;
  bool has_shutdown_seconds() const;
  private:
  bool _internal_has_shutdown_seconds() const;
  public:
  void clear_shutdown_seconds();
  int32_t shutdown_seconds() const;
  void set_shutdown_seconds(int32_t value);
  private:
  int32_t _internal_shutdown_seconds() const;
  void _internal_set_shutdown_seconds(int32_t value);
  public:

  // int32 factory_reset_config = 99;
  bool has_factory_reset_config() const;
  private:
  bool _internal_has_factory_reset_config() const;
  public:
  void clear_factory_reset_config();
  int32_t factory_reset_config() const;
  void set_factory_reset_config(int32_t value);
  private:
  int32_t _internal_factory_reset_config() const;
  void _internal_set_factory_reset_config(int32_t value);
  public:

  // int32 nodedb_reset = 100;
  bool has_nodedb_reset() const;
  private:
  bool _internal_has_nodedb_reset() const;
  public:
  void clear_nodedb_reset();
  int32_t nodedb_reset() const;
  void set_nodedb_reset(int32_t value);
  private:
  int32_t _internal_nodedb_reset() const;
  void _internal_set_nodedb_reset(int32_t value);
  public:

  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.AdminMessage)
 private:
  class _Internal;
  void set_has_get_channel_request();
  void set_has_get_channel_response();
  void set_has_get_owner_request();
  void set_has_get_owner_response();
  void set_has_get_config_request();
  void set_has_get_config_response();
  void set_has_get_module_config_request();
  void set_has_get_module_config_response();
  void set_has_get_canned_message_module_messages_request();
  void set_has_get_canned_message_module_messages_response();
  void set_has_get_device_metadata_request();
  void set_has_get_device_metadata_response();
  void set_has_get_ringtone_request();
  void set_has_get_ringtone_response();
  void set_has_get_device_connection_status_request();
  void set_has_get_device_connection_status_response();
  void set_has_set_ham_mode();
  void set_has_get_node_remote_hardware_pins_request();
  void set_has_get_node_remote_hardware_pins_response();
  void set_has_enter_dfu_mode_request();
  void set_has_delete_file_request();
  void set_has_set_scale();
  void set_has_backup_preferences();
  void set_has_restore_preferences();
  void set_has_remove_backup_preferences();
  void set_has_send_input_event();
  void set_has_set_owner();
  void set_has_set_channel();
  void set_has_set_config();
  void set_has_set_module_config();
  void set_has_set_canned_message_module_messages();
  void set_has_set_ringtone_message();
  void set_has_remove_by_nodenum();
  void set_has_set_favorite_node();
  void set_has_remove_favorite_node();
  void set_has_set_fixed_position();
  void set_has_remove_fixed_position();
  void set_has_set_time_only();
  void set_has_get_ui_config_request();
  void set_has_get_ui_config_response();
  void set_has_store_ui_config();
  void set_has_set_ignored_node();
  void set_has_remove_ignored_node();
  void set_has_begin_edit_settings();
  void set_has_commit_edit_settings();
  void set_has_add_contact();
  void set_has_key_verification();
  void set_has_factory_reset_device();
  void set_has_reboot_ota_seconds();
  void set_has_exit_simulator();
  void set_has_reboot_seconds();
  void set_has_shutdown_seconds();
  void set_has_factory_reset_config();
  void set_has_nodedb_reset();

  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_passkey_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t get_channel_request_;
      ::meshtastic::Channel* get_channel_response_;
      bool get_owner_request_;
      ::meshtastic::User* get_owner_response_;
      int get_config_request_;
      ::meshtastic::Config* get_config_response_;
      int get_module_config_request_;
      ::meshtastic::ModuleConfig* get_module_config_response_;
      bool get_canned_message_module_messages_request_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr get_canned_message_module_messages_response_;
      bool get_device_metadata_request_;
      ::meshtastic::DeviceMetadata* get_device_metadata_response_;
      bool get_ringtone_request_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr get_ringtone_response_;
      bool get_device_connection_status_request_;
      ::meshtastic::DeviceConnectionStatus* get_device_connection_status_response_;
      ::meshtastic::HamParameters* set_ham_mode_;
      bool get_node_remote_hardware_pins_request_;
      ::meshtastic::NodeRemoteHardwarePinsResponse* get_node_remote_hardware_pins_response_;
      bool enter_dfu_mode_request_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delete_file_request_;
      uint32_t set_scale_;
      int backup_preferences_;
      int restore_preferences_;
      int remove_backup_preferences_;
      ::meshtastic::AdminMessage_InputEvent* send_input_event_;
      ::meshtastic::User* set_owner_;
      ::meshtastic::Channel* set_channel_;
      ::meshtastic::Config* set_config_;
      ::meshtastic::ModuleConfig* set_module_config_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr set_canned_message_module_messages_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr set_ringtone_message_;
      uint32_t remove_by_nodenum_;
      uint32_t set_favorite_node_;
      uint32_t remove_favorite_node_;
      ::meshtastic::Position* set_fixed_position_;
      bool remove_fixed_position_;
      uint32_t set_time_only_;
      bool get_ui_config_request_;
      ::meshtastic::DeviceUIConfig* get_ui_config_response_;
      ::meshtastic::DeviceUIConfig* store_ui_config_;
      uint32_t set_ignored_node_;
      uint32_t remove_ignored_node_;
      bool begin_edit_settings_;
      bool commit_edit_settings_;
      ::meshtastic::SharedContact* add_contact_;
      ::meshtastic::KeyVerificationAdmin* key_verification_;
      int32_t factory_reset_device_;
      int32_t reboot_ota_seconds_;
      bool exit_simulator_;
      int32_t reboot_seconds_;
      int32_t shutdown_seconds_;
      int32_t factory_reset_config_;
      int32_t nodedb_reset_;
    } payload_variant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};
// -------------------------------------------------------------------

class HamParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.HamParameters) */ {
 public:
  inline HamParameters() : HamParameters(nullptr) {}
  ~HamParameters() override;
  explicit PROTOBUF_CONSTEXPR HamParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HamParameters(const HamParameters& from);
  HamParameters(HamParameters&& from) noexcept
    : HamParameters() {
    *this = ::std::move(from);
  }

  inline HamParameters& operator=(const HamParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline HamParameters& operator=(HamParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HamParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const HamParameters* internal_default_instance() {
    return reinterpret_cast<const HamParameters*>(
               &_HamParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HamParameters& a, HamParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(HamParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HamParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HamParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HamParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HamParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HamParameters& from) {
    HamParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HamParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.HamParameters";
  }
  protected:
  explicit HamParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallSignFieldNumber = 1,
    kShortNameFieldNumber = 4,
    kTxPowerFieldNumber = 2,
    kFrequencyFieldNumber = 3,
  };
  // string call_sign = 1;
  void clear_call_sign();
  const std::string& call_sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_sign();
  PROTOBUF_NODISCARD std::string* release_call_sign();
  void set_allocated_call_sign(std::string* call_sign);
  private:
  const std::string& _internal_call_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_sign(const std::string& value);
  std::string* _internal_mutable_call_sign();
  public:

  // string short_name = 4;
  void clear_short_name();
  const std::string& short_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_short_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_short_name();
  PROTOBUF_NODISCARD std::string* release_short_name();
  void set_allocated_short_name(std::string* short_name);
  private:
  const std::string& _internal_short_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_short_name(const std::string& value);
  std::string* _internal_mutable_short_name();
  public:

  // int32 tx_power = 2;
  void clear_tx_power();
  int32_t tx_power() const;
  void set_tx_power(int32_t value);
  private:
  int32_t _internal_tx_power() const;
  void _internal_set_tx_power(int32_t value);
  public:

  // float frequency = 3;
  void clear_frequency();
  float frequency() const;
  void set_frequency(float value);
  private:
  float _internal_frequency() const;
  void _internal_set_frequency(float value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.HamParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_sign_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr short_name_;
    int32_t tx_power_;
    float frequency_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};
// -------------------------------------------------------------------

class NodeRemoteHardwarePinsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.NodeRemoteHardwarePinsResponse) */ {
 public:
  inline NodeRemoteHardwarePinsResponse() : NodeRemoteHardwarePinsResponse(nullptr) {}
  ~NodeRemoteHardwarePinsResponse() override;
  explicit PROTOBUF_CONSTEXPR NodeRemoteHardwarePinsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeRemoteHardwarePinsResponse(const NodeRemoteHardwarePinsResponse& from);
  NodeRemoteHardwarePinsResponse(NodeRemoteHardwarePinsResponse&& from) noexcept
    : NodeRemoteHardwarePinsResponse() {
    *this = ::std::move(from);
  }

  inline NodeRemoteHardwarePinsResponse& operator=(const NodeRemoteHardwarePinsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRemoteHardwarePinsResponse& operator=(NodeRemoteHardwarePinsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRemoteHardwarePinsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRemoteHardwarePinsResponse* internal_default_instance() {
    return reinterpret_cast<const NodeRemoteHardwarePinsResponse*>(
               &_NodeRemoteHardwarePinsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NodeRemoteHardwarePinsResponse& a, NodeRemoteHardwarePinsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeRemoteHardwarePinsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRemoteHardwarePinsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRemoteHardwarePinsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeRemoteHardwarePinsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeRemoteHardwarePinsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeRemoteHardwarePinsResponse& from) {
    NodeRemoteHardwarePinsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeRemoteHardwarePinsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.NodeRemoteHardwarePinsResponse";
  }
  protected:
  explicit NodeRemoteHardwarePinsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeRemoteHardwarePinsFieldNumber = 1,
  };
  // repeated .meshtastic.NodeRemoteHardwarePin node_remote_hardware_pins = 1;
  int node_remote_hardware_pins_size() const;
  private:
  int _internal_node_remote_hardware_pins_size() const;
  public:
  void clear_node_remote_hardware_pins();
  ::meshtastic::NodeRemoteHardwarePin* mutable_node_remote_hardware_pins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin >*
      mutable_node_remote_hardware_pins();
  private:
  const ::meshtastic::NodeRemoteHardwarePin& _internal_node_remote_hardware_pins(int index) const;
  ::meshtastic::NodeRemoteHardwarePin* _internal_add_node_remote_hardware_pins();
  public:
  const ::meshtastic::NodeRemoteHardwarePin& node_remote_hardware_pins(int index) const;
  ::meshtastic::NodeRemoteHardwarePin* add_node_remote_hardware_pins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin >&
      node_remote_hardware_pins() const;

  // @@protoc_insertion_point(class_scope:meshtastic.NodeRemoteHardwarePinsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin > node_remote_hardware_pins_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};
// -------------------------------------------------------------------

class SharedContact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.SharedContact) */ {
 public:
  inline SharedContact() : SharedContact(nullptr) {}
  ~SharedContact() override;
  explicit PROTOBUF_CONSTEXPR SharedContact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SharedContact(const SharedContact& from);
  SharedContact(SharedContact&& from) noexcept
    : SharedContact() {
    *this = ::std::move(from);
  }

  inline SharedContact& operator=(const SharedContact& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharedContact& operator=(SharedContact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SharedContact& default_instance() {
    return *internal_default_instance();
  }
  static inline const SharedContact* internal_default_instance() {
    return reinterpret_cast<const SharedContact*>(
               &_SharedContact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SharedContact& a, SharedContact& b) {
    a.Swap(&b);
  }
  inline void Swap(SharedContact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharedContact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SharedContact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SharedContact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SharedContact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SharedContact& from) {
    SharedContact::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SharedContact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.SharedContact";
  }
  protected:
  explicit SharedContact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 2,
    kNodeNumFieldNumber = 1,
    kShouldIgnoreFieldNumber = 3,
  };
  // .meshtastic.User user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::meshtastic::User& user() const;
  PROTOBUF_NODISCARD ::meshtastic::User* release_user();
  ::meshtastic::User* mutable_user();
  void set_allocated_user(::meshtastic::User* user);
  private:
  const ::meshtastic::User& _internal_user() const;
  ::meshtastic::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::meshtastic::User* user);
  ::meshtastic::User* unsafe_arena_release_user();

  // uint32 node_num = 1;
  void clear_node_num();
  uint32_t node_num() const;
  void set_node_num(uint32_t value);
  private:
  uint32_t _internal_node_num() const;
  void _internal_set_node_num(uint32_t value);
  public:

  // bool should_ignore = 3;
  void clear_should_ignore();
  bool should_ignore() const;
  void set_should_ignore(bool value);
  private:
  bool _internal_should_ignore() const;
  void _internal_set_should_ignore(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.SharedContact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::meshtastic::User* user_;
    uint32_t node_num_;
    bool should_ignore_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};
// -------------------------------------------------------------------

class KeyVerificationAdmin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.KeyVerificationAdmin) */ {
 public:
  inline KeyVerificationAdmin() : KeyVerificationAdmin(nullptr) {}
  ~KeyVerificationAdmin() override;
  explicit PROTOBUF_CONSTEXPR KeyVerificationAdmin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyVerificationAdmin(const KeyVerificationAdmin& from);
  KeyVerificationAdmin(KeyVerificationAdmin&& from) noexcept
    : KeyVerificationAdmin() {
    *this = ::std::move(from);
  }

  inline KeyVerificationAdmin& operator=(const KeyVerificationAdmin& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyVerificationAdmin& operator=(KeyVerificationAdmin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyVerificationAdmin& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyVerificationAdmin* internal_default_instance() {
    return reinterpret_cast<const KeyVerificationAdmin*>(
               &_KeyVerificationAdmin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(KeyVerificationAdmin& a, KeyVerificationAdmin& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyVerificationAdmin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyVerificationAdmin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyVerificationAdmin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyVerificationAdmin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyVerificationAdmin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyVerificationAdmin& from) {
    KeyVerificationAdmin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyVerificationAdmin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.KeyVerificationAdmin";
  }
  protected:
  explicit KeyVerificationAdmin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef KeyVerificationAdmin_MessageType MessageType;
  static constexpr MessageType INITIATE_VERIFICATION =
    KeyVerificationAdmin_MessageType_INITIATE_VERIFICATION;
  static constexpr MessageType PROVIDE_SECURITY_NUMBER =
    KeyVerificationAdmin_MessageType_PROVIDE_SECURITY_NUMBER;
  static constexpr MessageType DO_VERIFY =
    KeyVerificationAdmin_MessageType_DO_VERIFY;
  static constexpr MessageType DO_NOT_VERIFY =
    KeyVerificationAdmin_MessageType_DO_NOT_VERIFY;
  static inline bool MessageType_IsValid(int value) {
    return KeyVerificationAdmin_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    KeyVerificationAdmin_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    KeyVerificationAdmin_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    KeyVerificationAdmin_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return KeyVerificationAdmin_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return KeyVerificationAdmin_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageType* value) {
    return KeyVerificationAdmin_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kRemoteNodenumFieldNumber = 2,
    kNonceFieldNumber = 3,
    kSecurityNumberFieldNumber = 4,
  };
  // .meshtastic.KeyVerificationAdmin.MessageType message_type = 1;
  void clear_message_type();
  ::meshtastic::KeyVerificationAdmin_MessageType message_type() const;
  void set_message_type(::meshtastic::KeyVerificationAdmin_MessageType value);
  private:
  ::meshtastic::KeyVerificationAdmin_MessageType _internal_message_type() const;
  void _internal_set_message_type(::meshtastic::KeyVerificationAdmin_MessageType value);
  public:

  // uint32 remote_nodenum = 2;
  void clear_remote_nodenum();
  uint32_t remote_nodenum() const;
  void set_remote_nodenum(uint32_t value);
  private:
  uint32_t _internal_remote_nodenum() const;
  void _internal_set_remote_nodenum(uint32_t value);
  public:

  // uint64 nonce = 3;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // optional uint32 security_number = 4;
  bool has_security_number() const;
  private:
  bool _internal_has_security_number() const;
  public:
  void clear_security_number();
  uint32_t security_number() const;
  void set_security_number(uint32_t value);
  private:
  uint32_t _internal_security_number() const;
  void _internal_set_security_number(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.KeyVerificationAdmin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int message_type_;
    uint32_t remote_nodenum_;
    uint64_t nonce_;
    uint32_t security_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fadmin_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AdminMessage_InputEvent

// uint32 event_code = 1;
inline void AdminMessage_InputEvent::clear_event_code() {
  _impl_.event_code_ = 0u;
}
inline uint32_t AdminMessage_InputEvent::_internal_event_code() const {
  return _impl_.event_code_;
}
inline uint32_t AdminMessage_InputEvent::event_code() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.InputEvent.event_code)
  return _internal_event_code();
}
inline void AdminMessage_InputEvent::_internal_set_event_code(uint32_t value) {
  
  _impl_.event_code_ = value;
}
inline void AdminMessage_InputEvent::set_event_code(uint32_t value) {
  _internal_set_event_code(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.InputEvent.event_code)
}

// uint32 kb_char = 2;
inline void AdminMessage_InputEvent::clear_kb_char() {
  _impl_.kb_char_ = 0u;
}
inline uint32_t AdminMessage_InputEvent::_internal_kb_char() const {
  return _impl_.kb_char_;
}
inline uint32_t AdminMessage_InputEvent::kb_char() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.InputEvent.kb_char)
  return _internal_kb_char();
}
inline void AdminMessage_InputEvent::_internal_set_kb_char(uint32_t value) {
  
  _impl_.kb_char_ = value;
}
inline void AdminMessage_InputEvent::set_kb_char(uint32_t value) {
  _internal_set_kb_char(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.InputEvent.kb_char)
}

// uint32 touch_x = 3;
inline void AdminMessage_InputEvent::clear_touch_x() {
  _impl_.touch_x_ = 0u;
}
inline uint32_t AdminMessage_InputEvent::_internal_touch_x() const {
  return _impl_.touch_x_;
}
inline uint32_t AdminMessage_InputEvent::touch_x() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.InputEvent.touch_x)
  return _internal_touch_x();
}
inline void AdminMessage_InputEvent::_internal_set_touch_x(uint32_t value) {
  
  _impl_.touch_x_ = value;
}
inline void AdminMessage_InputEvent::set_touch_x(uint32_t value) {
  _internal_set_touch_x(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.InputEvent.touch_x)
}

// uint32 touch_y = 4;
inline void AdminMessage_InputEvent::clear_touch_y() {
  _impl_.touch_y_ = 0u;
}
inline uint32_t AdminMessage_InputEvent::_internal_touch_y() const {
  return _impl_.touch_y_;
}
inline uint32_t AdminMessage_InputEvent::touch_y() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.InputEvent.touch_y)
  return _internal_touch_y();
}
inline void AdminMessage_InputEvent::_internal_set_touch_y(uint32_t value) {
  
  _impl_.touch_y_ = value;
}
inline void AdminMessage_InputEvent::set_touch_y(uint32_t value) {
  _internal_set_touch_y(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.InputEvent.touch_y)
}

// -------------------------------------------------------------------

// AdminMessage

// bytes session_passkey = 101;
inline void AdminMessage::clear_session_passkey() {
  _impl_.session_passkey_.ClearToEmpty();
}
inline const std::string& AdminMessage::session_passkey() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.session_passkey)
  return _internal_session_passkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdminMessage::set_session_passkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_passkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.session_passkey)
}
inline std::string* AdminMessage::mutable_session_passkey() {
  std::string* _s = _internal_mutable_session_passkey();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.session_passkey)
  return _s;
}
inline const std::string& AdminMessage::_internal_session_passkey() const {
  return _impl_.session_passkey_.Get();
}
inline void AdminMessage::_internal_set_session_passkey(const std::string& value) {
  
  _impl_.session_passkey_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminMessage::_internal_mutable_session_passkey() {
  
  return _impl_.session_passkey_.Mutable(GetArenaForAllocation());
}
inline std::string* AdminMessage::release_session_passkey() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.session_passkey)
  return _impl_.session_passkey_.Release();
}
inline void AdminMessage::set_allocated_session_passkey(std::string* session_passkey) {
  if (session_passkey != nullptr) {
    
  } else {
    
  }
  _impl_.session_passkey_.SetAllocated(session_passkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_passkey_.IsDefault()) {
    _impl_.session_passkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.session_passkey)
}

// uint32 get_channel_request = 1;
inline bool AdminMessage::_internal_has_get_channel_request() const {
  return payload_variant_case() == kGetChannelRequest;
}
inline bool AdminMessage::has_get_channel_request() const {
  return _internal_has_get_channel_request();
}
inline void AdminMessage::set_has_get_channel_request() {
  _impl_._oneof_case_[0] = kGetChannelRequest;
}
inline void AdminMessage::clear_get_channel_request() {
  if (_internal_has_get_channel_request()) {
    _impl_.payload_variant_.get_channel_request_ = 0u;
    clear_has_payload_variant();
  }
}
inline uint32_t AdminMessage::_internal_get_channel_request() const {
  if (_internal_has_get_channel_request()) {
    return _impl_.payload_variant_.get_channel_request_;
  }
  return 0u;
}
inline void AdminMessage::_internal_set_get_channel_request(uint32_t value) {
  if (!_internal_has_get_channel_request()) {
    clear_payload_variant();
    set_has_get_channel_request();
  }
  _impl_.payload_variant_.get_channel_request_ = value;
}
inline uint32_t AdminMessage::get_channel_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_channel_request)
  return _internal_get_channel_request();
}
inline void AdminMessage::set_get_channel_request(uint32_t value) {
  _internal_set_get_channel_request(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_channel_request)
}

// .meshtastic.Channel get_channel_response = 2;
inline bool AdminMessage::_internal_has_get_channel_response() const {
  return payload_variant_case() == kGetChannelResponse;
}
inline bool AdminMessage::has_get_channel_response() const {
  return _internal_has_get_channel_response();
}
inline void AdminMessage::set_has_get_channel_response() {
  _impl_._oneof_case_[0] = kGetChannelResponse;
}
inline ::meshtastic::Channel* AdminMessage::release_get_channel_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_channel_response)
  if (_internal_has_get_channel_response()) {
    clear_has_payload_variant();
    ::meshtastic::Channel* temp = _impl_.payload_variant_.get_channel_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_channel_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Channel& AdminMessage::_internal_get_channel_response() const {
  return _internal_has_get_channel_response()
      ? *_impl_.payload_variant_.get_channel_response_
      : reinterpret_cast< ::meshtastic::Channel&>(::meshtastic::_Channel_default_instance_);
}
inline const ::meshtastic::Channel& AdminMessage::get_channel_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_channel_response)
  return _internal_get_channel_response();
}
inline ::meshtastic::Channel* AdminMessage::unsafe_arena_release_get_channel_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_channel_response)
  if (_internal_has_get_channel_response()) {
    clear_has_payload_variant();
    ::meshtastic::Channel* temp = _impl_.payload_variant_.get_channel_response_;
    _impl_.payload_variant_.get_channel_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_channel_response(::meshtastic::Channel* get_channel_response) {
  clear_payload_variant();
  if (get_channel_response) {
    set_has_get_channel_response();
    _impl_.payload_variant_.get_channel_response_ = get_channel_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_channel_response)
}
inline ::meshtastic::Channel* AdminMessage::_internal_mutable_get_channel_response() {
  if (!_internal_has_get_channel_response()) {
    clear_payload_variant();
    set_has_get_channel_response();
    _impl_.payload_variant_.get_channel_response_ = CreateMaybeMessage< ::meshtastic::Channel >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.get_channel_response_;
}
inline ::meshtastic::Channel* AdminMessage::mutable_get_channel_response() {
  ::meshtastic::Channel* _msg = _internal_mutable_get_channel_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_channel_response)
  return _msg;
}

// bool get_owner_request = 3;
inline bool AdminMessage::_internal_has_get_owner_request() const {
  return payload_variant_case() == kGetOwnerRequest;
}
inline bool AdminMessage::has_get_owner_request() const {
  return _internal_has_get_owner_request();
}
inline void AdminMessage::set_has_get_owner_request() {
  _impl_._oneof_case_[0] = kGetOwnerRequest;
}
inline void AdminMessage::clear_get_owner_request() {
  if (_internal_has_get_owner_request()) {
    _impl_.payload_variant_.get_owner_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_get_owner_request() const {
  if (_internal_has_get_owner_request()) {
    return _impl_.payload_variant_.get_owner_request_;
  }
  return false;
}
inline void AdminMessage::_internal_set_get_owner_request(bool value) {
  if (!_internal_has_get_owner_request()) {
    clear_payload_variant();
    set_has_get_owner_request();
  }
  _impl_.payload_variant_.get_owner_request_ = value;
}
inline bool AdminMessage::get_owner_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_owner_request)
  return _internal_get_owner_request();
}
inline void AdminMessage::set_get_owner_request(bool value) {
  _internal_set_get_owner_request(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_owner_request)
}

// .meshtastic.User get_owner_response = 4;
inline bool AdminMessage::_internal_has_get_owner_response() const {
  return payload_variant_case() == kGetOwnerResponse;
}
inline bool AdminMessage::has_get_owner_response() const {
  return _internal_has_get_owner_response();
}
inline void AdminMessage::set_has_get_owner_response() {
  _impl_._oneof_case_[0] = kGetOwnerResponse;
}
inline ::meshtastic::User* AdminMessage::release_get_owner_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_owner_response)
  if (_internal_has_get_owner_response()) {
    clear_has_payload_variant();
    ::meshtastic::User* temp = _impl_.payload_variant_.get_owner_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_owner_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::User& AdminMessage::_internal_get_owner_response() const {
  return _internal_has_get_owner_response()
      ? *_impl_.payload_variant_.get_owner_response_
      : reinterpret_cast< ::meshtastic::User&>(::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& AdminMessage::get_owner_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_owner_response)
  return _internal_get_owner_response();
}
inline ::meshtastic::User* AdminMessage::unsafe_arena_release_get_owner_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_owner_response)
  if (_internal_has_get_owner_response()) {
    clear_has_payload_variant();
    ::meshtastic::User* temp = _impl_.payload_variant_.get_owner_response_;
    _impl_.payload_variant_.get_owner_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_owner_response(::meshtastic::User* get_owner_response) {
  clear_payload_variant();
  if (get_owner_response) {
    set_has_get_owner_response();
    _impl_.payload_variant_.get_owner_response_ = get_owner_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_owner_response)
}
inline ::meshtastic::User* AdminMessage::_internal_mutable_get_owner_response() {
  if (!_internal_has_get_owner_response()) {
    clear_payload_variant();
    set_has_get_owner_response();
    _impl_.payload_variant_.get_owner_response_ = CreateMaybeMessage< ::meshtastic::User >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.get_owner_response_;
}
inline ::meshtastic::User* AdminMessage::mutable_get_owner_response() {
  ::meshtastic::User* _msg = _internal_mutable_get_owner_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_owner_response)
  return _msg;
}

// .meshtastic.AdminMessage.ConfigType get_config_request = 5;
inline bool AdminMessage::_internal_has_get_config_request() const {
  return payload_variant_case() == kGetConfigRequest;
}
inline bool AdminMessage::has_get_config_request() const {
  return _internal_has_get_config_request();
}
inline void AdminMessage::set_has_get_config_request() {
  _impl_._oneof_case_[0] = kGetConfigRequest;
}
inline void AdminMessage::clear_get_config_request() {
  if (_internal_has_get_config_request()) {
    _impl_.payload_variant_.get_config_request_ = 0;
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_ConfigType AdminMessage::_internal_get_config_request() const {
  if (_internal_has_get_config_request()) {
    return static_cast< ::meshtastic::AdminMessage_ConfigType >(_impl_.payload_variant_.get_config_request_);
  }
  return static_cast< ::meshtastic::AdminMessage_ConfigType >(0);
}
inline ::meshtastic::AdminMessage_ConfigType AdminMessage::get_config_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_config_request)
  return _internal_get_config_request();
}
inline void AdminMessage::_internal_set_get_config_request(::meshtastic::AdminMessage_ConfigType value) {
  if (!_internal_has_get_config_request()) {
    clear_payload_variant();
    set_has_get_config_request();
  }
  _impl_.payload_variant_.get_config_request_ = value;
}
inline void AdminMessage::set_get_config_request(::meshtastic::AdminMessage_ConfigType value) {
  _internal_set_get_config_request(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_config_request)
}

// .meshtastic.Config get_config_response = 6;
inline bool AdminMessage::_internal_has_get_config_response() const {
  return payload_variant_case() == kGetConfigResponse;
}
inline bool AdminMessage::has_get_config_response() const {
  return _internal_has_get_config_response();
}
inline void AdminMessage::set_has_get_config_response() {
  _impl_._oneof_case_[0] = kGetConfigResponse;
}
inline ::meshtastic::Config* AdminMessage::release_get_config_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_config_response)
  if (_internal_has_get_config_response()) {
    clear_has_payload_variant();
    ::meshtastic::Config* temp = _impl_.payload_variant_.get_config_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config& AdminMessage::_internal_get_config_response() const {
  return _internal_has_get_config_response()
      ? *_impl_.payload_variant_.get_config_response_
      : reinterpret_cast< ::meshtastic::Config&>(::meshtastic::_Config_default_instance_);
}
inline const ::meshtastic::Config& AdminMessage::get_config_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_config_response)
  return _internal_get_config_response();
}
inline ::meshtastic::Config* AdminMessage::unsafe_arena_release_get_config_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_config_response)
  if (_internal_has_get_config_response()) {
    clear_has_payload_variant();
    ::meshtastic::Config* temp = _impl_.payload_variant_.get_config_response_;
    _impl_.payload_variant_.get_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_config_response(::meshtastic::Config* get_config_response) {
  clear_payload_variant();
  if (get_config_response) {
    set_has_get_config_response();
    _impl_.payload_variant_.get_config_response_ = get_config_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_config_response)
}
inline ::meshtastic::Config* AdminMessage::_internal_mutable_get_config_response() {
  if (!_internal_has_get_config_response()) {
    clear_payload_variant();
    set_has_get_config_response();
    _impl_.payload_variant_.get_config_response_ = CreateMaybeMessage< ::meshtastic::Config >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.get_config_response_;
}
inline ::meshtastic::Config* AdminMessage::mutable_get_config_response() {
  ::meshtastic::Config* _msg = _internal_mutable_get_config_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_config_response)
  return _msg;
}

// .meshtastic.AdminMessage.ModuleConfigType get_module_config_request = 7;
inline bool AdminMessage::_internal_has_get_module_config_request() const {
  return payload_variant_case() == kGetModuleConfigRequest;
}
inline bool AdminMessage::has_get_module_config_request() const {
  return _internal_has_get_module_config_request();
}
inline void AdminMessage::set_has_get_module_config_request() {
  _impl_._oneof_case_[0] = kGetModuleConfigRequest;
}
inline void AdminMessage::clear_get_module_config_request() {
  if (_internal_has_get_module_config_request()) {
    _impl_.payload_variant_.get_module_config_request_ = 0;
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_ModuleConfigType AdminMessage::_internal_get_module_config_request() const {
  if (_internal_has_get_module_config_request()) {
    return static_cast< ::meshtastic::AdminMessage_ModuleConfigType >(_impl_.payload_variant_.get_module_config_request_);
  }
  return static_cast< ::meshtastic::AdminMessage_ModuleConfigType >(0);
}
inline ::meshtastic::AdminMessage_ModuleConfigType AdminMessage::get_module_config_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_module_config_request)
  return _internal_get_module_config_request();
}
inline void AdminMessage::_internal_set_get_module_config_request(::meshtastic::AdminMessage_ModuleConfigType value) {
  if (!_internal_has_get_module_config_request()) {
    clear_payload_variant();
    set_has_get_module_config_request();
  }
  _impl_.payload_variant_.get_module_config_request_ = value;
}
inline void AdminMessage::set_get_module_config_request(::meshtastic::AdminMessage_ModuleConfigType value) {
  _internal_set_get_module_config_request(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_module_config_request)
}

// .meshtastic.ModuleConfig get_module_config_response = 8;
inline bool AdminMessage::_internal_has_get_module_config_response() const {
  return payload_variant_case() == kGetModuleConfigResponse;
}
inline bool AdminMessage::has_get_module_config_response() const {
  return _internal_has_get_module_config_response();
}
inline void AdminMessage::set_has_get_module_config_response() {
  _impl_._oneof_case_[0] = kGetModuleConfigResponse;
}
inline ::meshtastic::ModuleConfig* AdminMessage::release_get_module_config_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_module_config_response)
  if (_internal_has_get_module_config_response()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig* temp = _impl_.payload_variant_.get_module_config_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_module_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig& AdminMessage::_internal_get_module_config_response() const {
  return _internal_has_get_module_config_response()
      ? *_impl_.payload_variant_.get_module_config_response_
      : reinterpret_cast< ::meshtastic::ModuleConfig&>(::meshtastic::_ModuleConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig& AdminMessage::get_module_config_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_module_config_response)
  return _internal_get_module_config_response();
}
inline ::meshtastic::ModuleConfig* AdminMessage::unsafe_arena_release_get_module_config_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_module_config_response)
  if (_internal_has_get_module_config_response()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig* temp = _impl_.payload_variant_.get_module_config_response_;
    _impl_.payload_variant_.get_module_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_module_config_response(::meshtastic::ModuleConfig* get_module_config_response) {
  clear_payload_variant();
  if (get_module_config_response) {
    set_has_get_module_config_response();
    _impl_.payload_variant_.get_module_config_response_ = get_module_config_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_module_config_response)
}
inline ::meshtastic::ModuleConfig* AdminMessage::_internal_mutable_get_module_config_response() {
  if (!_internal_has_get_module_config_response()) {
    clear_payload_variant();
    set_has_get_module_config_response();
    _impl_.payload_variant_.get_module_config_response_ = CreateMaybeMessage< ::meshtastic::ModuleConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.get_module_config_response_;
}
inline ::meshtastic::ModuleConfig* AdminMessage::mutable_get_module_config_response() {
  ::meshtastic::ModuleConfig* _msg = _internal_mutable_get_module_config_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_module_config_response)
  return _msg;
}

// bool get_canned_message_module_messages_request = 10;
inline bool AdminMessage::_internal_has_get_canned_message_module_messages_request() const {
  return payload_variant_case() == kGetCannedMessageModuleMessagesRequest;
}
inline bool AdminMessage::has_get_canned_message_module_messages_request() const {
  return _internal_has_get_canned_message_module_messages_request();
}
inline void AdminMessage::set_has_get_canned_message_module_messages_request() {
  _impl_._oneof_case_[0] = kGetCannedMessageModuleMessagesRequest;
}
inline void AdminMessage::clear_get_canned_message_module_messages_request() {
  if (_internal_has_get_canned_message_module_messages_request()) {
    _impl_.payload_variant_.get_canned_message_module_messages_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_get_canned_message_module_messages_request() const {
  if (_internal_has_get_canned_message_module_messages_request()) {
    return _impl_.payload_variant_.get_canned_message_module_messages_request_;
  }
  return false;
}
inline void AdminMessage::_internal_set_get_canned_message_module_messages_request(bool value) {
  if (!_internal_has_get_canned_message_module_messages_request()) {
    clear_payload_variant();
    set_has_get_canned_message_module_messages_request();
  }
  _impl_.payload_variant_.get_canned_message_module_messages_request_ = value;
}
inline bool AdminMessage::get_canned_message_module_messages_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_canned_message_module_messages_request)
  return _internal_get_canned_message_module_messages_request();
}
inline void AdminMessage::set_get_canned_message_module_messages_request(bool value) {
  _internal_set_get_canned_message_module_messages_request(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_canned_message_module_messages_request)
}

// string get_canned_message_module_messages_response = 11;
inline bool AdminMessage::_internal_has_get_canned_message_module_messages_response() const {
  return payload_variant_case() == kGetCannedMessageModuleMessagesResponse;
}
inline bool AdminMessage::has_get_canned_message_module_messages_response() const {
  return _internal_has_get_canned_message_module_messages_response();
}
inline void AdminMessage::set_has_get_canned_message_module_messages_response() {
  _impl_._oneof_case_[0] = kGetCannedMessageModuleMessagesResponse;
}
inline void AdminMessage::clear_get_canned_message_module_messages_response() {
  if (_internal_has_get_canned_message_module_messages_response()) {
    _impl_.payload_variant_.get_canned_message_module_messages_response_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& AdminMessage::get_canned_message_module_messages_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_canned_message_module_messages_response)
  return _internal_get_canned_message_module_messages_response();
}
template <typename ArgT0, typename... ArgT>
inline void AdminMessage::set_get_canned_message_module_messages_response(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_get_canned_message_module_messages_response()) {
    clear_payload_variant();
    set_has_get_canned_message_module_messages_response();
    _impl_.payload_variant_.get_canned_message_module_messages_response_.InitDefault();
  }
  _impl_.payload_variant_.get_canned_message_module_messages_response_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_canned_message_module_messages_response)
}
inline std::string* AdminMessage::mutable_get_canned_message_module_messages_response() {
  std::string* _s = _internal_mutable_get_canned_message_module_messages_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_canned_message_module_messages_response)
  return _s;
}
inline const std::string& AdminMessage::_internal_get_canned_message_module_messages_response() const {
  if (_internal_has_get_canned_message_module_messages_response()) {
    return _impl_.payload_variant_.get_canned_message_module_messages_response_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AdminMessage::_internal_set_get_canned_message_module_messages_response(const std::string& value) {
  if (!_internal_has_get_canned_message_module_messages_response()) {
    clear_payload_variant();
    set_has_get_canned_message_module_messages_response();
    _impl_.payload_variant_.get_canned_message_module_messages_response_.InitDefault();
  }
  _impl_.payload_variant_.get_canned_message_module_messages_response_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminMessage::_internal_mutable_get_canned_message_module_messages_response() {
  if (!_internal_has_get_canned_message_module_messages_response()) {
    clear_payload_variant();
    set_has_get_canned_message_module_messages_response();
    _impl_.payload_variant_.get_canned_message_module_messages_response_.InitDefault();
  }
  return _impl_.payload_variant_.get_canned_message_module_messages_response_.Mutable(      GetArenaForAllocation());
}
inline std::string* AdminMessage::release_get_canned_message_module_messages_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_canned_message_module_messages_response)
  if (_internal_has_get_canned_message_module_messages_response()) {
    clear_has_payload_variant();
    return _impl_.payload_variant_.get_canned_message_module_messages_response_.Release();
  } else {
    return nullptr;
  }
}
inline void AdminMessage::set_allocated_get_canned_message_module_messages_response(std::string* get_canned_message_module_messages_response) {
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (get_canned_message_module_messages_response != nullptr) {
    set_has_get_canned_message_module_messages_response();
    _impl_.payload_variant_.get_canned_message_module_messages_response_.InitAllocated(get_canned_message_module_messages_response, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.get_canned_message_module_messages_response)
}

// bool get_device_metadata_request = 12;
inline bool AdminMessage::_internal_has_get_device_metadata_request() const {
  return payload_variant_case() == kGetDeviceMetadataRequest;
}
inline bool AdminMessage::has_get_device_metadata_request() const {
  return _internal_has_get_device_metadata_request();
}
inline void AdminMessage::set_has_get_device_metadata_request() {
  _impl_._oneof_case_[0] = kGetDeviceMetadataRequest;
}
inline void AdminMessage::clear_get_device_metadata_request() {
  if (_internal_has_get_device_metadata_request()) {
    _impl_.payload_variant_.get_device_metadata_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_get_device_metadata_request() const {
  if (_internal_has_get_device_metadata_request()) {
    return _impl_.payload_variant_.get_device_metadata_request_;
  }
  return false;
}
inline void AdminMessage::_internal_set_get_device_metadata_request(bool value) {
  if (!_internal_has_get_device_metadata_request()) {
    clear_payload_variant();
    set_has_get_device_metadata_request();
  }
  _impl_.payload_variant_.get_device_metadata_request_ = value;
}
inline bool AdminMessage::get_device_metadata_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_device_metadata_request)
  return _internal_get_device_metadata_request();
}
inline void AdminMessage::set_get_device_metadata_request(bool value) {
  _internal_set_get_device_metadata_request(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_device_metadata_request)
}

// .meshtastic.DeviceMetadata get_device_metadata_response = 13;
inline bool AdminMessage::_internal_has_get_device_metadata_response() const {
  return payload_variant_case() == kGetDeviceMetadataResponse;
}
inline bool AdminMessage::has_get_device_metadata_response() const {
  return _internal_has_get_device_metadata_response();
}
inline void AdminMessage::set_has_get_device_metadata_response() {
  _impl_._oneof_case_[0] = kGetDeviceMetadataResponse;
}
inline ::meshtastic::DeviceMetadata* AdminMessage::release_get_device_metadata_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_device_metadata_response)
  if (_internal_has_get_device_metadata_response()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceMetadata* temp = _impl_.payload_variant_.get_device_metadata_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_device_metadata_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceMetadata& AdminMessage::_internal_get_device_metadata_response() const {
  return _internal_has_get_device_metadata_response()
      ? *_impl_.payload_variant_.get_device_metadata_response_
      : reinterpret_cast< ::meshtastic::DeviceMetadata&>(::meshtastic::_DeviceMetadata_default_instance_);
}
inline const ::meshtastic::DeviceMetadata& AdminMessage::get_device_metadata_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_device_metadata_response)
  return _internal_get_device_metadata_response();
}
inline ::meshtastic::DeviceMetadata* AdminMessage::unsafe_arena_release_get_device_metadata_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_device_metadata_response)
  if (_internal_has_get_device_metadata_response()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceMetadata* temp = _impl_.payload_variant_.get_device_metadata_response_;
    _impl_.payload_variant_.get_device_metadata_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_device_metadata_response(::meshtastic::DeviceMetadata* get_device_metadata_response) {
  clear_payload_variant();
  if (get_device_metadata_response) {
    set_has_get_device_metadata_response();
    _impl_.payload_variant_.get_device_metadata_response_ = get_device_metadata_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_device_metadata_response)
}
inline ::meshtastic::DeviceMetadata* AdminMessage::_internal_mutable_get_device_metadata_response() {
  if (!_internal_has_get_device_metadata_response()) {
    clear_payload_variant();
    set_has_get_device_metadata_response();
    _impl_.payload_variant_.get_device_metadata_response_ = CreateMaybeMessage< ::meshtastic::DeviceMetadata >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.get_device_metadata_response_;
}
inline ::meshtastic::DeviceMetadata* AdminMessage::mutable_get_device_metadata_response() {
  ::meshtastic::DeviceMetadata* _msg = _internal_mutable_get_device_metadata_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_device_metadata_response)
  return _msg;
}

// bool get_ringtone_request = 14;
inline bool AdminMessage::_internal_has_get_ringtone_request() const {
  return payload_variant_case() == kGetRingtoneRequest;
}
inline bool AdminMessage::has_get_ringtone_request() const {
  return _internal_has_get_ringtone_request();
}
inline void AdminMessage::set_has_get_ringtone_request() {
  _impl_._oneof_case_[0] = kGetRingtoneRequest;
}
inline void AdminMessage::clear_get_ringtone_request() {
  if (_internal_has_get_ringtone_request()) {
    _impl_.payload_variant_.get_ringtone_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_get_ringtone_request() const {
  if (_internal_has_get_ringtone_request()) {
    return _impl_.payload_variant_.get_ringtone_request_;
  }
  return false;
}
inline void AdminMessage::_internal_set_get_ringtone_request(bool value) {
  if (!_internal_has_get_ringtone_request()) {
    clear_payload_variant();
    set_has_get_ringtone_request();
  }
  _impl_.payload_variant_.get_ringtone_request_ = value;
}
inline bool AdminMessage::get_ringtone_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_ringtone_request)
  return _internal_get_ringtone_request();
}
inline void AdminMessage::set_get_ringtone_request(bool value) {
  _internal_set_get_ringtone_request(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_ringtone_request)
}

// string get_ringtone_response = 15;
inline bool AdminMessage::_internal_has_get_ringtone_response() const {
  return payload_variant_case() == kGetRingtoneResponse;
}
inline bool AdminMessage::has_get_ringtone_response() const {
  return _internal_has_get_ringtone_response();
}
inline void AdminMessage::set_has_get_ringtone_response() {
  _impl_._oneof_case_[0] = kGetRingtoneResponse;
}
inline void AdminMessage::clear_get_ringtone_response() {
  if (_internal_has_get_ringtone_response()) {
    _impl_.payload_variant_.get_ringtone_response_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& AdminMessage::get_ringtone_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_ringtone_response)
  return _internal_get_ringtone_response();
}
template <typename ArgT0, typename... ArgT>
inline void AdminMessage::set_get_ringtone_response(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_get_ringtone_response()) {
    clear_payload_variant();
    set_has_get_ringtone_response();
    _impl_.payload_variant_.get_ringtone_response_.InitDefault();
  }
  _impl_.payload_variant_.get_ringtone_response_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_ringtone_response)
}
inline std::string* AdminMessage::mutable_get_ringtone_response() {
  std::string* _s = _internal_mutable_get_ringtone_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_ringtone_response)
  return _s;
}
inline const std::string& AdminMessage::_internal_get_ringtone_response() const {
  if (_internal_has_get_ringtone_response()) {
    return _impl_.payload_variant_.get_ringtone_response_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AdminMessage::_internal_set_get_ringtone_response(const std::string& value) {
  if (!_internal_has_get_ringtone_response()) {
    clear_payload_variant();
    set_has_get_ringtone_response();
    _impl_.payload_variant_.get_ringtone_response_.InitDefault();
  }
  _impl_.payload_variant_.get_ringtone_response_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminMessage::_internal_mutable_get_ringtone_response() {
  if (!_internal_has_get_ringtone_response()) {
    clear_payload_variant();
    set_has_get_ringtone_response();
    _impl_.payload_variant_.get_ringtone_response_.InitDefault();
  }
  return _impl_.payload_variant_.get_ringtone_response_.Mutable(      GetArenaForAllocation());
}
inline std::string* AdminMessage::release_get_ringtone_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_ringtone_response)
  if (_internal_has_get_ringtone_response()) {
    clear_has_payload_variant();
    return _impl_.payload_variant_.get_ringtone_response_.Release();
  } else {
    return nullptr;
  }
}
inline void AdminMessage::set_allocated_get_ringtone_response(std::string* get_ringtone_response) {
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (get_ringtone_response != nullptr) {
    set_has_get_ringtone_response();
    _impl_.payload_variant_.get_ringtone_response_.InitAllocated(get_ringtone_response, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.get_ringtone_response)
}

// bool get_device_connection_status_request = 16;
inline bool AdminMessage::_internal_has_get_device_connection_status_request() const {
  return payload_variant_case() == kGetDeviceConnectionStatusRequest;
}
inline bool AdminMessage::has_get_device_connection_status_request() const {
  return _internal_has_get_device_connection_status_request();
}
inline void AdminMessage::set_has_get_device_connection_status_request() {
  _impl_._oneof_case_[0] = kGetDeviceConnectionStatusRequest;
}
inline void AdminMessage::clear_get_device_connection_status_request() {
  if (_internal_has_get_device_connection_status_request()) {
    _impl_.payload_variant_.get_device_connection_status_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_get_device_connection_status_request() const {
  if (_internal_has_get_device_connection_status_request()) {
    return _impl_.payload_variant_.get_device_connection_status_request_;
  }
  return false;
}
inline void AdminMessage::_internal_set_get_device_connection_status_request(bool value) {
  if (!_internal_has_get_device_connection_status_request()) {
    clear_payload_variant();
    set_has_get_device_connection_status_request();
  }
  _impl_.payload_variant_.get_device_connection_status_request_ = value;
}
inline bool AdminMessage::get_device_connection_status_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_device_connection_status_request)
  return _internal_get_device_connection_status_request();
}
inline void AdminMessage::set_get_device_connection_status_request(bool value) {
  _internal_set_get_device_connection_status_request(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_device_connection_status_request)
}

// .meshtastic.DeviceConnectionStatus get_device_connection_status_response = 17;
inline bool AdminMessage::_internal_has_get_device_connection_status_response() const {
  return payload_variant_case() == kGetDeviceConnectionStatusResponse;
}
inline bool AdminMessage::has_get_device_connection_status_response() const {
  return _internal_has_get_device_connection_status_response();
}
inline void AdminMessage::set_has_get_device_connection_status_response() {
  _impl_._oneof_case_[0] = kGetDeviceConnectionStatusResponse;
}
inline ::meshtastic::DeviceConnectionStatus* AdminMessage::release_get_device_connection_status_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_device_connection_status_response)
  if (_internal_has_get_device_connection_status_response()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceConnectionStatus* temp = _impl_.payload_variant_.get_device_connection_status_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_device_connection_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceConnectionStatus& AdminMessage::_internal_get_device_connection_status_response() const {
  return _internal_has_get_device_connection_status_response()
      ? *_impl_.payload_variant_.get_device_connection_status_response_
      : reinterpret_cast< ::meshtastic::DeviceConnectionStatus&>(::meshtastic::_DeviceConnectionStatus_default_instance_);
}
inline const ::meshtastic::DeviceConnectionStatus& AdminMessage::get_device_connection_status_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_device_connection_status_response)
  return _internal_get_device_connection_status_response();
}
inline ::meshtastic::DeviceConnectionStatus* AdminMessage::unsafe_arena_release_get_device_connection_status_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_device_connection_status_response)
  if (_internal_has_get_device_connection_status_response()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceConnectionStatus* temp = _impl_.payload_variant_.get_device_connection_status_response_;
    _impl_.payload_variant_.get_device_connection_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_device_connection_status_response(::meshtastic::DeviceConnectionStatus* get_device_connection_status_response) {
  clear_payload_variant();
  if (get_device_connection_status_response) {
    set_has_get_device_connection_status_response();
    _impl_.payload_variant_.get_device_connection_status_response_ = get_device_connection_status_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_device_connection_status_response)
}
inline ::meshtastic::DeviceConnectionStatus* AdminMessage::_internal_mutable_get_device_connection_status_response() {
  if (!_internal_has_get_device_connection_status_response()) {
    clear_payload_variant();
    set_has_get_device_connection_status_response();
    _impl_.payload_variant_.get_device_connection_status_response_ = CreateMaybeMessage< ::meshtastic::DeviceConnectionStatus >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.get_device_connection_status_response_;
}
inline ::meshtastic::DeviceConnectionStatus* AdminMessage::mutable_get_device_connection_status_response() {
  ::meshtastic::DeviceConnectionStatus* _msg = _internal_mutable_get_device_connection_status_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_device_connection_status_response)
  return _msg;
}

// .meshtastic.HamParameters set_ham_mode = 18;
inline bool AdminMessage::_internal_has_set_ham_mode() const {
  return payload_variant_case() == kSetHamMode;
}
inline bool AdminMessage::has_set_ham_mode() const {
  return _internal_has_set_ham_mode();
}
inline void AdminMessage::set_has_set_ham_mode() {
  _impl_._oneof_case_[0] = kSetHamMode;
}
inline void AdminMessage::clear_set_ham_mode() {
  if (_internal_has_set_ham_mode()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.set_ham_mode_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::HamParameters* AdminMessage::release_set_ham_mode() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_ham_mode)
  if (_internal_has_set_ham_mode()) {
    clear_has_payload_variant();
    ::meshtastic::HamParameters* temp = _impl_.payload_variant_.set_ham_mode_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_ham_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::HamParameters& AdminMessage::_internal_set_ham_mode() const {
  return _internal_has_set_ham_mode()
      ? *_impl_.payload_variant_.set_ham_mode_
      : reinterpret_cast< ::meshtastic::HamParameters&>(::meshtastic::_HamParameters_default_instance_);
}
inline const ::meshtastic::HamParameters& AdminMessage::set_ham_mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_ham_mode)
  return _internal_set_ham_mode();
}
inline ::meshtastic::HamParameters* AdminMessage::unsafe_arena_release_set_ham_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_ham_mode)
  if (_internal_has_set_ham_mode()) {
    clear_has_payload_variant();
    ::meshtastic::HamParameters* temp = _impl_.payload_variant_.set_ham_mode_;
    _impl_.payload_variant_.set_ham_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_ham_mode(::meshtastic::HamParameters* set_ham_mode) {
  clear_payload_variant();
  if (set_ham_mode) {
    set_has_set_ham_mode();
    _impl_.payload_variant_.set_ham_mode_ = set_ham_mode;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_ham_mode)
}
inline ::meshtastic::HamParameters* AdminMessage::_internal_mutable_set_ham_mode() {
  if (!_internal_has_set_ham_mode()) {
    clear_payload_variant();
    set_has_set_ham_mode();
    _impl_.payload_variant_.set_ham_mode_ = CreateMaybeMessage< ::meshtastic::HamParameters >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.set_ham_mode_;
}
inline ::meshtastic::HamParameters* AdminMessage::mutable_set_ham_mode() {
  ::meshtastic::HamParameters* _msg = _internal_mutable_set_ham_mode();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_ham_mode)
  return _msg;
}

// bool get_node_remote_hardware_pins_request = 19;
inline bool AdminMessage::_internal_has_get_node_remote_hardware_pins_request() const {
  return payload_variant_case() == kGetNodeRemoteHardwarePinsRequest;
}
inline bool AdminMessage::has_get_node_remote_hardware_pins_request() const {
  return _internal_has_get_node_remote_hardware_pins_request();
}
inline void AdminMessage::set_has_get_node_remote_hardware_pins_request() {
  _impl_._oneof_case_[0] = kGetNodeRemoteHardwarePinsRequest;
}
inline void AdminMessage::clear_get_node_remote_hardware_pins_request() {
  if (_internal_has_get_node_remote_hardware_pins_request()) {
    _impl_.payload_variant_.get_node_remote_hardware_pins_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_get_node_remote_hardware_pins_request() const {
  if (_internal_has_get_node_remote_hardware_pins_request()) {
    return _impl_.payload_variant_.get_node_remote_hardware_pins_request_;
  }
  return false;
}
inline void AdminMessage::_internal_set_get_node_remote_hardware_pins_request(bool value) {
  if (!_internal_has_get_node_remote_hardware_pins_request()) {
    clear_payload_variant();
    set_has_get_node_remote_hardware_pins_request();
  }
  _impl_.payload_variant_.get_node_remote_hardware_pins_request_ = value;
}
inline bool AdminMessage::get_node_remote_hardware_pins_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_node_remote_hardware_pins_request)
  return _internal_get_node_remote_hardware_pins_request();
}
inline void AdminMessage::set_get_node_remote_hardware_pins_request(bool value) {
  _internal_set_get_node_remote_hardware_pins_request(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_node_remote_hardware_pins_request)
}

// .meshtastic.NodeRemoteHardwarePinsResponse get_node_remote_hardware_pins_response = 20;
inline bool AdminMessage::_internal_has_get_node_remote_hardware_pins_response() const {
  return payload_variant_case() == kGetNodeRemoteHardwarePinsResponse;
}
inline bool AdminMessage::has_get_node_remote_hardware_pins_response() const {
  return _internal_has_get_node_remote_hardware_pins_response();
}
inline void AdminMessage::set_has_get_node_remote_hardware_pins_response() {
  _impl_._oneof_case_[0] = kGetNodeRemoteHardwarePinsResponse;
}
inline void AdminMessage::clear_get_node_remote_hardware_pins_response() {
  if (_internal_has_get_node_remote_hardware_pins_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.get_node_remote_hardware_pins_response_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::NodeRemoteHardwarePinsResponse* AdminMessage::release_get_node_remote_hardware_pins_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_node_remote_hardware_pins_response)
  if (_internal_has_get_node_remote_hardware_pins_response()) {
    clear_has_payload_variant();
    ::meshtastic::NodeRemoteHardwarePinsResponse* temp = _impl_.payload_variant_.get_node_remote_hardware_pins_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_node_remote_hardware_pins_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::NodeRemoteHardwarePinsResponse& AdminMessage::_internal_get_node_remote_hardware_pins_response() const {
  return _internal_has_get_node_remote_hardware_pins_response()
      ? *_impl_.payload_variant_.get_node_remote_hardware_pins_response_
      : reinterpret_cast< ::meshtastic::NodeRemoteHardwarePinsResponse&>(::meshtastic::_NodeRemoteHardwarePinsResponse_default_instance_);
}
inline const ::meshtastic::NodeRemoteHardwarePinsResponse& AdminMessage::get_node_remote_hardware_pins_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_node_remote_hardware_pins_response)
  return _internal_get_node_remote_hardware_pins_response();
}
inline ::meshtastic::NodeRemoteHardwarePinsResponse* AdminMessage::unsafe_arena_release_get_node_remote_hardware_pins_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_node_remote_hardware_pins_response)
  if (_internal_has_get_node_remote_hardware_pins_response()) {
    clear_has_payload_variant();
    ::meshtastic::NodeRemoteHardwarePinsResponse* temp = _impl_.payload_variant_.get_node_remote_hardware_pins_response_;
    _impl_.payload_variant_.get_node_remote_hardware_pins_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_node_remote_hardware_pins_response(::meshtastic::NodeRemoteHardwarePinsResponse* get_node_remote_hardware_pins_response) {
  clear_payload_variant();
  if (get_node_remote_hardware_pins_response) {
    set_has_get_node_remote_hardware_pins_response();
    _impl_.payload_variant_.get_node_remote_hardware_pins_response_ = get_node_remote_hardware_pins_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_node_remote_hardware_pins_response)
}
inline ::meshtastic::NodeRemoteHardwarePinsResponse* AdminMessage::_internal_mutable_get_node_remote_hardware_pins_response() {
  if (!_internal_has_get_node_remote_hardware_pins_response()) {
    clear_payload_variant();
    set_has_get_node_remote_hardware_pins_response();
    _impl_.payload_variant_.get_node_remote_hardware_pins_response_ = CreateMaybeMessage< ::meshtastic::NodeRemoteHardwarePinsResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.get_node_remote_hardware_pins_response_;
}
inline ::meshtastic::NodeRemoteHardwarePinsResponse* AdminMessage::mutable_get_node_remote_hardware_pins_response() {
  ::meshtastic::NodeRemoteHardwarePinsResponse* _msg = _internal_mutable_get_node_remote_hardware_pins_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_node_remote_hardware_pins_response)
  return _msg;
}

// bool enter_dfu_mode_request = 21;
inline bool AdminMessage::_internal_has_enter_dfu_mode_request() const {
  return payload_variant_case() == kEnterDfuModeRequest;
}
inline bool AdminMessage::has_enter_dfu_mode_request() const {
  return _internal_has_enter_dfu_mode_request();
}
inline void AdminMessage::set_has_enter_dfu_mode_request() {
  _impl_._oneof_case_[0] = kEnterDfuModeRequest;
}
inline void AdminMessage::clear_enter_dfu_mode_request() {
  if (_internal_has_enter_dfu_mode_request()) {
    _impl_.payload_variant_.enter_dfu_mode_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_enter_dfu_mode_request() const {
  if (_internal_has_enter_dfu_mode_request()) {
    return _impl_.payload_variant_.enter_dfu_mode_request_;
  }
  return false;
}
inline void AdminMessage::_internal_set_enter_dfu_mode_request(bool value) {
  if (!_internal_has_enter_dfu_mode_request()) {
    clear_payload_variant();
    set_has_enter_dfu_mode_request();
  }
  _impl_.payload_variant_.enter_dfu_mode_request_ = value;
}
inline bool AdminMessage::enter_dfu_mode_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.enter_dfu_mode_request)
  return _internal_enter_dfu_mode_request();
}
inline void AdminMessage::set_enter_dfu_mode_request(bool value) {
  _internal_set_enter_dfu_mode_request(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.enter_dfu_mode_request)
}

// string delete_file_request = 22;
inline bool AdminMessage::_internal_has_delete_file_request() const {
  return payload_variant_case() == kDeleteFileRequest;
}
inline bool AdminMessage::has_delete_file_request() const {
  return _internal_has_delete_file_request();
}
inline void AdminMessage::set_has_delete_file_request() {
  _impl_._oneof_case_[0] = kDeleteFileRequest;
}
inline void AdminMessage::clear_delete_file_request() {
  if (_internal_has_delete_file_request()) {
    _impl_.payload_variant_.delete_file_request_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& AdminMessage::delete_file_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.delete_file_request)
  return _internal_delete_file_request();
}
template <typename ArgT0, typename... ArgT>
inline void AdminMessage::set_delete_file_request(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_delete_file_request()) {
    clear_payload_variant();
    set_has_delete_file_request();
    _impl_.payload_variant_.delete_file_request_.InitDefault();
  }
  _impl_.payload_variant_.delete_file_request_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.delete_file_request)
}
inline std::string* AdminMessage::mutable_delete_file_request() {
  std::string* _s = _internal_mutable_delete_file_request();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.delete_file_request)
  return _s;
}
inline const std::string& AdminMessage::_internal_delete_file_request() const {
  if (_internal_has_delete_file_request()) {
    return _impl_.payload_variant_.delete_file_request_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AdminMessage::_internal_set_delete_file_request(const std::string& value) {
  if (!_internal_has_delete_file_request()) {
    clear_payload_variant();
    set_has_delete_file_request();
    _impl_.payload_variant_.delete_file_request_.InitDefault();
  }
  _impl_.payload_variant_.delete_file_request_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminMessage::_internal_mutable_delete_file_request() {
  if (!_internal_has_delete_file_request()) {
    clear_payload_variant();
    set_has_delete_file_request();
    _impl_.payload_variant_.delete_file_request_.InitDefault();
  }
  return _impl_.payload_variant_.delete_file_request_.Mutable(      GetArenaForAllocation());
}
inline std::string* AdminMessage::release_delete_file_request() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.delete_file_request)
  if (_internal_has_delete_file_request()) {
    clear_has_payload_variant();
    return _impl_.payload_variant_.delete_file_request_.Release();
  } else {
    return nullptr;
  }
}
inline void AdminMessage::set_allocated_delete_file_request(std::string* delete_file_request) {
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (delete_file_request != nullptr) {
    set_has_delete_file_request();
    _impl_.payload_variant_.delete_file_request_.InitAllocated(delete_file_request, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.delete_file_request)
}

// uint32 set_scale = 23;
inline bool AdminMessage::_internal_has_set_scale() const {
  return payload_variant_case() == kSetScale;
}
inline bool AdminMessage::has_set_scale() const {
  return _internal_has_set_scale();
}
inline void AdminMessage::set_has_set_scale() {
  _impl_._oneof_case_[0] = kSetScale;
}
inline void AdminMessage::clear_set_scale() {
  if (_internal_has_set_scale()) {
    _impl_.payload_variant_.set_scale_ = 0u;
    clear_has_payload_variant();
  }
}
inline uint32_t AdminMessage::_internal_set_scale() const {
  if (_internal_has_set_scale()) {
    return _impl_.payload_variant_.set_scale_;
  }
  return 0u;
}
inline void AdminMessage::_internal_set_set_scale(uint32_t value) {
  if (!_internal_has_set_scale()) {
    clear_payload_variant();
    set_has_set_scale();
  }
  _impl_.payload_variant_.set_scale_ = value;
}
inline uint32_t AdminMessage::set_scale() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_scale)
  return _internal_set_scale();
}
inline void AdminMessage::set_set_scale(uint32_t value) {
  _internal_set_set_scale(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_scale)
}

// .meshtastic.AdminMessage.BackupLocation backup_preferences = 24;
inline bool AdminMessage::_internal_has_backup_preferences() const {
  return payload_variant_case() == kBackupPreferences;
}
inline bool AdminMessage::has_backup_preferences() const {
  return _internal_has_backup_preferences();
}
inline void AdminMessage::set_has_backup_preferences() {
  _impl_._oneof_case_[0] = kBackupPreferences;
}
inline void AdminMessage::clear_backup_preferences() {
  if (_internal_has_backup_preferences()) {
    _impl_.payload_variant_.backup_preferences_ = 0;
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::_internal_backup_preferences() const {
  if (_internal_has_backup_preferences()) {
    return static_cast< ::meshtastic::AdminMessage_BackupLocation >(_impl_.payload_variant_.backup_preferences_);
  }
  return static_cast< ::meshtastic::AdminMessage_BackupLocation >(0);
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::backup_preferences() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.backup_preferences)
  return _internal_backup_preferences();
}
inline void AdminMessage::_internal_set_backup_preferences(::meshtastic::AdminMessage_BackupLocation value) {
  if (!_internal_has_backup_preferences()) {
    clear_payload_variant();
    set_has_backup_preferences();
  }
  _impl_.payload_variant_.backup_preferences_ = value;
}
inline void AdminMessage::set_backup_preferences(::meshtastic::AdminMessage_BackupLocation value) {
  _internal_set_backup_preferences(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.backup_preferences)
}

// .meshtastic.AdminMessage.BackupLocation restore_preferences = 25;
inline bool AdminMessage::_internal_has_restore_preferences() const {
  return payload_variant_case() == kRestorePreferences;
}
inline bool AdminMessage::has_restore_preferences() const {
  return _internal_has_restore_preferences();
}
inline void AdminMessage::set_has_restore_preferences() {
  _impl_._oneof_case_[0] = kRestorePreferences;
}
inline void AdminMessage::clear_restore_preferences() {
  if (_internal_has_restore_preferences()) {
    _impl_.payload_variant_.restore_preferences_ = 0;
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::_internal_restore_preferences() const {
  if (_internal_has_restore_preferences()) {
    return static_cast< ::meshtastic::AdminMessage_BackupLocation >(_impl_.payload_variant_.restore_preferences_);
  }
  return static_cast< ::meshtastic::AdminMessage_BackupLocation >(0);
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::restore_preferences() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.restore_preferences)
  return _internal_restore_preferences();
}
inline void AdminMessage::_internal_set_restore_preferences(::meshtastic::AdminMessage_BackupLocation value) {
  if (!_internal_has_restore_preferences()) {
    clear_payload_variant();
    set_has_restore_preferences();
  }
  _impl_.payload_variant_.restore_preferences_ = value;
}
inline void AdminMessage::set_restore_preferences(::meshtastic::AdminMessage_BackupLocation value) {
  _internal_set_restore_preferences(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.restore_preferences)
}

// .meshtastic.AdminMessage.BackupLocation remove_backup_preferences = 26;
inline bool AdminMessage::_internal_has_remove_backup_preferences() const {
  return payload_variant_case() == kRemoveBackupPreferences;
}
inline bool AdminMessage::has_remove_backup_preferences() const {
  return _internal_has_remove_backup_preferences();
}
inline void AdminMessage::set_has_remove_backup_preferences() {
  _impl_._oneof_case_[0] = kRemoveBackupPreferences;
}
inline void AdminMessage::clear_remove_backup_preferences() {
  if (_internal_has_remove_backup_preferences()) {
    _impl_.payload_variant_.remove_backup_preferences_ = 0;
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::_internal_remove_backup_preferences() const {
  if (_internal_has_remove_backup_preferences()) {
    return static_cast< ::meshtastic::AdminMessage_BackupLocation >(_impl_.payload_variant_.remove_backup_preferences_);
  }
  return static_cast< ::meshtastic::AdminMessage_BackupLocation >(0);
}
inline ::meshtastic::AdminMessage_BackupLocation AdminMessage::remove_backup_preferences() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.remove_backup_preferences)
  return _internal_remove_backup_preferences();
}
inline void AdminMessage::_internal_set_remove_backup_preferences(::meshtastic::AdminMessage_BackupLocation value) {
  if (!_internal_has_remove_backup_preferences()) {
    clear_payload_variant();
    set_has_remove_backup_preferences();
  }
  _impl_.payload_variant_.remove_backup_preferences_ = value;
}
inline void AdminMessage::set_remove_backup_preferences(::meshtastic::AdminMessage_BackupLocation value) {
  _internal_set_remove_backup_preferences(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.remove_backup_preferences)
}

// .meshtastic.AdminMessage.InputEvent send_input_event = 27;
inline bool AdminMessage::_internal_has_send_input_event() const {
  return payload_variant_case() == kSendInputEvent;
}
inline bool AdminMessage::has_send_input_event() const {
  return _internal_has_send_input_event();
}
inline void AdminMessage::set_has_send_input_event() {
  _impl_._oneof_case_[0] = kSendInputEvent;
}
inline void AdminMessage::clear_send_input_event() {
  if (_internal_has_send_input_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.send_input_event_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::AdminMessage_InputEvent* AdminMessage::release_send_input_event() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.send_input_event)
  if (_internal_has_send_input_event()) {
    clear_has_payload_variant();
    ::meshtastic::AdminMessage_InputEvent* temp = _impl_.payload_variant_.send_input_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.send_input_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::AdminMessage_InputEvent& AdminMessage::_internal_send_input_event() const {
  return _internal_has_send_input_event()
      ? *_impl_.payload_variant_.send_input_event_
      : reinterpret_cast< ::meshtastic::AdminMessage_InputEvent&>(::meshtastic::_AdminMessage_InputEvent_default_instance_);
}
inline const ::meshtastic::AdminMessage_InputEvent& AdminMessage::send_input_event() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.send_input_event)
  return _internal_send_input_event();
}
inline ::meshtastic::AdminMessage_InputEvent* AdminMessage::unsafe_arena_release_send_input_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.send_input_event)
  if (_internal_has_send_input_event()) {
    clear_has_payload_variant();
    ::meshtastic::AdminMessage_InputEvent* temp = _impl_.payload_variant_.send_input_event_;
    _impl_.payload_variant_.send_input_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_send_input_event(::meshtastic::AdminMessage_InputEvent* send_input_event) {
  clear_payload_variant();
  if (send_input_event) {
    set_has_send_input_event();
    _impl_.payload_variant_.send_input_event_ = send_input_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.send_input_event)
}
inline ::meshtastic::AdminMessage_InputEvent* AdminMessage::_internal_mutable_send_input_event() {
  if (!_internal_has_send_input_event()) {
    clear_payload_variant();
    set_has_send_input_event();
    _impl_.payload_variant_.send_input_event_ = CreateMaybeMessage< ::meshtastic::AdminMessage_InputEvent >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.send_input_event_;
}
inline ::meshtastic::AdminMessage_InputEvent* AdminMessage::mutable_send_input_event() {
  ::meshtastic::AdminMessage_InputEvent* _msg = _internal_mutable_send_input_event();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.send_input_event)
  return _msg;
}

// .meshtastic.User set_owner = 32;
inline bool AdminMessage::_internal_has_set_owner() const {
  return payload_variant_case() == kSetOwner;
}
inline bool AdminMessage::has_set_owner() const {
  return _internal_has_set_owner();
}
inline void AdminMessage::set_has_set_owner() {
  _impl_._oneof_case_[0] = kSetOwner;
}
inline ::meshtastic::User* AdminMessage::release_set_owner() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_owner)
  if (_internal_has_set_owner()) {
    clear_has_payload_variant();
    ::meshtastic::User* temp = _impl_.payload_variant_.set_owner_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_owner_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::User& AdminMessage::_internal_set_owner() const {
  return _internal_has_set_owner()
      ? *_impl_.payload_variant_.set_owner_
      : reinterpret_cast< ::meshtastic::User&>(::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& AdminMessage::set_owner() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_owner)
  return _internal_set_owner();
}
inline ::meshtastic::User* AdminMessage::unsafe_arena_release_set_owner() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_owner)
  if (_internal_has_set_owner()) {
    clear_has_payload_variant();
    ::meshtastic::User* temp = _impl_.payload_variant_.set_owner_;
    _impl_.payload_variant_.set_owner_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_owner(::meshtastic::User* set_owner) {
  clear_payload_variant();
  if (set_owner) {
    set_has_set_owner();
    _impl_.payload_variant_.set_owner_ = set_owner;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_owner)
}
inline ::meshtastic::User* AdminMessage::_internal_mutable_set_owner() {
  if (!_internal_has_set_owner()) {
    clear_payload_variant();
    set_has_set_owner();
    _impl_.payload_variant_.set_owner_ = CreateMaybeMessage< ::meshtastic::User >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.set_owner_;
}
inline ::meshtastic::User* AdminMessage::mutable_set_owner() {
  ::meshtastic::User* _msg = _internal_mutable_set_owner();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_owner)
  return _msg;
}

// .meshtastic.Channel set_channel = 33;
inline bool AdminMessage::_internal_has_set_channel() const {
  return payload_variant_case() == kSetChannel;
}
inline bool AdminMessage::has_set_channel() const {
  return _internal_has_set_channel();
}
inline void AdminMessage::set_has_set_channel() {
  _impl_._oneof_case_[0] = kSetChannel;
}
inline ::meshtastic::Channel* AdminMessage::release_set_channel() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_channel)
  if (_internal_has_set_channel()) {
    clear_has_payload_variant();
    ::meshtastic::Channel* temp = _impl_.payload_variant_.set_channel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Channel& AdminMessage::_internal_set_channel() const {
  return _internal_has_set_channel()
      ? *_impl_.payload_variant_.set_channel_
      : reinterpret_cast< ::meshtastic::Channel&>(::meshtastic::_Channel_default_instance_);
}
inline const ::meshtastic::Channel& AdminMessage::set_channel() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_channel)
  return _internal_set_channel();
}
inline ::meshtastic::Channel* AdminMessage::unsafe_arena_release_set_channel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_channel)
  if (_internal_has_set_channel()) {
    clear_has_payload_variant();
    ::meshtastic::Channel* temp = _impl_.payload_variant_.set_channel_;
    _impl_.payload_variant_.set_channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_channel(::meshtastic::Channel* set_channel) {
  clear_payload_variant();
  if (set_channel) {
    set_has_set_channel();
    _impl_.payload_variant_.set_channel_ = set_channel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_channel)
}
inline ::meshtastic::Channel* AdminMessage::_internal_mutable_set_channel() {
  if (!_internal_has_set_channel()) {
    clear_payload_variant();
    set_has_set_channel();
    _impl_.payload_variant_.set_channel_ = CreateMaybeMessage< ::meshtastic::Channel >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.set_channel_;
}
inline ::meshtastic::Channel* AdminMessage::mutable_set_channel() {
  ::meshtastic::Channel* _msg = _internal_mutable_set_channel();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_channel)
  return _msg;
}

// .meshtastic.Config set_config = 34;
inline bool AdminMessage::_internal_has_set_config() const {
  return payload_variant_case() == kSetConfig;
}
inline bool AdminMessage::has_set_config() const {
  return _internal_has_set_config();
}
inline void AdminMessage::set_has_set_config() {
  _impl_._oneof_case_[0] = kSetConfig;
}
inline ::meshtastic::Config* AdminMessage::release_set_config() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_config)
  if (_internal_has_set_config()) {
    clear_has_payload_variant();
    ::meshtastic::Config* temp = _impl_.payload_variant_.set_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config& AdminMessage::_internal_set_config() const {
  return _internal_has_set_config()
      ? *_impl_.payload_variant_.set_config_
      : reinterpret_cast< ::meshtastic::Config&>(::meshtastic::_Config_default_instance_);
}
inline const ::meshtastic::Config& AdminMessage::set_config() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_config)
  return _internal_set_config();
}
inline ::meshtastic::Config* AdminMessage::unsafe_arena_release_set_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_config)
  if (_internal_has_set_config()) {
    clear_has_payload_variant();
    ::meshtastic::Config* temp = _impl_.payload_variant_.set_config_;
    _impl_.payload_variant_.set_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_config(::meshtastic::Config* set_config) {
  clear_payload_variant();
  if (set_config) {
    set_has_set_config();
    _impl_.payload_variant_.set_config_ = set_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_config)
}
inline ::meshtastic::Config* AdminMessage::_internal_mutable_set_config() {
  if (!_internal_has_set_config()) {
    clear_payload_variant();
    set_has_set_config();
    _impl_.payload_variant_.set_config_ = CreateMaybeMessage< ::meshtastic::Config >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.set_config_;
}
inline ::meshtastic::Config* AdminMessage::mutable_set_config() {
  ::meshtastic::Config* _msg = _internal_mutable_set_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_config)
  return _msg;
}

// .meshtastic.ModuleConfig set_module_config = 35;
inline bool AdminMessage::_internal_has_set_module_config() const {
  return payload_variant_case() == kSetModuleConfig;
}
inline bool AdminMessage::has_set_module_config() const {
  return _internal_has_set_module_config();
}
inline void AdminMessage::set_has_set_module_config() {
  _impl_._oneof_case_[0] = kSetModuleConfig;
}
inline ::meshtastic::ModuleConfig* AdminMessage::release_set_module_config() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_module_config)
  if (_internal_has_set_module_config()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig* temp = _impl_.payload_variant_.set_module_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_module_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig& AdminMessage::_internal_set_module_config() const {
  return _internal_has_set_module_config()
      ? *_impl_.payload_variant_.set_module_config_
      : reinterpret_cast< ::meshtastic::ModuleConfig&>(::meshtastic::_ModuleConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig& AdminMessage::set_module_config() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_module_config)
  return _internal_set_module_config();
}
inline ::meshtastic::ModuleConfig* AdminMessage::unsafe_arena_release_set_module_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_module_config)
  if (_internal_has_set_module_config()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig* temp = _impl_.payload_variant_.set_module_config_;
    _impl_.payload_variant_.set_module_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_module_config(::meshtastic::ModuleConfig* set_module_config) {
  clear_payload_variant();
  if (set_module_config) {
    set_has_set_module_config();
    _impl_.payload_variant_.set_module_config_ = set_module_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_module_config)
}
inline ::meshtastic::ModuleConfig* AdminMessage::_internal_mutable_set_module_config() {
  if (!_internal_has_set_module_config()) {
    clear_payload_variant();
    set_has_set_module_config();
    _impl_.payload_variant_.set_module_config_ = CreateMaybeMessage< ::meshtastic::ModuleConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.set_module_config_;
}
inline ::meshtastic::ModuleConfig* AdminMessage::mutable_set_module_config() {
  ::meshtastic::ModuleConfig* _msg = _internal_mutable_set_module_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_module_config)
  return _msg;
}

// string set_canned_message_module_messages = 36;
inline bool AdminMessage::_internal_has_set_canned_message_module_messages() const {
  return payload_variant_case() == kSetCannedMessageModuleMessages;
}
inline bool AdminMessage::has_set_canned_message_module_messages() const {
  return _internal_has_set_canned_message_module_messages();
}
inline void AdminMessage::set_has_set_canned_message_module_messages() {
  _impl_._oneof_case_[0] = kSetCannedMessageModuleMessages;
}
inline void AdminMessage::clear_set_canned_message_module_messages() {
  if (_internal_has_set_canned_message_module_messages()) {
    _impl_.payload_variant_.set_canned_message_module_messages_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& AdminMessage::set_canned_message_module_messages() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_canned_message_module_messages)
  return _internal_set_canned_message_module_messages();
}
template <typename ArgT0, typename... ArgT>
inline void AdminMessage::set_set_canned_message_module_messages(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_set_canned_message_module_messages()) {
    clear_payload_variant();
    set_has_set_canned_message_module_messages();
    _impl_.payload_variant_.set_canned_message_module_messages_.InitDefault();
  }
  _impl_.payload_variant_.set_canned_message_module_messages_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_canned_message_module_messages)
}
inline std::string* AdminMessage::mutable_set_canned_message_module_messages() {
  std::string* _s = _internal_mutable_set_canned_message_module_messages();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_canned_message_module_messages)
  return _s;
}
inline const std::string& AdminMessage::_internal_set_canned_message_module_messages() const {
  if (_internal_has_set_canned_message_module_messages()) {
    return _impl_.payload_variant_.set_canned_message_module_messages_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AdminMessage::_internal_set_set_canned_message_module_messages(const std::string& value) {
  if (!_internal_has_set_canned_message_module_messages()) {
    clear_payload_variant();
    set_has_set_canned_message_module_messages();
    _impl_.payload_variant_.set_canned_message_module_messages_.InitDefault();
  }
  _impl_.payload_variant_.set_canned_message_module_messages_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminMessage::_internal_mutable_set_canned_message_module_messages() {
  if (!_internal_has_set_canned_message_module_messages()) {
    clear_payload_variant();
    set_has_set_canned_message_module_messages();
    _impl_.payload_variant_.set_canned_message_module_messages_.InitDefault();
  }
  return _impl_.payload_variant_.set_canned_message_module_messages_.Mutable(      GetArenaForAllocation());
}
inline std::string* AdminMessage::release_set_canned_message_module_messages() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_canned_message_module_messages)
  if (_internal_has_set_canned_message_module_messages()) {
    clear_has_payload_variant();
    return _impl_.payload_variant_.set_canned_message_module_messages_.Release();
  } else {
    return nullptr;
  }
}
inline void AdminMessage::set_allocated_set_canned_message_module_messages(std::string* set_canned_message_module_messages) {
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (set_canned_message_module_messages != nullptr) {
    set_has_set_canned_message_module_messages();
    _impl_.payload_variant_.set_canned_message_module_messages_.InitAllocated(set_canned_message_module_messages, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.set_canned_message_module_messages)
}

// string set_ringtone_message = 37;
inline bool AdminMessage::_internal_has_set_ringtone_message() const {
  return payload_variant_case() == kSetRingtoneMessage;
}
inline bool AdminMessage::has_set_ringtone_message() const {
  return _internal_has_set_ringtone_message();
}
inline void AdminMessage::set_has_set_ringtone_message() {
  _impl_._oneof_case_[0] = kSetRingtoneMessage;
}
inline void AdminMessage::clear_set_ringtone_message() {
  if (_internal_has_set_ringtone_message()) {
    _impl_.payload_variant_.set_ringtone_message_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& AdminMessage::set_ringtone_message() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_ringtone_message)
  return _internal_set_ringtone_message();
}
template <typename ArgT0, typename... ArgT>
inline void AdminMessage::set_set_ringtone_message(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_set_ringtone_message()) {
    clear_payload_variant();
    set_has_set_ringtone_message();
    _impl_.payload_variant_.set_ringtone_message_.InitDefault();
  }
  _impl_.payload_variant_.set_ringtone_message_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_ringtone_message)
}
inline std::string* AdminMessage::mutable_set_ringtone_message() {
  std::string* _s = _internal_mutable_set_ringtone_message();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_ringtone_message)
  return _s;
}
inline const std::string& AdminMessage::_internal_set_ringtone_message() const {
  if (_internal_has_set_ringtone_message()) {
    return _impl_.payload_variant_.set_ringtone_message_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AdminMessage::_internal_set_set_ringtone_message(const std::string& value) {
  if (!_internal_has_set_ringtone_message()) {
    clear_payload_variant();
    set_has_set_ringtone_message();
    _impl_.payload_variant_.set_ringtone_message_.InitDefault();
  }
  _impl_.payload_variant_.set_ringtone_message_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminMessage::_internal_mutable_set_ringtone_message() {
  if (!_internal_has_set_ringtone_message()) {
    clear_payload_variant();
    set_has_set_ringtone_message();
    _impl_.payload_variant_.set_ringtone_message_.InitDefault();
  }
  return _impl_.payload_variant_.set_ringtone_message_.Mutable(      GetArenaForAllocation());
}
inline std::string* AdminMessage::release_set_ringtone_message() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_ringtone_message)
  if (_internal_has_set_ringtone_message()) {
    clear_has_payload_variant();
    return _impl_.payload_variant_.set_ringtone_message_.Release();
  } else {
    return nullptr;
  }
}
inline void AdminMessage::set_allocated_set_ringtone_message(std::string* set_ringtone_message) {
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (set_ringtone_message != nullptr) {
    set_has_set_ringtone_message();
    _impl_.payload_variant_.set_ringtone_message_.InitAllocated(set_ringtone_message, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.AdminMessage.set_ringtone_message)
}

// uint32 remove_by_nodenum = 38;
inline bool AdminMessage::_internal_has_remove_by_nodenum() const {
  return payload_variant_case() == kRemoveByNodenum;
}
inline bool AdminMessage::has_remove_by_nodenum() const {
  return _internal_has_remove_by_nodenum();
}
inline void AdminMessage::set_has_remove_by_nodenum() {
  _impl_._oneof_case_[0] = kRemoveByNodenum;
}
inline void AdminMessage::clear_remove_by_nodenum() {
  if (_internal_has_remove_by_nodenum()) {
    _impl_.payload_variant_.remove_by_nodenum_ = 0u;
    clear_has_payload_variant();
  }
}
inline uint32_t AdminMessage::_internal_remove_by_nodenum() const {
  if (_internal_has_remove_by_nodenum()) {
    return _impl_.payload_variant_.remove_by_nodenum_;
  }
  return 0u;
}
inline void AdminMessage::_internal_set_remove_by_nodenum(uint32_t value) {
  if (!_internal_has_remove_by_nodenum()) {
    clear_payload_variant();
    set_has_remove_by_nodenum();
  }
  _impl_.payload_variant_.remove_by_nodenum_ = value;
}
inline uint32_t AdminMessage::remove_by_nodenum() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.remove_by_nodenum)
  return _internal_remove_by_nodenum();
}
inline void AdminMessage::set_remove_by_nodenum(uint32_t value) {
  _internal_set_remove_by_nodenum(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.remove_by_nodenum)
}

// uint32 set_favorite_node = 39;
inline bool AdminMessage::_internal_has_set_favorite_node() const {
  return payload_variant_case() == kSetFavoriteNode;
}
inline bool AdminMessage::has_set_favorite_node() const {
  return _internal_has_set_favorite_node();
}
inline void AdminMessage::set_has_set_favorite_node() {
  _impl_._oneof_case_[0] = kSetFavoriteNode;
}
inline void AdminMessage::clear_set_favorite_node() {
  if (_internal_has_set_favorite_node()) {
    _impl_.payload_variant_.set_favorite_node_ = 0u;
    clear_has_payload_variant();
  }
}
inline uint32_t AdminMessage::_internal_set_favorite_node() const {
  if (_internal_has_set_favorite_node()) {
    return _impl_.payload_variant_.set_favorite_node_;
  }
  return 0u;
}
inline void AdminMessage::_internal_set_set_favorite_node(uint32_t value) {
  if (!_internal_has_set_favorite_node()) {
    clear_payload_variant();
    set_has_set_favorite_node();
  }
  _impl_.payload_variant_.set_favorite_node_ = value;
}
inline uint32_t AdminMessage::set_favorite_node() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_favorite_node)
  return _internal_set_favorite_node();
}
inline void AdminMessage::set_set_favorite_node(uint32_t value) {
  _internal_set_set_favorite_node(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_favorite_node)
}

// uint32 remove_favorite_node = 40;
inline bool AdminMessage::_internal_has_remove_favorite_node() const {
  return payload_variant_case() == kRemoveFavoriteNode;
}
inline bool AdminMessage::has_remove_favorite_node() const {
  return _internal_has_remove_favorite_node();
}
inline void AdminMessage::set_has_remove_favorite_node() {
  _impl_._oneof_case_[0] = kRemoveFavoriteNode;
}
inline void AdminMessage::clear_remove_favorite_node() {
  if (_internal_has_remove_favorite_node()) {
    _impl_.payload_variant_.remove_favorite_node_ = 0u;
    clear_has_payload_variant();
  }
}
inline uint32_t AdminMessage::_internal_remove_favorite_node() const {
  if (_internal_has_remove_favorite_node()) {
    return _impl_.payload_variant_.remove_favorite_node_;
  }
  return 0u;
}
inline void AdminMessage::_internal_set_remove_favorite_node(uint32_t value) {
  if (!_internal_has_remove_favorite_node()) {
    clear_payload_variant();
    set_has_remove_favorite_node();
  }
  _impl_.payload_variant_.remove_favorite_node_ = value;
}
inline uint32_t AdminMessage::remove_favorite_node() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.remove_favorite_node)
  return _internal_remove_favorite_node();
}
inline void AdminMessage::set_remove_favorite_node(uint32_t value) {
  _internal_set_remove_favorite_node(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.remove_favorite_node)
}

// .meshtastic.Position set_fixed_position = 41;
inline bool AdminMessage::_internal_has_set_fixed_position() const {
  return payload_variant_case() == kSetFixedPosition;
}
inline bool AdminMessage::has_set_fixed_position() const {
  return _internal_has_set_fixed_position();
}
inline void AdminMessage::set_has_set_fixed_position() {
  _impl_._oneof_case_[0] = kSetFixedPosition;
}
inline ::meshtastic::Position* AdminMessage::release_set_fixed_position() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.set_fixed_position)
  if (_internal_has_set_fixed_position()) {
    clear_has_payload_variant();
    ::meshtastic::Position* temp = _impl_.payload_variant_.set_fixed_position_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.set_fixed_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Position& AdminMessage::_internal_set_fixed_position() const {
  return _internal_has_set_fixed_position()
      ? *_impl_.payload_variant_.set_fixed_position_
      : reinterpret_cast< ::meshtastic::Position&>(::meshtastic::_Position_default_instance_);
}
inline const ::meshtastic::Position& AdminMessage::set_fixed_position() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_fixed_position)
  return _internal_set_fixed_position();
}
inline ::meshtastic::Position* AdminMessage::unsafe_arena_release_set_fixed_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.set_fixed_position)
  if (_internal_has_set_fixed_position()) {
    clear_has_payload_variant();
    ::meshtastic::Position* temp = _impl_.payload_variant_.set_fixed_position_;
    _impl_.payload_variant_.set_fixed_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_set_fixed_position(::meshtastic::Position* set_fixed_position) {
  clear_payload_variant();
  if (set_fixed_position) {
    set_has_set_fixed_position();
    _impl_.payload_variant_.set_fixed_position_ = set_fixed_position;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.set_fixed_position)
}
inline ::meshtastic::Position* AdminMessage::_internal_mutable_set_fixed_position() {
  if (!_internal_has_set_fixed_position()) {
    clear_payload_variant();
    set_has_set_fixed_position();
    _impl_.payload_variant_.set_fixed_position_ = CreateMaybeMessage< ::meshtastic::Position >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.set_fixed_position_;
}
inline ::meshtastic::Position* AdminMessage::mutable_set_fixed_position() {
  ::meshtastic::Position* _msg = _internal_mutable_set_fixed_position();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.set_fixed_position)
  return _msg;
}

// bool remove_fixed_position = 42;
inline bool AdminMessage::_internal_has_remove_fixed_position() const {
  return payload_variant_case() == kRemoveFixedPosition;
}
inline bool AdminMessage::has_remove_fixed_position() const {
  return _internal_has_remove_fixed_position();
}
inline void AdminMessage::set_has_remove_fixed_position() {
  _impl_._oneof_case_[0] = kRemoveFixedPosition;
}
inline void AdminMessage::clear_remove_fixed_position() {
  if (_internal_has_remove_fixed_position()) {
    _impl_.payload_variant_.remove_fixed_position_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_remove_fixed_position() const {
  if (_internal_has_remove_fixed_position()) {
    return _impl_.payload_variant_.remove_fixed_position_;
  }
  return false;
}
inline void AdminMessage::_internal_set_remove_fixed_position(bool value) {
  if (!_internal_has_remove_fixed_position()) {
    clear_payload_variant();
    set_has_remove_fixed_position();
  }
  _impl_.payload_variant_.remove_fixed_position_ = value;
}
inline bool AdminMessage::remove_fixed_position() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.remove_fixed_position)
  return _internal_remove_fixed_position();
}
inline void AdminMessage::set_remove_fixed_position(bool value) {
  _internal_set_remove_fixed_position(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.remove_fixed_position)
}

// fixed32 set_time_only = 43;
inline bool AdminMessage::_internal_has_set_time_only() const {
  return payload_variant_case() == kSetTimeOnly;
}
inline bool AdminMessage::has_set_time_only() const {
  return _internal_has_set_time_only();
}
inline void AdminMessage::set_has_set_time_only() {
  _impl_._oneof_case_[0] = kSetTimeOnly;
}
inline void AdminMessage::clear_set_time_only() {
  if (_internal_has_set_time_only()) {
    _impl_.payload_variant_.set_time_only_ = 0u;
    clear_has_payload_variant();
  }
}
inline uint32_t AdminMessage::_internal_set_time_only() const {
  if (_internal_has_set_time_only()) {
    return _impl_.payload_variant_.set_time_only_;
  }
  return 0u;
}
inline void AdminMessage::_internal_set_set_time_only(uint32_t value) {
  if (!_internal_has_set_time_only()) {
    clear_payload_variant();
    set_has_set_time_only();
  }
  _impl_.payload_variant_.set_time_only_ = value;
}
inline uint32_t AdminMessage::set_time_only() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_time_only)
  return _internal_set_time_only();
}
inline void AdminMessage::set_set_time_only(uint32_t value) {
  _internal_set_set_time_only(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_time_only)
}

// bool get_ui_config_request = 44;
inline bool AdminMessage::_internal_has_get_ui_config_request() const {
  return payload_variant_case() == kGetUiConfigRequest;
}
inline bool AdminMessage::has_get_ui_config_request() const {
  return _internal_has_get_ui_config_request();
}
inline void AdminMessage::set_has_get_ui_config_request() {
  _impl_._oneof_case_[0] = kGetUiConfigRequest;
}
inline void AdminMessage::clear_get_ui_config_request() {
  if (_internal_has_get_ui_config_request()) {
    _impl_.payload_variant_.get_ui_config_request_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_get_ui_config_request() const {
  if (_internal_has_get_ui_config_request()) {
    return _impl_.payload_variant_.get_ui_config_request_;
  }
  return false;
}
inline void AdminMessage::_internal_set_get_ui_config_request(bool value) {
  if (!_internal_has_get_ui_config_request()) {
    clear_payload_variant();
    set_has_get_ui_config_request();
  }
  _impl_.payload_variant_.get_ui_config_request_ = value;
}
inline bool AdminMessage::get_ui_config_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_ui_config_request)
  return _internal_get_ui_config_request();
}
inline void AdminMessage::set_get_ui_config_request(bool value) {
  _internal_set_get_ui_config_request(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.get_ui_config_request)
}

// .meshtastic.DeviceUIConfig get_ui_config_response = 45;
inline bool AdminMessage::_internal_has_get_ui_config_response() const {
  return payload_variant_case() == kGetUiConfigResponse;
}
inline bool AdminMessage::has_get_ui_config_response() const {
  return _internal_has_get_ui_config_response();
}
inline void AdminMessage::set_has_get_ui_config_response() {
  _impl_._oneof_case_[0] = kGetUiConfigResponse;
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::release_get_ui_config_response() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.get_ui_config_response)
  if (_internal_has_get_ui_config_response()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceUIConfig* temp = _impl_.payload_variant_.get_ui_config_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.get_ui_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceUIConfig& AdminMessage::_internal_get_ui_config_response() const {
  return _internal_has_get_ui_config_response()
      ? *_impl_.payload_variant_.get_ui_config_response_
      : reinterpret_cast< ::meshtastic::DeviceUIConfig&>(::meshtastic::_DeviceUIConfig_default_instance_);
}
inline const ::meshtastic::DeviceUIConfig& AdminMessage::get_ui_config_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.get_ui_config_response)
  return _internal_get_ui_config_response();
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::unsafe_arena_release_get_ui_config_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.get_ui_config_response)
  if (_internal_has_get_ui_config_response()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceUIConfig* temp = _impl_.payload_variant_.get_ui_config_response_;
    _impl_.payload_variant_.get_ui_config_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_get_ui_config_response(::meshtastic::DeviceUIConfig* get_ui_config_response) {
  clear_payload_variant();
  if (get_ui_config_response) {
    set_has_get_ui_config_response();
    _impl_.payload_variant_.get_ui_config_response_ = get_ui_config_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.get_ui_config_response)
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::_internal_mutable_get_ui_config_response() {
  if (!_internal_has_get_ui_config_response()) {
    clear_payload_variant();
    set_has_get_ui_config_response();
    _impl_.payload_variant_.get_ui_config_response_ = CreateMaybeMessage< ::meshtastic::DeviceUIConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.get_ui_config_response_;
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::mutable_get_ui_config_response() {
  ::meshtastic::DeviceUIConfig* _msg = _internal_mutable_get_ui_config_response();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.get_ui_config_response)
  return _msg;
}

// .meshtastic.DeviceUIConfig store_ui_config = 46;
inline bool AdminMessage::_internal_has_store_ui_config() const {
  return payload_variant_case() == kStoreUiConfig;
}
inline bool AdminMessage::has_store_ui_config() const {
  return _internal_has_store_ui_config();
}
inline void AdminMessage::set_has_store_ui_config() {
  _impl_._oneof_case_[0] = kStoreUiConfig;
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::release_store_ui_config() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.store_ui_config)
  if (_internal_has_store_ui_config()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceUIConfig* temp = _impl_.payload_variant_.store_ui_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.store_ui_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceUIConfig& AdminMessage::_internal_store_ui_config() const {
  return _internal_has_store_ui_config()
      ? *_impl_.payload_variant_.store_ui_config_
      : reinterpret_cast< ::meshtastic::DeviceUIConfig&>(::meshtastic::_DeviceUIConfig_default_instance_);
}
inline const ::meshtastic::DeviceUIConfig& AdminMessage::store_ui_config() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.store_ui_config)
  return _internal_store_ui_config();
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::unsafe_arena_release_store_ui_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.store_ui_config)
  if (_internal_has_store_ui_config()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceUIConfig* temp = _impl_.payload_variant_.store_ui_config_;
    _impl_.payload_variant_.store_ui_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_store_ui_config(::meshtastic::DeviceUIConfig* store_ui_config) {
  clear_payload_variant();
  if (store_ui_config) {
    set_has_store_ui_config();
    _impl_.payload_variant_.store_ui_config_ = store_ui_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.store_ui_config)
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::_internal_mutable_store_ui_config() {
  if (!_internal_has_store_ui_config()) {
    clear_payload_variant();
    set_has_store_ui_config();
    _impl_.payload_variant_.store_ui_config_ = CreateMaybeMessage< ::meshtastic::DeviceUIConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.store_ui_config_;
}
inline ::meshtastic::DeviceUIConfig* AdminMessage::mutable_store_ui_config() {
  ::meshtastic::DeviceUIConfig* _msg = _internal_mutable_store_ui_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.store_ui_config)
  return _msg;
}

// uint32 set_ignored_node = 47;
inline bool AdminMessage::_internal_has_set_ignored_node() const {
  return payload_variant_case() == kSetIgnoredNode;
}
inline bool AdminMessage::has_set_ignored_node() const {
  return _internal_has_set_ignored_node();
}
inline void AdminMessage::set_has_set_ignored_node() {
  _impl_._oneof_case_[0] = kSetIgnoredNode;
}
inline void AdminMessage::clear_set_ignored_node() {
  if (_internal_has_set_ignored_node()) {
    _impl_.payload_variant_.set_ignored_node_ = 0u;
    clear_has_payload_variant();
  }
}
inline uint32_t AdminMessage::_internal_set_ignored_node() const {
  if (_internal_has_set_ignored_node()) {
    return _impl_.payload_variant_.set_ignored_node_;
  }
  return 0u;
}
inline void AdminMessage::_internal_set_set_ignored_node(uint32_t value) {
  if (!_internal_has_set_ignored_node()) {
    clear_payload_variant();
    set_has_set_ignored_node();
  }
  _impl_.payload_variant_.set_ignored_node_ = value;
}
inline uint32_t AdminMessage::set_ignored_node() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.set_ignored_node)
  return _internal_set_ignored_node();
}
inline void AdminMessage::set_set_ignored_node(uint32_t value) {
  _internal_set_set_ignored_node(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.set_ignored_node)
}

// uint32 remove_ignored_node = 48;
inline bool AdminMessage::_internal_has_remove_ignored_node() const {
  return payload_variant_case() == kRemoveIgnoredNode;
}
inline bool AdminMessage::has_remove_ignored_node() const {
  return _internal_has_remove_ignored_node();
}
inline void AdminMessage::set_has_remove_ignored_node() {
  _impl_._oneof_case_[0] = kRemoveIgnoredNode;
}
inline void AdminMessage::clear_remove_ignored_node() {
  if (_internal_has_remove_ignored_node()) {
    _impl_.payload_variant_.remove_ignored_node_ = 0u;
    clear_has_payload_variant();
  }
}
inline uint32_t AdminMessage::_internal_remove_ignored_node() const {
  if (_internal_has_remove_ignored_node()) {
    return _impl_.payload_variant_.remove_ignored_node_;
  }
  return 0u;
}
inline void AdminMessage::_internal_set_remove_ignored_node(uint32_t value) {
  if (!_internal_has_remove_ignored_node()) {
    clear_payload_variant();
    set_has_remove_ignored_node();
  }
  _impl_.payload_variant_.remove_ignored_node_ = value;
}
inline uint32_t AdminMessage::remove_ignored_node() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.remove_ignored_node)
  return _internal_remove_ignored_node();
}
inline void AdminMessage::set_remove_ignored_node(uint32_t value) {
  _internal_set_remove_ignored_node(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.remove_ignored_node)
}

// bool begin_edit_settings = 64;
inline bool AdminMessage::_internal_has_begin_edit_settings() const {
  return payload_variant_case() == kBeginEditSettings;
}
inline bool AdminMessage::has_begin_edit_settings() const {
  return _internal_has_begin_edit_settings();
}
inline void AdminMessage::set_has_begin_edit_settings() {
  _impl_._oneof_case_[0] = kBeginEditSettings;
}
inline void AdminMessage::clear_begin_edit_settings() {
  if (_internal_has_begin_edit_settings()) {
    _impl_.payload_variant_.begin_edit_settings_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_begin_edit_settings() const {
  if (_internal_has_begin_edit_settings()) {
    return _impl_.payload_variant_.begin_edit_settings_;
  }
  return false;
}
inline void AdminMessage::_internal_set_begin_edit_settings(bool value) {
  if (!_internal_has_begin_edit_settings()) {
    clear_payload_variant();
    set_has_begin_edit_settings();
  }
  _impl_.payload_variant_.begin_edit_settings_ = value;
}
inline bool AdminMessage::begin_edit_settings() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.begin_edit_settings)
  return _internal_begin_edit_settings();
}
inline void AdminMessage::set_begin_edit_settings(bool value) {
  _internal_set_begin_edit_settings(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.begin_edit_settings)
}

// bool commit_edit_settings = 65;
inline bool AdminMessage::_internal_has_commit_edit_settings() const {
  return payload_variant_case() == kCommitEditSettings;
}
inline bool AdminMessage::has_commit_edit_settings() const {
  return _internal_has_commit_edit_settings();
}
inline void AdminMessage::set_has_commit_edit_settings() {
  _impl_._oneof_case_[0] = kCommitEditSettings;
}
inline void AdminMessage::clear_commit_edit_settings() {
  if (_internal_has_commit_edit_settings()) {
    _impl_.payload_variant_.commit_edit_settings_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_commit_edit_settings() const {
  if (_internal_has_commit_edit_settings()) {
    return _impl_.payload_variant_.commit_edit_settings_;
  }
  return false;
}
inline void AdminMessage::_internal_set_commit_edit_settings(bool value) {
  if (!_internal_has_commit_edit_settings()) {
    clear_payload_variant();
    set_has_commit_edit_settings();
  }
  _impl_.payload_variant_.commit_edit_settings_ = value;
}
inline bool AdminMessage::commit_edit_settings() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.commit_edit_settings)
  return _internal_commit_edit_settings();
}
inline void AdminMessage::set_commit_edit_settings(bool value) {
  _internal_set_commit_edit_settings(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.commit_edit_settings)
}

// .meshtastic.SharedContact add_contact = 66;
inline bool AdminMessage::_internal_has_add_contact() const {
  return payload_variant_case() == kAddContact;
}
inline bool AdminMessage::has_add_contact() const {
  return _internal_has_add_contact();
}
inline void AdminMessage::set_has_add_contact() {
  _impl_._oneof_case_[0] = kAddContact;
}
inline void AdminMessage::clear_add_contact() {
  if (_internal_has_add_contact()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.add_contact_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::SharedContact* AdminMessage::release_add_contact() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.add_contact)
  if (_internal_has_add_contact()) {
    clear_has_payload_variant();
    ::meshtastic::SharedContact* temp = _impl_.payload_variant_.add_contact_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.add_contact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::SharedContact& AdminMessage::_internal_add_contact() const {
  return _internal_has_add_contact()
      ? *_impl_.payload_variant_.add_contact_
      : reinterpret_cast< ::meshtastic::SharedContact&>(::meshtastic::_SharedContact_default_instance_);
}
inline const ::meshtastic::SharedContact& AdminMessage::add_contact() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.add_contact)
  return _internal_add_contact();
}
inline ::meshtastic::SharedContact* AdminMessage::unsafe_arena_release_add_contact() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.add_contact)
  if (_internal_has_add_contact()) {
    clear_has_payload_variant();
    ::meshtastic::SharedContact* temp = _impl_.payload_variant_.add_contact_;
    _impl_.payload_variant_.add_contact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_add_contact(::meshtastic::SharedContact* add_contact) {
  clear_payload_variant();
  if (add_contact) {
    set_has_add_contact();
    _impl_.payload_variant_.add_contact_ = add_contact;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.add_contact)
}
inline ::meshtastic::SharedContact* AdminMessage::_internal_mutable_add_contact() {
  if (!_internal_has_add_contact()) {
    clear_payload_variant();
    set_has_add_contact();
    _impl_.payload_variant_.add_contact_ = CreateMaybeMessage< ::meshtastic::SharedContact >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.add_contact_;
}
inline ::meshtastic::SharedContact* AdminMessage::mutable_add_contact() {
  ::meshtastic::SharedContact* _msg = _internal_mutable_add_contact();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.add_contact)
  return _msg;
}

// .meshtastic.KeyVerificationAdmin key_verification = 67;
inline bool AdminMessage::_internal_has_key_verification() const {
  return payload_variant_case() == kKeyVerification;
}
inline bool AdminMessage::has_key_verification() const {
  return _internal_has_key_verification();
}
inline void AdminMessage::set_has_key_verification() {
  _impl_._oneof_case_[0] = kKeyVerification;
}
inline void AdminMessage::clear_key_verification() {
  if (_internal_has_key_verification()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.key_verification_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::KeyVerificationAdmin* AdminMessage::release_key_verification() {
  // @@protoc_insertion_point(field_release:meshtastic.AdminMessage.key_verification)
  if (_internal_has_key_verification()) {
    clear_has_payload_variant();
    ::meshtastic::KeyVerificationAdmin* temp = _impl_.payload_variant_.key_verification_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.key_verification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::KeyVerificationAdmin& AdminMessage::_internal_key_verification() const {
  return _internal_has_key_verification()
      ? *_impl_.payload_variant_.key_verification_
      : reinterpret_cast< ::meshtastic::KeyVerificationAdmin&>(::meshtastic::_KeyVerificationAdmin_default_instance_);
}
inline const ::meshtastic::KeyVerificationAdmin& AdminMessage::key_verification() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.key_verification)
  return _internal_key_verification();
}
inline ::meshtastic::KeyVerificationAdmin* AdminMessage::unsafe_arena_release_key_verification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.AdminMessage.key_verification)
  if (_internal_has_key_verification()) {
    clear_has_payload_variant();
    ::meshtastic::KeyVerificationAdmin* temp = _impl_.payload_variant_.key_verification_;
    _impl_.payload_variant_.key_verification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AdminMessage::unsafe_arena_set_allocated_key_verification(::meshtastic::KeyVerificationAdmin* key_verification) {
  clear_payload_variant();
  if (key_verification) {
    set_has_key_verification();
    _impl_.payload_variant_.key_verification_ = key_verification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.AdminMessage.key_verification)
}
inline ::meshtastic::KeyVerificationAdmin* AdminMessage::_internal_mutable_key_verification() {
  if (!_internal_has_key_verification()) {
    clear_payload_variant();
    set_has_key_verification();
    _impl_.payload_variant_.key_verification_ = CreateMaybeMessage< ::meshtastic::KeyVerificationAdmin >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.key_verification_;
}
inline ::meshtastic::KeyVerificationAdmin* AdminMessage::mutable_key_verification() {
  ::meshtastic::KeyVerificationAdmin* _msg = _internal_mutable_key_verification();
  // @@protoc_insertion_point(field_mutable:meshtastic.AdminMessage.key_verification)
  return _msg;
}

// int32 factory_reset_device = 94;
inline bool AdminMessage::_internal_has_factory_reset_device() const {
  return payload_variant_case() == kFactoryResetDevice;
}
inline bool AdminMessage::has_factory_reset_device() const {
  return _internal_has_factory_reset_device();
}
inline void AdminMessage::set_has_factory_reset_device() {
  _impl_._oneof_case_[0] = kFactoryResetDevice;
}
inline void AdminMessage::clear_factory_reset_device() {
  if (_internal_has_factory_reset_device()) {
    _impl_.payload_variant_.factory_reset_device_ = 0;
    clear_has_payload_variant();
  }
}
inline int32_t AdminMessage::_internal_factory_reset_device() const {
  if (_internal_has_factory_reset_device()) {
    return _impl_.payload_variant_.factory_reset_device_;
  }
  return 0;
}
inline void AdminMessage::_internal_set_factory_reset_device(int32_t value) {
  if (!_internal_has_factory_reset_device()) {
    clear_payload_variant();
    set_has_factory_reset_device();
  }
  _impl_.payload_variant_.factory_reset_device_ = value;
}
inline int32_t AdminMessage::factory_reset_device() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.factory_reset_device)
  return _internal_factory_reset_device();
}
inline void AdminMessage::set_factory_reset_device(int32_t value) {
  _internal_set_factory_reset_device(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.factory_reset_device)
}

// int32 reboot_ota_seconds = 95;
inline bool AdminMessage::_internal_has_reboot_ota_seconds() const {
  return payload_variant_case() == kRebootOtaSeconds;
}
inline bool AdminMessage::has_reboot_ota_seconds() const {
  return _internal_has_reboot_ota_seconds();
}
inline void AdminMessage::set_has_reboot_ota_seconds() {
  _impl_._oneof_case_[0] = kRebootOtaSeconds;
}
inline void AdminMessage::clear_reboot_ota_seconds() {
  if (_internal_has_reboot_ota_seconds()) {
    _impl_.payload_variant_.reboot_ota_seconds_ = 0;
    clear_has_payload_variant();
  }
}
inline int32_t AdminMessage::_internal_reboot_ota_seconds() const {
  if (_internal_has_reboot_ota_seconds()) {
    return _impl_.payload_variant_.reboot_ota_seconds_;
  }
  return 0;
}
inline void AdminMessage::_internal_set_reboot_ota_seconds(int32_t value) {
  if (!_internal_has_reboot_ota_seconds()) {
    clear_payload_variant();
    set_has_reboot_ota_seconds();
  }
  _impl_.payload_variant_.reboot_ota_seconds_ = value;
}
inline int32_t AdminMessage::reboot_ota_seconds() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.reboot_ota_seconds)
  return _internal_reboot_ota_seconds();
}
inline void AdminMessage::set_reboot_ota_seconds(int32_t value) {
  _internal_set_reboot_ota_seconds(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.reboot_ota_seconds)
}

// bool exit_simulator = 96;
inline bool AdminMessage::_internal_has_exit_simulator() const {
  return payload_variant_case() == kExitSimulator;
}
inline bool AdminMessage::has_exit_simulator() const {
  return _internal_has_exit_simulator();
}
inline void AdminMessage::set_has_exit_simulator() {
  _impl_._oneof_case_[0] = kExitSimulator;
}
inline void AdminMessage::clear_exit_simulator() {
  if (_internal_has_exit_simulator()) {
    _impl_.payload_variant_.exit_simulator_ = false;
    clear_has_payload_variant();
  }
}
inline bool AdminMessage::_internal_exit_simulator() const {
  if (_internal_has_exit_simulator()) {
    return _impl_.payload_variant_.exit_simulator_;
  }
  return false;
}
inline void AdminMessage::_internal_set_exit_simulator(bool value) {
  if (!_internal_has_exit_simulator()) {
    clear_payload_variant();
    set_has_exit_simulator();
  }
  _impl_.payload_variant_.exit_simulator_ = value;
}
inline bool AdminMessage::exit_simulator() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.exit_simulator)
  return _internal_exit_simulator();
}
inline void AdminMessage::set_exit_simulator(bool value) {
  _internal_set_exit_simulator(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.exit_simulator)
}

// int32 reboot_seconds = 97;
inline bool AdminMessage::_internal_has_reboot_seconds() const {
  return payload_variant_case() == kRebootSeconds;
}
inline bool AdminMessage::has_reboot_seconds() const {
  return _internal_has_reboot_seconds();
}
inline void AdminMessage::set_has_reboot_seconds() {
  _impl_._oneof_case_[0] = kRebootSeconds;
}
inline void AdminMessage::clear_reboot_seconds() {
  if (_internal_has_reboot_seconds()) {
    _impl_.payload_variant_.reboot_seconds_ = 0;
    clear_has_payload_variant();
  }
}
inline int32_t AdminMessage::_internal_reboot_seconds() const {
  if (_internal_has_reboot_seconds()) {
    return _impl_.payload_variant_.reboot_seconds_;
  }
  return 0;
}
inline void AdminMessage::_internal_set_reboot_seconds(int32_t value) {
  if (!_internal_has_reboot_seconds()) {
    clear_payload_variant();
    set_has_reboot_seconds();
  }
  _impl_.payload_variant_.reboot_seconds_ = value;
}
inline int32_t AdminMessage::reboot_seconds() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.reboot_seconds)
  return _internal_reboot_seconds();
}
inline void AdminMessage::set_reboot_seconds(int32_t value) {
  _internal_set_reboot_seconds(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.reboot_seconds)
}

// int32 shutdown_seconds = 98;
inline bool AdminMessage::_internal_has_shutdown_seconds() const {
  return payload_variant_case() == kShutdownSeconds;
}
inline bool AdminMessage::has_shutdown_seconds() const {
  return _internal_has_shutdown_seconds();
}
inline void AdminMessage::set_has_shutdown_seconds() {
  _impl_._oneof_case_[0] = kShutdownSeconds;
}
inline void AdminMessage::clear_shutdown_seconds() {
  if (_internal_has_shutdown_seconds()) {
    _impl_.payload_variant_.shutdown_seconds_ = 0;
    clear_has_payload_variant();
  }
}
inline int32_t AdminMessage::_internal_shutdown_seconds() const {
  if (_internal_has_shutdown_seconds()) {
    return _impl_.payload_variant_.shutdown_seconds_;
  }
  return 0;
}
inline void AdminMessage::_internal_set_shutdown_seconds(int32_t value) {
  if (!_internal_has_shutdown_seconds()) {
    clear_payload_variant();
    set_has_shutdown_seconds();
  }
  _impl_.payload_variant_.shutdown_seconds_ = value;
}
inline int32_t AdminMessage::shutdown_seconds() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.shutdown_seconds)
  return _internal_shutdown_seconds();
}
inline void AdminMessage::set_shutdown_seconds(int32_t value) {
  _internal_set_shutdown_seconds(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.shutdown_seconds)
}

// int32 factory_reset_config = 99;
inline bool AdminMessage::_internal_has_factory_reset_config() const {
  return payload_variant_case() == kFactoryResetConfig;
}
inline bool AdminMessage::has_factory_reset_config() const {
  return _internal_has_factory_reset_config();
}
inline void AdminMessage::set_has_factory_reset_config() {
  _impl_._oneof_case_[0] = kFactoryResetConfig;
}
inline void AdminMessage::clear_factory_reset_config() {
  if (_internal_has_factory_reset_config()) {
    _impl_.payload_variant_.factory_reset_config_ = 0;
    clear_has_payload_variant();
  }
}
inline int32_t AdminMessage::_internal_factory_reset_config() const {
  if (_internal_has_factory_reset_config()) {
    return _impl_.payload_variant_.factory_reset_config_;
  }
  return 0;
}
inline void AdminMessage::_internal_set_factory_reset_config(int32_t value) {
  if (!_internal_has_factory_reset_config()) {
    clear_payload_variant();
    set_has_factory_reset_config();
  }
  _impl_.payload_variant_.factory_reset_config_ = value;
}
inline int32_t AdminMessage::factory_reset_config() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.factory_reset_config)
  return _internal_factory_reset_config();
}
inline void AdminMessage::set_factory_reset_config(int32_t value) {
  _internal_set_factory_reset_config(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.factory_reset_config)
}

// int32 nodedb_reset = 100;
inline bool AdminMessage::_internal_has_nodedb_reset() const {
  return payload_variant_case() == kNodedbReset;
}
inline bool AdminMessage::has_nodedb_reset() const {
  return _internal_has_nodedb_reset();
}
inline void AdminMessage::set_has_nodedb_reset() {
  _impl_._oneof_case_[0] = kNodedbReset;
}
inline void AdminMessage::clear_nodedb_reset() {
  if (_internal_has_nodedb_reset()) {
    _impl_.payload_variant_.nodedb_reset_ = 0;
    clear_has_payload_variant();
  }
}
inline int32_t AdminMessage::_internal_nodedb_reset() const {
  if (_internal_has_nodedb_reset()) {
    return _impl_.payload_variant_.nodedb_reset_;
  }
  return 0;
}
inline void AdminMessage::_internal_set_nodedb_reset(int32_t value) {
  if (!_internal_has_nodedb_reset()) {
    clear_payload_variant();
    set_has_nodedb_reset();
  }
  _impl_.payload_variant_.nodedb_reset_ = value;
}
inline int32_t AdminMessage::nodedb_reset() const {
  // @@protoc_insertion_point(field_get:meshtastic.AdminMessage.nodedb_reset)
  return _internal_nodedb_reset();
}
inline void AdminMessage::set_nodedb_reset(int32_t value) {
  _internal_set_nodedb_reset(value);
  // @@protoc_insertion_point(field_set:meshtastic.AdminMessage.nodedb_reset)
}

inline bool AdminMessage::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void AdminMessage::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline AdminMessage::PayloadVariantCase AdminMessage::payload_variant_case() const {
  return AdminMessage::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// HamParameters

// string call_sign = 1;
inline void HamParameters::clear_call_sign() {
  _impl_.call_sign_.ClearToEmpty();
}
inline const std::string& HamParameters::call_sign() const {
  // @@protoc_insertion_point(field_get:meshtastic.HamParameters.call_sign)
  return _internal_call_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HamParameters::set_call_sign(ArgT0&& arg0, ArgT... args) {
 
 _impl_.call_sign_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.HamParameters.call_sign)
}
inline std::string* HamParameters::mutable_call_sign() {
  std::string* _s = _internal_mutable_call_sign();
  // @@protoc_insertion_point(field_mutable:meshtastic.HamParameters.call_sign)
  return _s;
}
inline const std::string& HamParameters::_internal_call_sign() const {
  return _impl_.call_sign_.Get();
}
inline void HamParameters::_internal_set_call_sign(const std::string& value) {
  
  _impl_.call_sign_.Set(value, GetArenaForAllocation());
}
inline std::string* HamParameters::_internal_mutable_call_sign() {
  
  return _impl_.call_sign_.Mutable(GetArenaForAllocation());
}
inline std::string* HamParameters::release_call_sign() {
  // @@protoc_insertion_point(field_release:meshtastic.HamParameters.call_sign)
  return _impl_.call_sign_.Release();
}
inline void HamParameters::set_allocated_call_sign(std::string* call_sign) {
  if (call_sign != nullptr) {
    
  } else {
    
  }
  _impl_.call_sign_.SetAllocated(call_sign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.call_sign_.IsDefault()) {
    _impl_.call_sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.HamParameters.call_sign)
}

// int32 tx_power = 2;
inline void HamParameters::clear_tx_power() {
  _impl_.tx_power_ = 0;
}
inline int32_t HamParameters::_internal_tx_power() const {
  return _impl_.tx_power_;
}
inline int32_t HamParameters::tx_power() const {
  // @@protoc_insertion_point(field_get:meshtastic.HamParameters.tx_power)
  return _internal_tx_power();
}
inline void HamParameters::_internal_set_tx_power(int32_t value) {
  
  _impl_.tx_power_ = value;
}
inline void HamParameters::set_tx_power(int32_t value) {
  _internal_set_tx_power(value);
  // @@protoc_insertion_point(field_set:meshtastic.HamParameters.tx_power)
}

// float frequency = 3;
inline void HamParameters::clear_frequency() {
  _impl_.frequency_ = 0;
}
inline float HamParameters::_internal_frequency() const {
  return _impl_.frequency_;
}
inline float HamParameters::frequency() const {
  // @@protoc_insertion_point(field_get:meshtastic.HamParameters.frequency)
  return _internal_frequency();
}
inline void HamParameters::_internal_set_frequency(float value) {
  
  _impl_.frequency_ = value;
}
inline void HamParameters::set_frequency(float value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:meshtastic.HamParameters.frequency)
}

// string short_name = 4;
inline void HamParameters::clear_short_name() {
  _impl_.short_name_.ClearToEmpty();
}
inline const std::string& HamParameters::short_name() const {
  // @@protoc_insertion_point(field_get:meshtastic.HamParameters.short_name)
  return _internal_short_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HamParameters::set_short_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.short_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.HamParameters.short_name)
}
inline std::string* HamParameters::mutable_short_name() {
  std::string* _s = _internal_mutable_short_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.HamParameters.short_name)
  return _s;
}
inline const std::string& HamParameters::_internal_short_name() const {
  return _impl_.short_name_.Get();
}
inline void HamParameters::_internal_set_short_name(const std::string& value) {
  
  _impl_.short_name_.Set(value, GetArenaForAllocation());
}
inline std::string* HamParameters::_internal_mutable_short_name() {
  
  return _impl_.short_name_.Mutable(GetArenaForAllocation());
}
inline std::string* HamParameters::release_short_name() {
  // @@protoc_insertion_point(field_release:meshtastic.HamParameters.short_name)
  return _impl_.short_name_.Release();
}
inline void HamParameters::set_allocated_short_name(std::string* short_name) {
  if (short_name != nullptr) {
    
  } else {
    
  }
  _impl_.short_name_.SetAllocated(short_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.short_name_.IsDefault()) {
    _impl_.short_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.HamParameters.short_name)
}

// -------------------------------------------------------------------

// NodeRemoteHardwarePinsResponse

// repeated .meshtastic.NodeRemoteHardwarePin node_remote_hardware_pins = 1;
inline int NodeRemoteHardwarePinsResponse::_internal_node_remote_hardware_pins_size() const {
  return _impl_.node_remote_hardware_pins_.size();
}
inline int NodeRemoteHardwarePinsResponse::node_remote_hardware_pins_size() const {
  return _internal_node_remote_hardware_pins_size();
}
inline ::meshtastic::NodeRemoteHardwarePin* NodeRemoteHardwarePinsResponse::mutable_node_remote_hardware_pins(int index) {
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeRemoteHardwarePinsResponse.node_remote_hardware_pins)
  return _impl_.node_remote_hardware_pins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin >*
NodeRemoteHardwarePinsResponse::mutable_node_remote_hardware_pins() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.NodeRemoteHardwarePinsResponse.node_remote_hardware_pins)
  return &_impl_.node_remote_hardware_pins_;
}
inline const ::meshtastic::NodeRemoteHardwarePin& NodeRemoteHardwarePinsResponse::_internal_node_remote_hardware_pins(int index) const {
  return _impl_.node_remote_hardware_pins_.Get(index);
}
inline const ::meshtastic::NodeRemoteHardwarePin& NodeRemoteHardwarePinsResponse::node_remote_hardware_pins(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeRemoteHardwarePinsResponse.node_remote_hardware_pins)
  return _internal_node_remote_hardware_pins(index);
}
inline ::meshtastic::NodeRemoteHardwarePin* NodeRemoteHardwarePinsResponse::_internal_add_node_remote_hardware_pins() {
  return _impl_.node_remote_hardware_pins_.Add();
}
inline ::meshtastic::NodeRemoteHardwarePin* NodeRemoteHardwarePinsResponse::add_node_remote_hardware_pins() {
  ::meshtastic::NodeRemoteHardwarePin* _add = _internal_add_node_remote_hardware_pins();
  // @@protoc_insertion_point(field_add:meshtastic.NodeRemoteHardwarePinsResponse.node_remote_hardware_pins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin >&
NodeRemoteHardwarePinsResponse::node_remote_hardware_pins() const {
  // @@protoc_insertion_point(field_list:meshtastic.NodeRemoteHardwarePinsResponse.node_remote_hardware_pins)
  return _impl_.node_remote_hardware_pins_;
}

// -------------------------------------------------------------------

// SharedContact

// uint32 node_num = 1;
inline void SharedContact::clear_node_num() {
  _impl_.node_num_ = 0u;
}
inline uint32_t SharedContact::_internal_node_num() const {
  return _impl_.node_num_;
}
inline uint32_t SharedContact::node_num() const {
  // @@protoc_insertion_point(field_get:meshtastic.SharedContact.node_num)
  return _internal_node_num();
}
inline void SharedContact::_internal_set_node_num(uint32_t value) {
  
  _impl_.node_num_ = value;
}
inline void SharedContact::set_node_num(uint32_t value) {
  _internal_set_node_num(value);
  // @@protoc_insertion_point(field_set:meshtastic.SharedContact.node_num)
}

// .meshtastic.User user = 2;
inline bool SharedContact::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool SharedContact::has_user() const {
  return _internal_has_user();
}
inline const ::meshtastic::User& SharedContact::_internal_user() const {
  const ::meshtastic::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::User&>(
      ::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& SharedContact::user() const {
  // @@protoc_insertion_point(field_get:meshtastic.SharedContact.user)
  return _internal_user();
}
inline void SharedContact::unsafe_arena_set_allocated_user(
    ::meshtastic::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.SharedContact.user)
}
inline ::meshtastic::User* SharedContact::release_user() {
  
  ::meshtastic::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::User* SharedContact::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:meshtastic.SharedContact.user)
  
  ::meshtastic::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::meshtastic::User* SharedContact::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::meshtastic::User* SharedContact::mutable_user() {
  ::meshtastic::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:meshtastic.SharedContact.user)
  return _msg;
}
inline void SharedContact::set_allocated_user(::meshtastic::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user));
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.SharedContact.user)
}

// bool should_ignore = 3;
inline void SharedContact::clear_should_ignore() {
  _impl_.should_ignore_ = false;
}
inline bool SharedContact::_internal_should_ignore() const {
  return _impl_.should_ignore_;
}
inline bool SharedContact::should_ignore() const {
  // @@protoc_insertion_point(field_get:meshtastic.SharedContact.should_ignore)
  return _internal_should_ignore();
}
inline void SharedContact::_internal_set_should_ignore(bool value) {
  
  _impl_.should_ignore_ = value;
}
inline void SharedContact::set_should_ignore(bool value) {
  _internal_set_should_ignore(value);
  // @@protoc_insertion_point(field_set:meshtastic.SharedContact.should_ignore)
}

// -------------------------------------------------------------------

// KeyVerificationAdmin

// .meshtastic.KeyVerificationAdmin.MessageType message_type = 1;
inline void KeyVerificationAdmin::clear_message_type() {
  _impl_.message_type_ = 0;
}
inline ::meshtastic::KeyVerificationAdmin_MessageType KeyVerificationAdmin::_internal_message_type() const {
  return static_cast< ::meshtastic::KeyVerificationAdmin_MessageType >(_impl_.message_type_);
}
inline ::meshtastic::KeyVerificationAdmin_MessageType KeyVerificationAdmin::message_type() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationAdmin.message_type)
  return _internal_message_type();
}
inline void KeyVerificationAdmin::_internal_set_message_type(::meshtastic::KeyVerificationAdmin_MessageType value) {
  
  _impl_.message_type_ = value;
}
inline void KeyVerificationAdmin::set_message_type(::meshtastic::KeyVerificationAdmin_MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationAdmin.message_type)
}

// uint32 remote_nodenum = 2;
inline void KeyVerificationAdmin::clear_remote_nodenum() {
  _impl_.remote_nodenum_ = 0u;
}
inline uint32_t KeyVerificationAdmin::_internal_remote_nodenum() const {
  return _impl_.remote_nodenum_;
}
inline uint32_t KeyVerificationAdmin::remote_nodenum() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationAdmin.remote_nodenum)
  return _internal_remote_nodenum();
}
inline void KeyVerificationAdmin::_internal_set_remote_nodenum(uint32_t value) {
  
  _impl_.remote_nodenum_ = value;
}
inline void KeyVerificationAdmin::set_remote_nodenum(uint32_t value) {
  _internal_set_remote_nodenum(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationAdmin.remote_nodenum)
}

// uint64 nonce = 3;
inline void KeyVerificationAdmin::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t KeyVerificationAdmin::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t KeyVerificationAdmin::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationAdmin.nonce)
  return _internal_nonce();
}
inline void KeyVerificationAdmin::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void KeyVerificationAdmin::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationAdmin.nonce)
}

// optional uint32 security_number = 4;
inline bool KeyVerificationAdmin::_internal_has_security_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyVerificationAdmin::has_security_number() const {
  return _internal_has_security_number();
}
inline void KeyVerificationAdmin::clear_security_number() {
  _impl_.security_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t KeyVerificationAdmin::_internal_security_number() const {
  return _impl_.security_number_;
}
inline uint32_t KeyVerificationAdmin::security_number() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationAdmin.security_number)
  return _internal_security_number();
}
inline void KeyVerificationAdmin::_internal_set_security_number(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.security_number_ = value;
}
inline void KeyVerificationAdmin::set_security_number(uint32_t value) {
  _internal_set_security_number(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationAdmin.security_number)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meshtastic

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::meshtastic::AdminMessage_ConfigType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::AdminMessage_ConfigType>() {
  return ::meshtastic::AdminMessage_ConfigType_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::AdminMessage_ModuleConfigType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::AdminMessage_ModuleConfigType>() {
  return ::meshtastic::AdminMessage_ModuleConfigType_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::AdminMessage_BackupLocation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::AdminMessage_BackupLocation>() {
  return ::meshtastic::AdminMessage_BackupLocation_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::KeyVerificationAdmin_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::KeyVerificationAdmin_MessageType>() {
  return ::meshtastic::KeyVerificationAdmin_MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fadmin_2eproto
