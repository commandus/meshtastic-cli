// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meshtastic/localonly.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_meshtastic_2flocalonly_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_meshtastic_2flocalonly_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "meshtastic/config.pb.h"
#include "meshtastic/module_config.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_meshtastic_2flocalonly_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_meshtastic_2flocalonly_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_meshtastic_2flocalonly_2eproto;
namespace meshtastic {
class LocalConfig;
struct LocalConfigDefaultTypeInternal;
extern LocalConfigDefaultTypeInternal _LocalConfig_default_instance_;
class LocalModuleConfig;
struct LocalModuleConfigDefaultTypeInternal;
extern LocalModuleConfigDefaultTypeInternal _LocalModuleConfig_default_instance_;
}  // namespace meshtastic
PROTOBUF_NAMESPACE_OPEN
template<> ::meshtastic::LocalConfig* Arena::CreateMaybeMessage<::meshtastic::LocalConfig>(Arena*);
template<> ::meshtastic::LocalModuleConfig* Arena::CreateMaybeMessage<::meshtastic::LocalModuleConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace meshtastic {

// ===================================================================

class LocalConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.LocalConfig) */ {
 public:
  inline LocalConfig() : LocalConfig(nullptr) {}
  ~LocalConfig() override;
  explicit PROTOBUF_CONSTEXPR LocalConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalConfig(const LocalConfig& from);
  LocalConfig(LocalConfig&& from) noexcept
    : LocalConfig() {
    *this = ::std::move(from);
  }

  inline LocalConfig& operator=(const LocalConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalConfig& operator=(LocalConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalConfig* internal_default_instance() {
    return reinterpret_cast<const LocalConfig*>(
               &_LocalConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LocalConfig& a, LocalConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalConfig& from) {
    LocalConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.LocalConfig";
  }
  protected:
  explicit LocalConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kPositionFieldNumber = 2,
    kPowerFieldNumber = 3,
    kNetworkFieldNumber = 4,
    kDisplayFieldNumber = 5,
    kLoraFieldNumber = 6,
    kBluetoothFieldNumber = 7,
    kSecurityFieldNumber = 9,
    kVersionFieldNumber = 8,
  };
  // .meshtastic.Config.DeviceConfig device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::meshtastic::Config_DeviceConfig& device() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_DeviceConfig* release_device();
  ::meshtastic::Config_DeviceConfig* mutable_device();
  void set_allocated_device(::meshtastic::Config_DeviceConfig* device);
  private:
  const ::meshtastic::Config_DeviceConfig& _internal_device() const;
  ::meshtastic::Config_DeviceConfig* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::meshtastic::Config_DeviceConfig* device);
  ::meshtastic::Config_DeviceConfig* unsafe_arena_release_device();

  // .meshtastic.Config.PositionConfig position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::meshtastic::Config_PositionConfig& position() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_PositionConfig* release_position();
  ::meshtastic::Config_PositionConfig* mutable_position();
  void set_allocated_position(::meshtastic::Config_PositionConfig* position);
  private:
  const ::meshtastic::Config_PositionConfig& _internal_position() const;
  ::meshtastic::Config_PositionConfig* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::meshtastic::Config_PositionConfig* position);
  ::meshtastic::Config_PositionConfig* unsafe_arena_release_position();

  // .meshtastic.Config.PowerConfig power = 3;
  bool has_power() const;
  private:
  bool _internal_has_power() const;
  public:
  void clear_power();
  const ::meshtastic::Config_PowerConfig& power() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_PowerConfig* release_power();
  ::meshtastic::Config_PowerConfig* mutable_power();
  void set_allocated_power(::meshtastic::Config_PowerConfig* power);
  private:
  const ::meshtastic::Config_PowerConfig& _internal_power() const;
  ::meshtastic::Config_PowerConfig* _internal_mutable_power();
  public:
  void unsafe_arena_set_allocated_power(
      ::meshtastic::Config_PowerConfig* power);
  ::meshtastic::Config_PowerConfig* unsafe_arena_release_power();

  // .meshtastic.Config.NetworkConfig network = 4;
  bool has_network() const;
  private:
  bool _internal_has_network() const;
  public:
  void clear_network();
  const ::meshtastic::Config_NetworkConfig& network() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_NetworkConfig* release_network();
  ::meshtastic::Config_NetworkConfig* mutable_network();
  void set_allocated_network(::meshtastic::Config_NetworkConfig* network);
  private:
  const ::meshtastic::Config_NetworkConfig& _internal_network() const;
  ::meshtastic::Config_NetworkConfig* _internal_mutable_network();
  public:
  void unsafe_arena_set_allocated_network(
      ::meshtastic::Config_NetworkConfig* network);
  ::meshtastic::Config_NetworkConfig* unsafe_arena_release_network();

  // .meshtastic.Config.DisplayConfig display = 5;
  bool has_display() const;
  private:
  bool _internal_has_display() const;
  public:
  void clear_display();
  const ::meshtastic::Config_DisplayConfig& display() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_DisplayConfig* release_display();
  ::meshtastic::Config_DisplayConfig* mutable_display();
  void set_allocated_display(::meshtastic::Config_DisplayConfig* display);
  private:
  const ::meshtastic::Config_DisplayConfig& _internal_display() const;
  ::meshtastic::Config_DisplayConfig* _internal_mutable_display();
  public:
  void unsafe_arena_set_allocated_display(
      ::meshtastic::Config_DisplayConfig* display);
  ::meshtastic::Config_DisplayConfig* unsafe_arena_release_display();

  // .meshtastic.Config.LoRaConfig lora = 6;
  bool has_lora() const;
  private:
  bool _internal_has_lora() const;
  public:
  void clear_lora();
  const ::meshtastic::Config_LoRaConfig& lora() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_LoRaConfig* release_lora();
  ::meshtastic::Config_LoRaConfig* mutable_lora();
  void set_allocated_lora(::meshtastic::Config_LoRaConfig* lora);
  private:
  const ::meshtastic::Config_LoRaConfig& _internal_lora() const;
  ::meshtastic::Config_LoRaConfig* _internal_mutable_lora();
  public:
  void unsafe_arena_set_allocated_lora(
      ::meshtastic::Config_LoRaConfig* lora);
  ::meshtastic::Config_LoRaConfig* unsafe_arena_release_lora();

  // .meshtastic.Config.BluetoothConfig bluetooth = 7;
  bool has_bluetooth() const;
  private:
  bool _internal_has_bluetooth() const;
  public:
  void clear_bluetooth();
  const ::meshtastic::Config_BluetoothConfig& bluetooth() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_BluetoothConfig* release_bluetooth();
  ::meshtastic::Config_BluetoothConfig* mutable_bluetooth();
  void set_allocated_bluetooth(::meshtastic::Config_BluetoothConfig* bluetooth);
  private:
  const ::meshtastic::Config_BluetoothConfig& _internal_bluetooth() const;
  ::meshtastic::Config_BluetoothConfig* _internal_mutable_bluetooth();
  public:
  void unsafe_arena_set_allocated_bluetooth(
      ::meshtastic::Config_BluetoothConfig* bluetooth);
  ::meshtastic::Config_BluetoothConfig* unsafe_arena_release_bluetooth();

  // .meshtastic.Config.SecurityConfig security = 9;
  bool has_security() const;
  private:
  bool _internal_has_security() const;
  public:
  void clear_security();
  const ::meshtastic::Config_SecurityConfig& security() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_SecurityConfig* release_security();
  ::meshtastic::Config_SecurityConfig* mutable_security();
  void set_allocated_security(::meshtastic::Config_SecurityConfig* security);
  private:
  const ::meshtastic::Config_SecurityConfig& _internal_security() const;
  ::meshtastic::Config_SecurityConfig* _internal_mutable_security();
  public:
  void unsafe_arena_set_allocated_security(
      ::meshtastic::Config_SecurityConfig* security);
  ::meshtastic::Config_SecurityConfig* unsafe_arena_release_security();

  // uint32 version = 8;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.LocalConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::meshtastic::Config_DeviceConfig* device_;
    ::meshtastic::Config_PositionConfig* position_;
    ::meshtastic::Config_PowerConfig* power_;
    ::meshtastic::Config_NetworkConfig* network_;
    ::meshtastic::Config_DisplayConfig* display_;
    ::meshtastic::Config_LoRaConfig* lora_;
    ::meshtastic::Config_BluetoothConfig* bluetooth_;
    ::meshtastic::Config_SecurityConfig* security_;
    uint32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2flocalonly_2eproto;
};
// -------------------------------------------------------------------

class LocalModuleConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.LocalModuleConfig) */ {
 public:
  inline LocalModuleConfig() : LocalModuleConfig(nullptr) {}
  ~LocalModuleConfig() override;
  explicit PROTOBUF_CONSTEXPR LocalModuleConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalModuleConfig(const LocalModuleConfig& from);
  LocalModuleConfig(LocalModuleConfig&& from) noexcept
    : LocalModuleConfig() {
    *this = ::std::move(from);
  }

  inline LocalModuleConfig& operator=(const LocalModuleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalModuleConfig& operator=(LocalModuleConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalModuleConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalModuleConfig* internal_default_instance() {
    return reinterpret_cast<const LocalModuleConfig*>(
               &_LocalModuleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LocalModuleConfig& a, LocalModuleConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalModuleConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalModuleConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalModuleConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalModuleConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalModuleConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalModuleConfig& from) {
    LocalModuleConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalModuleConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.LocalModuleConfig";
  }
  protected:
  explicit LocalModuleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMqttFieldNumber = 1,
    kSerialFieldNumber = 2,
    kExternalNotificationFieldNumber = 3,
    kStoreForwardFieldNumber = 4,
    kRangeTestFieldNumber = 5,
    kTelemetryFieldNumber = 6,
    kCannedMessageFieldNumber = 7,
    kAudioFieldNumber = 9,
    kRemoteHardwareFieldNumber = 10,
    kNeighborInfoFieldNumber = 11,
    kAmbientLightingFieldNumber = 12,
    kDetectionSensorFieldNumber = 13,
    kPaxcounterFieldNumber = 14,
    kVersionFieldNumber = 8,
  };
  // .meshtastic.ModuleConfig.MQTTConfig mqtt = 1;
  bool has_mqtt() const;
  private:
  bool _internal_has_mqtt() const;
  public:
  void clear_mqtt();
  const ::meshtastic::ModuleConfig_MQTTConfig& mqtt() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_MQTTConfig* release_mqtt();
  ::meshtastic::ModuleConfig_MQTTConfig* mutable_mqtt();
  void set_allocated_mqtt(::meshtastic::ModuleConfig_MQTTConfig* mqtt);
  private:
  const ::meshtastic::ModuleConfig_MQTTConfig& _internal_mqtt() const;
  ::meshtastic::ModuleConfig_MQTTConfig* _internal_mutable_mqtt();
  public:
  void unsafe_arena_set_allocated_mqtt(
      ::meshtastic::ModuleConfig_MQTTConfig* mqtt);
  ::meshtastic::ModuleConfig_MQTTConfig* unsafe_arena_release_mqtt();

  // .meshtastic.ModuleConfig.SerialConfig serial = 2;
  bool has_serial() const;
  private:
  bool _internal_has_serial() const;
  public:
  void clear_serial();
  const ::meshtastic::ModuleConfig_SerialConfig& serial() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_SerialConfig* release_serial();
  ::meshtastic::ModuleConfig_SerialConfig* mutable_serial();
  void set_allocated_serial(::meshtastic::ModuleConfig_SerialConfig* serial);
  private:
  const ::meshtastic::ModuleConfig_SerialConfig& _internal_serial() const;
  ::meshtastic::ModuleConfig_SerialConfig* _internal_mutable_serial();
  public:
  void unsafe_arena_set_allocated_serial(
      ::meshtastic::ModuleConfig_SerialConfig* serial);
  ::meshtastic::ModuleConfig_SerialConfig* unsafe_arena_release_serial();

  // .meshtastic.ModuleConfig.ExternalNotificationConfig external_notification = 3;
  bool has_external_notification() const;
  private:
  bool _internal_has_external_notification() const;
  public:
  void clear_external_notification();
  const ::meshtastic::ModuleConfig_ExternalNotificationConfig& external_notification() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_ExternalNotificationConfig* release_external_notification();
  ::meshtastic::ModuleConfig_ExternalNotificationConfig* mutable_external_notification();
  void set_allocated_external_notification(::meshtastic::ModuleConfig_ExternalNotificationConfig* external_notification);
  private:
  const ::meshtastic::ModuleConfig_ExternalNotificationConfig& _internal_external_notification() const;
  ::meshtastic::ModuleConfig_ExternalNotificationConfig* _internal_mutable_external_notification();
  public:
  void unsafe_arena_set_allocated_external_notification(
      ::meshtastic::ModuleConfig_ExternalNotificationConfig* external_notification);
  ::meshtastic::ModuleConfig_ExternalNotificationConfig* unsafe_arena_release_external_notification();

  // .meshtastic.ModuleConfig.StoreForwardConfig store_forward = 4;
  bool has_store_forward() const;
  private:
  bool _internal_has_store_forward() const;
  public:
  void clear_store_forward();
  const ::meshtastic::ModuleConfig_StoreForwardConfig& store_forward() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_StoreForwardConfig* release_store_forward();
  ::meshtastic::ModuleConfig_StoreForwardConfig* mutable_store_forward();
  void set_allocated_store_forward(::meshtastic::ModuleConfig_StoreForwardConfig* store_forward);
  private:
  const ::meshtastic::ModuleConfig_StoreForwardConfig& _internal_store_forward() const;
  ::meshtastic::ModuleConfig_StoreForwardConfig* _internal_mutable_store_forward();
  public:
  void unsafe_arena_set_allocated_store_forward(
      ::meshtastic::ModuleConfig_StoreForwardConfig* store_forward);
  ::meshtastic::ModuleConfig_StoreForwardConfig* unsafe_arena_release_store_forward();

  // .meshtastic.ModuleConfig.RangeTestConfig range_test = 5;
  bool has_range_test() const;
  private:
  bool _internal_has_range_test() const;
  public:
  void clear_range_test();
  const ::meshtastic::ModuleConfig_RangeTestConfig& range_test() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_RangeTestConfig* release_range_test();
  ::meshtastic::ModuleConfig_RangeTestConfig* mutable_range_test();
  void set_allocated_range_test(::meshtastic::ModuleConfig_RangeTestConfig* range_test);
  private:
  const ::meshtastic::ModuleConfig_RangeTestConfig& _internal_range_test() const;
  ::meshtastic::ModuleConfig_RangeTestConfig* _internal_mutable_range_test();
  public:
  void unsafe_arena_set_allocated_range_test(
      ::meshtastic::ModuleConfig_RangeTestConfig* range_test);
  ::meshtastic::ModuleConfig_RangeTestConfig* unsafe_arena_release_range_test();

  // .meshtastic.ModuleConfig.TelemetryConfig telemetry = 6;
  bool has_telemetry() const;
  private:
  bool _internal_has_telemetry() const;
  public:
  void clear_telemetry();
  const ::meshtastic::ModuleConfig_TelemetryConfig& telemetry() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_TelemetryConfig* release_telemetry();
  ::meshtastic::ModuleConfig_TelemetryConfig* mutable_telemetry();
  void set_allocated_telemetry(::meshtastic::ModuleConfig_TelemetryConfig* telemetry);
  private:
  const ::meshtastic::ModuleConfig_TelemetryConfig& _internal_telemetry() const;
  ::meshtastic::ModuleConfig_TelemetryConfig* _internal_mutable_telemetry();
  public:
  void unsafe_arena_set_allocated_telemetry(
      ::meshtastic::ModuleConfig_TelemetryConfig* telemetry);
  ::meshtastic::ModuleConfig_TelemetryConfig* unsafe_arena_release_telemetry();

  // .meshtastic.ModuleConfig.CannedMessageConfig canned_message = 7;
  bool has_canned_message() const;
  private:
  bool _internal_has_canned_message() const;
  public:
  void clear_canned_message();
  const ::meshtastic::ModuleConfig_CannedMessageConfig& canned_message() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_CannedMessageConfig* release_canned_message();
  ::meshtastic::ModuleConfig_CannedMessageConfig* mutable_canned_message();
  void set_allocated_canned_message(::meshtastic::ModuleConfig_CannedMessageConfig* canned_message);
  private:
  const ::meshtastic::ModuleConfig_CannedMessageConfig& _internal_canned_message() const;
  ::meshtastic::ModuleConfig_CannedMessageConfig* _internal_mutable_canned_message();
  public:
  void unsafe_arena_set_allocated_canned_message(
      ::meshtastic::ModuleConfig_CannedMessageConfig* canned_message);
  ::meshtastic::ModuleConfig_CannedMessageConfig* unsafe_arena_release_canned_message();

  // .meshtastic.ModuleConfig.AudioConfig audio = 9;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::meshtastic::ModuleConfig_AudioConfig& audio() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_AudioConfig* release_audio();
  ::meshtastic::ModuleConfig_AudioConfig* mutable_audio();
  void set_allocated_audio(::meshtastic::ModuleConfig_AudioConfig* audio);
  private:
  const ::meshtastic::ModuleConfig_AudioConfig& _internal_audio() const;
  ::meshtastic::ModuleConfig_AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::meshtastic::ModuleConfig_AudioConfig* audio);
  ::meshtastic::ModuleConfig_AudioConfig* unsafe_arena_release_audio();

  // .meshtastic.ModuleConfig.RemoteHardwareConfig remote_hardware = 10;
  bool has_remote_hardware() const;
  private:
  bool _internal_has_remote_hardware() const;
  public:
  void clear_remote_hardware();
  const ::meshtastic::ModuleConfig_RemoteHardwareConfig& remote_hardware() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_RemoteHardwareConfig* release_remote_hardware();
  ::meshtastic::ModuleConfig_RemoteHardwareConfig* mutable_remote_hardware();
  void set_allocated_remote_hardware(::meshtastic::ModuleConfig_RemoteHardwareConfig* remote_hardware);
  private:
  const ::meshtastic::ModuleConfig_RemoteHardwareConfig& _internal_remote_hardware() const;
  ::meshtastic::ModuleConfig_RemoteHardwareConfig* _internal_mutable_remote_hardware();
  public:
  void unsafe_arena_set_allocated_remote_hardware(
      ::meshtastic::ModuleConfig_RemoteHardwareConfig* remote_hardware);
  ::meshtastic::ModuleConfig_RemoteHardwareConfig* unsafe_arena_release_remote_hardware();

  // .meshtastic.ModuleConfig.NeighborInfoConfig neighbor_info = 11;
  bool has_neighbor_info() const;
  private:
  bool _internal_has_neighbor_info() const;
  public:
  void clear_neighbor_info();
  const ::meshtastic::ModuleConfig_NeighborInfoConfig& neighbor_info() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_NeighborInfoConfig* release_neighbor_info();
  ::meshtastic::ModuleConfig_NeighborInfoConfig* mutable_neighbor_info();
  void set_allocated_neighbor_info(::meshtastic::ModuleConfig_NeighborInfoConfig* neighbor_info);
  private:
  const ::meshtastic::ModuleConfig_NeighborInfoConfig& _internal_neighbor_info() const;
  ::meshtastic::ModuleConfig_NeighborInfoConfig* _internal_mutable_neighbor_info();
  public:
  void unsafe_arena_set_allocated_neighbor_info(
      ::meshtastic::ModuleConfig_NeighborInfoConfig* neighbor_info);
  ::meshtastic::ModuleConfig_NeighborInfoConfig* unsafe_arena_release_neighbor_info();

  // .meshtastic.ModuleConfig.AmbientLightingConfig ambient_lighting = 12;
  bool has_ambient_lighting() const;
  private:
  bool _internal_has_ambient_lighting() const;
  public:
  void clear_ambient_lighting();
  const ::meshtastic::ModuleConfig_AmbientLightingConfig& ambient_lighting() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_AmbientLightingConfig* release_ambient_lighting();
  ::meshtastic::ModuleConfig_AmbientLightingConfig* mutable_ambient_lighting();
  void set_allocated_ambient_lighting(::meshtastic::ModuleConfig_AmbientLightingConfig* ambient_lighting);
  private:
  const ::meshtastic::ModuleConfig_AmbientLightingConfig& _internal_ambient_lighting() const;
  ::meshtastic::ModuleConfig_AmbientLightingConfig* _internal_mutable_ambient_lighting();
  public:
  void unsafe_arena_set_allocated_ambient_lighting(
      ::meshtastic::ModuleConfig_AmbientLightingConfig* ambient_lighting);
  ::meshtastic::ModuleConfig_AmbientLightingConfig* unsafe_arena_release_ambient_lighting();

  // .meshtastic.ModuleConfig.DetectionSensorConfig detection_sensor = 13;
  bool has_detection_sensor() const;
  private:
  bool _internal_has_detection_sensor() const;
  public:
  void clear_detection_sensor();
  const ::meshtastic::ModuleConfig_DetectionSensorConfig& detection_sensor() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_DetectionSensorConfig* release_detection_sensor();
  ::meshtastic::ModuleConfig_DetectionSensorConfig* mutable_detection_sensor();
  void set_allocated_detection_sensor(::meshtastic::ModuleConfig_DetectionSensorConfig* detection_sensor);
  private:
  const ::meshtastic::ModuleConfig_DetectionSensorConfig& _internal_detection_sensor() const;
  ::meshtastic::ModuleConfig_DetectionSensorConfig* _internal_mutable_detection_sensor();
  public:
  void unsafe_arena_set_allocated_detection_sensor(
      ::meshtastic::ModuleConfig_DetectionSensorConfig* detection_sensor);
  ::meshtastic::ModuleConfig_DetectionSensorConfig* unsafe_arena_release_detection_sensor();

  // .meshtastic.ModuleConfig.PaxcounterConfig paxcounter = 14;
  bool has_paxcounter() const;
  private:
  bool _internal_has_paxcounter() const;
  public:
  void clear_paxcounter();
  const ::meshtastic::ModuleConfig_PaxcounterConfig& paxcounter() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_PaxcounterConfig* release_paxcounter();
  ::meshtastic::ModuleConfig_PaxcounterConfig* mutable_paxcounter();
  void set_allocated_paxcounter(::meshtastic::ModuleConfig_PaxcounterConfig* paxcounter);
  private:
  const ::meshtastic::ModuleConfig_PaxcounterConfig& _internal_paxcounter() const;
  ::meshtastic::ModuleConfig_PaxcounterConfig* _internal_mutable_paxcounter();
  public:
  void unsafe_arena_set_allocated_paxcounter(
      ::meshtastic::ModuleConfig_PaxcounterConfig* paxcounter);
  ::meshtastic::ModuleConfig_PaxcounterConfig* unsafe_arena_release_paxcounter();

  // uint32 version = 8;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.LocalModuleConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::meshtastic::ModuleConfig_MQTTConfig* mqtt_;
    ::meshtastic::ModuleConfig_SerialConfig* serial_;
    ::meshtastic::ModuleConfig_ExternalNotificationConfig* external_notification_;
    ::meshtastic::ModuleConfig_StoreForwardConfig* store_forward_;
    ::meshtastic::ModuleConfig_RangeTestConfig* range_test_;
    ::meshtastic::ModuleConfig_TelemetryConfig* telemetry_;
    ::meshtastic::ModuleConfig_CannedMessageConfig* canned_message_;
    ::meshtastic::ModuleConfig_AudioConfig* audio_;
    ::meshtastic::ModuleConfig_RemoteHardwareConfig* remote_hardware_;
    ::meshtastic::ModuleConfig_NeighborInfoConfig* neighbor_info_;
    ::meshtastic::ModuleConfig_AmbientLightingConfig* ambient_lighting_;
    ::meshtastic::ModuleConfig_DetectionSensorConfig* detection_sensor_;
    ::meshtastic::ModuleConfig_PaxcounterConfig* paxcounter_;
    uint32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2flocalonly_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LocalConfig

// .meshtastic.Config.DeviceConfig device = 1;
inline bool LocalConfig::_internal_has_device() const {
  return this != internal_default_instance() && _impl_.device_ != nullptr;
}
inline bool LocalConfig::has_device() const {
  return _internal_has_device();
}
inline const ::meshtastic::Config_DeviceConfig& LocalConfig::_internal_device() const {
  const ::meshtastic::Config_DeviceConfig* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Config_DeviceConfig&>(
      ::meshtastic::_Config_DeviceConfig_default_instance_);
}
inline const ::meshtastic::Config_DeviceConfig& LocalConfig::device() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalConfig.device)
  return _internal_device();
}
inline void LocalConfig::unsafe_arena_set_allocated_device(
    ::meshtastic::Config_DeviceConfig* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalConfig.device)
}
inline ::meshtastic::Config_DeviceConfig* LocalConfig::release_device() {
  
  ::meshtastic::Config_DeviceConfig* temp = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::Config_DeviceConfig* LocalConfig::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalConfig.device)
  
  ::meshtastic::Config_DeviceConfig* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::meshtastic::Config_DeviceConfig* LocalConfig::_internal_mutable_device() {
  
  if (_impl_.device_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::Config_DeviceConfig>(GetArenaForAllocation());
    _impl_.device_ = p;
  }
  return _impl_.device_;
}
inline ::meshtastic::Config_DeviceConfig* LocalConfig::mutable_device() {
  ::meshtastic::Config_DeviceConfig* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalConfig.device)
  return _msg;
}
inline void LocalConfig::set_allocated_device(::meshtastic::Config_DeviceConfig* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device));
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_ = device;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalConfig.device)
}

// .meshtastic.Config.PositionConfig position = 2;
inline bool LocalConfig::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool LocalConfig::has_position() const {
  return _internal_has_position();
}
inline const ::meshtastic::Config_PositionConfig& LocalConfig::_internal_position() const {
  const ::meshtastic::Config_PositionConfig* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Config_PositionConfig&>(
      ::meshtastic::_Config_PositionConfig_default_instance_);
}
inline const ::meshtastic::Config_PositionConfig& LocalConfig::position() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalConfig.position)
  return _internal_position();
}
inline void LocalConfig::unsafe_arena_set_allocated_position(
    ::meshtastic::Config_PositionConfig* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalConfig.position)
}
inline ::meshtastic::Config_PositionConfig* LocalConfig::release_position() {
  
  ::meshtastic::Config_PositionConfig* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::Config_PositionConfig* LocalConfig::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalConfig.position)
  
  ::meshtastic::Config_PositionConfig* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::meshtastic::Config_PositionConfig* LocalConfig::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::Config_PositionConfig>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::meshtastic::Config_PositionConfig* LocalConfig::mutable_position() {
  ::meshtastic::Config_PositionConfig* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalConfig.position)
  return _msg;
}
inline void LocalConfig::set_allocated_position(::meshtastic::Config_PositionConfig* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalConfig.position)
}

// .meshtastic.Config.PowerConfig power = 3;
inline bool LocalConfig::_internal_has_power() const {
  return this != internal_default_instance() && _impl_.power_ != nullptr;
}
inline bool LocalConfig::has_power() const {
  return _internal_has_power();
}
inline const ::meshtastic::Config_PowerConfig& LocalConfig::_internal_power() const {
  const ::meshtastic::Config_PowerConfig* p = _impl_.power_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Config_PowerConfig&>(
      ::meshtastic::_Config_PowerConfig_default_instance_);
}
inline const ::meshtastic::Config_PowerConfig& LocalConfig::power() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalConfig.power)
  return _internal_power();
}
inline void LocalConfig::unsafe_arena_set_allocated_power(
    ::meshtastic::Config_PowerConfig* power) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.power_);
  }
  _impl_.power_ = power;
  if (power) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalConfig.power)
}
inline ::meshtastic::Config_PowerConfig* LocalConfig::release_power() {
  
  ::meshtastic::Config_PowerConfig* temp = _impl_.power_;
  _impl_.power_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::Config_PowerConfig* LocalConfig::unsafe_arena_release_power() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalConfig.power)
  
  ::meshtastic::Config_PowerConfig* temp = _impl_.power_;
  _impl_.power_ = nullptr;
  return temp;
}
inline ::meshtastic::Config_PowerConfig* LocalConfig::_internal_mutable_power() {
  
  if (_impl_.power_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::Config_PowerConfig>(GetArenaForAllocation());
    _impl_.power_ = p;
  }
  return _impl_.power_;
}
inline ::meshtastic::Config_PowerConfig* LocalConfig::mutable_power() {
  ::meshtastic::Config_PowerConfig* _msg = _internal_mutable_power();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalConfig.power)
  return _msg;
}
inline void LocalConfig::set_allocated_power(::meshtastic::Config_PowerConfig* power) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.power_);
  }
  if (power) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(power));
    if (message_arena != submessage_arena) {
      power = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, power, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.power_ = power;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalConfig.power)
}

// .meshtastic.Config.NetworkConfig network = 4;
inline bool LocalConfig::_internal_has_network() const {
  return this != internal_default_instance() && _impl_.network_ != nullptr;
}
inline bool LocalConfig::has_network() const {
  return _internal_has_network();
}
inline const ::meshtastic::Config_NetworkConfig& LocalConfig::_internal_network() const {
  const ::meshtastic::Config_NetworkConfig* p = _impl_.network_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Config_NetworkConfig&>(
      ::meshtastic::_Config_NetworkConfig_default_instance_);
}
inline const ::meshtastic::Config_NetworkConfig& LocalConfig::network() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalConfig.network)
  return _internal_network();
}
inline void LocalConfig::unsafe_arena_set_allocated_network(
    ::meshtastic::Config_NetworkConfig* network) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.network_);
  }
  _impl_.network_ = network;
  if (network) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalConfig.network)
}
inline ::meshtastic::Config_NetworkConfig* LocalConfig::release_network() {
  
  ::meshtastic::Config_NetworkConfig* temp = _impl_.network_;
  _impl_.network_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::Config_NetworkConfig* LocalConfig::unsafe_arena_release_network() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalConfig.network)
  
  ::meshtastic::Config_NetworkConfig* temp = _impl_.network_;
  _impl_.network_ = nullptr;
  return temp;
}
inline ::meshtastic::Config_NetworkConfig* LocalConfig::_internal_mutable_network() {
  
  if (_impl_.network_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::Config_NetworkConfig>(GetArenaForAllocation());
    _impl_.network_ = p;
  }
  return _impl_.network_;
}
inline ::meshtastic::Config_NetworkConfig* LocalConfig::mutable_network() {
  ::meshtastic::Config_NetworkConfig* _msg = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalConfig.network)
  return _msg;
}
inline void LocalConfig::set_allocated_network(::meshtastic::Config_NetworkConfig* network) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.network_);
  }
  if (network) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(network));
    if (message_arena != submessage_arena) {
      network = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.network_ = network;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalConfig.network)
}

// .meshtastic.Config.DisplayConfig display = 5;
inline bool LocalConfig::_internal_has_display() const {
  return this != internal_default_instance() && _impl_.display_ != nullptr;
}
inline bool LocalConfig::has_display() const {
  return _internal_has_display();
}
inline const ::meshtastic::Config_DisplayConfig& LocalConfig::_internal_display() const {
  const ::meshtastic::Config_DisplayConfig* p = _impl_.display_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Config_DisplayConfig&>(
      ::meshtastic::_Config_DisplayConfig_default_instance_);
}
inline const ::meshtastic::Config_DisplayConfig& LocalConfig::display() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalConfig.display)
  return _internal_display();
}
inline void LocalConfig::unsafe_arena_set_allocated_display(
    ::meshtastic::Config_DisplayConfig* display) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.display_);
  }
  _impl_.display_ = display;
  if (display) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalConfig.display)
}
inline ::meshtastic::Config_DisplayConfig* LocalConfig::release_display() {
  
  ::meshtastic::Config_DisplayConfig* temp = _impl_.display_;
  _impl_.display_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::Config_DisplayConfig* LocalConfig::unsafe_arena_release_display() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalConfig.display)
  
  ::meshtastic::Config_DisplayConfig* temp = _impl_.display_;
  _impl_.display_ = nullptr;
  return temp;
}
inline ::meshtastic::Config_DisplayConfig* LocalConfig::_internal_mutable_display() {
  
  if (_impl_.display_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::Config_DisplayConfig>(GetArenaForAllocation());
    _impl_.display_ = p;
  }
  return _impl_.display_;
}
inline ::meshtastic::Config_DisplayConfig* LocalConfig::mutable_display() {
  ::meshtastic::Config_DisplayConfig* _msg = _internal_mutable_display();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalConfig.display)
  return _msg;
}
inline void LocalConfig::set_allocated_display(::meshtastic::Config_DisplayConfig* display) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.display_);
  }
  if (display) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(display));
    if (message_arena != submessage_arena) {
      display = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, display, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.display_ = display;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalConfig.display)
}

// .meshtastic.Config.LoRaConfig lora = 6;
inline bool LocalConfig::_internal_has_lora() const {
  return this != internal_default_instance() && _impl_.lora_ != nullptr;
}
inline bool LocalConfig::has_lora() const {
  return _internal_has_lora();
}
inline const ::meshtastic::Config_LoRaConfig& LocalConfig::_internal_lora() const {
  const ::meshtastic::Config_LoRaConfig* p = _impl_.lora_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Config_LoRaConfig&>(
      ::meshtastic::_Config_LoRaConfig_default_instance_);
}
inline const ::meshtastic::Config_LoRaConfig& LocalConfig::lora() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalConfig.lora)
  return _internal_lora();
}
inline void LocalConfig::unsafe_arena_set_allocated_lora(
    ::meshtastic::Config_LoRaConfig* lora) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lora_);
  }
  _impl_.lora_ = lora;
  if (lora) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalConfig.lora)
}
inline ::meshtastic::Config_LoRaConfig* LocalConfig::release_lora() {
  
  ::meshtastic::Config_LoRaConfig* temp = _impl_.lora_;
  _impl_.lora_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::Config_LoRaConfig* LocalConfig::unsafe_arena_release_lora() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalConfig.lora)
  
  ::meshtastic::Config_LoRaConfig* temp = _impl_.lora_;
  _impl_.lora_ = nullptr;
  return temp;
}
inline ::meshtastic::Config_LoRaConfig* LocalConfig::_internal_mutable_lora() {
  
  if (_impl_.lora_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::Config_LoRaConfig>(GetArenaForAllocation());
    _impl_.lora_ = p;
  }
  return _impl_.lora_;
}
inline ::meshtastic::Config_LoRaConfig* LocalConfig::mutable_lora() {
  ::meshtastic::Config_LoRaConfig* _msg = _internal_mutable_lora();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalConfig.lora)
  return _msg;
}
inline void LocalConfig::set_allocated_lora(::meshtastic::Config_LoRaConfig* lora) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lora_);
  }
  if (lora) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lora));
    if (message_arena != submessage_arena) {
      lora = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lora, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lora_ = lora;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalConfig.lora)
}

// .meshtastic.Config.BluetoothConfig bluetooth = 7;
inline bool LocalConfig::_internal_has_bluetooth() const {
  return this != internal_default_instance() && _impl_.bluetooth_ != nullptr;
}
inline bool LocalConfig::has_bluetooth() const {
  return _internal_has_bluetooth();
}
inline const ::meshtastic::Config_BluetoothConfig& LocalConfig::_internal_bluetooth() const {
  const ::meshtastic::Config_BluetoothConfig* p = _impl_.bluetooth_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Config_BluetoothConfig&>(
      ::meshtastic::_Config_BluetoothConfig_default_instance_);
}
inline const ::meshtastic::Config_BluetoothConfig& LocalConfig::bluetooth() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalConfig.bluetooth)
  return _internal_bluetooth();
}
inline void LocalConfig::unsafe_arena_set_allocated_bluetooth(
    ::meshtastic::Config_BluetoothConfig* bluetooth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bluetooth_);
  }
  _impl_.bluetooth_ = bluetooth;
  if (bluetooth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalConfig.bluetooth)
}
inline ::meshtastic::Config_BluetoothConfig* LocalConfig::release_bluetooth() {
  
  ::meshtastic::Config_BluetoothConfig* temp = _impl_.bluetooth_;
  _impl_.bluetooth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::Config_BluetoothConfig* LocalConfig::unsafe_arena_release_bluetooth() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalConfig.bluetooth)
  
  ::meshtastic::Config_BluetoothConfig* temp = _impl_.bluetooth_;
  _impl_.bluetooth_ = nullptr;
  return temp;
}
inline ::meshtastic::Config_BluetoothConfig* LocalConfig::_internal_mutable_bluetooth() {
  
  if (_impl_.bluetooth_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::Config_BluetoothConfig>(GetArenaForAllocation());
    _impl_.bluetooth_ = p;
  }
  return _impl_.bluetooth_;
}
inline ::meshtastic::Config_BluetoothConfig* LocalConfig::mutable_bluetooth() {
  ::meshtastic::Config_BluetoothConfig* _msg = _internal_mutable_bluetooth();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalConfig.bluetooth)
  return _msg;
}
inline void LocalConfig::set_allocated_bluetooth(::meshtastic::Config_BluetoothConfig* bluetooth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bluetooth_);
  }
  if (bluetooth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bluetooth));
    if (message_arena != submessage_arena) {
      bluetooth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bluetooth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bluetooth_ = bluetooth;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalConfig.bluetooth)
}

// uint32 version = 8;
inline void LocalConfig::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t LocalConfig::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t LocalConfig::version() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalConfig.version)
  return _internal_version();
}
inline void LocalConfig::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void LocalConfig::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:meshtastic.LocalConfig.version)
}

// .meshtastic.Config.SecurityConfig security = 9;
inline bool LocalConfig::_internal_has_security() const {
  return this != internal_default_instance() && _impl_.security_ != nullptr;
}
inline bool LocalConfig::has_security() const {
  return _internal_has_security();
}
inline const ::meshtastic::Config_SecurityConfig& LocalConfig::_internal_security() const {
  const ::meshtastic::Config_SecurityConfig* p = _impl_.security_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Config_SecurityConfig&>(
      ::meshtastic::_Config_SecurityConfig_default_instance_);
}
inline const ::meshtastic::Config_SecurityConfig& LocalConfig::security() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalConfig.security)
  return _internal_security();
}
inline void LocalConfig::unsafe_arena_set_allocated_security(
    ::meshtastic::Config_SecurityConfig* security) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.security_);
  }
  _impl_.security_ = security;
  if (security) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalConfig.security)
}
inline ::meshtastic::Config_SecurityConfig* LocalConfig::release_security() {
  
  ::meshtastic::Config_SecurityConfig* temp = _impl_.security_;
  _impl_.security_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::Config_SecurityConfig* LocalConfig::unsafe_arena_release_security() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalConfig.security)
  
  ::meshtastic::Config_SecurityConfig* temp = _impl_.security_;
  _impl_.security_ = nullptr;
  return temp;
}
inline ::meshtastic::Config_SecurityConfig* LocalConfig::_internal_mutable_security() {
  
  if (_impl_.security_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::Config_SecurityConfig>(GetArenaForAllocation());
    _impl_.security_ = p;
  }
  return _impl_.security_;
}
inline ::meshtastic::Config_SecurityConfig* LocalConfig::mutable_security() {
  ::meshtastic::Config_SecurityConfig* _msg = _internal_mutable_security();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalConfig.security)
  return _msg;
}
inline void LocalConfig::set_allocated_security(::meshtastic::Config_SecurityConfig* security) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.security_);
  }
  if (security) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(security));
    if (message_arena != submessage_arena) {
      security = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, security, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.security_ = security;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalConfig.security)
}

// -------------------------------------------------------------------

// LocalModuleConfig

// .meshtastic.ModuleConfig.MQTTConfig mqtt = 1;
inline bool LocalModuleConfig::_internal_has_mqtt() const {
  return this != internal_default_instance() && _impl_.mqtt_ != nullptr;
}
inline bool LocalModuleConfig::has_mqtt() const {
  return _internal_has_mqtt();
}
inline const ::meshtastic::ModuleConfig_MQTTConfig& LocalModuleConfig::_internal_mqtt() const {
  const ::meshtastic::ModuleConfig_MQTTConfig* p = _impl_.mqtt_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_MQTTConfig&>(
      ::meshtastic::_ModuleConfig_MQTTConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_MQTTConfig& LocalModuleConfig::mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.mqtt)
  return _internal_mqtt();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_mqtt(
    ::meshtastic::ModuleConfig_MQTTConfig* mqtt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mqtt_);
  }
  _impl_.mqtt_ = mqtt;
  if (mqtt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.mqtt)
}
inline ::meshtastic::ModuleConfig_MQTTConfig* LocalModuleConfig::release_mqtt() {
  
  ::meshtastic::ModuleConfig_MQTTConfig* temp = _impl_.mqtt_;
  _impl_.mqtt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_MQTTConfig* LocalModuleConfig::unsafe_arena_release_mqtt() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.mqtt)
  
  ::meshtastic::ModuleConfig_MQTTConfig* temp = _impl_.mqtt_;
  _impl_.mqtt_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_MQTTConfig* LocalModuleConfig::_internal_mutable_mqtt() {
  
  if (_impl_.mqtt_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_MQTTConfig>(GetArenaForAllocation());
    _impl_.mqtt_ = p;
  }
  return _impl_.mqtt_;
}
inline ::meshtastic::ModuleConfig_MQTTConfig* LocalModuleConfig::mutable_mqtt() {
  ::meshtastic::ModuleConfig_MQTTConfig* _msg = _internal_mutable_mqtt();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.mqtt)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_mqtt(::meshtastic::ModuleConfig_MQTTConfig* mqtt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mqtt_);
  }
  if (mqtt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mqtt));
    if (message_arena != submessage_arena) {
      mqtt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mqtt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mqtt_ = mqtt;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.mqtt)
}

// .meshtastic.ModuleConfig.SerialConfig serial = 2;
inline bool LocalModuleConfig::_internal_has_serial() const {
  return this != internal_default_instance() && _impl_.serial_ != nullptr;
}
inline bool LocalModuleConfig::has_serial() const {
  return _internal_has_serial();
}
inline const ::meshtastic::ModuleConfig_SerialConfig& LocalModuleConfig::_internal_serial() const {
  const ::meshtastic::ModuleConfig_SerialConfig* p = _impl_.serial_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_SerialConfig&>(
      ::meshtastic::_ModuleConfig_SerialConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_SerialConfig& LocalModuleConfig::serial() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.serial)
  return _internal_serial();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_serial(
    ::meshtastic::ModuleConfig_SerialConfig* serial) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.serial_);
  }
  _impl_.serial_ = serial;
  if (serial) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.serial)
}
inline ::meshtastic::ModuleConfig_SerialConfig* LocalModuleConfig::release_serial() {
  
  ::meshtastic::ModuleConfig_SerialConfig* temp = _impl_.serial_;
  _impl_.serial_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_SerialConfig* LocalModuleConfig::unsafe_arena_release_serial() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.serial)
  
  ::meshtastic::ModuleConfig_SerialConfig* temp = _impl_.serial_;
  _impl_.serial_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_SerialConfig* LocalModuleConfig::_internal_mutable_serial() {
  
  if (_impl_.serial_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_SerialConfig>(GetArenaForAllocation());
    _impl_.serial_ = p;
  }
  return _impl_.serial_;
}
inline ::meshtastic::ModuleConfig_SerialConfig* LocalModuleConfig::mutable_serial() {
  ::meshtastic::ModuleConfig_SerialConfig* _msg = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.serial)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_serial(::meshtastic::ModuleConfig_SerialConfig* serial) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.serial_);
  }
  if (serial) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(serial));
    if (message_arena != submessage_arena) {
      serial = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, serial, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.serial_ = serial;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.serial)
}

// .meshtastic.ModuleConfig.ExternalNotificationConfig external_notification = 3;
inline bool LocalModuleConfig::_internal_has_external_notification() const {
  return this != internal_default_instance() && _impl_.external_notification_ != nullptr;
}
inline bool LocalModuleConfig::has_external_notification() const {
  return _internal_has_external_notification();
}
inline const ::meshtastic::ModuleConfig_ExternalNotificationConfig& LocalModuleConfig::_internal_external_notification() const {
  const ::meshtastic::ModuleConfig_ExternalNotificationConfig* p = _impl_.external_notification_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_ExternalNotificationConfig&>(
      ::meshtastic::_ModuleConfig_ExternalNotificationConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_ExternalNotificationConfig& LocalModuleConfig::external_notification() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.external_notification)
  return _internal_external_notification();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_external_notification(
    ::meshtastic::ModuleConfig_ExternalNotificationConfig* external_notification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_notification_);
  }
  _impl_.external_notification_ = external_notification;
  if (external_notification) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.external_notification)
}
inline ::meshtastic::ModuleConfig_ExternalNotificationConfig* LocalModuleConfig::release_external_notification() {
  
  ::meshtastic::ModuleConfig_ExternalNotificationConfig* temp = _impl_.external_notification_;
  _impl_.external_notification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_ExternalNotificationConfig* LocalModuleConfig::unsafe_arena_release_external_notification() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.external_notification)
  
  ::meshtastic::ModuleConfig_ExternalNotificationConfig* temp = _impl_.external_notification_;
  _impl_.external_notification_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_ExternalNotificationConfig* LocalModuleConfig::_internal_mutable_external_notification() {
  
  if (_impl_.external_notification_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_ExternalNotificationConfig>(GetArenaForAllocation());
    _impl_.external_notification_ = p;
  }
  return _impl_.external_notification_;
}
inline ::meshtastic::ModuleConfig_ExternalNotificationConfig* LocalModuleConfig::mutable_external_notification() {
  ::meshtastic::ModuleConfig_ExternalNotificationConfig* _msg = _internal_mutable_external_notification();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.external_notification)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_external_notification(::meshtastic::ModuleConfig_ExternalNotificationConfig* external_notification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_notification_);
  }
  if (external_notification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(external_notification));
    if (message_arena != submessage_arena) {
      external_notification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_notification, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.external_notification_ = external_notification;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.external_notification)
}

// .meshtastic.ModuleConfig.StoreForwardConfig store_forward = 4;
inline bool LocalModuleConfig::_internal_has_store_forward() const {
  return this != internal_default_instance() && _impl_.store_forward_ != nullptr;
}
inline bool LocalModuleConfig::has_store_forward() const {
  return _internal_has_store_forward();
}
inline const ::meshtastic::ModuleConfig_StoreForwardConfig& LocalModuleConfig::_internal_store_forward() const {
  const ::meshtastic::ModuleConfig_StoreForwardConfig* p = _impl_.store_forward_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_StoreForwardConfig&>(
      ::meshtastic::_ModuleConfig_StoreForwardConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_StoreForwardConfig& LocalModuleConfig::store_forward() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.store_forward)
  return _internal_store_forward();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_store_forward(
    ::meshtastic::ModuleConfig_StoreForwardConfig* store_forward) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.store_forward_);
  }
  _impl_.store_forward_ = store_forward;
  if (store_forward) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.store_forward)
}
inline ::meshtastic::ModuleConfig_StoreForwardConfig* LocalModuleConfig::release_store_forward() {
  
  ::meshtastic::ModuleConfig_StoreForwardConfig* temp = _impl_.store_forward_;
  _impl_.store_forward_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_StoreForwardConfig* LocalModuleConfig::unsafe_arena_release_store_forward() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.store_forward)
  
  ::meshtastic::ModuleConfig_StoreForwardConfig* temp = _impl_.store_forward_;
  _impl_.store_forward_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_StoreForwardConfig* LocalModuleConfig::_internal_mutable_store_forward() {
  
  if (_impl_.store_forward_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_StoreForwardConfig>(GetArenaForAllocation());
    _impl_.store_forward_ = p;
  }
  return _impl_.store_forward_;
}
inline ::meshtastic::ModuleConfig_StoreForwardConfig* LocalModuleConfig::mutable_store_forward() {
  ::meshtastic::ModuleConfig_StoreForwardConfig* _msg = _internal_mutable_store_forward();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.store_forward)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_store_forward(::meshtastic::ModuleConfig_StoreForwardConfig* store_forward) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.store_forward_);
  }
  if (store_forward) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_forward));
    if (message_arena != submessage_arena) {
      store_forward = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store_forward, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.store_forward_ = store_forward;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.store_forward)
}

// .meshtastic.ModuleConfig.RangeTestConfig range_test = 5;
inline bool LocalModuleConfig::_internal_has_range_test() const {
  return this != internal_default_instance() && _impl_.range_test_ != nullptr;
}
inline bool LocalModuleConfig::has_range_test() const {
  return _internal_has_range_test();
}
inline const ::meshtastic::ModuleConfig_RangeTestConfig& LocalModuleConfig::_internal_range_test() const {
  const ::meshtastic::ModuleConfig_RangeTestConfig* p = _impl_.range_test_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_RangeTestConfig&>(
      ::meshtastic::_ModuleConfig_RangeTestConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_RangeTestConfig& LocalModuleConfig::range_test() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.range_test)
  return _internal_range_test();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_range_test(
    ::meshtastic::ModuleConfig_RangeTestConfig* range_test) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_test_);
  }
  _impl_.range_test_ = range_test;
  if (range_test) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.range_test)
}
inline ::meshtastic::ModuleConfig_RangeTestConfig* LocalModuleConfig::release_range_test() {
  
  ::meshtastic::ModuleConfig_RangeTestConfig* temp = _impl_.range_test_;
  _impl_.range_test_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_RangeTestConfig* LocalModuleConfig::unsafe_arena_release_range_test() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.range_test)
  
  ::meshtastic::ModuleConfig_RangeTestConfig* temp = _impl_.range_test_;
  _impl_.range_test_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_RangeTestConfig* LocalModuleConfig::_internal_mutable_range_test() {
  
  if (_impl_.range_test_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_RangeTestConfig>(GetArenaForAllocation());
    _impl_.range_test_ = p;
  }
  return _impl_.range_test_;
}
inline ::meshtastic::ModuleConfig_RangeTestConfig* LocalModuleConfig::mutable_range_test() {
  ::meshtastic::ModuleConfig_RangeTestConfig* _msg = _internal_mutable_range_test();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.range_test)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_range_test(::meshtastic::ModuleConfig_RangeTestConfig* range_test) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_test_);
  }
  if (range_test) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_test));
    if (message_arena != submessage_arena) {
      range_test = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range_test, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.range_test_ = range_test;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.range_test)
}

// .meshtastic.ModuleConfig.TelemetryConfig telemetry = 6;
inline bool LocalModuleConfig::_internal_has_telemetry() const {
  return this != internal_default_instance() && _impl_.telemetry_ != nullptr;
}
inline bool LocalModuleConfig::has_telemetry() const {
  return _internal_has_telemetry();
}
inline const ::meshtastic::ModuleConfig_TelemetryConfig& LocalModuleConfig::_internal_telemetry() const {
  const ::meshtastic::ModuleConfig_TelemetryConfig* p = _impl_.telemetry_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_TelemetryConfig&>(
      ::meshtastic::_ModuleConfig_TelemetryConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_TelemetryConfig& LocalModuleConfig::telemetry() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.telemetry)
  return _internal_telemetry();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_telemetry(
    ::meshtastic::ModuleConfig_TelemetryConfig* telemetry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.telemetry_);
  }
  _impl_.telemetry_ = telemetry;
  if (telemetry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.telemetry)
}
inline ::meshtastic::ModuleConfig_TelemetryConfig* LocalModuleConfig::release_telemetry() {
  
  ::meshtastic::ModuleConfig_TelemetryConfig* temp = _impl_.telemetry_;
  _impl_.telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_TelemetryConfig* LocalModuleConfig::unsafe_arena_release_telemetry() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.telemetry)
  
  ::meshtastic::ModuleConfig_TelemetryConfig* temp = _impl_.telemetry_;
  _impl_.telemetry_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_TelemetryConfig* LocalModuleConfig::_internal_mutable_telemetry() {
  
  if (_impl_.telemetry_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_TelemetryConfig>(GetArenaForAllocation());
    _impl_.telemetry_ = p;
  }
  return _impl_.telemetry_;
}
inline ::meshtastic::ModuleConfig_TelemetryConfig* LocalModuleConfig::mutable_telemetry() {
  ::meshtastic::ModuleConfig_TelemetryConfig* _msg = _internal_mutable_telemetry();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.telemetry)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_telemetry(::meshtastic::ModuleConfig_TelemetryConfig* telemetry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.telemetry_);
  }
  if (telemetry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(telemetry));
    if (message_arena != submessage_arena) {
      telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, telemetry, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.telemetry_ = telemetry;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.telemetry)
}

// .meshtastic.ModuleConfig.CannedMessageConfig canned_message = 7;
inline bool LocalModuleConfig::_internal_has_canned_message() const {
  return this != internal_default_instance() && _impl_.canned_message_ != nullptr;
}
inline bool LocalModuleConfig::has_canned_message() const {
  return _internal_has_canned_message();
}
inline const ::meshtastic::ModuleConfig_CannedMessageConfig& LocalModuleConfig::_internal_canned_message() const {
  const ::meshtastic::ModuleConfig_CannedMessageConfig* p = _impl_.canned_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_CannedMessageConfig&>(
      ::meshtastic::_ModuleConfig_CannedMessageConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_CannedMessageConfig& LocalModuleConfig::canned_message() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.canned_message)
  return _internal_canned_message();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_canned_message(
    ::meshtastic::ModuleConfig_CannedMessageConfig* canned_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.canned_message_);
  }
  _impl_.canned_message_ = canned_message;
  if (canned_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.canned_message)
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig* LocalModuleConfig::release_canned_message() {
  
  ::meshtastic::ModuleConfig_CannedMessageConfig* temp = _impl_.canned_message_;
  _impl_.canned_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig* LocalModuleConfig::unsafe_arena_release_canned_message() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.canned_message)
  
  ::meshtastic::ModuleConfig_CannedMessageConfig* temp = _impl_.canned_message_;
  _impl_.canned_message_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig* LocalModuleConfig::_internal_mutable_canned_message() {
  
  if (_impl_.canned_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_CannedMessageConfig>(GetArenaForAllocation());
    _impl_.canned_message_ = p;
  }
  return _impl_.canned_message_;
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig* LocalModuleConfig::mutable_canned_message() {
  ::meshtastic::ModuleConfig_CannedMessageConfig* _msg = _internal_mutable_canned_message();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.canned_message)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_canned_message(::meshtastic::ModuleConfig_CannedMessageConfig* canned_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.canned_message_);
  }
  if (canned_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(canned_message));
    if (message_arena != submessage_arena) {
      canned_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, canned_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.canned_message_ = canned_message;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.canned_message)
}

// .meshtastic.ModuleConfig.AudioConfig audio = 9;
inline bool LocalModuleConfig::_internal_has_audio() const {
  return this != internal_default_instance() && _impl_.audio_ != nullptr;
}
inline bool LocalModuleConfig::has_audio() const {
  return _internal_has_audio();
}
inline const ::meshtastic::ModuleConfig_AudioConfig& LocalModuleConfig::_internal_audio() const {
  const ::meshtastic::ModuleConfig_AudioConfig* p = _impl_.audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_AudioConfig&>(
      ::meshtastic::_ModuleConfig_AudioConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_AudioConfig& LocalModuleConfig::audio() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.audio)
  return _internal_audio();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_audio(
    ::meshtastic::ModuleConfig_AudioConfig* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_);
  }
  _impl_.audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.audio)
}
inline ::meshtastic::ModuleConfig_AudioConfig* LocalModuleConfig::release_audio() {
  
  ::meshtastic::ModuleConfig_AudioConfig* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_AudioConfig* LocalModuleConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.audio)
  
  ::meshtastic::ModuleConfig_AudioConfig* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_AudioConfig* LocalModuleConfig::_internal_mutable_audio() {
  
  if (_impl_.audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_AudioConfig>(GetArenaForAllocation());
    _impl_.audio_ = p;
  }
  return _impl_.audio_;
}
inline ::meshtastic::ModuleConfig_AudioConfig* LocalModuleConfig::mutable_audio() {
  ::meshtastic::ModuleConfig_AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.audio)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_audio(::meshtastic::ModuleConfig_AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_);
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio));
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.audio)
}

// .meshtastic.ModuleConfig.RemoteHardwareConfig remote_hardware = 10;
inline bool LocalModuleConfig::_internal_has_remote_hardware() const {
  return this != internal_default_instance() && _impl_.remote_hardware_ != nullptr;
}
inline bool LocalModuleConfig::has_remote_hardware() const {
  return _internal_has_remote_hardware();
}
inline const ::meshtastic::ModuleConfig_RemoteHardwareConfig& LocalModuleConfig::_internal_remote_hardware() const {
  const ::meshtastic::ModuleConfig_RemoteHardwareConfig* p = _impl_.remote_hardware_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_RemoteHardwareConfig&>(
      ::meshtastic::_ModuleConfig_RemoteHardwareConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_RemoteHardwareConfig& LocalModuleConfig::remote_hardware() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.remote_hardware)
  return _internal_remote_hardware();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_remote_hardware(
    ::meshtastic::ModuleConfig_RemoteHardwareConfig* remote_hardware) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remote_hardware_);
  }
  _impl_.remote_hardware_ = remote_hardware;
  if (remote_hardware) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.remote_hardware)
}
inline ::meshtastic::ModuleConfig_RemoteHardwareConfig* LocalModuleConfig::release_remote_hardware() {
  
  ::meshtastic::ModuleConfig_RemoteHardwareConfig* temp = _impl_.remote_hardware_;
  _impl_.remote_hardware_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_RemoteHardwareConfig* LocalModuleConfig::unsafe_arena_release_remote_hardware() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.remote_hardware)
  
  ::meshtastic::ModuleConfig_RemoteHardwareConfig* temp = _impl_.remote_hardware_;
  _impl_.remote_hardware_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_RemoteHardwareConfig* LocalModuleConfig::_internal_mutable_remote_hardware() {
  
  if (_impl_.remote_hardware_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_RemoteHardwareConfig>(GetArenaForAllocation());
    _impl_.remote_hardware_ = p;
  }
  return _impl_.remote_hardware_;
}
inline ::meshtastic::ModuleConfig_RemoteHardwareConfig* LocalModuleConfig::mutable_remote_hardware() {
  ::meshtastic::ModuleConfig_RemoteHardwareConfig* _msg = _internal_mutable_remote_hardware();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.remote_hardware)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_remote_hardware(::meshtastic::ModuleConfig_RemoteHardwareConfig* remote_hardware) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remote_hardware_);
  }
  if (remote_hardware) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(remote_hardware));
    if (message_arena != submessage_arena) {
      remote_hardware = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remote_hardware, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remote_hardware_ = remote_hardware;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.remote_hardware)
}

// .meshtastic.ModuleConfig.NeighborInfoConfig neighbor_info = 11;
inline bool LocalModuleConfig::_internal_has_neighbor_info() const {
  return this != internal_default_instance() && _impl_.neighbor_info_ != nullptr;
}
inline bool LocalModuleConfig::has_neighbor_info() const {
  return _internal_has_neighbor_info();
}
inline const ::meshtastic::ModuleConfig_NeighborInfoConfig& LocalModuleConfig::_internal_neighbor_info() const {
  const ::meshtastic::ModuleConfig_NeighborInfoConfig* p = _impl_.neighbor_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_NeighborInfoConfig&>(
      ::meshtastic::_ModuleConfig_NeighborInfoConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_NeighborInfoConfig& LocalModuleConfig::neighbor_info() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.neighbor_info)
  return _internal_neighbor_info();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_neighbor_info(
    ::meshtastic::ModuleConfig_NeighborInfoConfig* neighbor_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.neighbor_info_);
  }
  _impl_.neighbor_info_ = neighbor_info;
  if (neighbor_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.neighbor_info)
}
inline ::meshtastic::ModuleConfig_NeighborInfoConfig* LocalModuleConfig::release_neighbor_info() {
  
  ::meshtastic::ModuleConfig_NeighborInfoConfig* temp = _impl_.neighbor_info_;
  _impl_.neighbor_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_NeighborInfoConfig* LocalModuleConfig::unsafe_arena_release_neighbor_info() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.neighbor_info)
  
  ::meshtastic::ModuleConfig_NeighborInfoConfig* temp = _impl_.neighbor_info_;
  _impl_.neighbor_info_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_NeighborInfoConfig* LocalModuleConfig::_internal_mutable_neighbor_info() {
  
  if (_impl_.neighbor_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_NeighborInfoConfig>(GetArenaForAllocation());
    _impl_.neighbor_info_ = p;
  }
  return _impl_.neighbor_info_;
}
inline ::meshtastic::ModuleConfig_NeighborInfoConfig* LocalModuleConfig::mutable_neighbor_info() {
  ::meshtastic::ModuleConfig_NeighborInfoConfig* _msg = _internal_mutable_neighbor_info();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.neighbor_info)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_neighbor_info(::meshtastic::ModuleConfig_NeighborInfoConfig* neighbor_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.neighbor_info_);
  }
  if (neighbor_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(neighbor_info));
    if (message_arena != submessage_arena) {
      neighbor_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neighbor_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.neighbor_info_ = neighbor_info;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.neighbor_info)
}

// .meshtastic.ModuleConfig.AmbientLightingConfig ambient_lighting = 12;
inline bool LocalModuleConfig::_internal_has_ambient_lighting() const {
  return this != internal_default_instance() && _impl_.ambient_lighting_ != nullptr;
}
inline bool LocalModuleConfig::has_ambient_lighting() const {
  return _internal_has_ambient_lighting();
}
inline const ::meshtastic::ModuleConfig_AmbientLightingConfig& LocalModuleConfig::_internal_ambient_lighting() const {
  const ::meshtastic::ModuleConfig_AmbientLightingConfig* p = _impl_.ambient_lighting_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_AmbientLightingConfig&>(
      ::meshtastic::_ModuleConfig_AmbientLightingConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_AmbientLightingConfig& LocalModuleConfig::ambient_lighting() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.ambient_lighting)
  return _internal_ambient_lighting();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_ambient_lighting(
    ::meshtastic::ModuleConfig_AmbientLightingConfig* ambient_lighting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ambient_lighting_);
  }
  _impl_.ambient_lighting_ = ambient_lighting;
  if (ambient_lighting) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.ambient_lighting)
}
inline ::meshtastic::ModuleConfig_AmbientLightingConfig* LocalModuleConfig::release_ambient_lighting() {
  
  ::meshtastic::ModuleConfig_AmbientLightingConfig* temp = _impl_.ambient_lighting_;
  _impl_.ambient_lighting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_AmbientLightingConfig* LocalModuleConfig::unsafe_arena_release_ambient_lighting() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.ambient_lighting)
  
  ::meshtastic::ModuleConfig_AmbientLightingConfig* temp = _impl_.ambient_lighting_;
  _impl_.ambient_lighting_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_AmbientLightingConfig* LocalModuleConfig::_internal_mutable_ambient_lighting() {
  
  if (_impl_.ambient_lighting_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_AmbientLightingConfig>(GetArenaForAllocation());
    _impl_.ambient_lighting_ = p;
  }
  return _impl_.ambient_lighting_;
}
inline ::meshtastic::ModuleConfig_AmbientLightingConfig* LocalModuleConfig::mutable_ambient_lighting() {
  ::meshtastic::ModuleConfig_AmbientLightingConfig* _msg = _internal_mutable_ambient_lighting();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.ambient_lighting)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_ambient_lighting(::meshtastic::ModuleConfig_AmbientLightingConfig* ambient_lighting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ambient_lighting_);
  }
  if (ambient_lighting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ambient_lighting));
    if (message_arena != submessage_arena) {
      ambient_lighting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ambient_lighting, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ambient_lighting_ = ambient_lighting;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.ambient_lighting)
}

// .meshtastic.ModuleConfig.DetectionSensorConfig detection_sensor = 13;
inline bool LocalModuleConfig::_internal_has_detection_sensor() const {
  return this != internal_default_instance() && _impl_.detection_sensor_ != nullptr;
}
inline bool LocalModuleConfig::has_detection_sensor() const {
  return _internal_has_detection_sensor();
}
inline const ::meshtastic::ModuleConfig_DetectionSensorConfig& LocalModuleConfig::_internal_detection_sensor() const {
  const ::meshtastic::ModuleConfig_DetectionSensorConfig* p = _impl_.detection_sensor_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_DetectionSensorConfig&>(
      ::meshtastic::_ModuleConfig_DetectionSensorConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_DetectionSensorConfig& LocalModuleConfig::detection_sensor() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.detection_sensor)
  return _internal_detection_sensor();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_detection_sensor(
    ::meshtastic::ModuleConfig_DetectionSensorConfig* detection_sensor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.detection_sensor_);
  }
  _impl_.detection_sensor_ = detection_sensor;
  if (detection_sensor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.detection_sensor)
}
inline ::meshtastic::ModuleConfig_DetectionSensorConfig* LocalModuleConfig::release_detection_sensor() {
  
  ::meshtastic::ModuleConfig_DetectionSensorConfig* temp = _impl_.detection_sensor_;
  _impl_.detection_sensor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_DetectionSensorConfig* LocalModuleConfig::unsafe_arena_release_detection_sensor() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.detection_sensor)
  
  ::meshtastic::ModuleConfig_DetectionSensorConfig* temp = _impl_.detection_sensor_;
  _impl_.detection_sensor_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_DetectionSensorConfig* LocalModuleConfig::_internal_mutable_detection_sensor() {
  
  if (_impl_.detection_sensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_DetectionSensorConfig>(GetArenaForAllocation());
    _impl_.detection_sensor_ = p;
  }
  return _impl_.detection_sensor_;
}
inline ::meshtastic::ModuleConfig_DetectionSensorConfig* LocalModuleConfig::mutable_detection_sensor() {
  ::meshtastic::ModuleConfig_DetectionSensorConfig* _msg = _internal_mutable_detection_sensor();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.detection_sensor)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_detection_sensor(::meshtastic::ModuleConfig_DetectionSensorConfig* detection_sensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.detection_sensor_);
  }
  if (detection_sensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(detection_sensor));
    if (message_arena != submessage_arena) {
      detection_sensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detection_sensor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.detection_sensor_ = detection_sensor;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.detection_sensor)
}

// .meshtastic.ModuleConfig.PaxcounterConfig paxcounter = 14;
inline bool LocalModuleConfig::_internal_has_paxcounter() const {
  return this != internal_default_instance() && _impl_.paxcounter_ != nullptr;
}
inline bool LocalModuleConfig::has_paxcounter() const {
  return _internal_has_paxcounter();
}
inline const ::meshtastic::ModuleConfig_PaxcounterConfig& LocalModuleConfig::_internal_paxcounter() const {
  const ::meshtastic::ModuleConfig_PaxcounterConfig* p = _impl_.paxcounter_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_PaxcounterConfig&>(
      ::meshtastic::_ModuleConfig_PaxcounterConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_PaxcounterConfig& LocalModuleConfig::paxcounter() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.paxcounter)
  return _internal_paxcounter();
}
inline void LocalModuleConfig::unsafe_arena_set_allocated_paxcounter(
    ::meshtastic::ModuleConfig_PaxcounterConfig* paxcounter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paxcounter_);
  }
  _impl_.paxcounter_ = paxcounter;
  if (paxcounter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.LocalModuleConfig.paxcounter)
}
inline ::meshtastic::ModuleConfig_PaxcounterConfig* LocalModuleConfig::release_paxcounter() {
  
  ::meshtastic::ModuleConfig_PaxcounterConfig* temp = _impl_.paxcounter_;
  _impl_.paxcounter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_PaxcounterConfig* LocalModuleConfig::unsafe_arena_release_paxcounter() {
  // @@protoc_insertion_point(field_release:meshtastic.LocalModuleConfig.paxcounter)
  
  ::meshtastic::ModuleConfig_PaxcounterConfig* temp = _impl_.paxcounter_;
  _impl_.paxcounter_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_PaxcounterConfig* LocalModuleConfig::_internal_mutable_paxcounter() {
  
  if (_impl_.paxcounter_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_PaxcounterConfig>(GetArenaForAllocation());
    _impl_.paxcounter_ = p;
  }
  return _impl_.paxcounter_;
}
inline ::meshtastic::ModuleConfig_PaxcounterConfig* LocalModuleConfig::mutable_paxcounter() {
  ::meshtastic::ModuleConfig_PaxcounterConfig* _msg = _internal_mutable_paxcounter();
  // @@protoc_insertion_point(field_mutable:meshtastic.LocalModuleConfig.paxcounter)
  return _msg;
}
inline void LocalModuleConfig::set_allocated_paxcounter(::meshtastic::ModuleConfig_PaxcounterConfig* paxcounter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paxcounter_);
  }
  if (paxcounter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(paxcounter));
    if (message_arena != submessage_arena) {
      paxcounter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paxcounter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.paxcounter_ = paxcounter;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LocalModuleConfig.paxcounter)
}

// uint32 version = 8;
inline void LocalModuleConfig::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t LocalModuleConfig::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t LocalModuleConfig::version() const {
  // @@protoc_insertion_point(field_get:meshtastic.LocalModuleConfig.version)
  return _internal_version();
}
inline void LocalModuleConfig::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void LocalModuleConfig::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:meshtastic.LocalModuleConfig.version)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meshtastic

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_meshtastic_2flocalonly_2eproto
