// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: meshtastic/mesh.proto
// Protobuf C++ Version: 5.29.5

#ifndef meshtastic_2fmesh_2eproto_2epb_2eh
#define meshtastic_2fmesh_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "meshtastic/channel.pb.h"
#include "meshtastic/config.pb.h"
#include "meshtastic/device_ui.pb.h"
#include "meshtastic/module_config.pb.h"
#include "meshtastic/portnums.pb.h"
#include "meshtastic/telemetry.pb.h"
#include "meshtastic/xmodem.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_meshtastic_2fmesh_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_meshtastic_2fmesh_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_meshtastic_2fmesh_2eproto;
namespace meshtastic {
class ChunkedPayload;
struct ChunkedPayloadDefaultTypeInternal;
extern ChunkedPayloadDefaultTypeInternal _ChunkedPayload_default_instance_;
class ChunkedPayloadResponse;
struct ChunkedPayloadResponseDefaultTypeInternal;
extern ChunkedPayloadResponseDefaultTypeInternal _ChunkedPayloadResponse_default_instance_;
class ClientNotification;
struct ClientNotificationDefaultTypeInternal;
extern ClientNotificationDefaultTypeInternal _ClientNotification_default_instance_;
class Compressed;
struct CompressedDefaultTypeInternal;
extern CompressedDefaultTypeInternal _Compressed_default_instance_;
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class DeviceMetadata;
struct DeviceMetadataDefaultTypeInternal;
extern DeviceMetadataDefaultTypeInternal _DeviceMetadata_default_instance_;
class DuplicatedPublicKey;
struct DuplicatedPublicKeyDefaultTypeInternal;
extern DuplicatedPublicKeyDefaultTypeInternal _DuplicatedPublicKey_default_instance_;
class FileInfo;
struct FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class FromRadio;
struct FromRadioDefaultTypeInternal;
extern FromRadioDefaultTypeInternal _FromRadio_default_instance_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class KeyVerification;
struct KeyVerificationDefaultTypeInternal;
extern KeyVerificationDefaultTypeInternal _KeyVerification_default_instance_;
class KeyVerificationFinal;
struct KeyVerificationFinalDefaultTypeInternal;
extern KeyVerificationFinalDefaultTypeInternal _KeyVerificationFinal_default_instance_;
class KeyVerificationNumberInform;
struct KeyVerificationNumberInformDefaultTypeInternal;
extern KeyVerificationNumberInformDefaultTypeInternal _KeyVerificationNumberInform_default_instance_;
class KeyVerificationNumberRequest;
struct KeyVerificationNumberRequestDefaultTypeInternal;
extern KeyVerificationNumberRequestDefaultTypeInternal _KeyVerificationNumberRequest_default_instance_;
class LogRecord;
struct LogRecordDefaultTypeInternal;
extern LogRecordDefaultTypeInternal _LogRecord_default_instance_;
class LowEntropyKey;
struct LowEntropyKeyDefaultTypeInternal;
extern LowEntropyKeyDefaultTypeInternal _LowEntropyKey_default_instance_;
class MeshPacket;
struct MeshPacketDefaultTypeInternal;
extern MeshPacketDefaultTypeInternal _MeshPacket_default_instance_;
class MqttClientProxyMessage;
struct MqttClientProxyMessageDefaultTypeInternal;
extern MqttClientProxyMessageDefaultTypeInternal _MqttClientProxyMessage_default_instance_;
class MyNodeInfo;
struct MyNodeInfoDefaultTypeInternal;
extern MyNodeInfoDefaultTypeInternal _MyNodeInfo_default_instance_;
class Neighbor;
struct NeighborDefaultTypeInternal;
extern NeighborDefaultTypeInternal _Neighbor_default_instance_;
class NeighborInfo;
struct NeighborInfoDefaultTypeInternal;
extern NeighborInfoDefaultTypeInternal _NeighborInfo_default_instance_;
class NodeInfo;
struct NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class NodeRemoteHardwarePin;
struct NodeRemoteHardwarePinDefaultTypeInternal;
extern NodeRemoteHardwarePinDefaultTypeInternal _NodeRemoteHardwarePin_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class QueueStatus;
struct QueueStatusDefaultTypeInternal;
extern QueueStatusDefaultTypeInternal _QueueStatus_default_instance_;
class RouteDiscovery;
struct RouteDiscoveryDefaultTypeInternal;
extern RouteDiscoveryDefaultTypeInternal _RouteDiscovery_default_instance_;
class Routing;
struct RoutingDefaultTypeInternal;
extern RoutingDefaultTypeInternal _Routing_default_instance_;
class ToRadio;
struct ToRadioDefaultTypeInternal;
extern ToRadioDefaultTypeInternal _ToRadio_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class Waypoint;
struct WaypointDefaultTypeInternal;
extern WaypointDefaultTypeInternal _Waypoint_default_instance_;
class resend_chunks;
struct resend_chunksDefaultTypeInternal;
extern resend_chunksDefaultTypeInternal _resend_chunks_default_instance_;
}  // namespace meshtastic
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace meshtastic {
enum Position_LocSource : int {
  Position_LocSource_LOC_UNSET = 0,
  Position_LocSource_LOC_MANUAL = 1,
  Position_LocSource_LOC_INTERNAL = 2,
  Position_LocSource_LOC_EXTERNAL = 3,
  Position_LocSource_Position_LocSource_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Position_LocSource_Position_LocSource_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Position_LocSource_IsValid(int value);
extern const uint32_t Position_LocSource_internal_data_[];
constexpr Position_LocSource Position_LocSource_LocSource_MIN = static_cast<Position_LocSource>(0);
constexpr Position_LocSource Position_LocSource_LocSource_MAX = static_cast<Position_LocSource>(3);
constexpr int Position_LocSource_LocSource_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Position_LocSource_descriptor();
template <typename T>
const std::string& Position_LocSource_Name(T value) {
  static_assert(std::is_same<T, Position_LocSource>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LocSource_Name().");
  return Position_LocSource_Name(static_cast<Position_LocSource>(value));
}
template <>
inline const std::string& Position_LocSource_Name(Position_LocSource value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Position_LocSource_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Position_LocSource_Parse(absl::string_view name, Position_LocSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Position_LocSource>(
      Position_LocSource_descriptor(), name, value);
}
enum Position_AltSource : int {
  Position_AltSource_ALT_UNSET = 0,
  Position_AltSource_ALT_MANUAL = 1,
  Position_AltSource_ALT_INTERNAL = 2,
  Position_AltSource_ALT_EXTERNAL = 3,
  Position_AltSource_ALT_BAROMETRIC = 4,
  Position_AltSource_Position_AltSource_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Position_AltSource_Position_AltSource_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Position_AltSource_IsValid(int value);
extern const uint32_t Position_AltSource_internal_data_[];
constexpr Position_AltSource Position_AltSource_AltSource_MIN = static_cast<Position_AltSource>(0);
constexpr Position_AltSource Position_AltSource_AltSource_MAX = static_cast<Position_AltSource>(4);
constexpr int Position_AltSource_AltSource_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
Position_AltSource_descriptor();
template <typename T>
const std::string& Position_AltSource_Name(T value) {
  static_assert(std::is_same<T, Position_AltSource>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AltSource_Name().");
  return Position_AltSource_Name(static_cast<Position_AltSource>(value));
}
template <>
inline const std::string& Position_AltSource_Name(Position_AltSource value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Position_AltSource_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool Position_AltSource_Parse(absl::string_view name, Position_AltSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Position_AltSource>(
      Position_AltSource_descriptor(), name, value);
}
enum Routing_Error : int {
  Routing_Error_NONE = 0,
  Routing_Error_NO_ROUTE = 1,
  Routing_Error_GOT_NAK = 2,
  Routing_Error_TIMEOUT = 3,
  Routing_Error_NO_INTERFACE = 4,
  Routing_Error_MAX_RETRANSMIT = 5,
  Routing_Error_NO_CHANNEL = 6,
  Routing_Error_TOO_LARGE = 7,
  Routing_Error_NO_RESPONSE = 8,
  Routing_Error_DUTY_CYCLE_LIMIT = 9,
  Routing_Error_BAD_REQUEST = 32,
  Routing_Error_NOT_AUTHORIZED = 33,
  Routing_Error_PKI_FAILED = 34,
  Routing_Error_PKI_UNKNOWN_PUBKEY = 35,
  Routing_Error_ADMIN_BAD_SESSION_KEY = 36,
  Routing_Error_ADMIN_PUBLIC_KEY_UNAUTHORIZED = 37,
  Routing_Error_RATE_LIMIT_EXCEEDED = 38,
  Routing_Error_Routing_Error_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Routing_Error_Routing_Error_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Routing_Error_IsValid(int value);
extern const uint32_t Routing_Error_internal_data_[];
constexpr Routing_Error Routing_Error_Error_MIN = static_cast<Routing_Error>(0);
constexpr Routing_Error Routing_Error_Error_MAX = static_cast<Routing_Error>(38);
constexpr int Routing_Error_Error_ARRAYSIZE = 38 + 1;
const ::google::protobuf::EnumDescriptor*
Routing_Error_descriptor();
template <typename T>
const std::string& Routing_Error_Name(T value) {
  static_assert(std::is_same<T, Routing_Error>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Error_Name().");
  return ::google::protobuf::internal::NameOfEnum(Routing_Error_descriptor(), value);
}
inline bool Routing_Error_Parse(absl::string_view name, Routing_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Routing_Error>(
      Routing_Error_descriptor(), name, value);
}
enum MeshPacket_Priority : int {
  MeshPacket_Priority_UNSET = 0,
  MeshPacket_Priority_MIN = 1,
  MeshPacket_Priority_BACKGROUND = 10,
  MeshPacket_Priority_DEFAULT = 64,
  MeshPacket_Priority_RELIABLE = 70,
  MeshPacket_Priority_RESPONSE = 80,
  MeshPacket_Priority_HIGH = 100,
  MeshPacket_Priority_ALERT = 110,
  MeshPacket_Priority_ACK = 120,
  MeshPacket_Priority_MAX = 127,
  MeshPacket_Priority_MeshPacket_Priority_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MeshPacket_Priority_MeshPacket_Priority_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MeshPacket_Priority_IsValid(int value);
extern const uint32_t MeshPacket_Priority_internal_data_[];
constexpr MeshPacket_Priority MeshPacket_Priority_Priority_MIN = static_cast<MeshPacket_Priority>(0);
constexpr MeshPacket_Priority MeshPacket_Priority_Priority_MAX = static_cast<MeshPacket_Priority>(127);
constexpr int MeshPacket_Priority_Priority_ARRAYSIZE = 127 + 1;
const ::google::protobuf::EnumDescriptor*
MeshPacket_Priority_descriptor();
template <typename T>
const std::string& MeshPacket_Priority_Name(T value) {
  static_assert(std::is_same<T, MeshPacket_Priority>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Priority_Name().");
  return ::google::protobuf::internal::NameOfEnum(MeshPacket_Priority_descriptor(), value);
}
inline bool MeshPacket_Priority_Parse(absl::string_view name, MeshPacket_Priority* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeshPacket_Priority>(
      MeshPacket_Priority_descriptor(), name, value);
}
enum MeshPacket_Delayed : int {
  MeshPacket_Delayed_NO_DELAY = 0,
  MeshPacket_Delayed_DELAYED_BROADCAST = 1,
  MeshPacket_Delayed_DELAYED_DIRECT = 2,
  MeshPacket_Delayed_MeshPacket_Delayed_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MeshPacket_Delayed_MeshPacket_Delayed_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MeshPacket_Delayed_IsValid(int value);
extern const uint32_t MeshPacket_Delayed_internal_data_[];
constexpr MeshPacket_Delayed MeshPacket_Delayed_Delayed_MIN = static_cast<MeshPacket_Delayed>(0);
constexpr MeshPacket_Delayed MeshPacket_Delayed_Delayed_MAX = static_cast<MeshPacket_Delayed>(2);
constexpr int MeshPacket_Delayed_Delayed_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
MeshPacket_Delayed_descriptor();
template <typename T>
const std::string& MeshPacket_Delayed_Name(T value) {
  static_assert(std::is_same<T, MeshPacket_Delayed>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Delayed_Name().");
  return MeshPacket_Delayed_Name(static_cast<MeshPacket_Delayed>(value));
}
template <>
inline const std::string& MeshPacket_Delayed_Name(MeshPacket_Delayed value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MeshPacket_Delayed_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool MeshPacket_Delayed_Parse(absl::string_view name, MeshPacket_Delayed* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeshPacket_Delayed>(
      MeshPacket_Delayed_descriptor(), name, value);
}
enum MeshPacket_TransportMechanism : int {
  MeshPacket_TransportMechanism_TRANSPORT_INTERNAL = 0,
  MeshPacket_TransportMechanism_TRANSPORT_LORA = 1,
  MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT1 = 2,
  MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT2 = 3,
  MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT3 = 4,
  MeshPacket_TransportMechanism_TRANSPORT_MQTT = 5,
  MeshPacket_TransportMechanism_TRANSPORT_MULTICAST_UDP = 6,
  MeshPacket_TransportMechanism_TRANSPORT_API = 7,
  MeshPacket_TransportMechanism_MeshPacket_TransportMechanism_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MeshPacket_TransportMechanism_MeshPacket_TransportMechanism_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MeshPacket_TransportMechanism_IsValid(int value);
extern const uint32_t MeshPacket_TransportMechanism_internal_data_[];
constexpr MeshPacket_TransportMechanism MeshPacket_TransportMechanism_TransportMechanism_MIN = static_cast<MeshPacket_TransportMechanism>(0);
constexpr MeshPacket_TransportMechanism MeshPacket_TransportMechanism_TransportMechanism_MAX = static_cast<MeshPacket_TransportMechanism>(7);
constexpr int MeshPacket_TransportMechanism_TransportMechanism_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
MeshPacket_TransportMechanism_descriptor();
template <typename T>
const std::string& MeshPacket_TransportMechanism_Name(T value) {
  static_assert(std::is_same<T, MeshPacket_TransportMechanism>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TransportMechanism_Name().");
  return MeshPacket_TransportMechanism_Name(static_cast<MeshPacket_TransportMechanism>(value));
}
template <>
inline const std::string& MeshPacket_TransportMechanism_Name(MeshPacket_TransportMechanism value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MeshPacket_TransportMechanism_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool MeshPacket_TransportMechanism_Parse(absl::string_view name, MeshPacket_TransportMechanism* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeshPacket_TransportMechanism>(
      MeshPacket_TransportMechanism_descriptor(), name, value);
}
enum LogRecord_Level : int {
  LogRecord_Level_UNSET = 0,
  LogRecord_Level_CRITICAL = 50,
  LogRecord_Level_ERROR = 40,
  LogRecord_Level_WARNING = 30,
  LogRecord_Level_INFO = 20,
  LogRecord_Level_DEBUG = 10,
  LogRecord_Level_TRACE = 5,
  LogRecord_Level_LogRecord_Level_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LogRecord_Level_LogRecord_Level_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LogRecord_Level_IsValid(int value);
extern const uint32_t LogRecord_Level_internal_data_[];
constexpr LogRecord_Level LogRecord_Level_Level_MIN = static_cast<LogRecord_Level>(0);
constexpr LogRecord_Level LogRecord_Level_Level_MAX = static_cast<LogRecord_Level>(50);
constexpr int LogRecord_Level_Level_ARRAYSIZE = 50 + 1;
const ::google::protobuf::EnumDescriptor*
LogRecord_Level_descriptor();
template <typename T>
const std::string& LogRecord_Level_Name(T value) {
  static_assert(std::is_same<T, LogRecord_Level>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Level_Name().");
  return ::google::protobuf::internal::NameOfEnum(LogRecord_Level_descriptor(), value);
}
inline bool LogRecord_Level_Parse(absl::string_view name, LogRecord_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogRecord_Level>(
      LogRecord_Level_descriptor(), name, value);
}
enum HardwareModel : int {
  UNSET = 0,
  TLORA_V2 = 1,
  TLORA_V1 = 2,
  TLORA_V2_1_1P6 = 3,
  TBEAM = 4,
  HELTEC_V2_0 = 5,
  TBEAM_V0P7 = 6,
  T_ECHO = 7,
  TLORA_V1_1P3 = 8,
  RAK4631 = 9,
  HELTEC_V2_1 = 10,
  HELTEC_V1 = 11,
  LILYGO_TBEAM_S3_CORE = 12,
  RAK11200 = 13,
  NANO_G1 = 14,
  TLORA_V2_1_1P8 = 15,
  TLORA_T3_S3 = 16,
  NANO_G1_EXPLORER = 17,
  NANO_G2_ULTRA = 18,
  LORA_TYPE = 19,
  WIPHONE = 20,
  WIO_WM1110 = 21,
  RAK2560 = 22,
  HELTEC_HRU_3601 = 23,
  HELTEC_WIRELESS_BRIDGE = 24,
  STATION_G1 = 25,
  RAK11310 = 26,
  SENSELORA_RP2040 = 27,
  SENSELORA_S3 = 28,
  CANARYONE = 29,
  RP2040_LORA = 30,
  STATION_G2 = 31,
  LORA_RELAY_V1 = 32,
  NRF52840DK = 33,
  PPR = 34,
  GENIEBLOCKS = 35,
  NRF52_UNKNOWN = 36,
  PORTDUINO = 37,
  ANDROID_SIM = 38,
  DIY_V1 = 39,
  NRF52840_PCA10059 = 40,
  DR_DEV = 41,
  M5STACK = 42,
  HELTEC_V3 = 43,
  HELTEC_WSL_V3 = 44,
  BETAFPV_2400_TX = 45,
  BETAFPV_900_NANO_TX = 46,
  RPI_PICO = 47,
  HELTEC_WIRELESS_TRACKER = 48,
  HELTEC_WIRELESS_PAPER = 49,
  T_DECK = 50,
  T_WATCH_S3 = 51,
  PICOMPUTER_S3 = 52,
  HELTEC_HT62 = 53,
  EBYTE_ESP32_S3 = 54,
  ESP32_S3_PICO = 55,
  CHATTER_2 = 56,
  HELTEC_WIRELESS_PAPER_V1_0 = 57,
  HELTEC_WIRELESS_TRACKER_V1_0 = 58,
  UNPHONE = 59,
  TD_LORAC = 60,
  CDEBYTE_EORA_S3 = 61,
  TWC_MESH_V4 = 62,
  NRF52_PROMICRO_DIY = 63,
  RADIOMASTER_900_BANDIT_NANO = 64,
  HELTEC_CAPSULE_SENSOR_V3 = 65,
  HELTEC_VISION_MASTER_T190 = 66,
  HELTEC_VISION_MASTER_E213 = 67,
  HELTEC_VISION_MASTER_E290 = 68,
  HELTEC_MESH_NODE_T114 = 69,
  SENSECAP_INDICATOR = 70,
  TRACKER_T1000_E = 71,
  RAK3172 = 72,
  WIO_E5 = 73,
  RADIOMASTER_900_BANDIT = 74,
  ME25LS01_4Y10TD = 75,
  RP2040_FEATHER_RFM95 = 76,
  M5STACK_COREBASIC = 77,
  M5STACK_CORE2 = 78,
  RPI_PICO2 = 79,
  M5STACK_CORES3 = 80,
  SEEED_XIAO_S3 = 81,
  MS24SF1 = 82,
  TLORA_C6 = 83,
  WISMESH_TAP = 84,
  ROUTASTIC = 85,
  MESH_TAB = 86,
  MESHLINK = 87,
  XIAO_NRF52_KIT = 88,
  THINKNODE_M1 = 89,
  THINKNODE_M2 = 90,
  T_ETH_ELITE = 91,
  HELTEC_SENSOR_HUB = 92,
  RESERVED_FRIED_CHICKEN = 93,
  HELTEC_MESH_POCKET = 94,
  SEEED_SOLAR_NODE = 95,
  NOMADSTAR_METEOR_PRO = 96,
  CROWPANEL = 97,
  LINK_32 = 98,
  SEEED_WIO_TRACKER_L1 = 99,
  SEEED_WIO_TRACKER_L1_EINK = 100,
  QWANTZ_TINY_ARMS = 101,
  T_DECK_PRO = 102,
  T_LORA_PAGER = 103,
  M5STACK_RESERVED = 104,
  WISMESH_TAG = 105,
  RAK3312 = 106,
  THINKNODE_M5 = 107,
  HELTEC_MESH_SOLAR = 108,
  T_ECHO_LITE = 109,
  HELTEC_V4 = 110,
  M5STACK_C6L = 111,
  PRIVATE_HW = 255,
  HardwareModel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  HardwareModel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool HardwareModel_IsValid(int value);
extern const uint32_t HardwareModel_internal_data_[];
constexpr HardwareModel HardwareModel_MIN = static_cast<HardwareModel>(0);
constexpr HardwareModel HardwareModel_MAX = static_cast<HardwareModel>(255);
constexpr int HardwareModel_ARRAYSIZE = 255 + 1;
const ::google::protobuf::EnumDescriptor*
HardwareModel_descriptor();
template <typename T>
const std::string& HardwareModel_Name(T value) {
  static_assert(std::is_same<T, HardwareModel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HardwareModel_Name().");
  return ::google::protobuf::internal::NameOfEnum(HardwareModel_descriptor(), value);
}
inline bool HardwareModel_Parse(absl::string_view name, HardwareModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HardwareModel>(
      HardwareModel_descriptor(), name, value);
}
enum Constants : int {
  ZERO = 0,
  DATA_PAYLOAD_LEN = 233,
  Constants_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Constants_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Constants_IsValid(int value);
extern const uint32_t Constants_internal_data_[];
constexpr Constants Constants_MIN = static_cast<Constants>(0);
constexpr Constants Constants_MAX = static_cast<Constants>(233);
constexpr int Constants_ARRAYSIZE = 233 + 1;
const ::google::protobuf::EnumDescriptor*
Constants_descriptor();
template <typename T>
const std::string& Constants_Name(T value) {
  static_assert(std::is_same<T, Constants>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Constants_Name().");
  return ::google::protobuf::internal::NameOfEnum(Constants_descriptor(), value);
}
inline bool Constants_Parse(absl::string_view name, Constants* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Constants>(
      Constants_descriptor(), name, value);
}
enum CriticalErrorCode : int {
  NONE = 0,
  TX_WATCHDOG = 1,
  SLEEP_ENTER_WAIT = 2,
  NO_RADIO = 3,
  UNSPECIFIED = 4,
  UBLOX_UNIT_FAILED = 5,
  NO_AXP192 = 6,
  INVALID_RADIO_SETTING = 7,
  TRANSMIT_FAILED = 8,
  BROWNOUT = 9,
  SX1262_FAILURE = 10,
  RADIO_SPI_BUG = 11,
  FLASH_CORRUPTION_RECOVERABLE = 12,
  FLASH_CORRUPTION_UNRECOVERABLE = 13,
  CriticalErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CriticalErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CriticalErrorCode_IsValid(int value);
extern const uint32_t CriticalErrorCode_internal_data_[];
constexpr CriticalErrorCode CriticalErrorCode_MIN = static_cast<CriticalErrorCode>(0);
constexpr CriticalErrorCode CriticalErrorCode_MAX = static_cast<CriticalErrorCode>(13);
constexpr int CriticalErrorCode_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor*
CriticalErrorCode_descriptor();
template <typename T>
const std::string& CriticalErrorCode_Name(T value) {
  static_assert(std::is_same<T, CriticalErrorCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CriticalErrorCode_Name().");
  return CriticalErrorCode_Name(static_cast<CriticalErrorCode>(value));
}
template <>
inline const std::string& CriticalErrorCode_Name(CriticalErrorCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CriticalErrorCode_descriptor,
                                                 0, 13>(
      static_cast<int>(value));
}
inline bool CriticalErrorCode_Parse(absl::string_view name, CriticalErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CriticalErrorCode>(
      CriticalErrorCode_descriptor(), name, value);
}
enum FirmwareEdition : int {
  VANILLA = 0,
  SMART_CITIZEN = 1,
  OPEN_SAUCE = 16,
  DEFCON = 17,
  BURNING_MAN = 18,
  HAMVENTION = 19,
  DIY_EDITION = 127,
  FirmwareEdition_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FirmwareEdition_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FirmwareEdition_IsValid(int value);
extern const uint32_t FirmwareEdition_internal_data_[];
constexpr FirmwareEdition FirmwareEdition_MIN = static_cast<FirmwareEdition>(0);
constexpr FirmwareEdition FirmwareEdition_MAX = static_cast<FirmwareEdition>(127);
constexpr int FirmwareEdition_ARRAYSIZE = 127 + 1;
const ::google::protobuf::EnumDescriptor*
FirmwareEdition_descriptor();
template <typename T>
const std::string& FirmwareEdition_Name(T value) {
  static_assert(std::is_same<T, FirmwareEdition>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FirmwareEdition_Name().");
  return ::google::protobuf::internal::NameOfEnum(FirmwareEdition_descriptor(), value);
}
inline bool FirmwareEdition_Parse(absl::string_view name, FirmwareEdition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FirmwareEdition>(
      FirmwareEdition_descriptor(), name, value);
}
enum ExcludedModules : int {
  EXCLUDED_NONE = 0,
  MQTT_CONFIG = 1,
  SERIAL_CONFIG = 2,
  EXTNOTIF_CONFIG = 4,
  STOREFORWARD_CONFIG = 8,
  RANGETEST_CONFIG = 16,
  TELEMETRY_CONFIG = 32,
  CANNEDMSG_CONFIG = 64,
  AUDIO_CONFIG = 128,
  REMOTEHARDWARE_CONFIG = 256,
  NEIGHBORINFO_CONFIG = 512,
  AMBIENTLIGHTING_CONFIG = 1024,
  DETECTIONSENSOR_CONFIG = 2048,
  PAXCOUNTER_CONFIG = 4096,
  BLUETOOTH_CONFIG = 8192,
  NETWORK_CONFIG = 16384,
  ExcludedModules_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ExcludedModules_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ExcludedModules_IsValid(int value);
extern const uint32_t ExcludedModules_internal_data_[];
constexpr ExcludedModules ExcludedModules_MIN = static_cast<ExcludedModules>(0);
constexpr ExcludedModules ExcludedModules_MAX = static_cast<ExcludedModules>(16384);
constexpr int ExcludedModules_ARRAYSIZE = 16384 + 1;
const ::google::protobuf::EnumDescriptor*
ExcludedModules_descriptor();
template <typename T>
const std::string& ExcludedModules_Name(T value) {
  static_assert(std::is_same<T, ExcludedModules>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ExcludedModules_Name().");
  return ::google::protobuf::internal::NameOfEnum(ExcludedModules_descriptor(), value);
}
inline bool ExcludedModules_Parse(absl::string_view name, ExcludedModules* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExcludedModules>(
      ExcludedModules_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class resend_chunks final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.resend_chunks) */ {
 public:
  inline resend_chunks() : resend_chunks(nullptr) {}
  ~resend_chunks() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(resend_chunks* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(resend_chunks));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR resend_chunks(
      ::google::protobuf::internal::ConstantInitialized);

  inline resend_chunks(const resend_chunks& from) : resend_chunks(nullptr, from) {}
  inline resend_chunks(resend_chunks&& from) noexcept
      : resend_chunks(nullptr, std::move(from)) {}
  inline resend_chunks& operator=(const resend_chunks& from) {
    CopyFrom(from);
    return *this;
  }
  inline resend_chunks& operator=(resend_chunks&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resend_chunks& default_instance() {
    return *internal_default_instance();
  }
  static inline const resend_chunks* internal_default_instance() {
    return reinterpret_cast<const resend_chunks*>(
        &_resend_chunks_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(resend_chunks& a, resend_chunks& b) { a.Swap(&b); }
  inline void Swap(resend_chunks* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resend_chunks* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resend_chunks* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<resend_chunks>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const resend_chunks& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const resend_chunks& from) { resend_chunks::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(resend_chunks* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.resend_chunks"; }

 protected:
  explicit resend_chunks(::google::protobuf::Arena* arena);
  resend_chunks(::google::protobuf::Arena* arena, const resend_chunks& from);
  resend_chunks(::google::protobuf::Arena* arena, resend_chunks&& from) noexcept
      : resend_chunks(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChunksFieldNumber = 1,
  };
  // repeated uint32 chunks = 1;
  int chunks_size() const;
  private:
  int _internal_chunks_size() const;

  public:
  void clear_chunks() ;
  ::uint32_t chunks(int index) const;
  void set_chunks(int index, ::uint32_t value);
  void add_chunks(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& chunks() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_chunks();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_chunks() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_chunks();

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.resend_chunks)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const resend_chunks& from_msg);
    ::google::protobuf::RepeatedField<::uint32_t> chunks_;
    ::google::protobuf::internal::CachedSize _chunks_cached_byte_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Waypoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Waypoint) */ {
 public:
  inline Waypoint() : Waypoint(nullptr) {}
  ~Waypoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Waypoint* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Waypoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Waypoint(
      ::google::protobuf::internal::ConstantInitialized);

  inline Waypoint(const Waypoint& from) : Waypoint(nullptr, from) {}
  inline Waypoint(Waypoint&& from) noexcept
      : Waypoint(nullptr, std::move(from)) {}
  inline Waypoint& operator=(const Waypoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Waypoint& operator=(Waypoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Waypoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Waypoint* internal_default_instance() {
    return reinterpret_cast<const Waypoint*>(
        &_Waypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Waypoint& a, Waypoint& b) { a.Swap(&b); }
  inline void Swap(Waypoint* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Waypoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Waypoint* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Waypoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Waypoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Waypoint& from) { Waypoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Waypoint* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Waypoint"; }

 protected:
  explicit Waypoint(::google::protobuf::Arena* arena);
  Waypoint(::google::protobuf::Arena* arena, const Waypoint& from);
  Waypoint(::google::protobuf::Arena* arena, Waypoint&& from) noexcept
      : Waypoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 6,
    kDescriptionFieldNumber = 7,
    kIdFieldNumber = 1,
    kLatitudeIFieldNumber = 2,
    kLongitudeIFieldNumber = 3,
    kExpireFieldNumber = 4,
    kLockedToFieldNumber = 5,
    kIconFieldNumber = 8,
  };
  // string name = 6;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string description = 7;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // optional sfixed32 latitude_i = 2;
  bool has_latitude_i() const;
  void clear_latitude_i() ;
  ::int32_t latitude_i() const;
  void set_latitude_i(::int32_t value);

  private:
  ::int32_t _internal_latitude_i() const;
  void _internal_set_latitude_i(::int32_t value);

  public:
  // optional sfixed32 longitude_i = 3;
  bool has_longitude_i() const;
  void clear_longitude_i() ;
  ::int32_t longitude_i() const;
  void set_longitude_i(::int32_t value);

  private:
  ::int32_t _internal_longitude_i() const;
  void _internal_set_longitude_i(::int32_t value);

  public:
  // uint32 expire = 4;
  void clear_expire() ;
  ::uint32_t expire() const;
  void set_expire(::uint32_t value);

  private:
  ::uint32_t _internal_expire() const;
  void _internal_set_expire(::uint32_t value);

  public:
  // uint32 locked_to = 5;
  void clear_locked_to() ;
  ::uint32_t locked_to() const;
  void set_locked_to(::uint32_t value);

  private:
  ::uint32_t _internal_locked_to() const;
  void _internal_set_locked_to(::uint32_t value);

  public:
  // fixed32 icon = 8;
  void clear_icon() ;
  ::uint32_t icon() const;
  void set_icon(::uint32_t value);

  private:
  ::uint32_t _internal_icon() const;
  void _internal_set_icon(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Waypoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      51, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Waypoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::uint32_t id_;
    ::int32_t latitude_i_;
    ::int32_t longitude_i_;
    ::uint32_t expire_;
    ::uint32_t locked_to_;
    ::uint32_t icon_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class User final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(User* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(User));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR User(
      ::google::protobuf::internal::ConstantInitialized);

  inline User(const User& from) : User(nullptr, from) {}
  inline User(User&& from) noexcept
      : User(nullptr, std::move(from)) {}
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
        &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(User& a, User& b) { a.Swap(&b); }
  inline void Swap(User* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<User>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const User& from) { User::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(User* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.User"; }

 protected:
  explicit User(::google::protobuf::Arena* arena);
  User(::google::protobuf::Arena* arena, const User& from);
  User(::google::protobuf::Arena* arena, User&& from) noexcept
      : User(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kLongNameFieldNumber = 2,
    kShortNameFieldNumber = 3,
    kMacaddrFieldNumber = 4,
    kPublicKeyFieldNumber = 8,
    kHwModelFieldNumber = 5,
    kRoleFieldNumber = 7,
    kIsLicensedFieldNumber = 6,
    kIsUnmessagableFieldNumber = 9,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string long_name = 2;
  void clear_long_name() ;
  const std::string& long_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_long_name(Arg_&& arg, Args_... args);
  std::string* mutable_long_name();
  PROTOBUF_NODISCARD std::string* release_long_name();
  void set_allocated_long_name(std::string* value);

  private:
  const std::string& _internal_long_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_long_name(
      const std::string& value);
  std::string* _internal_mutable_long_name();

  public:
  // string short_name = 3;
  void clear_short_name() ;
  const std::string& short_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_short_name(Arg_&& arg, Args_... args);
  std::string* mutable_short_name();
  PROTOBUF_NODISCARD std::string* release_short_name();
  void set_allocated_short_name(std::string* value);

  private:
  const std::string& _internal_short_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_short_name(
      const std::string& value);
  std::string* _internal_mutable_short_name();

  public:
  // bytes macaddr = 4 [deprecated = true];
  [[deprecated]]  void clear_macaddr() ;
  [[deprecated]] const std::string& macaddr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_macaddr(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_macaddr();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_macaddr();
  [[deprecated]] void set_allocated_macaddr(std::string* value);

  private:
  const std::string& _internal_macaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_macaddr(
      const std::string& value);
  std::string* _internal_mutable_macaddr();

  public:
  // bytes public_key = 8;
  void clear_public_key() ;
  const std::string& public_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_public_key(Arg_&& arg, Args_... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* value);

  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(
      const std::string& value);
  std::string* _internal_mutable_public_key();

  public:
  // .meshtastic.HardwareModel hw_model = 5;
  void clear_hw_model() ;
  ::meshtastic::HardwareModel hw_model() const;
  void set_hw_model(::meshtastic::HardwareModel value);

  private:
  ::meshtastic::HardwareModel _internal_hw_model() const;
  void _internal_set_hw_model(::meshtastic::HardwareModel value);

  public:
  // .meshtastic.Config.DeviceConfig.Role role = 7;
  void clear_role() ;
  ::meshtastic::Config_DeviceConfig_Role role() const;
  void set_role(::meshtastic::Config_DeviceConfig_Role value);

  private:
  ::meshtastic::Config_DeviceConfig_Role _internal_role() const;
  void _internal_set_role(::meshtastic::Config_DeviceConfig_Role value);

  public:
  // bool is_licensed = 6;
  void clear_is_licensed() ;
  bool is_licensed() const;
  void set_is_licensed(bool value);

  private:
  bool _internal_is_licensed() const;
  void _internal_set_is_licensed(bool value);

  public:
  // optional bool is_unmessagable = 9;
  bool has_is_unmessagable() const;
  void clear_is_unmessagable() ;
  bool is_unmessagable() const;
  void set_is_unmessagable(bool value);

  private:
  bool _internal_is_unmessagable() const;
  void _internal_set_is_unmessagable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.User)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      53, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const User& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr long_name_;
    ::google::protobuf::internal::ArenaStringPtr short_name_;
    ::google::protobuf::internal::ArenaStringPtr macaddr_;
    ::google::protobuf::internal::ArenaStringPtr public_key_;
    int hw_model_;
    int role_;
    bool is_licensed_;
    bool is_unmessagable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class RouteDiscovery final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.RouteDiscovery) */ {
 public:
  inline RouteDiscovery() : RouteDiscovery(nullptr) {}
  ~RouteDiscovery() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RouteDiscovery* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RouteDiscovery));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteDiscovery(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteDiscovery(const RouteDiscovery& from) : RouteDiscovery(nullptr, from) {}
  inline RouteDiscovery(RouteDiscovery&& from) noexcept
      : RouteDiscovery(nullptr, std::move(from)) {}
  inline RouteDiscovery& operator=(const RouteDiscovery& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteDiscovery& operator=(RouteDiscovery&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteDiscovery& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteDiscovery* internal_default_instance() {
    return reinterpret_cast<const RouteDiscovery*>(
        &_RouteDiscovery_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RouteDiscovery& a, RouteDiscovery& b) { a.Swap(&b); }
  inline void Swap(RouteDiscovery* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteDiscovery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteDiscovery* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RouteDiscovery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteDiscovery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteDiscovery& from) { RouteDiscovery::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RouteDiscovery* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.RouteDiscovery"; }

 protected:
  explicit RouteDiscovery(::google::protobuf::Arena* arena);
  RouteDiscovery(::google::protobuf::Arena* arena, const RouteDiscovery& from);
  RouteDiscovery(::google::protobuf::Arena* arena, RouteDiscovery&& from) noexcept
      : RouteDiscovery(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRouteFieldNumber = 1,
    kSnrTowardsFieldNumber = 2,
    kRouteBackFieldNumber = 3,
    kSnrBackFieldNumber = 4,
  };
  // repeated fixed32 route = 1;
  int route_size() const;
  private:
  int _internal_route_size() const;

  public:
  void clear_route() ;
  ::uint32_t route(int index) const;
  void set_route(int index, ::uint32_t value);
  void add_route(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& route() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_route();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_route() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_route();

  public:
  // repeated int32 snr_towards = 2;
  int snr_towards_size() const;
  private:
  int _internal_snr_towards_size() const;

  public:
  void clear_snr_towards() ;
  ::int32_t snr_towards(int index) const;
  void set_snr_towards(int index, ::int32_t value);
  void add_snr_towards(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& snr_towards() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_snr_towards();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_snr_towards() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_snr_towards();

  public:
  // repeated fixed32 route_back = 3;
  int route_back_size() const;
  private:
  int _internal_route_back_size() const;

  public:
  void clear_route_back() ;
  ::uint32_t route_back(int index) const;
  void set_route_back(int index, ::uint32_t value);
  void add_route_back(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& route_back() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_route_back();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_route_back() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_route_back();

  public:
  // repeated int32 snr_back = 4;
  int snr_back_size() const;
  private:
  int _internal_snr_back_size() const;

  public:
  void clear_snr_back() ;
  ::int32_t snr_back(int index) const;
  void set_snr_back(int index, ::int32_t value);
  void add_snr_back(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& snr_back() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_snr_back();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_snr_back() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_snr_back();

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.RouteDiscovery)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RouteDiscovery& from_msg);
    ::google::protobuf::RepeatedField<::uint32_t> route_;
    ::google::protobuf::RepeatedField<::int32_t> snr_towards_;
    ::google::protobuf::internal::CachedSize _snr_towards_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> route_back_;
    ::google::protobuf::RepeatedField<::int32_t> snr_back_;
    ::google::protobuf::internal::CachedSize _snr_back_cached_byte_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class QueueStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.QueueStatus) */ {
 public:
  inline QueueStatus() : QueueStatus(nullptr) {}
  ~QueueStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(QueueStatus* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(QueueStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueueStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueueStatus(const QueueStatus& from) : QueueStatus(nullptr, from) {}
  inline QueueStatus(QueueStatus&& from) noexcept
      : QueueStatus(nullptr, std::move(from)) {}
  inline QueueStatus& operator=(const QueueStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueueStatus& operator=(QueueStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueueStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueueStatus* internal_default_instance() {
    return reinterpret_cast<const QueueStatus*>(
        &_QueueStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(QueueStatus& a, QueueStatus& b) { a.Swap(&b); }
  inline void Swap(QueueStatus* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueueStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueueStatus* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<QueueStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueueStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueueStatus& from) { QueueStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(QueueStatus* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.QueueStatus"; }

 protected:
  explicit QueueStatus(::google::protobuf::Arena* arena);
  QueueStatus(::google::protobuf::Arena* arena, const QueueStatus& from);
  QueueStatus(::google::protobuf::Arena* arena, QueueStatus&& from) noexcept
      : QueueStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResFieldNumber = 1,
    kFreeFieldNumber = 2,
    kMaxlenFieldNumber = 3,
    kMeshPacketIdFieldNumber = 4,
  };
  // int32 res = 1;
  void clear_res() ;
  ::int32_t res() const;
  void set_res(::int32_t value);

  private:
  ::int32_t _internal_res() const;
  void _internal_set_res(::int32_t value);

  public:
  // uint32 free = 2;
  void clear_free() ;
  ::uint32_t free() const;
  void set_free(::uint32_t value);

  private:
  ::uint32_t _internal_free() const;
  void _internal_set_free(::uint32_t value);

  public:
  // uint32 maxlen = 3;
  void clear_maxlen() ;
  ::uint32_t maxlen() const;
  void set_maxlen(::uint32_t value);

  private:
  ::uint32_t _internal_maxlen() const;
  void _internal_set_maxlen(::uint32_t value);

  public:
  // uint32 mesh_packet_id = 4;
  void clear_mesh_packet_id() ;
  ::uint32_t mesh_packet_id() const;
  void set_mesh_packet_id(::uint32_t value);

  private:
  ::uint32_t _internal_mesh_packet_id() const;
  void _internal_set_mesh_packet_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.QueueStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const QueueStatus& from_msg);
    ::int32_t res_;
    ::uint32_t free_;
    ::uint32_t maxlen_;
    ::uint32_t mesh_packet_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Position final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Position* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Position));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Position(
      ::google::protobuf::internal::ConstantInitialized);

  inline Position(const Position& from) : Position(nullptr, from) {}
  inline Position(Position&& from) noexcept
      : Position(nullptr, std::move(from)) {}
  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
        &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Position& a, Position& b) { a.Swap(&b); }
  inline void Swap(Position* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Position>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Position& from) { Position::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Position* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Position"; }

 protected:
  explicit Position(::google::protobuf::Arena* arena);
  Position(::google::protobuf::Arena* arena, const Position& from);
  Position(::google::protobuf::Arena* arena, Position&& from) noexcept
      : Position(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using LocSource = Position_LocSource;
  static constexpr LocSource LOC_UNSET = Position_LocSource_LOC_UNSET;
  static constexpr LocSource LOC_MANUAL = Position_LocSource_LOC_MANUAL;
  static constexpr LocSource LOC_INTERNAL = Position_LocSource_LOC_INTERNAL;
  static constexpr LocSource LOC_EXTERNAL = Position_LocSource_LOC_EXTERNAL;
  static inline bool LocSource_IsValid(int value) {
    return Position_LocSource_IsValid(value);
  }
  static constexpr LocSource LocSource_MIN = Position_LocSource_LocSource_MIN;
  static constexpr LocSource LocSource_MAX = Position_LocSource_LocSource_MAX;
  static constexpr int LocSource_ARRAYSIZE = Position_LocSource_LocSource_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LocSource_descriptor() {
    return Position_LocSource_descriptor();
  }
  template <typename T>
  static inline const std::string& LocSource_Name(T value) {
    return Position_LocSource_Name(value);
  }
  static inline bool LocSource_Parse(absl::string_view name, LocSource* value) {
    return Position_LocSource_Parse(name, value);
  }
  using AltSource = Position_AltSource;
  static constexpr AltSource ALT_UNSET = Position_AltSource_ALT_UNSET;
  static constexpr AltSource ALT_MANUAL = Position_AltSource_ALT_MANUAL;
  static constexpr AltSource ALT_INTERNAL = Position_AltSource_ALT_INTERNAL;
  static constexpr AltSource ALT_EXTERNAL = Position_AltSource_ALT_EXTERNAL;
  static constexpr AltSource ALT_BAROMETRIC = Position_AltSource_ALT_BAROMETRIC;
  static inline bool AltSource_IsValid(int value) {
    return Position_AltSource_IsValid(value);
  }
  static constexpr AltSource AltSource_MIN = Position_AltSource_AltSource_MIN;
  static constexpr AltSource AltSource_MAX = Position_AltSource_AltSource_MAX;
  static constexpr int AltSource_ARRAYSIZE = Position_AltSource_AltSource_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AltSource_descriptor() {
    return Position_AltSource_descriptor();
  }
  template <typename T>
  static inline const std::string& AltSource_Name(T value) {
    return Position_AltSource_Name(value);
  }
  static inline bool AltSource_Parse(absl::string_view name, AltSource* value) {
    return Position_AltSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kLatitudeIFieldNumber = 1,
    kLongitudeIFieldNumber = 2,
    kAltitudeFieldNumber = 3,
    kTimeFieldNumber = 4,
    kLocationSourceFieldNumber = 5,
    kAltitudeSourceFieldNumber = 6,
    kTimestampFieldNumber = 7,
    kTimestampMillisAdjustFieldNumber = 8,
    kAltitudeHaeFieldNumber = 9,
    kAltitudeGeoidalSeparationFieldNumber = 10,
    kPDOPFieldNumber = 11,
    kHDOPFieldNumber = 12,
    kVDOPFieldNumber = 13,
    kGpsAccuracyFieldNumber = 14,
    kGroundSpeedFieldNumber = 15,
    kGroundTrackFieldNumber = 16,
    kFixQualityFieldNumber = 17,
    kFixTypeFieldNumber = 18,
    kSatsInViewFieldNumber = 19,
    kSensorIdFieldNumber = 20,
    kNextUpdateFieldNumber = 21,
    kSeqNumberFieldNumber = 22,
    kPrecisionBitsFieldNumber = 23,
  };
  // optional sfixed32 latitude_i = 1;
  bool has_latitude_i() const;
  void clear_latitude_i() ;
  ::int32_t latitude_i() const;
  void set_latitude_i(::int32_t value);

  private:
  ::int32_t _internal_latitude_i() const;
  void _internal_set_latitude_i(::int32_t value);

  public:
  // optional sfixed32 longitude_i = 2;
  bool has_longitude_i() const;
  void clear_longitude_i() ;
  ::int32_t longitude_i() const;
  void set_longitude_i(::int32_t value);

  private:
  ::int32_t _internal_longitude_i() const;
  void _internal_set_longitude_i(::int32_t value);

  public:
  // optional int32 altitude = 3;
  bool has_altitude() const;
  void clear_altitude() ;
  ::int32_t altitude() const;
  void set_altitude(::int32_t value);

  private:
  ::int32_t _internal_altitude() const;
  void _internal_set_altitude(::int32_t value);

  public:
  // fixed32 time = 4;
  void clear_time() ;
  ::uint32_t time() const;
  void set_time(::uint32_t value);

  private:
  ::uint32_t _internal_time() const;
  void _internal_set_time(::uint32_t value);

  public:
  // .meshtastic.Position.LocSource location_source = 5;
  void clear_location_source() ;
  ::meshtastic::Position_LocSource location_source() const;
  void set_location_source(::meshtastic::Position_LocSource value);

  private:
  ::meshtastic::Position_LocSource _internal_location_source() const;
  void _internal_set_location_source(::meshtastic::Position_LocSource value);

  public:
  // .meshtastic.Position.AltSource altitude_source = 6;
  void clear_altitude_source() ;
  ::meshtastic::Position_AltSource altitude_source() const;
  void set_altitude_source(::meshtastic::Position_AltSource value);

  private:
  ::meshtastic::Position_AltSource _internal_altitude_source() const;
  void _internal_set_altitude_source(::meshtastic::Position_AltSource value);

  public:
  // fixed32 timestamp = 7;
  void clear_timestamp() ;
  ::uint32_t timestamp() const;
  void set_timestamp(::uint32_t value);

  private:
  ::uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint32_t value);

  public:
  // int32 timestamp_millis_adjust = 8;
  void clear_timestamp_millis_adjust() ;
  ::int32_t timestamp_millis_adjust() const;
  void set_timestamp_millis_adjust(::int32_t value);

  private:
  ::int32_t _internal_timestamp_millis_adjust() const;
  void _internal_set_timestamp_millis_adjust(::int32_t value);

  public:
  // optional sint32 altitude_hae = 9;
  bool has_altitude_hae() const;
  void clear_altitude_hae() ;
  ::int32_t altitude_hae() const;
  void set_altitude_hae(::int32_t value);

  private:
  ::int32_t _internal_altitude_hae() const;
  void _internal_set_altitude_hae(::int32_t value);

  public:
  // optional sint32 altitude_geoidal_separation = 10;
  bool has_altitude_geoidal_separation() const;
  void clear_altitude_geoidal_separation() ;
  ::int32_t altitude_geoidal_separation() const;
  void set_altitude_geoidal_separation(::int32_t value);

  private:
  ::int32_t _internal_altitude_geoidal_separation() const;
  void _internal_set_altitude_geoidal_separation(::int32_t value);

  public:
  // uint32 PDOP = 11;
  void clear_pdop() ;
  ::uint32_t pdop() const;
  void set_pdop(::uint32_t value);

  private:
  ::uint32_t _internal_pdop() const;
  void _internal_set_pdop(::uint32_t value);

  public:
  // uint32 HDOP = 12;
  void clear_hdop() ;
  ::uint32_t hdop() const;
  void set_hdop(::uint32_t value);

  private:
  ::uint32_t _internal_hdop() const;
  void _internal_set_hdop(::uint32_t value);

  public:
  // uint32 VDOP = 13;
  void clear_vdop() ;
  ::uint32_t vdop() const;
  void set_vdop(::uint32_t value);

  private:
  ::uint32_t _internal_vdop() const;
  void _internal_set_vdop(::uint32_t value);

  public:
  // uint32 gps_accuracy = 14;
  void clear_gps_accuracy() ;
  ::uint32_t gps_accuracy() const;
  void set_gps_accuracy(::uint32_t value);

  private:
  ::uint32_t _internal_gps_accuracy() const;
  void _internal_set_gps_accuracy(::uint32_t value);

  public:
  // optional uint32 ground_speed = 15;
  bool has_ground_speed() const;
  void clear_ground_speed() ;
  ::uint32_t ground_speed() const;
  void set_ground_speed(::uint32_t value);

  private:
  ::uint32_t _internal_ground_speed() const;
  void _internal_set_ground_speed(::uint32_t value);

  public:
  // optional uint32 ground_track = 16;
  bool has_ground_track() const;
  void clear_ground_track() ;
  ::uint32_t ground_track() const;
  void set_ground_track(::uint32_t value);

  private:
  ::uint32_t _internal_ground_track() const;
  void _internal_set_ground_track(::uint32_t value);

  public:
  // uint32 fix_quality = 17;
  void clear_fix_quality() ;
  ::uint32_t fix_quality() const;
  void set_fix_quality(::uint32_t value);

  private:
  ::uint32_t _internal_fix_quality() const;
  void _internal_set_fix_quality(::uint32_t value);

  public:
  // uint32 fix_type = 18;
  void clear_fix_type() ;
  ::uint32_t fix_type() const;
  void set_fix_type(::uint32_t value);

  private:
  ::uint32_t _internal_fix_type() const;
  void _internal_set_fix_type(::uint32_t value);

  public:
  // uint32 sats_in_view = 19;
  void clear_sats_in_view() ;
  ::uint32_t sats_in_view() const;
  void set_sats_in_view(::uint32_t value);

  private:
  ::uint32_t _internal_sats_in_view() const;
  void _internal_set_sats_in_view(::uint32_t value);

  public:
  // uint32 sensor_id = 20;
  void clear_sensor_id() ;
  ::uint32_t sensor_id() const;
  void set_sensor_id(::uint32_t value);

  private:
  ::uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(::uint32_t value);

  public:
  // uint32 next_update = 21;
  void clear_next_update() ;
  ::uint32_t next_update() const;
  void set_next_update(::uint32_t value);

  private:
  ::uint32_t _internal_next_update() const;
  void _internal_set_next_update(::uint32_t value);

  public:
  // uint32 seq_number = 22;
  void clear_seq_number() ;
  ::uint32_t seq_number() const;
  void set_seq_number(::uint32_t value);

  private:
  ::uint32_t _internal_seq_number() const;
  void _internal_set_seq_number(::uint32_t value);

  public:
  // uint32 precision_bits = 23;
  void clear_precision_bits() ;
  ::uint32_t precision_bits() const;
  void set_precision_bits(::uint32_t value);

  private:
  ::uint32_t _internal_precision_bits() const;
  void _internal_set_precision_bits(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Position)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 23, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Position& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t latitude_i_;
    ::int32_t longitude_i_;
    ::int32_t altitude_;
    ::uint32_t time_;
    int location_source_;
    int altitude_source_;
    ::uint32_t timestamp_;
    ::int32_t timestamp_millis_adjust_;
    ::int32_t altitude_hae_;
    ::int32_t altitude_geoidal_separation_;
    ::uint32_t pdop_;
    ::uint32_t hdop_;
    ::uint32_t vdop_;
    ::uint32_t gps_accuracy_;
    ::uint32_t ground_speed_;
    ::uint32_t ground_track_;
    ::uint32_t fix_quality_;
    ::uint32_t fix_type_;
    ::uint32_t sats_in_view_;
    ::uint32_t sensor_id_;
    ::uint32_t next_update_;
    ::uint32_t seq_number_;
    ::uint32_t precision_bits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Neighbor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Neighbor) */ {
 public:
  inline Neighbor() : Neighbor(nullptr) {}
  ~Neighbor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Neighbor* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Neighbor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Neighbor(
      ::google::protobuf::internal::ConstantInitialized);

  inline Neighbor(const Neighbor& from) : Neighbor(nullptr, from) {}
  inline Neighbor(Neighbor&& from) noexcept
      : Neighbor(nullptr, std::move(from)) {}
  inline Neighbor& operator=(const Neighbor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neighbor& operator=(Neighbor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neighbor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neighbor* internal_default_instance() {
    return reinterpret_cast<const Neighbor*>(
        &_Neighbor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(Neighbor& a, Neighbor& b) { a.Swap(&b); }
  inline void Swap(Neighbor* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neighbor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neighbor* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Neighbor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Neighbor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Neighbor& from) { Neighbor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Neighbor* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Neighbor"; }

 protected:
  explicit Neighbor(::google::protobuf::Arena* arena);
  Neighbor(::google::protobuf::Arena* arena, const Neighbor& from);
  Neighbor(::google::protobuf::Arena* arena, Neighbor&& from) noexcept
      : Neighbor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeIdFieldNumber = 1,
    kSnrFieldNumber = 2,
    kLastRxTimeFieldNumber = 3,
    kNodeBroadcastIntervalSecsFieldNumber = 4,
  };
  // uint32 node_id = 1;
  void clear_node_id() ;
  ::uint32_t node_id() const;
  void set_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_node_id() const;
  void _internal_set_node_id(::uint32_t value);

  public:
  // float snr = 2;
  void clear_snr() ;
  float snr() const;
  void set_snr(float value);

  private:
  float _internal_snr() const;
  void _internal_set_snr(float value);

  public:
  // fixed32 last_rx_time = 3;
  void clear_last_rx_time() ;
  ::uint32_t last_rx_time() const;
  void set_last_rx_time(::uint32_t value);

  private:
  ::uint32_t _internal_last_rx_time() const;
  void _internal_set_last_rx_time(::uint32_t value);

  public:
  // uint32 node_broadcast_interval_secs = 4;
  void clear_node_broadcast_interval_secs() ;
  ::uint32_t node_broadcast_interval_secs() const;
  void set_node_broadcast_interval_secs(::uint32_t value);

  private:
  ::uint32_t _internal_node_broadcast_interval_secs() const;
  void _internal_set_node_broadcast_interval_secs(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Neighbor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Neighbor& from_msg);
    ::uint32_t node_id_;
    float snr_;
    ::uint32_t last_rx_time_;
    ::uint32_t node_broadcast_interval_secs_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class MyNodeInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.MyNodeInfo) */ {
 public:
  inline MyNodeInfo() : MyNodeInfo(nullptr) {}
  ~MyNodeInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MyNodeInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MyNodeInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MyNodeInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline MyNodeInfo(const MyNodeInfo& from) : MyNodeInfo(nullptr, from) {}
  inline MyNodeInfo(MyNodeInfo&& from) noexcept
      : MyNodeInfo(nullptr, std::move(from)) {}
  inline MyNodeInfo& operator=(const MyNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyNodeInfo& operator=(MyNodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MyNodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MyNodeInfo* internal_default_instance() {
    return reinterpret_cast<const MyNodeInfo*>(
        &_MyNodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(MyNodeInfo& a, MyNodeInfo& b) { a.Swap(&b); }
  inline void Swap(MyNodeInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyNodeInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MyNodeInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MyNodeInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MyNodeInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MyNodeInfo& from) { MyNodeInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MyNodeInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.MyNodeInfo"; }

 protected:
  explicit MyNodeInfo(::google::protobuf::Arena* arena);
  MyNodeInfo(::google::protobuf::Arena* arena, const MyNodeInfo& from);
  MyNodeInfo(::google::protobuf::Arena* arena, MyNodeInfo&& from) noexcept
      : MyNodeInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceIdFieldNumber = 12,
    kPioEnvFieldNumber = 13,
    kMyNodeNumFieldNumber = 1,
    kRebootCountFieldNumber = 8,
    kMinAppVersionFieldNumber = 11,
    kFirmwareEditionFieldNumber = 14,
    kNodedbCountFieldNumber = 15,
  };
  // bytes device_id = 12;
  void clear_device_id() ;
  const std::string& device_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_id(Arg_&& arg, Args_... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* value);

  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(
      const std::string& value);
  std::string* _internal_mutable_device_id();

  public:
  // string pio_env = 13;
  void clear_pio_env() ;
  const std::string& pio_env() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pio_env(Arg_&& arg, Args_... args);
  std::string* mutable_pio_env();
  PROTOBUF_NODISCARD std::string* release_pio_env();
  void set_allocated_pio_env(std::string* value);

  private:
  const std::string& _internal_pio_env() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pio_env(
      const std::string& value);
  std::string* _internal_mutable_pio_env();

  public:
  // uint32 my_node_num = 1;
  void clear_my_node_num() ;
  ::uint32_t my_node_num() const;
  void set_my_node_num(::uint32_t value);

  private:
  ::uint32_t _internal_my_node_num() const;
  void _internal_set_my_node_num(::uint32_t value);

  public:
  // uint32 reboot_count = 8;
  void clear_reboot_count() ;
  ::uint32_t reboot_count() const;
  void set_reboot_count(::uint32_t value);

  private:
  ::uint32_t _internal_reboot_count() const;
  void _internal_set_reboot_count(::uint32_t value);

  public:
  // uint32 min_app_version = 11;
  void clear_min_app_version() ;
  ::uint32_t min_app_version() const;
  void set_min_app_version(::uint32_t value);

  private:
  ::uint32_t _internal_min_app_version() const;
  void _internal_set_min_app_version(::uint32_t value);

  public:
  // .meshtastic.FirmwareEdition firmware_edition = 14;
  void clear_firmware_edition() ;
  ::meshtastic::FirmwareEdition firmware_edition() const;
  void set_firmware_edition(::meshtastic::FirmwareEdition value);

  private:
  ::meshtastic::FirmwareEdition _internal_firmware_edition() const;
  void _internal_set_firmware_edition(::meshtastic::FirmwareEdition value);

  public:
  // uint32 nodedb_count = 15;
  void clear_nodedb_count() ;
  ::uint32_t nodedb_count() const;
  void set_nodedb_count(::uint32_t value);

  private:
  ::uint32_t _internal_nodedb_count() const;
  void _internal_set_nodedb_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.MyNodeInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      37, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MyNodeInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr device_id_;
    ::google::protobuf::internal::ArenaStringPtr pio_env_;
    ::uint32_t my_node_num_;
    ::uint32_t reboot_count_;
    ::uint32_t min_app_version_;
    int firmware_edition_;
    ::uint32_t nodedb_count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class MqttClientProxyMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.MqttClientProxyMessage) */ {
 public:
  inline MqttClientProxyMessage() : MqttClientProxyMessage(nullptr) {}
  ~MqttClientProxyMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MqttClientProxyMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MqttClientProxyMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MqttClientProxyMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline MqttClientProxyMessage(const MqttClientProxyMessage& from) : MqttClientProxyMessage(nullptr, from) {}
  inline MqttClientProxyMessage(MqttClientProxyMessage&& from) noexcept
      : MqttClientProxyMessage(nullptr, std::move(from)) {}
  inline MqttClientProxyMessage& operator=(const MqttClientProxyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MqttClientProxyMessage& operator=(MqttClientProxyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MqttClientProxyMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kData = 2,
    kText = 3,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };
  static inline const MqttClientProxyMessage* internal_default_instance() {
    return reinterpret_cast<const MqttClientProxyMessage*>(
        &_MqttClientProxyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(MqttClientProxyMessage& a, MqttClientProxyMessage& b) { a.Swap(&b); }
  inline void Swap(MqttClientProxyMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MqttClientProxyMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MqttClientProxyMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MqttClientProxyMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MqttClientProxyMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MqttClientProxyMessage& from) { MqttClientProxyMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MqttClientProxyMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.MqttClientProxyMessage"; }

 protected:
  explicit MqttClientProxyMessage(::google::protobuf::Arena* arena);
  MqttClientProxyMessage(::google::protobuf::Arena* arena, const MqttClientProxyMessage& from);
  MqttClientProxyMessage(::google::protobuf::Arena* arena, MqttClientProxyMessage&& from) noexcept
      : MqttClientProxyMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTopicFieldNumber = 1,
    kRetainedFieldNumber = 4,
    kDataFieldNumber = 2,
    kTextFieldNumber = 3,
  };
  // string topic = 1;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // bool retained = 4;
  void clear_retained() ;
  bool retained() const;
  void set_retained(bool value);

  private:
  bool _internal_retained() const;
  void _internal_set_retained(bool value);

  public:
  // bytes data = 2;
  bool has_data() const;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string text = 3;
  bool has_text() const;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.MqttClientProxyMessage)
 private:
  class _Internal;
  void set_has_data();
  void set_has_text();
  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 0,
      51, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MqttClientProxyMessage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr topic_;
    bool retained_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr data_;
      ::google::protobuf::internal::ArenaStringPtr text_;
    } payload_variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class LowEntropyKey final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:meshtastic.LowEntropyKey) */ {
 public:
  inline LowEntropyKey() : LowEntropyKey(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LowEntropyKey* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LowEntropyKey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LowEntropyKey(
      ::google::protobuf::internal::ConstantInitialized);

  inline LowEntropyKey(const LowEntropyKey& from) : LowEntropyKey(nullptr, from) {}
  inline LowEntropyKey(LowEntropyKey&& from) noexcept
      : LowEntropyKey(nullptr, std::move(from)) {}
  inline LowEntropyKey& operator=(const LowEntropyKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline LowEntropyKey& operator=(LowEntropyKey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LowEntropyKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const LowEntropyKey* internal_default_instance() {
    return reinterpret_cast<const LowEntropyKey*>(
        &_LowEntropyKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(LowEntropyKey& a, LowEntropyKey& b) { a.Swap(&b); }
  inline void Swap(LowEntropyKey* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LowEntropyKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LowEntropyKey* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<LowEntropyKey>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LowEntropyKey& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LowEntropyKey& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.LowEntropyKey"; }

 protected:
  explicit LowEntropyKey(::google::protobuf::Arena* arena);
  LowEntropyKey(::google::protobuf::Arena* arena, const LowEntropyKey& from);
  LowEntropyKey(::google::protobuf::Arena* arena, LowEntropyKey&& from) noexcept
      : LowEntropyKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:meshtastic.LowEntropyKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LowEntropyKey& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class LogRecord final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.LogRecord) */ {
 public:
  inline LogRecord() : LogRecord(nullptr) {}
  ~LogRecord() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LogRecord* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LogRecord));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LogRecord(
      ::google::protobuf::internal::ConstantInitialized);

  inline LogRecord(const LogRecord& from) : LogRecord(nullptr, from) {}
  inline LogRecord(LogRecord&& from) noexcept
      : LogRecord(nullptr, std::move(from)) {}
  inline LogRecord& operator=(const LogRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogRecord& operator=(LogRecord&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogRecord* internal_default_instance() {
    return reinterpret_cast<const LogRecord*>(
        &_LogRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(LogRecord& a, LogRecord& b) { a.Swap(&b); }
  inline void Swap(LogRecord* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogRecord* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LogRecord>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LogRecord& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LogRecord& from) { LogRecord::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LogRecord* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.LogRecord"; }

 protected:
  explicit LogRecord(::google::protobuf::Arena* arena);
  LogRecord(::google::protobuf::Arena* arena, const LogRecord& from);
  LogRecord(::google::protobuf::Arena* arena, LogRecord&& from) noexcept
      : LogRecord(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Level = LogRecord_Level;
  static constexpr Level UNSET = LogRecord_Level_UNSET;
  static constexpr Level CRITICAL = LogRecord_Level_CRITICAL;
  static constexpr Level ERROR = LogRecord_Level_ERROR;
  static constexpr Level WARNING = LogRecord_Level_WARNING;
  static constexpr Level INFO = LogRecord_Level_INFO;
  static constexpr Level DEBUG = LogRecord_Level_DEBUG;
  static constexpr Level TRACE = LogRecord_Level_TRACE;
  static inline bool Level_IsValid(int value) {
    return LogRecord_Level_IsValid(value);
  }
  static constexpr Level Level_MIN = LogRecord_Level_Level_MIN;
  static constexpr Level Level_MAX = LogRecord_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE = LogRecord_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Level_descriptor() {
    return LogRecord_Level_descriptor();
  }
  template <typename T>
  static inline const std::string& Level_Name(T value) {
    return LogRecord_Level_Name(value);
  }
  static inline bool Level_Parse(absl::string_view name, Level* value) {
    return LogRecord_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 1,
    kSourceFieldNumber = 3,
    kTimeFieldNumber = 2,
    kLevelFieldNumber = 4,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // string source = 3;
  void clear_source() ;
  const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* value);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // fixed32 time = 2;
  void clear_time() ;
  ::uint32_t time() const;
  void set_time(::uint32_t value);

  private:
  ::uint32_t _internal_time() const;
  void _internal_set_time(::uint32_t value);

  public:
  // .meshtastic.LogRecord.Level level = 4;
  void clear_level() ;
  ::meshtastic::LogRecord_Level level() const;
  void set_level(::meshtastic::LogRecord_Level value);

  private:
  ::meshtastic::LogRecord_Level _internal_level() const;
  void _internal_set_level(::meshtastic::LogRecord_Level value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.LogRecord)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LogRecord& from_msg);
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    ::uint32_t time_;
    int level_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class KeyVerificationNumberRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.KeyVerificationNumberRequest) */ {
 public:
  inline KeyVerificationNumberRequest() : KeyVerificationNumberRequest(nullptr) {}
  ~KeyVerificationNumberRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KeyVerificationNumberRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KeyVerificationNumberRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyVerificationNumberRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyVerificationNumberRequest(const KeyVerificationNumberRequest& from) : KeyVerificationNumberRequest(nullptr, from) {}
  inline KeyVerificationNumberRequest(KeyVerificationNumberRequest&& from) noexcept
      : KeyVerificationNumberRequest(nullptr, std::move(from)) {}
  inline KeyVerificationNumberRequest& operator=(const KeyVerificationNumberRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyVerificationNumberRequest& operator=(KeyVerificationNumberRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyVerificationNumberRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyVerificationNumberRequest* internal_default_instance() {
    return reinterpret_cast<const KeyVerificationNumberRequest*>(
        &_KeyVerificationNumberRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(KeyVerificationNumberRequest& a, KeyVerificationNumberRequest& b) { a.Swap(&b); }
  inline void Swap(KeyVerificationNumberRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyVerificationNumberRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyVerificationNumberRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KeyVerificationNumberRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyVerificationNumberRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyVerificationNumberRequest& from) { KeyVerificationNumberRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KeyVerificationNumberRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.KeyVerificationNumberRequest"; }

 protected:
  explicit KeyVerificationNumberRequest(::google::protobuf::Arena* arena);
  KeyVerificationNumberRequest(::google::protobuf::Arena* arena, const KeyVerificationNumberRequest& from);
  KeyVerificationNumberRequest(::google::protobuf::Arena* arena, KeyVerificationNumberRequest&& from) noexcept
      : KeyVerificationNumberRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRemoteLongnameFieldNumber = 2,
    kNonceFieldNumber = 1,
  };
  // string remote_longname = 2;
  void clear_remote_longname() ;
  const std::string& remote_longname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_remote_longname(Arg_&& arg, Args_... args);
  std::string* mutable_remote_longname();
  PROTOBUF_NODISCARD std::string* release_remote_longname();
  void set_allocated_remote_longname(std::string* value);

  private:
  const std::string& _internal_remote_longname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_longname(
      const std::string& value);
  std::string* _internal_mutable_remote_longname();

  public:
  // uint64 nonce = 1;
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.KeyVerificationNumberRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      63, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyVerificationNumberRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr remote_longname_;
    ::uint64_t nonce_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class KeyVerificationNumberInform final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.KeyVerificationNumberInform) */ {
 public:
  inline KeyVerificationNumberInform() : KeyVerificationNumberInform(nullptr) {}
  ~KeyVerificationNumberInform() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KeyVerificationNumberInform* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KeyVerificationNumberInform));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyVerificationNumberInform(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyVerificationNumberInform(const KeyVerificationNumberInform& from) : KeyVerificationNumberInform(nullptr, from) {}
  inline KeyVerificationNumberInform(KeyVerificationNumberInform&& from) noexcept
      : KeyVerificationNumberInform(nullptr, std::move(from)) {}
  inline KeyVerificationNumberInform& operator=(const KeyVerificationNumberInform& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyVerificationNumberInform& operator=(KeyVerificationNumberInform&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyVerificationNumberInform& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyVerificationNumberInform* internal_default_instance() {
    return reinterpret_cast<const KeyVerificationNumberInform*>(
        &_KeyVerificationNumberInform_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(KeyVerificationNumberInform& a, KeyVerificationNumberInform& b) { a.Swap(&b); }
  inline void Swap(KeyVerificationNumberInform* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyVerificationNumberInform* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyVerificationNumberInform* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KeyVerificationNumberInform>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyVerificationNumberInform& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyVerificationNumberInform& from) { KeyVerificationNumberInform::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KeyVerificationNumberInform* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.KeyVerificationNumberInform"; }

 protected:
  explicit KeyVerificationNumberInform(::google::protobuf::Arena* arena);
  KeyVerificationNumberInform(::google::protobuf::Arena* arena, const KeyVerificationNumberInform& from);
  KeyVerificationNumberInform(::google::protobuf::Arena* arena, KeyVerificationNumberInform&& from) noexcept
      : KeyVerificationNumberInform(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRemoteLongnameFieldNumber = 2,
    kNonceFieldNumber = 1,
    kSecurityNumberFieldNumber = 3,
  };
  // string remote_longname = 2;
  void clear_remote_longname() ;
  const std::string& remote_longname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_remote_longname(Arg_&& arg, Args_... args);
  std::string* mutable_remote_longname();
  PROTOBUF_NODISCARD std::string* release_remote_longname();
  void set_allocated_remote_longname(std::string* value);

  private:
  const std::string& _internal_remote_longname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_longname(
      const std::string& value);
  std::string* _internal_mutable_remote_longname();

  public:
  // uint64 nonce = 1;
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // uint32 security_number = 3;
  void clear_security_number() ;
  ::uint32_t security_number() const;
  void set_security_number(::uint32_t value);

  private:
  ::uint32_t _internal_security_number() const;
  void _internal_set_security_number(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.KeyVerificationNumberInform)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      62, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyVerificationNumberInform& from_msg);
    ::google::protobuf::internal::ArenaStringPtr remote_longname_;
    ::uint64_t nonce_;
    ::uint32_t security_number_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class KeyVerificationFinal final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.KeyVerificationFinal) */ {
 public:
  inline KeyVerificationFinal() : KeyVerificationFinal(nullptr) {}
  ~KeyVerificationFinal() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KeyVerificationFinal* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KeyVerificationFinal));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyVerificationFinal(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyVerificationFinal(const KeyVerificationFinal& from) : KeyVerificationFinal(nullptr, from) {}
  inline KeyVerificationFinal(KeyVerificationFinal&& from) noexcept
      : KeyVerificationFinal(nullptr, std::move(from)) {}
  inline KeyVerificationFinal& operator=(const KeyVerificationFinal& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyVerificationFinal& operator=(KeyVerificationFinal&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyVerificationFinal& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyVerificationFinal* internal_default_instance() {
    return reinterpret_cast<const KeyVerificationFinal*>(
        &_KeyVerificationFinal_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(KeyVerificationFinal& a, KeyVerificationFinal& b) { a.Swap(&b); }
  inline void Swap(KeyVerificationFinal* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyVerificationFinal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyVerificationFinal* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KeyVerificationFinal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyVerificationFinal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyVerificationFinal& from) { KeyVerificationFinal::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KeyVerificationFinal* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.KeyVerificationFinal"; }

 protected:
  explicit KeyVerificationFinal(::google::protobuf::Arena* arena);
  KeyVerificationFinal(::google::protobuf::Arena* arena, const KeyVerificationFinal& from);
  KeyVerificationFinal(::google::protobuf::Arena* arena, KeyVerificationFinal&& from) noexcept
      : KeyVerificationFinal(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRemoteLongnameFieldNumber = 2,
    kVerificationCharactersFieldNumber = 4,
    kNonceFieldNumber = 1,
    kIsSenderFieldNumber = 3,
  };
  // string remote_longname = 2;
  void clear_remote_longname() ;
  const std::string& remote_longname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_remote_longname(Arg_&& arg, Args_... args);
  std::string* mutable_remote_longname();
  PROTOBUF_NODISCARD std::string* release_remote_longname();
  void set_allocated_remote_longname(std::string* value);

  private:
  const std::string& _internal_remote_longname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_longname(
      const std::string& value);
  std::string* _internal_mutable_remote_longname();

  public:
  // string verification_characters = 4;
  void clear_verification_characters() ;
  const std::string& verification_characters() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verification_characters(Arg_&& arg, Args_... args);
  std::string* mutable_verification_characters();
  PROTOBUF_NODISCARD std::string* release_verification_characters();
  void set_allocated_verification_characters(std::string* value);

  private:
  const std::string& _internal_verification_characters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_characters(
      const std::string& value);
  std::string* _internal_mutable_verification_characters();

  public:
  // uint64 nonce = 1;
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // bool isSender = 3;
  void clear_issender() ;
  bool issender() const;
  void set_issender(bool value);

  private:
  bool _internal_issender() const;
  void _internal_set_issender(bool value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.KeyVerificationFinal)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      78, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyVerificationFinal& from_msg);
    ::google::protobuf::internal::ArenaStringPtr remote_longname_;
    ::google::protobuf::internal::ArenaStringPtr verification_characters_;
    ::uint64_t nonce_;
    bool issender_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class KeyVerification final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.KeyVerification) */ {
 public:
  inline KeyVerification() : KeyVerification(nullptr) {}
  ~KeyVerification() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KeyVerification* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KeyVerification));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyVerification(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyVerification(const KeyVerification& from) : KeyVerification(nullptr, from) {}
  inline KeyVerification(KeyVerification&& from) noexcept
      : KeyVerification(nullptr, std::move(from)) {}
  inline KeyVerification& operator=(const KeyVerification& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyVerification& operator=(KeyVerification&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyVerification& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyVerification* internal_default_instance() {
    return reinterpret_cast<const KeyVerification*>(
        &_KeyVerification_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(KeyVerification& a, KeyVerification& b) { a.Swap(&b); }
  inline void Swap(KeyVerification* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyVerification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyVerification* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KeyVerification>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyVerification& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyVerification& from) { KeyVerification::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KeyVerification* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.KeyVerification"; }

 protected:
  explicit KeyVerification(::google::protobuf::Arena* arena);
  KeyVerification(::google::protobuf::Arena* arena, const KeyVerification& from);
  KeyVerification(::google::protobuf::Arena* arena, KeyVerification&& from) noexcept
      : KeyVerification(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHash1FieldNumber = 2,
    kHash2FieldNumber = 3,
    kNonceFieldNumber = 1,
  };
  // bytes hash1 = 2;
  void clear_hash1() ;
  const std::string& hash1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash1(Arg_&& arg, Args_... args);
  std::string* mutable_hash1();
  PROTOBUF_NODISCARD std::string* release_hash1();
  void set_allocated_hash1(std::string* value);

  private:
  const std::string& _internal_hash1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash1(
      const std::string& value);
  std::string* _internal_mutable_hash1();

  public:
  // bytes hash2 = 3;
  void clear_hash2() ;
  const std::string& hash2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash2(Arg_&& arg, Args_... args);
  std::string* mutable_hash2();
  PROTOBUF_NODISCARD std::string* release_hash2();
  void set_allocated_hash2(std::string* value);

  private:
  const std::string& _internal_hash2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash2(
      const std::string& value);
  std::string* _internal_mutable_hash2();

  public:
  // uint64 nonce = 1;
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.KeyVerification)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyVerification& from_msg);
    ::google::protobuf::internal::ArenaStringPtr hash1_;
    ::google::protobuf::internal::ArenaStringPtr hash2_;
    ::uint64_t nonce_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Heartbeat final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  ~Heartbeat() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Heartbeat* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Heartbeat));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Heartbeat(
      ::google::protobuf::internal::ConstantInitialized);

  inline Heartbeat(const Heartbeat& from) : Heartbeat(nullptr, from) {}
  inline Heartbeat(Heartbeat&& from) noexcept
      : Heartbeat(nullptr, std::move(from)) {}
  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
        &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(Heartbeat& a, Heartbeat& b) { a.Swap(&b); }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Heartbeat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Heartbeat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Heartbeat& from) { Heartbeat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Heartbeat* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Heartbeat"; }

 protected:
  explicit Heartbeat(::google::protobuf::Arena* arena);
  Heartbeat(::google::protobuf::Arena* arena, const Heartbeat& from);
  Heartbeat(::google::protobuf::Arena* arena, Heartbeat&& from) noexcept
      : Heartbeat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNonceFieldNumber = 1,
  };
  // uint32 nonce = 1;
  void clear_nonce() ;
  ::uint32_t nonce() const;
  void set_nonce(::uint32_t value);

  private:
  ::uint32_t _internal_nonce() const;
  void _internal_set_nonce(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Heartbeat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Heartbeat& from_msg);
    ::uint32_t nonce_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class FileInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.FileInfo) */ {
 public:
  inline FileInfo() : FileInfo(nullptr) {}
  ~FileInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FileInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FileInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FileInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline FileInfo(const FileInfo& from) : FileInfo(nullptr, from) {}
  inline FileInfo(FileInfo&& from) noexcept
      : FileInfo(nullptr, std::move(from)) {}
  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
        &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(FileInfo& a, FileInfo& b) { a.Swap(&b); }
  inline void Swap(FileInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FileInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FileInfo& from) { FileInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FileInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.FileInfo"; }

 protected:
  explicit FileInfo(::google::protobuf::Arena* arena);
  FileInfo(::google::protobuf::Arena* arena, const FileInfo& from);
  FileInfo(::google::protobuf::Arena* arena, FileInfo&& from) noexcept
      : FileInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFileNameFieldNumber = 1,
    kSizeBytesFieldNumber = 2,
  };
  // string file_name = 1;
  void clear_file_name() ;
  const std::string& file_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_name(Arg_&& arg, Args_... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* value);

  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(
      const std::string& value);
  std::string* _internal_mutable_file_name();

  public:
  // uint32 size_bytes = 2;
  void clear_size_bytes() ;
  ::uint32_t size_bytes() const;
  void set_size_bytes(::uint32_t value);

  private:
  ::uint32_t _internal_size_bytes() const;
  void _internal_set_size_bytes(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.FileInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FileInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr file_name_;
    ::uint32_t size_bytes_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class DuplicatedPublicKey final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:meshtastic.DuplicatedPublicKey) */ {
 public:
  inline DuplicatedPublicKey() : DuplicatedPublicKey(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DuplicatedPublicKey* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DuplicatedPublicKey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DuplicatedPublicKey(
      ::google::protobuf::internal::ConstantInitialized);

  inline DuplicatedPublicKey(const DuplicatedPublicKey& from) : DuplicatedPublicKey(nullptr, from) {}
  inline DuplicatedPublicKey(DuplicatedPublicKey&& from) noexcept
      : DuplicatedPublicKey(nullptr, std::move(from)) {}
  inline DuplicatedPublicKey& operator=(const DuplicatedPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline DuplicatedPublicKey& operator=(DuplicatedPublicKey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DuplicatedPublicKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const DuplicatedPublicKey* internal_default_instance() {
    return reinterpret_cast<const DuplicatedPublicKey*>(
        &_DuplicatedPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(DuplicatedPublicKey& a, DuplicatedPublicKey& b) { a.Swap(&b); }
  inline void Swap(DuplicatedPublicKey* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DuplicatedPublicKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DuplicatedPublicKey* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DuplicatedPublicKey>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DuplicatedPublicKey& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DuplicatedPublicKey& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.DuplicatedPublicKey"; }

 protected:
  explicit DuplicatedPublicKey(::google::protobuf::Arena* arena);
  DuplicatedPublicKey(::google::protobuf::Arena* arena, const DuplicatedPublicKey& from);
  DuplicatedPublicKey(::google::protobuf::Arena* arena, DuplicatedPublicKey&& from) noexcept
      : DuplicatedPublicKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:meshtastic.DuplicatedPublicKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DuplicatedPublicKey& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class DeviceMetadata final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.DeviceMetadata) */ {
 public:
  inline DeviceMetadata() : DeviceMetadata(nullptr) {}
  ~DeviceMetadata() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeviceMetadata* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeviceMetadata));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceMetadata(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeviceMetadata(const DeviceMetadata& from) : DeviceMetadata(nullptr, from) {}
  inline DeviceMetadata(DeviceMetadata&& from) noexcept
      : DeviceMetadata(nullptr, std::move(from)) {}
  inline DeviceMetadata& operator=(const DeviceMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceMetadata& operator=(DeviceMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceMetadata* internal_default_instance() {
    return reinterpret_cast<const DeviceMetadata*>(
        &_DeviceMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(DeviceMetadata& a, DeviceMetadata& b) { a.Swap(&b); }
  inline void Swap(DeviceMetadata* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceMetadata* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeviceMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeviceMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeviceMetadata& from) { DeviceMetadata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeviceMetadata* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.DeviceMetadata"; }

 protected:
  explicit DeviceMetadata(::google::protobuf::Arena* arena);
  DeviceMetadata(::google::protobuf::Arena* arena, const DeviceMetadata& from);
  DeviceMetadata(::google::protobuf::Arena* arena, DeviceMetadata&& from) noexcept
      : DeviceMetadata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFirmwareVersionFieldNumber = 1,
    kDeviceStateVersionFieldNumber = 2,
    kCanShutdownFieldNumber = 3,
    kHasWifiFieldNumber = 4,
    kHasBluetoothFieldNumber = 5,
    kHasEthernetFieldNumber = 6,
    kRoleFieldNumber = 7,
    kPositionFlagsFieldNumber = 8,
    kHwModelFieldNumber = 9,
    kHasRemoteHardwareFieldNumber = 10,
    kHasPKCFieldNumber = 11,
    kExcludedModulesFieldNumber = 12,
  };
  // string firmware_version = 1;
  void clear_firmware_version() ;
  const std::string& firmware_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_firmware_version(Arg_&& arg, Args_... args);
  std::string* mutable_firmware_version();
  PROTOBUF_NODISCARD std::string* release_firmware_version();
  void set_allocated_firmware_version(std::string* value);

  private:
  const std::string& _internal_firmware_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_version(
      const std::string& value);
  std::string* _internal_mutable_firmware_version();

  public:
  // uint32 device_state_version = 2;
  void clear_device_state_version() ;
  ::uint32_t device_state_version() const;
  void set_device_state_version(::uint32_t value);

  private:
  ::uint32_t _internal_device_state_version() const;
  void _internal_set_device_state_version(::uint32_t value);

  public:
  // bool canShutdown = 3;
  void clear_canshutdown() ;
  bool canshutdown() const;
  void set_canshutdown(bool value);

  private:
  bool _internal_canshutdown() const;
  void _internal_set_canshutdown(bool value);

  public:
  // bool hasWifi = 4;
  void clear_haswifi() ;
  bool haswifi() const;
  void set_haswifi(bool value);

  private:
  bool _internal_haswifi() const;
  void _internal_set_haswifi(bool value);

  public:
  // bool hasBluetooth = 5;
  void clear_hasbluetooth() ;
  bool hasbluetooth() const;
  void set_hasbluetooth(bool value);

  private:
  bool _internal_hasbluetooth() const;
  void _internal_set_hasbluetooth(bool value);

  public:
  // bool hasEthernet = 6;
  void clear_hasethernet() ;
  bool hasethernet() const;
  void set_hasethernet(bool value);

  private:
  bool _internal_hasethernet() const;
  void _internal_set_hasethernet(bool value);

  public:
  // .meshtastic.Config.DeviceConfig.Role role = 7;
  void clear_role() ;
  ::meshtastic::Config_DeviceConfig_Role role() const;
  void set_role(::meshtastic::Config_DeviceConfig_Role value);

  private:
  ::meshtastic::Config_DeviceConfig_Role _internal_role() const;
  void _internal_set_role(::meshtastic::Config_DeviceConfig_Role value);

  public:
  // uint32 position_flags = 8;
  void clear_position_flags() ;
  ::uint32_t position_flags() const;
  void set_position_flags(::uint32_t value);

  private:
  ::uint32_t _internal_position_flags() const;
  void _internal_set_position_flags(::uint32_t value);

  public:
  // .meshtastic.HardwareModel hw_model = 9;
  void clear_hw_model() ;
  ::meshtastic::HardwareModel hw_model() const;
  void set_hw_model(::meshtastic::HardwareModel value);

  private:
  ::meshtastic::HardwareModel _internal_hw_model() const;
  void _internal_set_hw_model(::meshtastic::HardwareModel value);

  public:
  // bool hasRemoteHardware = 10;
  void clear_hasremotehardware() ;
  bool hasremotehardware() const;
  void set_hasremotehardware(bool value);

  private:
  bool _internal_hasremotehardware() const;
  void _internal_set_hasremotehardware(bool value);

  public:
  // bool hasPKC = 11;
  void clear_haspkc() ;
  bool haspkc() const;
  void set_haspkc(bool value);

  private:
  bool _internal_haspkc() const;
  void _internal_set_haspkc(bool value);

  public:
  // uint32 excluded_modules = 12;
  void clear_excluded_modules() ;
  ::uint32_t excluded_modules() const;
  void set_excluded_modules(::uint32_t value);

  private:
  ::uint32_t _internal_excluded_modules() const;
  void _internal_set_excluded_modules(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.DeviceMetadata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 0,
      58, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeviceMetadata& from_msg);
    ::google::protobuf::internal::ArenaStringPtr firmware_version_;
    ::uint32_t device_state_version_;
    bool canshutdown_;
    bool haswifi_;
    bool hasbluetooth_;
    bool hasethernet_;
    int role_;
    ::uint32_t position_flags_;
    int hw_model_;
    bool hasremotehardware_;
    bool haspkc_;
    ::uint32_t excluded_modules_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Data final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Data* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Data));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Data(
      ::google::protobuf::internal::ConstantInitialized);

  inline Data(const Data& from) : Data(nullptr, from) {}
  inline Data(Data&& from) noexcept
      : Data(nullptr, std::move(from)) {}
  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
        &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Data& a, Data& b) { a.Swap(&b); }
  inline void Swap(Data* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Data>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Data& from) { Data::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Data* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Data"; }

 protected:
  explicit Data(::google::protobuf::Arena* arena);
  Data(::google::protobuf::Arena* arena, const Data& from);
  Data(::google::protobuf::Arena* arena, Data&& from) noexcept
      : Data(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPayloadFieldNumber = 2,
    kPortnumFieldNumber = 1,
    kWantResponseFieldNumber = 3,
    kDestFieldNumber = 4,
    kSourceFieldNumber = 5,
    kRequestIdFieldNumber = 6,
    kReplyIdFieldNumber = 7,
    kEmojiFieldNumber = 8,
    kBitfieldFieldNumber = 9,
  };
  // bytes payload = 2;
  void clear_payload() ;
  const std::string& payload() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* value);

  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(
      const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // .meshtastic.PortNum portnum = 1;
  void clear_portnum() ;
  ::meshtastic::PortNum portnum() const;
  void set_portnum(::meshtastic::PortNum value);

  private:
  ::meshtastic::PortNum _internal_portnum() const;
  void _internal_set_portnum(::meshtastic::PortNum value);

  public:
  // bool want_response = 3;
  void clear_want_response() ;
  bool want_response() const;
  void set_want_response(bool value);

  private:
  bool _internal_want_response() const;
  void _internal_set_want_response(bool value);

  public:
  // fixed32 dest = 4;
  void clear_dest() ;
  ::uint32_t dest() const;
  void set_dest(::uint32_t value);

  private:
  ::uint32_t _internal_dest() const;
  void _internal_set_dest(::uint32_t value);

  public:
  // fixed32 source = 5;
  void clear_source() ;
  ::uint32_t source() const;
  void set_source(::uint32_t value);

  private:
  ::uint32_t _internal_source() const;
  void _internal_set_source(::uint32_t value);

  public:
  // fixed32 request_id = 6;
  void clear_request_id() ;
  ::uint32_t request_id() const;
  void set_request_id(::uint32_t value);

  private:
  ::uint32_t _internal_request_id() const;
  void _internal_set_request_id(::uint32_t value);

  public:
  // fixed32 reply_id = 7;
  void clear_reply_id() ;
  ::uint32_t reply_id() const;
  void set_reply_id(::uint32_t value);

  private:
  ::uint32_t _internal_reply_id() const;
  void _internal_set_reply_id(::uint32_t value);

  public:
  // fixed32 emoji = 8;
  void clear_emoji() ;
  ::uint32_t emoji() const;
  void set_emoji(::uint32_t value);

  private:
  ::uint32_t _internal_emoji() const;
  void _internal_set_emoji(::uint32_t value);

  public:
  // optional uint32 bitfield = 9;
  bool has_bitfield() const;
  void clear_bitfield() ;
  ::uint32_t bitfield() const;
  void set_bitfield(::uint32_t value);

  private:
  ::uint32_t _internal_bitfield() const;
  void _internal_set_bitfield(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Data)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Data& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr payload_;
    int portnum_;
    bool want_response_;
    ::uint32_t dest_;
    ::uint32_t source_;
    ::uint32_t request_id_;
    ::uint32_t reply_id_;
    ::uint32_t emoji_;
    ::uint32_t bitfield_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Compressed final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Compressed) */ {
 public:
  inline Compressed() : Compressed(nullptr) {}
  ~Compressed() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Compressed* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Compressed));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Compressed(
      ::google::protobuf::internal::ConstantInitialized);

  inline Compressed(const Compressed& from) : Compressed(nullptr, from) {}
  inline Compressed(Compressed&& from) noexcept
      : Compressed(nullptr, std::move(from)) {}
  inline Compressed& operator=(const Compressed& from) {
    CopyFrom(from);
    return *this;
  }
  inline Compressed& operator=(Compressed&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Compressed& default_instance() {
    return *internal_default_instance();
  }
  static inline const Compressed* internal_default_instance() {
    return reinterpret_cast<const Compressed*>(
        &_Compressed_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(Compressed& a, Compressed& b) { a.Swap(&b); }
  inline void Swap(Compressed* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Compressed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Compressed* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Compressed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Compressed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Compressed& from) { Compressed::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Compressed* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Compressed"; }

 protected:
  explicit Compressed(::google::protobuf::Arena* arena);
  Compressed(::google::protobuf::Arena* arena, const Compressed& from);
  Compressed(::google::protobuf::Arena* arena, Compressed&& from) noexcept
      : Compressed(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kPortnumFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // .meshtastic.PortNum portnum = 1;
  void clear_portnum() ;
  ::meshtastic::PortNum portnum() const;
  void set_portnum(::meshtastic::PortNum value);

  private:
  ::meshtastic::PortNum _internal_portnum() const;
  void _internal_set_portnum(::meshtastic::PortNum value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Compressed)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Compressed& from_msg);
    ::google::protobuf::internal::ArenaStringPtr data_;
    int portnum_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class ChunkedPayload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.ChunkedPayload) */ {
 public:
  inline ChunkedPayload() : ChunkedPayload(nullptr) {}
  ~ChunkedPayload() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChunkedPayload* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChunkedPayload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChunkedPayload(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChunkedPayload(const ChunkedPayload& from) : ChunkedPayload(nullptr, from) {}
  inline ChunkedPayload(ChunkedPayload&& from) noexcept
      : ChunkedPayload(nullptr, std::move(from)) {}
  inline ChunkedPayload& operator=(const ChunkedPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkedPayload& operator=(ChunkedPayload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChunkedPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChunkedPayload* internal_default_instance() {
    return reinterpret_cast<const ChunkedPayload*>(
        &_ChunkedPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(ChunkedPayload& a, ChunkedPayload& b) { a.Swap(&b); }
  inline void Swap(ChunkedPayload* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkedPayload* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChunkedPayload* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChunkedPayload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChunkedPayload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChunkedPayload& from) { ChunkedPayload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChunkedPayload* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.ChunkedPayload"; }

 protected:
  explicit ChunkedPayload(::google::protobuf::Arena* arena);
  ChunkedPayload(::google::protobuf::Arena* arena, const ChunkedPayload& from);
  ChunkedPayload(::google::protobuf::Arena* arena, ChunkedPayload&& from) noexcept
      : ChunkedPayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPayloadChunkFieldNumber = 4,
    kPayloadIdFieldNumber = 1,
    kChunkCountFieldNumber = 2,
    kChunkIndexFieldNumber = 3,
  };
  // bytes payload_chunk = 4;
  void clear_payload_chunk() ;
  const std::string& payload_chunk() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload_chunk(Arg_&& arg, Args_... args);
  std::string* mutable_payload_chunk();
  PROTOBUF_NODISCARD std::string* release_payload_chunk();
  void set_allocated_payload_chunk(std::string* value);

  private:
  const std::string& _internal_payload_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_chunk(
      const std::string& value);
  std::string* _internal_mutable_payload_chunk();

  public:
  // uint32 payload_id = 1;
  void clear_payload_id() ;
  ::uint32_t payload_id() const;
  void set_payload_id(::uint32_t value);

  private:
  ::uint32_t _internal_payload_id() const;
  void _internal_set_payload_id(::uint32_t value);

  public:
  // uint32 chunk_count = 2;
  void clear_chunk_count() ;
  ::uint32_t chunk_count() const;
  void set_chunk_count(::uint32_t value);

  private:
  ::uint32_t _internal_chunk_count() const;
  void _internal_set_chunk_count(::uint32_t value);

  public:
  // uint32 chunk_index = 3;
  void clear_chunk_index() ;
  ::uint32_t chunk_index() const;
  void set_chunk_index(::uint32_t value);

  private:
  ::uint32_t _internal_chunk_index() const;
  void _internal_set_chunk_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.ChunkedPayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ChunkedPayload& from_msg);
    ::google::protobuf::internal::ArenaStringPtr payload_chunk_;
    ::uint32_t payload_id_;
    ::uint32_t chunk_count_;
    ::uint32_t chunk_index_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Routing final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Routing) */ {
 public:
  inline Routing() : Routing(nullptr) {}
  ~Routing() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Routing* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Routing));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Routing(
      ::google::protobuf::internal::ConstantInitialized);

  inline Routing(const Routing& from) : Routing(nullptr, from) {}
  inline Routing(Routing&& from) noexcept
      : Routing(nullptr, std::move(from)) {}
  inline Routing& operator=(const Routing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Routing& operator=(Routing&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Routing& default_instance() {
    return *internal_default_instance();
  }
  enum VariantCase {
    kRouteRequest = 1,
    kRouteReply = 2,
    kErrorReason = 3,
    VARIANT_NOT_SET = 0,
  };
  static inline const Routing* internal_default_instance() {
    return reinterpret_cast<const Routing*>(
        &_Routing_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Routing& a, Routing& b) { a.Swap(&b); }
  inline void Swap(Routing* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Routing* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Routing* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Routing>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Routing& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Routing& from) { Routing::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Routing* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Routing"; }

 protected:
  explicit Routing(::google::protobuf::Arena* arena);
  Routing(::google::protobuf::Arena* arena, const Routing& from);
  Routing(::google::protobuf::Arena* arena, Routing&& from) noexcept
      : Routing(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Error = Routing_Error;
  static constexpr Error NONE = Routing_Error_NONE;
  static constexpr Error NO_ROUTE = Routing_Error_NO_ROUTE;
  static constexpr Error GOT_NAK = Routing_Error_GOT_NAK;
  static constexpr Error TIMEOUT = Routing_Error_TIMEOUT;
  static constexpr Error NO_INTERFACE = Routing_Error_NO_INTERFACE;
  static constexpr Error MAX_RETRANSMIT = Routing_Error_MAX_RETRANSMIT;
  static constexpr Error NO_CHANNEL = Routing_Error_NO_CHANNEL;
  static constexpr Error TOO_LARGE = Routing_Error_TOO_LARGE;
  static constexpr Error NO_RESPONSE = Routing_Error_NO_RESPONSE;
  static constexpr Error DUTY_CYCLE_LIMIT = Routing_Error_DUTY_CYCLE_LIMIT;
  static constexpr Error BAD_REQUEST = Routing_Error_BAD_REQUEST;
  static constexpr Error NOT_AUTHORIZED = Routing_Error_NOT_AUTHORIZED;
  static constexpr Error PKI_FAILED = Routing_Error_PKI_FAILED;
  static constexpr Error PKI_UNKNOWN_PUBKEY = Routing_Error_PKI_UNKNOWN_PUBKEY;
  static constexpr Error ADMIN_BAD_SESSION_KEY = Routing_Error_ADMIN_BAD_SESSION_KEY;
  static constexpr Error ADMIN_PUBLIC_KEY_UNAUTHORIZED = Routing_Error_ADMIN_PUBLIC_KEY_UNAUTHORIZED;
  static constexpr Error RATE_LIMIT_EXCEEDED = Routing_Error_RATE_LIMIT_EXCEEDED;
  static inline bool Error_IsValid(int value) {
    return Routing_Error_IsValid(value);
  }
  static constexpr Error Error_MIN = Routing_Error_Error_MIN;
  static constexpr Error Error_MAX = Routing_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE = Routing_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Error_descriptor() {
    return Routing_Error_descriptor();
  }
  template <typename T>
  static inline const std::string& Error_Name(T value) {
    return Routing_Error_Name(value);
  }
  static inline bool Error_Parse(absl::string_view name, Error* value) {
    return Routing_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kRouteRequestFieldNumber = 1,
    kRouteReplyFieldNumber = 2,
    kErrorReasonFieldNumber = 3,
  };
  // .meshtastic.RouteDiscovery route_request = 1;
  bool has_route_request() const;
  private:
  bool _internal_has_route_request() const;

  public:
  void clear_route_request() ;
  const ::meshtastic::RouteDiscovery& route_request() const;
  PROTOBUF_NODISCARD ::meshtastic::RouteDiscovery* release_route_request();
  ::meshtastic::RouteDiscovery* mutable_route_request();
  void set_allocated_route_request(::meshtastic::RouteDiscovery* value);
  void unsafe_arena_set_allocated_route_request(::meshtastic::RouteDiscovery* value);
  ::meshtastic::RouteDiscovery* unsafe_arena_release_route_request();

  private:
  const ::meshtastic::RouteDiscovery& _internal_route_request() const;
  ::meshtastic::RouteDiscovery* _internal_mutable_route_request();

  public:
  // .meshtastic.RouteDiscovery route_reply = 2;
  bool has_route_reply() const;
  private:
  bool _internal_has_route_reply() const;

  public:
  void clear_route_reply() ;
  const ::meshtastic::RouteDiscovery& route_reply() const;
  PROTOBUF_NODISCARD ::meshtastic::RouteDiscovery* release_route_reply();
  ::meshtastic::RouteDiscovery* mutable_route_reply();
  void set_allocated_route_reply(::meshtastic::RouteDiscovery* value);
  void unsafe_arena_set_allocated_route_reply(::meshtastic::RouteDiscovery* value);
  ::meshtastic::RouteDiscovery* unsafe_arena_release_route_reply();

  private:
  const ::meshtastic::RouteDiscovery& _internal_route_reply() const;
  ::meshtastic::RouteDiscovery* _internal_mutable_route_reply();

  public:
  // .meshtastic.Routing.Error error_reason = 3;
  bool has_error_reason() const;
  void clear_error_reason() ;
  ::meshtastic::Routing_Error error_reason() const;
  void set_error_reason(::meshtastic::Routing_Error value);

  private:
  ::meshtastic::Routing_Error _internal_error_reason() const;
  void _internal_set_error_reason(::meshtastic::Routing_Error value);

  public:
  void clear_variant();
  VariantCase variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.Routing)
 private:
  class _Internal;
  void set_has_route_request();
  void set_has_route_reply();
  void set_has_error_reason();
  inline bool has_variant() const;
  inline void clear_has_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Routing& from_msg);
    union VariantUnion {
      constexpr VariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::meshtastic::RouteDiscovery* route_request_;
      ::meshtastic::RouteDiscovery* route_reply_;
      int error_reason_;
    } variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class NodeRemoteHardwarePin final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.NodeRemoteHardwarePin) */ {
 public:
  inline NodeRemoteHardwarePin() : NodeRemoteHardwarePin(nullptr) {}
  ~NodeRemoteHardwarePin() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeRemoteHardwarePin* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeRemoteHardwarePin));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeRemoteHardwarePin(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeRemoteHardwarePin(const NodeRemoteHardwarePin& from) : NodeRemoteHardwarePin(nullptr, from) {}
  inline NodeRemoteHardwarePin(NodeRemoteHardwarePin&& from) noexcept
      : NodeRemoteHardwarePin(nullptr, std::move(from)) {}
  inline NodeRemoteHardwarePin& operator=(const NodeRemoteHardwarePin& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRemoteHardwarePin& operator=(NodeRemoteHardwarePin&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRemoteHardwarePin& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRemoteHardwarePin* internal_default_instance() {
    return reinterpret_cast<const NodeRemoteHardwarePin*>(
        &_NodeRemoteHardwarePin_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(NodeRemoteHardwarePin& a, NodeRemoteHardwarePin& b) { a.Swap(&b); }
  inline void Swap(NodeRemoteHardwarePin* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRemoteHardwarePin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRemoteHardwarePin* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeRemoteHardwarePin>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeRemoteHardwarePin& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeRemoteHardwarePin& from) { NodeRemoteHardwarePin::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeRemoteHardwarePin* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.NodeRemoteHardwarePin"; }

 protected:
  explicit NodeRemoteHardwarePin(::google::protobuf::Arena* arena);
  NodeRemoteHardwarePin(::google::protobuf::Arena* arena, const NodeRemoteHardwarePin& from);
  NodeRemoteHardwarePin(::google::protobuf::Arena* arena, NodeRemoteHardwarePin&& from) noexcept
      : NodeRemoteHardwarePin(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPinFieldNumber = 2,
    kNodeNumFieldNumber = 1,
  };
  // .meshtastic.RemoteHardwarePin pin = 2;
  bool has_pin() const;
  void clear_pin() ;
  const ::meshtastic::RemoteHardwarePin& pin() const;
  PROTOBUF_NODISCARD ::meshtastic::RemoteHardwarePin* release_pin();
  ::meshtastic::RemoteHardwarePin* mutable_pin();
  void set_allocated_pin(::meshtastic::RemoteHardwarePin* value);
  void unsafe_arena_set_allocated_pin(::meshtastic::RemoteHardwarePin* value);
  ::meshtastic::RemoteHardwarePin* unsafe_arena_release_pin();

  private:
  const ::meshtastic::RemoteHardwarePin& _internal_pin() const;
  ::meshtastic::RemoteHardwarePin* _internal_mutable_pin();

  public:
  // uint32 node_num = 1;
  void clear_node_num() ;
  ::uint32_t node_num() const;
  void set_node_num(::uint32_t value);

  private:
  ::uint32_t _internal_node_num() const;
  void _internal_set_node_num(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.NodeRemoteHardwarePin)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeRemoteHardwarePin& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::meshtastic::RemoteHardwarePin* pin_;
    ::uint32_t node_num_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  ~NodeInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeInfo(const NodeInfo& from) : NodeInfo(nullptr, from) {}
  inline NodeInfo(NodeInfo&& from) noexcept
      : NodeInfo(nullptr, std::move(from)) {}
  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
        &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(NodeInfo& a, NodeInfo& b) { a.Swap(&b); }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeInfo& from) { NodeInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.NodeInfo"; }

 protected:
  explicit NodeInfo(::google::protobuf::Arena* arena);
  NodeInfo(::google::protobuf::Arena* arena, const NodeInfo& from);
  NodeInfo(::google::protobuf::Arena* arena, NodeInfo&& from) noexcept
      : NodeInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 2,
    kPositionFieldNumber = 3,
    kDeviceMetricsFieldNumber = 6,
    kNumFieldNumber = 1,
    kSnrFieldNumber = 4,
    kLastHeardFieldNumber = 5,
    kChannelFieldNumber = 7,
    kHopsAwayFieldNumber = 9,
    kViaMqttFieldNumber = 8,
    kIsFavoriteFieldNumber = 10,
    kIsIgnoredFieldNumber = 11,
    kIsKeyManuallyVerifiedFieldNumber = 12,
  };
  // .meshtastic.User user = 2;
  bool has_user() const;
  void clear_user() ;
  const ::meshtastic::User& user() const;
  PROTOBUF_NODISCARD ::meshtastic::User* release_user();
  ::meshtastic::User* mutable_user();
  void set_allocated_user(::meshtastic::User* value);
  void unsafe_arena_set_allocated_user(::meshtastic::User* value);
  ::meshtastic::User* unsafe_arena_release_user();

  private:
  const ::meshtastic::User& _internal_user() const;
  ::meshtastic::User* _internal_mutable_user();

  public:
  // .meshtastic.Position position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::meshtastic::Position& position() const;
  PROTOBUF_NODISCARD ::meshtastic::Position* release_position();
  ::meshtastic::Position* mutable_position();
  void set_allocated_position(::meshtastic::Position* value);
  void unsafe_arena_set_allocated_position(::meshtastic::Position* value);
  ::meshtastic::Position* unsafe_arena_release_position();

  private:
  const ::meshtastic::Position& _internal_position() const;
  ::meshtastic::Position* _internal_mutable_position();

  public:
  // .meshtastic.DeviceMetrics device_metrics = 6;
  bool has_device_metrics() const;
  void clear_device_metrics() ;
  const ::meshtastic::DeviceMetrics& device_metrics() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceMetrics* release_device_metrics();
  ::meshtastic::DeviceMetrics* mutable_device_metrics();
  void set_allocated_device_metrics(::meshtastic::DeviceMetrics* value);
  void unsafe_arena_set_allocated_device_metrics(::meshtastic::DeviceMetrics* value);
  ::meshtastic::DeviceMetrics* unsafe_arena_release_device_metrics();

  private:
  const ::meshtastic::DeviceMetrics& _internal_device_metrics() const;
  ::meshtastic::DeviceMetrics* _internal_mutable_device_metrics();

  public:
  // uint32 num = 1;
  void clear_num() ;
  ::uint32_t num() const;
  void set_num(::uint32_t value);

  private:
  ::uint32_t _internal_num() const;
  void _internal_set_num(::uint32_t value);

  public:
  // float snr = 4;
  void clear_snr() ;
  float snr() const;
  void set_snr(float value);

  private:
  float _internal_snr() const;
  void _internal_set_snr(float value);

  public:
  // fixed32 last_heard = 5;
  void clear_last_heard() ;
  ::uint32_t last_heard() const;
  void set_last_heard(::uint32_t value);

  private:
  ::uint32_t _internal_last_heard() const;
  void _internal_set_last_heard(::uint32_t value);

  public:
  // uint32 channel = 7;
  void clear_channel() ;
  ::uint32_t channel() const;
  void set_channel(::uint32_t value);

  private:
  ::uint32_t _internal_channel() const;
  void _internal_set_channel(::uint32_t value);

  public:
  // optional uint32 hops_away = 9;
  bool has_hops_away() const;
  void clear_hops_away() ;
  ::uint32_t hops_away() const;
  void set_hops_away(::uint32_t value);

  private:
  ::uint32_t _internal_hops_away() const;
  void _internal_set_hops_away(::uint32_t value);

  public:
  // bool via_mqtt = 8;
  void clear_via_mqtt() ;
  bool via_mqtt() const;
  void set_via_mqtt(bool value);

  private:
  bool _internal_via_mqtt() const;
  void _internal_set_via_mqtt(bool value);

  public:
  // bool is_favorite = 10;
  void clear_is_favorite() ;
  bool is_favorite() const;
  void set_is_favorite(bool value);

  private:
  bool _internal_is_favorite() const;
  void _internal_set_is_favorite(bool value);

  public:
  // bool is_ignored = 11;
  void clear_is_ignored() ;
  bool is_ignored() const;
  void set_is_ignored(bool value);

  private:
  bool _internal_is_ignored() const;
  void _internal_set_is_ignored(bool value);

  public:
  // bool is_key_manually_verified = 12;
  void clear_is_key_manually_verified() ;
  bool is_key_manually_verified() const;
  void set_is_key_manually_verified(bool value);

  private:
  bool _internal_is_key_manually_verified() const;
  void _internal_set_is_key_manually_verified(bool value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.NodeInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::meshtastic::User* user_;
    ::meshtastic::Position* position_;
    ::meshtastic::DeviceMetrics* device_metrics_;
    ::uint32_t num_;
    float snr_;
    ::uint32_t last_heard_;
    ::uint32_t channel_;
    ::uint32_t hops_away_;
    bool via_mqtt_;
    bool is_favorite_;
    bool is_ignored_;
    bool is_key_manually_verified_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class NeighborInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.NeighborInfo) */ {
 public:
  inline NeighborInfo() : NeighborInfo(nullptr) {}
  ~NeighborInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NeighborInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NeighborInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NeighborInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NeighborInfo(const NeighborInfo& from) : NeighborInfo(nullptr, from) {}
  inline NeighborInfo(NeighborInfo&& from) noexcept
      : NeighborInfo(nullptr, std::move(from)) {}
  inline NeighborInfo& operator=(const NeighborInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NeighborInfo& operator=(NeighborInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NeighborInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NeighborInfo* internal_default_instance() {
    return reinterpret_cast<const NeighborInfo*>(
        &_NeighborInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(NeighborInfo& a, NeighborInfo& b) { a.Swap(&b); }
  inline void Swap(NeighborInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NeighborInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NeighborInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NeighborInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NeighborInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NeighborInfo& from) { NeighborInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NeighborInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.NeighborInfo"; }

 protected:
  explicit NeighborInfo(::google::protobuf::Arena* arena);
  NeighborInfo(::google::protobuf::Arena* arena, const NeighborInfo& from);
  NeighborInfo(::google::protobuf::Arena* arena, NeighborInfo&& from) noexcept
      : NeighborInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNeighborsFieldNumber = 4,
    kNodeIdFieldNumber = 1,
    kLastSentByIdFieldNumber = 2,
    kNodeBroadcastIntervalSecsFieldNumber = 3,
  };
  // repeated .meshtastic.Neighbor neighbors = 4;
  int neighbors_size() const;
  private:
  int _internal_neighbors_size() const;

  public:
  void clear_neighbors() ;
  ::meshtastic::Neighbor* mutable_neighbors(int index);
  ::google::protobuf::RepeatedPtrField<::meshtastic::Neighbor>* mutable_neighbors();

  private:
  const ::google::protobuf::RepeatedPtrField<::meshtastic::Neighbor>& _internal_neighbors() const;
  ::google::protobuf::RepeatedPtrField<::meshtastic::Neighbor>* _internal_mutable_neighbors();
  public:
  const ::meshtastic::Neighbor& neighbors(int index) const;
  ::meshtastic::Neighbor* add_neighbors();
  const ::google::protobuf::RepeatedPtrField<::meshtastic::Neighbor>& neighbors() const;
  // uint32 node_id = 1;
  void clear_node_id() ;
  ::uint32_t node_id() const;
  void set_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_node_id() const;
  void _internal_set_node_id(::uint32_t value);

  public:
  // uint32 last_sent_by_id = 2;
  void clear_last_sent_by_id() ;
  ::uint32_t last_sent_by_id() const;
  void set_last_sent_by_id(::uint32_t value);

  private:
  ::uint32_t _internal_last_sent_by_id() const;
  void _internal_set_last_sent_by_id(::uint32_t value);

  public:
  // uint32 node_broadcast_interval_secs = 3;
  void clear_node_broadcast_interval_secs() ;
  ::uint32_t node_broadcast_interval_secs() const;
  void set_node_broadcast_interval_secs(::uint32_t value);

  private:
  ::uint32_t _internal_node_broadcast_interval_secs() const;
  void _internal_set_node_broadcast_interval_secs(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.NeighborInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NeighborInfo& from_msg);
    ::google::protobuf::RepeatedPtrField< ::meshtastic::Neighbor > neighbors_;
    ::uint32_t node_id_;
    ::uint32_t last_sent_by_id_;
    ::uint32_t node_broadcast_interval_secs_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class MeshPacket final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.MeshPacket) */ {
 public:
  inline MeshPacket() : MeshPacket(nullptr) {}
  ~MeshPacket() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MeshPacket* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MeshPacket));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MeshPacket(
      ::google::protobuf::internal::ConstantInitialized);

  inline MeshPacket(const MeshPacket& from) : MeshPacket(nullptr, from) {}
  inline MeshPacket(MeshPacket&& from) noexcept
      : MeshPacket(nullptr, std::move(from)) {}
  inline MeshPacket& operator=(const MeshPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshPacket& operator=(MeshPacket&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshPacket& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kDecoded = 4,
    kEncrypted = 5,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };
  static inline const MeshPacket* internal_default_instance() {
    return reinterpret_cast<const MeshPacket*>(
        &_MeshPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(MeshPacket& a, MeshPacket& b) { a.Swap(&b); }
  inline void Swap(MeshPacket* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshPacket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshPacket* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MeshPacket>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MeshPacket& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MeshPacket& from) { MeshPacket::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MeshPacket* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.MeshPacket"; }

 protected:
  explicit MeshPacket(::google::protobuf::Arena* arena);
  MeshPacket(::google::protobuf::Arena* arena, const MeshPacket& from);
  MeshPacket(::google::protobuf::Arena* arena, MeshPacket&& from) noexcept
      : MeshPacket(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Priority = MeshPacket_Priority;
  static constexpr Priority UNSET = MeshPacket_Priority_UNSET;
  static constexpr Priority MIN = MeshPacket_Priority_MIN;
  static constexpr Priority BACKGROUND = MeshPacket_Priority_BACKGROUND;
  static constexpr Priority DEFAULT = MeshPacket_Priority_DEFAULT;
  static constexpr Priority RELIABLE = MeshPacket_Priority_RELIABLE;
  static constexpr Priority RESPONSE = MeshPacket_Priority_RESPONSE;
  static constexpr Priority HIGH = MeshPacket_Priority_HIGH;
  static constexpr Priority ALERT = MeshPacket_Priority_ALERT;
  static constexpr Priority ACK = MeshPacket_Priority_ACK;
  static constexpr Priority MAX = MeshPacket_Priority_MAX;
  static inline bool Priority_IsValid(int value) {
    return MeshPacket_Priority_IsValid(value);
  }
  static constexpr Priority Priority_MIN = MeshPacket_Priority_Priority_MIN;
  static constexpr Priority Priority_MAX = MeshPacket_Priority_Priority_MAX;
  static constexpr int Priority_ARRAYSIZE = MeshPacket_Priority_Priority_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Priority_descriptor() {
    return MeshPacket_Priority_descriptor();
  }
  template <typename T>
  static inline const std::string& Priority_Name(T value) {
    return MeshPacket_Priority_Name(value);
  }
  static inline bool Priority_Parse(absl::string_view name, Priority* value) {
    return MeshPacket_Priority_Parse(name, value);
  }
  using Delayed = MeshPacket_Delayed;
  static constexpr Delayed NO_DELAY = MeshPacket_Delayed_NO_DELAY;
  static constexpr Delayed DELAYED_BROADCAST = MeshPacket_Delayed_DELAYED_BROADCAST;
  static constexpr Delayed DELAYED_DIRECT = MeshPacket_Delayed_DELAYED_DIRECT;
  static inline bool Delayed_IsValid(int value) {
    return MeshPacket_Delayed_IsValid(value);
  }
  static constexpr Delayed Delayed_MIN = MeshPacket_Delayed_Delayed_MIN;
  static constexpr Delayed Delayed_MAX = MeshPacket_Delayed_Delayed_MAX;
  static constexpr int Delayed_ARRAYSIZE = MeshPacket_Delayed_Delayed_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Delayed_descriptor() {
    return MeshPacket_Delayed_descriptor();
  }
  template <typename T>
  static inline const std::string& Delayed_Name(T value) {
    return MeshPacket_Delayed_Name(value);
  }
  static inline bool Delayed_Parse(absl::string_view name, Delayed* value) {
    return MeshPacket_Delayed_Parse(name, value);
  }
  using TransportMechanism = MeshPacket_TransportMechanism;
  static constexpr TransportMechanism TRANSPORT_INTERNAL = MeshPacket_TransportMechanism_TRANSPORT_INTERNAL;
  static constexpr TransportMechanism TRANSPORT_LORA = MeshPacket_TransportMechanism_TRANSPORT_LORA;
  static constexpr TransportMechanism TRANSPORT_LORA_ALT1 = MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT1;
  static constexpr TransportMechanism TRANSPORT_LORA_ALT2 = MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT2;
  static constexpr TransportMechanism TRANSPORT_LORA_ALT3 = MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT3;
  static constexpr TransportMechanism TRANSPORT_MQTT = MeshPacket_TransportMechanism_TRANSPORT_MQTT;
  static constexpr TransportMechanism TRANSPORT_MULTICAST_UDP = MeshPacket_TransportMechanism_TRANSPORT_MULTICAST_UDP;
  static constexpr TransportMechanism TRANSPORT_API = MeshPacket_TransportMechanism_TRANSPORT_API;
  static inline bool TransportMechanism_IsValid(int value) {
    return MeshPacket_TransportMechanism_IsValid(value);
  }
  static constexpr TransportMechanism TransportMechanism_MIN = MeshPacket_TransportMechanism_TransportMechanism_MIN;
  static constexpr TransportMechanism TransportMechanism_MAX = MeshPacket_TransportMechanism_TransportMechanism_MAX;
  static constexpr int TransportMechanism_ARRAYSIZE = MeshPacket_TransportMechanism_TransportMechanism_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TransportMechanism_descriptor() {
    return MeshPacket_TransportMechanism_descriptor();
  }
  template <typename T>
  static inline const std::string& TransportMechanism_Name(T value) {
    return MeshPacket_TransportMechanism_Name(value);
  }
  static inline bool TransportMechanism_Parse(absl::string_view name, TransportMechanism* value) {
    return MeshPacket_TransportMechanism_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPublicKeyFieldNumber = 16,
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kChannelFieldNumber = 3,
    kIdFieldNumber = 6,
    kRxTimeFieldNumber = 7,
    kRxSnrFieldNumber = 8,
    kHopLimitFieldNumber = 9,
    kPriorityFieldNumber = 11,
    kRxRssiFieldNumber = 12,
    kDelayedFieldNumber = 13,
    kWantAckFieldNumber = 10,
    kViaMqttFieldNumber = 14,
    kPkiEncryptedFieldNumber = 17,
    kHopStartFieldNumber = 15,
    kNextHopFieldNumber = 18,
    kRelayNodeFieldNumber = 19,
    kTxAfterFieldNumber = 20,
    kTransportMechanismFieldNumber = 21,
    kDecodedFieldNumber = 4,
    kEncryptedFieldNumber = 5,
  };
  // bytes public_key = 16;
  void clear_public_key() ;
  const std::string& public_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_public_key(Arg_&& arg, Args_... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* value);

  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(
      const std::string& value);
  std::string* _internal_mutable_public_key();

  public:
  // fixed32 from = 1;
  void clear_from() ;
  ::uint32_t from() const;
  void set_from(::uint32_t value);

  private:
  ::uint32_t _internal_from() const;
  void _internal_set_from(::uint32_t value);

  public:
  // fixed32 to = 2;
  void clear_to() ;
  ::uint32_t to() const;
  void set_to(::uint32_t value);

  private:
  ::uint32_t _internal_to() const;
  void _internal_set_to(::uint32_t value);

  public:
  // uint32 channel = 3;
  void clear_channel() ;
  ::uint32_t channel() const;
  void set_channel(::uint32_t value);

  private:
  ::uint32_t _internal_channel() const;
  void _internal_set_channel(::uint32_t value);

  public:
  // fixed32 id = 6;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // fixed32 rx_time = 7;
  void clear_rx_time() ;
  ::uint32_t rx_time() const;
  void set_rx_time(::uint32_t value);

  private:
  ::uint32_t _internal_rx_time() const;
  void _internal_set_rx_time(::uint32_t value);

  public:
  // float rx_snr = 8;
  void clear_rx_snr() ;
  float rx_snr() const;
  void set_rx_snr(float value);

  private:
  float _internal_rx_snr() const;
  void _internal_set_rx_snr(float value);

  public:
  // uint32 hop_limit = 9;
  void clear_hop_limit() ;
  ::uint32_t hop_limit() const;
  void set_hop_limit(::uint32_t value);

  private:
  ::uint32_t _internal_hop_limit() const;
  void _internal_set_hop_limit(::uint32_t value);

  public:
  // .meshtastic.MeshPacket.Priority priority = 11;
  void clear_priority() ;
  ::meshtastic::MeshPacket_Priority priority() const;
  void set_priority(::meshtastic::MeshPacket_Priority value);

  private:
  ::meshtastic::MeshPacket_Priority _internal_priority() const;
  void _internal_set_priority(::meshtastic::MeshPacket_Priority value);

  public:
  // int32 rx_rssi = 12;
  void clear_rx_rssi() ;
  ::int32_t rx_rssi() const;
  void set_rx_rssi(::int32_t value);

  private:
  ::int32_t _internal_rx_rssi() const;
  void _internal_set_rx_rssi(::int32_t value);

  public:
  // .meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
  [[deprecated]]  void clear_delayed() ;
  [[deprecated]] ::meshtastic::MeshPacket_Delayed delayed() const;
  [[deprecated]] void set_delayed(::meshtastic::MeshPacket_Delayed value);

  private:
  ::meshtastic::MeshPacket_Delayed _internal_delayed() const;
  void _internal_set_delayed(::meshtastic::MeshPacket_Delayed value);

  public:
  // bool want_ack = 10;
  void clear_want_ack() ;
  bool want_ack() const;
  void set_want_ack(bool value);

  private:
  bool _internal_want_ack() const;
  void _internal_set_want_ack(bool value);

  public:
  // bool via_mqtt = 14;
  void clear_via_mqtt() ;
  bool via_mqtt() const;
  void set_via_mqtt(bool value);

  private:
  bool _internal_via_mqtt() const;
  void _internal_set_via_mqtt(bool value);

  public:
  // bool pki_encrypted = 17;
  void clear_pki_encrypted() ;
  bool pki_encrypted() const;
  void set_pki_encrypted(bool value);

  private:
  bool _internal_pki_encrypted() const;
  void _internal_set_pki_encrypted(bool value);

  public:
  // uint32 hop_start = 15;
  void clear_hop_start() ;
  ::uint32_t hop_start() const;
  void set_hop_start(::uint32_t value);

  private:
  ::uint32_t _internal_hop_start() const;
  void _internal_set_hop_start(::uint32_t value);

  public:
  // uint32 next_hop = 18;
  void clear_next_hop() ;
  ::uint32_t next_hop() const;
  void set_next_hop(::uint32_t value);

  private:
  ::uint32_t _internal_next_hop() const;
  void _internal_set_next_hop(::uint32_t value);

  public:
  // uint32 relay_node = 19;
  void clear_relay_node() ;
  ::uint32_t relay_node() const;
  void set_relay_node(::uint32_t value);

  private:
  ::uint32_t _internal_relay_node() const;
  void _internal_set_relay_node(::uint32_t value);

  public:
  // uint32 tx_after = 20;
  void clear_tx_after() ;
  ::uint32_t tx_after() const;
  void set_tx_after(::uint32_t value);

  private:
  ::uint32_t _internal_tx_after() const;
  void _internal_set_tx_after(::uint32_t value);

  public:
  // .meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;
  void clear_transport_mechanism() ;
  ::meshtastic::MeshPacket_TransportMechanism transport_mechanism() const;
  void set_transport_mechanism(::meshtastic::MeshPacket_TransportMechanism value);

  private:
  ::meshtastic::MeshPacket_TransportMechanism _internal_transport_mechanism() const;
  void _internal_set_transport_mechanism(::meshtastic::MeshPacket_TransportMechanism value);

  public:
  // .meshtastic.Data decoded = 4;
  bool has_decoded() const;
  private:
  bool _internal_has_decoded() const;

  public:
  void clear_decoded() ;
  const ::meshtastic::Data& decoded() const;
  PROTOBUF_NODISCARD ::meshtastic::Data* release_decoded();
  ::meshtastic::Data* mutable_decoded();
  void set_allocated_decoded(::meshtastic::Data* value);
  void unsafe_arena_set_allocated_decoded(::meshtastic::Data* value);
  ::meshtastic::Data* unsafe_arena_release_decoded();

  private:
  const ::meshtastic::Data& _internal_decoded() const;
  ::meshtastic::Data* _internal_mutable_decoded();

  public:
  // bytes encrypted = 5;
  bool has_encrypted() const;
  void clear_encrypted() ;
  const std::string& encrypted() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encrypted(Arg_&& arg, Args_... args);
  std::string* mutable_encrypted();
  PROTOBUF_NODISCARD std::string* release_encrypted();
  void set_allocated_encrypted(std::string* value);

  private:
  const std::string& _internal_encrypted() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted(
      const std::string& value);
  std::string* _internal_mutable_encrypted();

  public:
  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.MeshPacket)
 private:
  class _Internal;
  void set_has_decoded();
  void set_has_encrypted();
  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 21, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MeshPacket& from_msg);
    ::google::protobuf::internal::ArenaStringPtr public_key_;
    ::uint32_t from_;
    ::uint32_t to_;
    ::uint32_t channel_;
    ::uint32_t id_;
    ::uint32_t rx_time_;
    float rx_snr_;
    ::uint32_t hop_limit_;
    int priority_;
    ::int32_t rx_rssi_;
    int delayed_;
    bool want_ack_;
    bool via_mqtt_;
    bool pki_encrypted_;
    ::uint32_t hop_start_;
    ::uint32_t next_hop_;
    ::uint32_t relay_node_;
    ::uint32_t tx_after_;
    int transport_mechanism_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::meshtastic::Data* decoded_;
      ::google::protobuf::internal::ArenaStringPtr encrypted_;
    } payload_variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class ClientNotification final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.ClientNotification) */ {
 public:
  inline ClientNotification() : ClientNotification(nullptr) {}
  ~ClientNotification() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClientNotification* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClientNotification));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClientNotification(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClientNotification(const ClientNotification& from) : ClientNotification(nullptr, from) {}
  inline ClientNotification(ClientNotification&& from) noexcept
      : ClientNotification(nullptr, std::move(from)) {}
  inline ClientNotification& operator=(const ClientNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientNotification& operator=(ClientNotification&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientNotification& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kKeyVerificationNumberInform = 11,
    kKeyVerificationNumberRequest = 12,
    kKeyVerificationFinal = 13,
    kDuplicatedPublicKey = 14,
    kLowEntropyKey = 15,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };
  static inline const ClientNotification* internal_default_instance() {
    return reinterpret_cast<const ClientNotification*>(
        &_ClientNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ClientNotification& a, ClientNotification& b) { a.Swap(&b); }
  inline void Swap(ClientNotification* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientNotification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientNotification* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ClientNotification>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClientNotification& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClientNotification& from) { ClientNotification::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClientNotification* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.ClientNotification"; }

 protected:
  explicit ClientNotification(::google::protobuf::Arena* arena);
  ClientNotification(::google::protobuf::Arena* arena, const ClientNotification& from);
  ClientNotification(::google::protobuf::Arena* arena, ClientNotification&& from) noexcept
      : ClientNotification(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 4,
    kReplyIdFieldNumber = 1,
    kTimeFieldNumber = 2,
    kLevelFieldNumber = 3,
    kKeyVerificationNumberInformFieldNumber = 11,
    kKeyVerificationNumberRequestFieldNumber = 12,
    kKeyVerificationFinalFieldNumber = 13,
    kDuplicatedPublicKeyFieldNumber = 14,
    kLowEntropyKeyFieldNumber = 15,
  };
  // string message = 4;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // optional uint32 reply_id = 1;
  bool has_reply_id() const;
  void clear_reply_id() ;
  ::uint32_t reply_id() const;
  void set_reply_id(::uint32_t value);

  private:
  ::uint32_t _internal_reply_id() const;
  void _internal_set_reply_id(::uint32_t value);

  public:
  // fixed32 time = 2;
  void clear_time() ;
  ::uint32_t time() const;
  void set_time(::uint32_t value);

  private:
  ::uint32_t _internal_time() const;
  void _internal_set_time(::uint32_t value);

  public:
  // .meshtastic.LogRecord.Level level = 3;
  void clear_level() ;
  ::meshtastic::LogRecord_Level level() const;
  void set_level(::meshtastic::LogRecord_Level value);

  private:
  ::meshtastic::LogRecord_Level _internal_level() const;
  void _internal_set_level(::meshtastic::LogRecord_Level value);

  public:
  // .meshtastic.KeyVerificationNumberInform key_verification_number_inform = 11;
  bool has_key_verification_number_inform() const;
  private:
  bool _internal_has_key_verification_number_inform() const;

  public:
  void clear_key_verification_number_inform() ;
  const ::meshtastic::KeyVerificationNumberInform& key_verification_number_inform() const;
  PROTOBUF_NODISCARD ::meshtastic::KeyVerificationNumberInform* release_key_verification_number_inform();
  ::meshtastic::KeyVerificationNumberInform* mutable_key_verification_number_inform();
  void set_allocated_key_verification_number_inform(::meshtastic::KeyVerificationNumberInform* value);
  void unsafe_arena_set_allocated_key_verification_number_inform(::meshtastic::KeyVerificationNumberInform* value);
  ::meshtastic::KeyVerificationNumberInform* unsafe_arena_release_key_verification_number_inform();

  private:
  const ::meshtastic::KeyVerificationNumberInform& _internal_key_verification_number_inform() const;
  ::meshtastic::KeyVerificationNumberInform* _internal_mutable_key_verification_number_inform();

  public:
  // .meshtastic.KeyVerificationNumberRequest key_verification_number_request = 12;
  bool has_key_verification_number_request() const;
  private:
  bool _internal_has_key_verification_number_request() const;

  public:
  void clear_key_verification_number_request() ;
  const ::meshtastic::KeyVerificationNumberRequest& key_verification_number_request() const;
  PROTOBUF_NODISCARD ::meshtastic::KeyVerificationNumberRequest* release_key_verification_number_request();
  ::meshtastic::KeyVerificationNumberRequest* mutable_key_verification_number_request();
  void set_allocated_key_verification_number_request(::meshtastic::KeyVerificationNumberRequest* value);
  void unsafe_arena_set_allocated_key_verification_number_request(::meshtastic::KeyVerificationNumberRequest* value);
  ::meshtastic::KeyVerificationNumberRequest* unsafe_arena_release_key_verification_number_request();

  private:
  const ::meshtastic::KeyVerificationNumberRequest& _internal_key_verification_number_request() const;
  ::meshtastic::KeyVerificationNumberRequest* _internal_mutable_key_verification_number_request();

  public:
  // .meshtastic.KeyVerificationFinal key_verification_final = 13;
  bool has_key_verification_final() const;
  private:
  bool _internal_has_key_verification_final() const;

  public:
  void clear_key_verification_final() ;
  const ::meshtastic::KeyVerificationFinal& key_verification_final() const;
  PROTOBUF_NODISCARD ::meshtastic::KeyVerificationFinal* release_key_verification_final();
  ::meshtastic::KeyVerificationFinal* mutable_key_verification_final();
  void set_allocated_key_verification_final(::meshtastic::KeyVerificationFinal* value);
  void unsafe_arena_set_allocated_key_verification_final(::meshtastic::KeyVerificationFinal* value);
  ::meshtastic::KeyVerificationFinal* unsafe_arena_release_key_verification_final();

  private:
  const ::meshtastic::KeyVerificationFinal& _internal_key_verification_final() const;
  ::meshtastic::KeyVerificationFinal* _internal_mutable_key_verification_final();

  public:
  // .meshtastic.DuplicatedPublicKey duplicated_public_key = 14;
  bool has_duplicated_public_key() const;
  private:
  bool _internal_has_duplicated_public_key() const;

  public:
  void clear_duplicated_public_key() ;
  const ::meshtastic::DuplicatedPublicKey& duplicated_public_key() const;
  PROTOBUF_NODISCARD ::meshtastic::DuplicatedPublicKey* release_duplicated_public_key();
  ::meshtastic::DuplicatedPublicKey* mutable_duplicated_public_key();
  void set_allocated_duplicated_public_key(::meshtastic::DuplicatedPublicKey* value);
  void unsafe_arena_set_allocated_duplicated_public_key(::meshtastic::DuplicatedPublicKey* value);
  ::meshtastic::DuplicatedPublicKey* unsafe_arena_release_duplicated_public_key();

  private:
  const ::meshtastic::DuplicatedPublicKey& _internal_duplicated_public_key() const;
  ::meshtastic::DuplicatedPublicKey* _internal_mutable_duplicated_public_key();

  public:
  // .meshtastic.LowEntropyKey low_entropy_key = 15;
  bool has_low_entropy_key() const;
  private:
  bool _internal_has_low_entropy_key() const;

  public:
  void clear_low_entropy_key() ;
  const ::meshtastic::LowEntropyKey& low_entropy_key() const;
  PROTOBUF_NODISCARD ::meshtastic::LowEntropyKey* release_low_entropy_key();
  ::meshtastic::LowEntropyKey* mutable_low_entropy_key();
  void set_allocated_low_entropy_key(::meshtastic::LowEntropyKey* value);
  void unsafe_arena_set_allocated_low_entropy_key(::meshtastic::LowEntropyKey* value);
  ::meshtastic::LowEntropyKey* unsafe_arena_release_low_entropy_key();

  private:
  const ::meshtastic::LowEntropyKey& _internal_low_entropy_key() const;
  ::meshtastic::LowEntropyKey* _internal_mutable_low_entropy_key();

  public:
  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.ClientNotification)
 private:
  class _Internal;
  void set_has_key_verification_number_inform();
  void set_has_key_verification_number_request();
  void set_has_key_verification_final();
  void set_has_duplicated_public_key();
  void set_has_low_entropy_key();
  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 9, 5,
      53, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClientNotification& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint32_t reply_id_;
    ::uint32_t time_;
    int level_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::meshtastic::KeyVerificationNumberInform* key_verification_number_inform_;
      ::meshtastic::KeyVerificationNumberRequest* key_verification_number_request_;
      ::meshtastic::KeyVerificationFinal* key_verification_final_;
      ::meshtastic::DuplicatedPublicKey* duplicated_public_key_;
      ::meshtastic::LowEntropyKey* low_entropy_key_;
    } payload_variant_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class ChunkedPayloadResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.ChunkedPayloadResponse) */ {
 public:
  inline ChunkedPayloadResponse() : ChunkedPayloadResponse(nullptr) {}
  ~ChunkedPayloadResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChunkedPayloadResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChunkedPayloadResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChunkedPayloadResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChunkedPayloadResponse(const ChunkedPayloadResponse& from) : ChunkedPayloadResponse(nullptr, from) {}
  inline ChunkedPayloadResponse(ChunkedPayloadResponse&& from) noexcept
      : ChunkedPayloadResponse(nullptr, std::move(from)) {}
  inline ChunkedPayloadResponse& operator=(const ChunkedPayloadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkedPayloadResponse& operator=(ChunkedPayloadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChunkedPayloadResponse& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kRequestTransfer = 2,
    kAcceptTransfer = 3,
    kResendChunks = 4,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };
  static inline const ChunkedPayloadResponse* internal_default_instance() {
    return reinterpret_cast<const ChunkedPayloadResponse*>(
        &_ChunkedPayloadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(ChunkedPayloadResponse& a, ChunkedPayloadResponse& b) { a.Swap(&b); }
  inline void Swap(ChunkedPayloadResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkedPayloadResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChunkedPayloadResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChunkedPayloadResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChunkedPayloadResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChunkedPayloadResponse& from) { ChunkedPayloadResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChunkedPayloadResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.ChunkedPayloadResponse"; }

 protected:
  explicit ChunkedPayloadResponse(::google::protobuf::Arena* arena);
  ChunkedPayloadResponse(::google::protobuf::Arena* arena, const ChunkedPayloadResponse& from);
  ChunkedPayloadResponse(::google::protobuf::Arena* arena, ChunkedPayloadResponse&& from) noexcept
      : ChunkedPayloadResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPayloadIdFieldNumber = 1,
    kRequestTransferFieldNumber = 2,
    kAcceptTransferFieldNumber = 3,
    kResendChunksFieldNumber = 4,
  };
  // uint32 payload_id = 1;
  void clear_payload_id() ;
  ::uint32_t payload_id() const;
  void set_payload_id(::uint32_t value);

  private:
  ::uint32_t _internal_payload_id() const;
  void _internal_set_payload_id(::uint32_t value);

  public:
  // bool request_transfer = 2;
  bool has_request_transfer() const;
  void clear_request_transfer() ;
  bool request_transfer() const;
  void set_request_transfer(bool value);

  private:
  bool _internal_request_transfer() const;
  void _internal_set_request_transfer(bool value);

  public:
  // bool accept_transfer = 3;
  bool has_accept_transfer() const;
  void clear_accept_transfer() ;
  bool accept_transfer() const;
  void set_accept_transfer(bool value);

  private:
  bool _internal_accept_transfer() const;
  void _internal_set_accept_transfer(bool value);

  public:
  // .meshtastic.resend_chunks resend_chunks = 4;
  bool has_resend_chunks() const;
  private:
  bool _internal_has_resend_chunks() const;

  public:
  void clear_resend_chunks() ;
  const ::meshtastic::resend_chunks& resend_chunks() const;
  PROTOBUF_NODISCARD ::meshtastic::resend_chunks* release_resend_chunks();
  ::meshtastic::resend_chunks* mutable_resend_chunks();
  void set_allocated_resend_chunks(::meshtastic::resend_chunks* value);
  void unsafe_arena_set_allocated_resend_chunks(::meshtastic::resend_chunks* value);
  ::meshtastic::resend_chunks* unsafe_arena_release_resend_chunks();

  private:
  const ::meshtastic::resend_chunks& _internal_resend_chunks() const;
  ::meshtastic::resend_chunks* _internal_mutable_resend_chunks();

  public:
  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.ChunkedPayloadResponse)
 private:
  class _Internal;
  void set_has_request_transfer();
  void set_has_accept_transfer();
  void set_has_resend_chunks();
  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ChunkedPayloadResponse& from_msg);
    ::uint32_t payload_id_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool request_transfer_;
      bool accept_transfer_;
      ::meshtastic::resend_chunks* resend_chunks_;
    } payload_variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class ToRadio final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.ToRadio) */ {
 public:
  inline ToRadio() : ToRadio(nullptr) {}
  ~ToRadio() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ToRadio* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ToRadio));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ToRadio(
      ::google::protobuf::internal::ConstantInitialized);

  inline ToRadio(const ToRadio& from) : ToRadio(nullptr, from) {}
  inline ToRadio(ToRadio&& from) noexcept
      : ToRadio(nullptr, std::move(from)) {}
  inline ToRadio& operator=(const ToRadio& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToRadio& operator=(ToRadio&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToRadio& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kPacket = 1,
    kWantConfigId = 3,
    kDisconnect = 4,
    kXmodemPacket = 5,
    kMqttClientProxyMessage = 6,
    kHeartbeat = 7,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };
  static inline const ToRadio* internal_default_instance() {
    return reinterpret_cast<const ToRadio*>(
        &_ToRadio_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(ToRadio& a, ToRadio& b) { a.Swap(&b); }
  inline void Swap(ToRadio* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToRadio* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToRadio* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ToRadio>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ToRadio& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ToRadio& from) { ToRadio::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ToRadio* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.ToRadio"; }

 protected:
  explicit ToRadio(::google::protobuf::Arena* arena);
  ToRadio(::google::protobuf::Arena* arena, const ToRadio& from);
  ToRadio(::google::protobuf::Arena* arena, ToRadio&& from) noexcept
      : ToRadio(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPacketFieldNumber = 1,
    kWantConfigIdFieldNumber = 3,
    kDisconnectFieldNumber = 4,
    kXmodemPacketFieldNumber = 5,
    kMqttClientProxyMessageFieldNumber = 6,
    kHeartbeatFieldNumber = 7,
  };
  // .meshtastic.MeshPacket packet = 1;
  bool has_packet() const;
  private:
  bool _internal_has_packet() const;

  public:
  void clear_packet() ;
  const ::meshtastic::MeshPacket& packet() const;
  PROTOBUF_NODISCARD ::meshtastic::MeshPacket* release_packet();
  ::meshtastic::MeshPacket* mutable_packet();
  void set_allocated_packet(::meshtastic::MeshPacket* value);
  void unsafe_arena_set_allocated_packet(::meshtastic::MeshPacket* value);
  ::meshtastic::MeshPacket* unsafe_arena_release_packet();

  private:
  const ::meshtastic::MeshPacket& _internal_packet() const;
  ::meshtastic::MeshPacket* _internal_mutable_packet();

  public:
  // uint32 want_config_id = 3;
  bool has_want_config_id() const;
  void clear_want_config_id() ;
  ::uint32_t want_config_id() const;
  void set_want_config_id(::uint32_t value);

  private:
  ::uint32_t _internal_want_config_id() const;
  void _internal_set_want_config_id(::uint32_t value);

  public:
  // bool disconnect = 4;
  bool has_disconnect() const;
  void clear_disconnect() ;
  bool disconnect() const;
  void set_disconnect(bool value);

  private:
  bool _internal_disconnect() const;
  void _internal_set_disconnect(bool value);

  public:
  // .meshtastic.XModem xmodemPacket = 5;
  bool has_xmodempacket() const;
  private:
  bool _internal_has_xmodempacket() const;

  public:
  void clear_xmodempacket() ;
  const ::meshtastic::XModem& xmodempacket() const;
  PROTOBUF_NODISCARD ::meshtastic::XModem* release_xmodempacket();
  ::meshtastic::XModem* mutable_xmodempacket();
  void set_allocated_xmodempacket(::meshtastic::XModem* value);
  void unsafe_arena_set_allocated_xmodempacket(::meshtastic::XModem* value);
  ::meshtastic::XModem* unsafe_arena_release_xmodempacket();

  private:
  const ::meshtastic::XModem& _internal_xmodempacket() const;
  ::meshtastic::XModem* _internal_mutable_xmodempacket();

  public:
  // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 6;
  bool has_mqttclientproxymessage() const;
  private:
  bool _internal_has_mqttclientproxymessage() const;

  public:
  void clear_mqttclientproxymessage() ;
  const ::meshtastic::MqttClientProxyMessage& mqttclientproxymessage() const;
  PROTOBUF_NODISCARD ::meshtastic::MqttClientProxyMessage* release_mqttclientproxymessage();
  ::meshtastic::MqttClientProxyMessage* mutable_mqttclientproxymessage();
  void set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* value);
  void unsafe_arena_set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* value);
  ::meshtastic::MqttClientProxyMessage* unsafe_arena_release_mqttclientproxymessage();

  private:
  const ::meshtastic::MqttClientProxyMessage& _internal_mqttclientproxymessage() const;
  ::meshtastic::MqttClientProxyMessage* _internal_mutable_mqttclientproxymessage();

  public:
  // .meshtastic.Heartbeat heartbeat = 7;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;

  public:
  void clear_heartbeat() ;
  const ::meshtastic::Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::meshtastic::Heartbeat* release_heartbeat();
  ::meshtastic::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::meshtastic::Heartbeat* value);
  void unsafe_arena_set_allocated_heartbeat(::meshtastic::Heartbeat* value);
  ::meshtastic::Heartbeat* unsafe_arena_release_heartbeat();

  private:
  const ::meshtastic::Heartbeat& _internal_heartbeat() const;
  ::meshtastic::Heartbeat* _internal_mutable_heartbeat();

  public:
  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.ToRadio)
 private:
  class _Internal;
  void set_has_packet();
  void set_has_want_config_id();
  void set_has_disconnect();
  void set_has_xmodempacket();
  void set_has_mqttclientproxymessage();
  void set_has_heartbeat();
  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 6, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ToRadio& from_msg);
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::meshtastic::MeshPacket* packet_;
      ::uint32_t want_config_id_;
      bool disconnect_;
      ::meshtastic::XModem* xmodempacket_;
      ::meshtastic::MqttClientProxyMessage* mqttclientproxymessage_;
      ::meshtastic::Heartbeat* heartbeat_;
    } payload_variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class FromRadio final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.FromRadio) */ {
 public:
  inline FromRadio() : FromRadio(nullptr) {}
  ~FromRadio() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FromRadio* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FromRadio));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FromRadio(
      ::google::protobuf::internal::ConstantInitialized);

  inline FromRadio(const FromRadio& from) : FromRadio(nullptr, from) {}
  inline FromRadio(FromRadio&& from) noexcept
      : FromRadio(nullptr, std::move(from)) {}
  inline FromRadio& operator=(const FromRadio& from) {
    CopyFrom(from);
    return *this;
  }
  inline FromRadio& operator=(FromRadio&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FromRadio& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kPacket = 2,
    kMyInfo = 3,
    kNodeInfo = 4,
    kConfig = 5,
    kLogRecord = 6,
    kConfigCompleteId = 7,
    kRebooted = 8,
    kModuleConfig = 9,
    kChannel = 10,
    kQueueStatus = 11,
    kXmodemPacket = 12,
    kMetadata = 13,
    kMqttClientProxyMessage = 14,
    kFileInfo = 15,
    kClientNotification = 16,
    kDeviceuiConfig = 17,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };
  static inline const FromRadio* internal_default_instance() {
    return reinterpret_cast<const FromRadio*>(
        &_FromRadio_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(FromRadio& a, FromRadio& b) { a.Swap(&b); }
  inline void Swap(FromRadio* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FromRadio* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FromRadio* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FromRadio>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FromRadio& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FromRadio& from) { FromRadio::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FromRadio* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.FromRadio"; }

 protected:
  explicit FromRadio(::google::protobuf::Arena* arena);
  FromRadio(::google::protobuf::Arena* arena, const FromRadio& from);
  FromRadio(::google::protobuf::Arena* arena, FromRadio&& from) noexcept
      : FromRadio(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kPacketFieldNumber = 2,
    kMyInfoFieldNumber = 3,
    kNodeInfoFieldNumber = 4,
    kConfigFieldNumber = 5,
    kLogRecordFieldNumber = 6,
    kConfigCompleteIdFieldNumber = 7,
    kRebootedFieldNumber = 8,
    kModuleConfigFieldNumber = 9,
    kChannelFieldNumber = 10,
    kQueueStatusFieldNumber = 11,
    kXmodemPacketFieldNumber = 12,
    kMetadataFieldNumber = 13,
    kMqttClientProxyMessageFieldNumber = 14,
    kFileInfoFieldNumber = 15,
    kClientNotificationFieldNumber = 16,
    kDeviceuiConfigFieldNumber = 17,
  };
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // .meshtastic.MeshPacket packet = 2;
  bool has_packet() const;
  private:
  bool _internal_has_packet() const;

  public:
  void clear_packet() ;
  const ::meshtastic::MeshPacket& packet() const;
  PROTOBUF_NODISCARD ::meshtastic::MeshPacket* release_packet();
  ::meshtastic::MeshPacket* mutable_packet();
  void set_allocated_packet(::meshtastic::MeshPacket* value);
  void unsafe_arena_set_allocated_packet(::meshtastic::MeshPacket* value);
  ::meshtastic::MeshPacket* unsafe_arena_release_packet();

  private:
  const ::meshtastic::MeshPacket& _internal_packet() const;
  ::meshtastic::MeshPacket* _internal_mutable_packet();

  public:
  // .meshtastic.MyNodeInfo my_info = 3;
  bool has_my_info() const;
  private:
  bool _internal_has_my_info() const;

  public:
  void clear_my_info() ;
  const ::meshtastic::MyNodeInfo& my_info() const;
  PROTOBUF_NODISCARD ::meshtastic::MyNodeInfo* release_my_info();
  ::meshtastic::MyNodeInfo* mutable_my_info();
  void set_allocated_my_info(::meshtastic::MyNodeInfo* value);
  void unsafe_arena_set_allocated_my_info(::meshtastic::MyNodeInfo* value);
  ::meshtastic::MyNodeInfo* unsafe_arena_release_my_info();

  private:
  const ::meshtastic::MyNodeInfo& _internal_my_info() const;
  ::meshtastic::MyNodeInfo* _internal_mutable_my_info();

  public:
  // .meshtastic.NodeInfo node_info = 4;
  bool has_node_info() const;
  private:
  bool _internal_has_node_info() const;

  public:
  void clear_node_info() ;
  const ::meshtastic::NodeInfo& node_info() const;
  PROTOBUF_NODISCARD ::meshtastic::NodeInfo* release_node_info();
  ::meshtastic::NodeInfo* mutable_node_info();
  void set_allocated_node_info(::meshtastic::NodeInfo* value);
  void unsafe_arena_set_allocated_node_info(::meshtastic::NodeInfo* value);
  ::meshtastic::NodeInfo* unsafe_arena_release_node_info();

  private:
  const ::meshtastic::NodeInfo& _internal_node_info() const;
  ::meshtastic::NodeInfo* _internal_mutable_node_info();

  public:
  // .meshtastic.Config config = 5;
  bool has_config() const;
  private:
  bool _internal_has_config() const;

  public:
  void clear_config() ;
  const ::meshtastic::Config& config() const;
  PROTOBUF_NODISCARD ::meshtastic::Config* release_config();
  ::meshtastic::Config* mutable_config();
  void set_allocated_config(::meshtastic::Config* value);
  void unsafe_arena_set_allocated_config(::meshtastic::Config* value);
  ::meshtastic::Config* unsafe_arena_release_config();

  private:
  const ::meshtastic::Config& _internal_config() const;
  ::meshtastic::Config* _internal_mutable_config();

  public:
  // .meshtastic.LogRecord log_record = 6;
  bool has_log_record() const;
  private:
  bool _internal_has_log_record() const;

  public:
  void clear_log_record() ;
  const ::meshtastic::LogRecord& log_record() const;
  PROTOBUF_NODISCARD ::meshtastic::LogRecord* release_log_record();
  ::meshtastic::LogRecord* mutable_log_record();
  void set_allocated_log_record(::meshtastic::LogRecord* value);
  void unsafe_arena_set_allocated_log_record(::meshtastic::LogRecord* value);
  ::meshtastic::LogRecord* unsafe_arena_release_log_record();

  private:
  const ::meshtastic::LogRecord& _internal_log_record() const;
  ::meshtastic::LogRecord* _internal_mutable_log_record();

  public:
  // uint32 config_complete_id = 7;
  bool has_config_complete_id() const;
  void clear_config_complete_id() ;
  ::uint32_t config_complete_id() const;
  void set_config_complete_id(::uint32_t value);

  private:
  ::uint32_t _internal_config_complete_id() const;
  void _internal_set_config_complete_id(::uint32_t value);

  public:
  // bool rebooted = 8;
  bool has_rebooted() const;
  void clear_rebooted() ;
  bool rebooted() const;
  void set_rebooted(bool value);

  private:
  bool _internal_rebooted() const;
  void _internal_set_rebooted(bool value);

  public:
  // .meshtastic.ModuleConfig moduleConfig = 9;
  bool has_moduleconfig() const;
  private:
  bool _internal_has_moduleconfig() const;

  public:
  void clear_moduleconfig() ;
  const ::meshtastic::ModuleConfig& moduleconfig() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig* release_moduleconfig();
  ::meshtastic::ModuleConfig* mutable_moduleconfig();
  void set_allocated_moduleconfig(::meshtastic::ModuleConfig* value);
  void unsafe_arena_set_allocated_moduleconfig(::meshtastic::ModuleConfig* value);
  ::meshtastic::ModuleConfig* unsafe_arena_release_moduleconfig();

  private:
  const ::meshtastic::ModuleConfig& _internal_moduleconfig() const;
  ::meshtastic::ModuleConfig* _internal_mutable_moduleconfig();

  public:
  // .meshtastic.Channel channel = 10;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;

  public:
  void clear_channel() ;
  const ::meshtastic::Channel& channel() const;
  PROTOBUF_NODISCARD ::meshtastic::Channel* release_channel();
  ::meshtastic::Channel* mutable_channel();
  void set_allocated_channel(::meshtastic::Channel* value);
  void unsafe_arena_set_allocated_channel(::meshtastic::Channel* value);
  ::meshtastic::Channel* unsafe_arena_release_channel();

  private:
  const ::meshtastic::Channel& _internal_channel() const;
  ::meshtastic::Channel* _internal_mutable_channel();

  public:
  // .meshtastic.QueueStatus queueStatus = 11;
  bool has_queuestatus() const;
  private:
  bool _internal_has_queuestatus() const;

  public:
  void clear_queuestatus() ;
  const ::meshtastic::QueueStatus& queuestatus() const;
  PROTOBUF_NODISCARD ::meshtastic::QueueStatus* release_queuestatus();
  ::meshtastic::QueueStatus* mutable_queuestatus();
  void set_allocated_queuestatus(::meshtastic::QueueStatus* value);
  void unsafe_arena_set_allocated_queuestatus(::meshtastic::QueueStatus* value);
  ::meshtastic::QueueStatus* unsafe_arena_release_queuestatus();

  private:
  const ::meshtastic::QueueStatus& _internal_queuestatus() const;
  ::meshtastic::QueueStatus* _internal_mutable_queuestatus();

  public:
  // .meshtastic.XModem xmodemPacket = 12;
  bool has_xmodempacket() const;
  private:
  bool _internal_has_xmodempacket() const;

  public:
  void clear_xmodempacket() ;
  const ::meshtastic::XModem& xmodempacket() const;
  PROTOBUF_NODISCARD ::meshtastic::XModem* release_xmodempacket();
  ::meshtastic::XModem* mutable_xmodempacket();
  void set_allocated_xmodempacket(::meshtastic::XModem* value);
  void unsafe_arena_set_allocated_xmodempacket(::meshtastic::XModem* value);
  ::meshtastic::XModem* unsafe_arena_release_xmodempacket();

  private:
  const ::meshtastic::XModem& _internal_xmodempacket() const;
  ::meshtastic::XModem* _internal_mutable_xmodempacket();

  public:
  // .meshtastic.DeviceMetadata metadata = 13;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;

  public:
  void clear_metadata() ;
  const ::meshtastic::DeviceMetadata& metadata() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceMetadata* release_metadata();
  ::meshtastic::DeviceMetadata* mutable_metadata();
  void set_allocated_metadata(::meshtastic::DeviceMetadata* value);
  void unsafe_arena_set_allocated_metadata(::meshtastic::DeviceMetadata* value);
  ::meshtastic::DeviceMetadata* unsafe_arena_release_metadata();

  private:
  const ::meshtastic::DeviceMetadata& _internal_metadata() const;
  ::meshtastic::DeviceMetadata* _internal_mutable_metadata();

  public:
  // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 14;
  bool has_mqttclientproxymessage() const;
  private:
  bool _internal_has_mqttclientproxymessage() const;

  public:
  void clear_mqttclientproxymessage() ;
  const ::meshtastic::MqttClientProxyMessage& mqttclientproxymessage() const;
  PROTOBUF_NODISCARD ::meshtastic::MqttClientProxyMessage* release_mqttclientproxymessage();
  ::meshtastic::MqttClientProxyMessage* mutable_mqttclientproxymessage();
  void set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* value);
  void unsafe_arena_set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* value);
  ::meshtastic::MqttClientProxyMessage* unsafe_arena_release_mqttclientproxymessage();

  private:
  const ::meshtastic::MqttClientProxyMessage& _internal_mqttclientproxymessage() const;
  ::meshtastic::MqttClientProxyMessage* _internal_mutable_mqttclientproxymessage();

  public:
  // .meshtastic.FileInfo fileInfo = 15;
  bool has_fileinfo() const;
  private:
  bool _internal_has_fileinfo() const;

  public:
  void clear_fileinfo() ;
  const ::meshtastic::FileInfo& fileinfo() const;
  PROTOBUF_NODISCARD ::meshtastic::FileInfo* release_fileinfo();
  ::meshtastic::FileInfo* mutable_fileinfo();
  void set_allocated_fileinfo(::meshtastic::FileInfo* value);
  void unsafe_arena_set_allocated_fileinfo(::meshtastic::FileInfo* value);
  ::meshtastic::FileInfo* unsafe_arena_release_fileinfo();

  private:
  const ::meshtastic::FileInfo& _internal_fileinfo() const;
  ::meshtastic::FileInfo* _internal_mutable_fileinfo();

  public:
  // .meshtastic.ClientNotification clientNotification = 16;
  bool has_clientnotification() const;
  private:
  bool _internal_has_clientnotification() const;

  public:
  void clear_clientnotification() ;
  const ::meshtastic::ClientNotification& clientnotification() const;
  PROTOBUF_NODISCARD ::meshtastic::ClientNotification* release_clientnotification();
  ::meshtastic::ClientNotification* mutable_clientnotification();
  void set_allocated_clientnotification(::meshtastic::ClientNotification* value);
  void unsafe_arena_set_allocated_clientnotification(::meshtastic::ClientNotification* value);
  ::meshtastic::ClientNotification* unsafe_arena_release_clientnotification();

  private:
  const ::meshtastic::ClientNotification& _internal_clientnotification() const;
  ::meshtastic::ClientNotification* _internal_mutable_clientnotification();

  public:
  // .meshtastic.DeviceUIConfig deviceuiConfig = 17;
  bool has_deviceuiconfig() const;
  private:
  bool _internal_has_deviceuiconfig() const;

  public:
  void clear_deviceuiconfig() ;
  const ::meshtastic::DeviceUIConfig& deviceuiconfig() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceUIConfig* release_deviceuiconfig();
  ::meshtastic::DeviceUIConfig* mutable_deviceuiconfig();
  void set_allocated_deviceuiconfig(::meshtastic::DeviceUIConfig* value);
  void unsafe_arena_set_allocated_deviceuiconfig(::meshtastic::DeviceUIConfig* value);
  ::meshtastic::DeviceUIConfig* unsafe_arena_release_deviceuiconfig();

  private:
  const ::meshtastic::DeviceUIConfig& _internal_deviceuiconfig() const;
  ::meshtastic::DeviceUIConfig* _internal_mutable_deviceuiconfig();

  public:
  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.FromRadio)
 private:
  class _Internal;
  void set_has_packet();
  void set_has_my_info();
  void set_has_node_info();
  void set_has_config();
  void set_has_log_record();
  void set_has_config_complete_id();
  void set_has_rebooted();
  void set_has_moduleconfig();
  void set_has_channel();
  void set_has_queuestatus();
  void set_has_xmodempacket();
  void set_has_metadata();
  void set_has_mqttclientproxymessage();
  void set_has_fileinfo();
  void set_has_clientnotification();
  void set_has_deviceuiconfig();
  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 17, 14,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FromRadio& from_msg);
    ::uint32_t id_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::meshtastic::MeshPacket* packet_;
      ::meshtastic::MyNodeInfo* my_info_;
      ::meshtastic::NodeInfo* node_info_;
      ::meshtastic::Config* config_;
      ::meshtastic::LogRecord* log_record_;
      ::uint32_t config_complete_id_;
      bool rebooted_;
      ::meshtastic::ModuleConfig* moduleconfig_;
      ::meshtastic::Channel* channel_;
      ::meshtastic::QueueStatus* queuestatus_;
      ::meshtastic::XModem* xmodempacket_;
      ::meshtastic::DeviceMetadata* metadata_;
      ::meshtastic::MqttClientProxyMessage* mqttclientproxymessage_;
      ::meshtastic::FileInfo* fileinfo_;
      ::meshtastic::ClientNotification* clientnotification_;
      ::meshtastic::DeviceUIConfig* deviceuiconfig_;
    } payload_variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Position

// optional sfixed32 latitude_i = 1;
inline bool Position::has_latitude_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Position::clear_latitude_i() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Position::latitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.latitude_i)
  return _internal_latitude_i();
}
inline void Position::set_latitude_i(::int32_t value) {
  _internal_set_latitude_i(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.Position.latitude_i)
}
inline ::int32_t Position::_internal_latitude_i() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latitude_i_;
}
inline void Position::_internal_set_latitude_i(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_i_ = value;
}

// optional sfixed32 longitude_i = 2;
inline bool Position::has_longitude_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Position::clear_longitude_i() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Position::longitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.longitude_i)
  return _internal_longitude_i();
}
inline void Position::set_longitude_i(::int32_t value) {
  _internal_set_longitude_i(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:meshtastic.Position.longitude_i)
}
inline ::int32_t Position::_internal_longitude_i() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.longitude_i_;
}
inline void Position::_internal_set_longitude_i(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_i_ = value;
}

// optional int32 altitude = 3;
inline bool Position::has_altitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Position::clear_altitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t Position::altitude() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.altitude)
  return _internal_altitude();
}
inline void Position::set_altitude(::int32_t value) {
  _internal_set_altitude(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:meshtastic.Position.altitude)
}
inline ::int32_t Position::_internal_altitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.altitude_;
}
inline void Position::_internal_set_altitude(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_ = value;
}

// fixed32 time = 4;
inline void Position::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0u;
}
inline ::uint32_t Position::time() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.time)
  return _internal_time();
}
inline void Position::set_time(::uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.time)
}
inline ::uint32_t Position::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void Position::_internal_set_time(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// .meshtastic.Position.LocSource location_source = 5;
inline void Position::clear_location_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_source_ = 0;
}
inline ::meshtastic::Position_LocSource Position::location_source() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.location_source)
  return _internal_location_source();
}
inline void Position::set_location_source(::meshtastic::Position_LocSource value) {
  _internal_set_location_source(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.location_source)
}
inline ::meshtastic::Position_LocSource Position::_internal_location_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Position_LocSource>(_impl_.location_source_);
}
inline void Position::_internal_set_location_source(::meshtastic::Position_LocSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_source_ = value;
}

// .meshtastic.Position.AltSource altitude_source = 6;
inline void Position::clear_altitude_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_source_ = 0;
}
inline ::meshtastic::Position_AltSource Position::altitude_source() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.altitude_source)
  return _internal_altitude_source();
}
inline void Position::set_altitude_source(::meshtastic::Position_AltSource value) {
  _internal_set_altitude_source(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.altitude_source)
}
inline ::meshtastic::Position_AltSource Position::_internal_altitude_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Position_AltSource>(_impl_.altitude_source_);
}
inline void Position::_internal_set_altitude_source(::meshtastic::Position_AltSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_source_ = value;
}

// fixed32 timestamp = 7;
inline void Position::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = 0u;
}
inline ::uint32_t Position::timestamp() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.timestamp)
  return _internal_timestamp();
}
inline void Position::set_timestamp(::uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.timestamp)
}
inline ::uint32_t Position::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void Position::_internal_set_timestamp(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// int32 timestamp_millis_adjust = 8;
inline void Position::clear_timestamp_millis_adjust() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_millis_adjust_ = 0;
}
inline ::int32_t Position::timestamp_millis_adjust() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.timestamp_millis_adjust)
  return _internal_timestamp_millis_adjust();
}
inline void Position::set_timestamp_millis_adjust(::int32_t value) {
  _internal_set_timestamp_millis_adjust(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.timestamp_millis_adjust)
}
inline ::int32_t Position::_internal_timestamp_millis_adjust() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_millis_adjust_;
}
inline void Position::_internal_set_timestamp_millis_adjust(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_millis_adjust_ = value;
}

// optional sint32 altitude_hae = 9;
inline bool Position::has_altitude_hae() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Position::clear_altitude_hae() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_hae_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t Position::altitude_hae() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.altitude_hae)
  return _internal_altitude_hae();
}
inline void Position::set_altitude_hae(::int32_t value) {
  _internal_set_altitude_hae(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:meshtastic.Position.altitude_hae)
}
inline ::int32_t Position::_internal_altitude_hae() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.altitude_hae_;
}
inline void Position::_internal_set_altitude_hae(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_hae_ = value;
}

// optional sint32 altitude_geoidal_separation = 10;
inline bool Position::has_altitude_geoidal_separation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Position::clear_altitude_geoidal_separation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_geoidal_separation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t Position::altitude_geoidal_separation() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.altitude_geoidal_separation)
  return _internal_altitude_geoidal_separation();
}
inline void Position::set_altitude_geoidal_separation(::int32_t value) {
  _internal_set_altitude_geoidal_separation(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:meshtastic.Position.altitude_geoidal_separation)
}
inline ::int32_t Position::_internal_altitude_geoidal_separation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.altitude_geoidal_separation_;
}
inline void Position::_internal_set_altitude_geoidal_separation(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_geoidal_separation_ = value;
}

// uint32 PDOP = 11;
inline void Position::clear_pdop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pdop_ = 0u;
}
inline ::uint32_t Position::pdop() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.PDOP)
  return _internal_pdop();
}
inline void Position::set_pdop(::uint32_t value) {
  _internal_set_pdop(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.PDOP)
}
inline ::uint32_t Position::_internal_pdop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pdop_;
}
inline void Position::_internal_set_pdop(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pdop_ = value;
}

// uint32 HDOP = 12;
inline void Position::clear_hdop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hdop_ = 0u;
}
inline ::uint32_t Position::hdop() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.HDOP)
  return _internal_hdop();
}
inline void Position::set_hdop(::uint32_t value) {
  _internal_set_hdop(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.HDOP)
}
inline ::uint32_t Position::_internal_hdop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hdop_;
}
inline void Position::_internal_set_hdop(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hdop_ = value;
}

// uint32 VDOP = 13;
inline void Position::clear_vdop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vdop_ = 0u;
}
inline ::uint32_t Position::vdop() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.VDOP)
  return _internal_vdop();
}
inline void Position::set_vdop(::uint32_t value) {
  _internal_set_vdop(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.VDOP)
}
inline ::uint32_t Position::_internal_vdop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vdop_;
}
inline void Position::_internal_set_vdop(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vdop_ = value;
}

// uint32 gps_accuracy = 14;
inline void Position::clear_gps_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_accuracy_ = 0u;
}
inline ::uint32_t Position::gps_accuracy() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.gps_accuracy)
  return _internal_gps_accuracy();
}
inline void Position::set_gps_accuracy(::uint32_t value) {
  _internal_set_gps_accuracy(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.gps_accuracy)
}
inline ::uint32_t Position::_internal_gps_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gps_accuracy_;
}
inline void Position::_internal_set_gps_accuracy(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_accuracy_ = value;
}

// optional uint32 ground_speed = 15;
inline bool Position::has_ground_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Position::clear_ground_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ground_speed_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t Position::ground_speed() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.ground_speed)
  return _internal_ground_speed();
}
inline void Position::set_ground_speed(::uint32_t value) {
  _internal_set_ground_speed(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:meshtastic.Position.ground_speed)
}
inline ::uint32_t Position::_internal_ground_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ground_speed_;
}
inline void Position::_internal_set_ground_speed(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ground_speed_ = value;
}

// optional uint32 ground_track = 16;
inline bool Position::has_ground_track() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Position::clear_ground_track() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ground_track_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t Position::ground_track() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.ground_track)
  return _internal_ground_track();
}
inline void Position::set_ground_track(::uint32_t value) {
  _internal_set_ground_track(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:meshtastic.Position.ground_track)
}
inline ::uint32_t Position::_internal_ground_track() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ground_track_;
}
inline void Position::_internal_set_ground_track(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ground_track_ = value;
}

// uint32 fix_quality = 17;
inline void Position::clear_fix_quality() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fix_quality_ = 0u;
}
inline ::uint32_t Position::fix_quality() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.fix_quality)
  return _internal_fix_quality();
}
inline void Position::set_fix_quality(::uint32_t value) {
  _internal_set_fix_quality(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.fix_quality)
}
inline ::uint32_t Position::_internal_fix_quality() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fix_quality_;
}
inline void Position::_internal_set_fix_quality(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fix_quality_ = value;
}

// uint32 fix_type = 18;
inline void Position::clear_fix_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fix_type_ = 0u;
}
inline ::uint32_t Position::fix_type() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.fix_type)
  return _internal_fix_type();
}
inline void Position::set_fix_type(::uint32_t value) {
  _internal_set_fix_type(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.fix_type)
}
inline ::uint32_t Position::_internal_fix_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fix_type_;
}
inline void Position::_internal_set_fix_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fix_type_ = value;
}

// uint32 sats_in_view = 19;
inline void Position::clear_sats_in_view() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sats_in_view_ = 0u;
}
inline ::uint32_t Position::sats_in_view() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.sats_in_view)
  return _internal_sats_in_view();
}
inline void Position::set_sats_in_view(::uint32_t value) {
  _internal_set_sats_in_view(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.sats_in_view)
}
inline ::uint32_t Position::_internal_sats_in_view() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sats_in_view_;
}
inline void Position::_internal_set_sats_in_view(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sats_in_view_ = value;
}

// uint32 sensor_id = 20;
inline void Position::clear_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_ = 0u;
}
inline ::uint32_t Position::sensor_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.sensor_id)
  return _internal_sensor_id();
}
inline void Position::set_sensor_id(::uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.sensor_id)
}
inline ::uint32_t Position::_internal_sensor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensor_id_;
}
inline void Position::_internal_set_sensor_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_ = value;
}

// uint32 next_update = 21;
inline void Position::clear_next_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_update_ = 0u;
}
inline ::uint32_t Position::next_update() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.next_update)
  return _internal_next_update();
}
inline void Position::set_next_update(::uint32_t value) {
  _internal_set_next_update(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.next_update)
}
inline ::uint32_t Position::_internal_next_update() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_update_;
}
inline void Position::_internal_set_next_update(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_update_ = value;
}

// uint32 seq_number = 22;
inline void Position::clear_seq_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seq_number_ = 0u;
}
inline ::uint32_t Position::seq_number() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.seq_number)
  return _internal_seq_number();
}
inline void Position::set_seq_number(::uint32_t value) {
  _internal_set_seq_number(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.seq_number)
}
inline ::uint32_t Position::_internal_seq_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.seq_number_;
}
inline void Position::_internal_set_seq_number(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seq_number_ = value;
}

// uint32 precision_bits = 23;
inline void Position::clear_precision_bits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.precision_bits_ = 0u;
}
inline ::uint32_t Position::precision_bits() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.precision_bits)
  return _internal_precision_bits();
}
inline void Position::set_precision_bits(::uint32_t value) {
  _internal_set_precision_bits(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.precision_bits)
}
inline ::uint32_t Position::_internal_precision_bits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.precision_bits_;
}
inline void Position::_internal_set_precision_bits(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.precision_bits_ = value;
}

// -------------------------------------------------------------------

// User

// string id = 1;
inline void User::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& User::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.User.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.User.id)
}
inline std::string* User::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:meshtastic.User.id)
  return _s;
}
inline const std::string& User::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* User::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.User.id)
  return _impl_.id_.Release();
}
inline void User::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.User.id)
}

// string long_name = 2;
inline void User::clear_long_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.long_name_.ClearToEmpty();
}
inline const std::string& User::long_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.User.long_name)
  return _internal_long_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_long_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.long_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.User.long_name)
}
inline std::string* User::mutable_long_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_long_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.User.long_name)
  return _s;
}
inline const std::string& User::_internal_long_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.long_name_.Get();
}
inline void User::_internal_set_long_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.long_name_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_long_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.long_name_.Mutable( GetArena());
}
inline std::string* User::release_long_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.User.long_name)
  return _impl_.long_name_.Release();
}
inline void User::set_allocated_long_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.long_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.long_name_.IsDefault()) {
    _impl_.long_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.User.long_name)
}

// string short_name = 3;
inline void User::clear_short_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.short_name_.ClearToEmpty();
}
inline const std::string& User::short_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.User.short_name)
  return _internal_short_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_short_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.short_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.User.short_name)
}
inline std::string* User::mutable_short_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_short_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.User.short_name)
  return _s;
}
inline const std::string& User::_internal_short_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.short_name_.Get();
}
inline void User::_internal_set_short_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.short_name_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_short_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.short_name_.Mutable( GetArena());
}
inline std::string* User::release_short_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.User.short_name)
  return _impl_.short_name_.Release();
}
inline void User::set_allocated_short_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.short_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.short_name_.IsDefault()) {
    _impl_.short_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.User.short_name)
}

// bytes macaddr = 4 [deprecated = true];
inline void User::clear_macaddr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.macaddr_.ClearToEmpty();
}
inline const std::string& User::macaddr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.User.macaddr)
  return _internal_macaddr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_macaddr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.macaddr_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.User.macaddr)
}
inline std::string* User::mutable_macaddr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_macaddr();
  // @@protoc_insertion_point(field_mutable:meshtastic.User.macaddr)
  return _s;
}
inline const std::string& User::_internal_macaddr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.macaddr_.Get();
}
inline void User::_internal_set_macaddr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.macaddr_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_macaddr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.macaddr_.Mutable( GetArena());
}
inline std::string* User::release_macaddr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.User.macaddr)
  return _impl_.macaddr_.Release();
}
inline void User::set_allocated_macaddr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.macaddr_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.macaddr_.IsDefault()) {
    _impl_.macaddr_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.User.macaddr)
}

// .meshtastic.HardwareModel hw_model = 5;
inline void User::clear_hw_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hw_model_ = 0;
}
inline ::meshtastic::HardwareModel User::hw_model() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.hw_model)
  return _internal_hw_model();
}
inline void User::set_hw_model(::meshtastic::HardwareModel value) {
  _internal_set_hw_model(value);
  // @@protoc_insertion_point(field_set:meshtastic.User.hw_model)
}
inline ::meshtastic::HardwareModel User::_internal_hw_model() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::HardwareModel>(_impl_.hw_model_);
}
inline void User::_internal_set_hw_model(::meshtastic::HardwareModel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hw_model_ = value;
}

// bool is_licensed = 6;
inline void User::clear_is_licensed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_licensed_ = false;
}
inline bool User::is_licensed() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.is_licensed)
  return _internal_is_licensed();
}
inline void User::set_is_licensed(bool value) {
  _internal_set_is_licensed(value);
  // @@protoc_insertion_point(field_set:meshtastic.User.is_licensed)
}
inline bool User::_internal_is_licensed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_licensed_;
}
inline void User::_internal_set_is_licensed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_licensed_ = value;
}

// .meshtastic.Config.DeviceConfig.Role role = 7;
inline void User::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = 0;
}
inline ::meshtastic::Config_DeviceConfig_Role User::role() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.role)
  return _internal_role();
}
inline void User::set_role(::meshtastic::Config_DeviceConfig_Role value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:meshtastic.User.role)
}
inline ::meshtastic::Config_DeviceConfig_Role User::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_DeviceConfig_Role>(_impl_.role_);
}
inline void User::_internal_set_role(::meshtastic::Config_DeviceConfig_Role value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = value;
}

// bytes public_key = 8;
inline void User::clear_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& User::public_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.User.public_key)
  return _internal_public_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_public_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.User.public_key)
}
inline std::string* User::mutable_public_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.User.public_key)
  return _s;
}
inline const std::string& User::_internal_public_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.public_key_.Get();
}
inline void User::_internal_set_public_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.public_key_.Mutable( GetArena());
}
inline std::string* User::release_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.User.public_key)
  return _impl_.public_key_.Release();
}
inline void User::set_allocated_public_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.User.public_key)
}

// optional bool is_unmessagable = 9;
inline bool User::has_is_unmessagable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void User::clear_is_unmessagable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_unmessagable_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool User::is_unmessagable() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.is_unmessagable)
  return _internal_is_unmessagable();
}
inline void User::set_is_unmessagable(bool value) {
  _internal_set_is_unmessagable(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.User.is_unmessagable)
}
inline bool User::_internal_is_unmessagable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_unmessagable_;
}
inline void User::_internal_set_is_unmessagable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_unmessagable_ = value;
}

// -------------------------------------------------------------------

// RouteDiscovery

// repeated fixed32 route = 1;
inline int RouteDiscovery::_internal_route_size() const {
  return _internal_route().size();
}
inline int RouteDiscovery::route_size() const {
  return _internal_route_size();
}
inline void RouteDiscovery::clear_route() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.route_.Clear();
}
inline ::uint32_t RouteDiscovery::route(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.RouteDiscovery.route)
  return _internal_route().Get(index);
}
inline void RouteDiscovery::set_route(int index, ::uint32_t value) {
  _internal_mutable_route()->Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.RouteDiscovery.route)
}
inline void RouteDiscovery::add_route(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_route()->Add(value);
  // @@protoc_insertion_point(field_add:meshtastic.RouteDiscovery.route)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& RouteDiscovery::route() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.RouteDiscovery.route)
  return _internal_route();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* RouteDiscovery::mutable_route()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.RouteDiscovery.route)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_route();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
RouteDiscovery::_internal_route() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.route_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* RouteDiscovery::_internal_mutable_route() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.route_;
}

// repeated int32 snr_towards = 2;
inline int RouteDiscovery::_internal_snr_towards_size() const {
  return _internal_snr_towards().size();
}
inline int RouteDiscovery::snr_towards_size() const {
  return _internal_snr_towards_size();
}
inline void RouteDiscovery::clear_snr_towards() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snr_towards_.Clear();
}
inline ::int32_t RouteDiscovery::snr_towards(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.RouteDiscovery.snr_towards)
  return _internal_snr_towards().Get(index);
}
inline void RouteDiscovery::set_snr_towards(int index, ::int32_t value) {
  _internal_mutable_snr_towards()->Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.RouteDiscovery.snr_towards)
}
inline void RouteDiscovery::add_snr_towards(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_snr_towards()->Add(value);
  // @@protoc_insertion_point(field_add:meshtastic.RouteDiscovery.snr_towards)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& RouteDiscovery::snr_towards() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.RouteDiscovery.snr_towards)
  return _internal_snr_towards();
}
inline ::google::protobuf::RepeatedField<::int32_t>* RouteDiscovery::mutable_snr_towards()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.RouteDiscovery.snr_towards)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_snr_towards();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
RouteDiscovery::_internal_snr_towards() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snr_towards_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* RouteDiscovery::_internal_mutable_snr_towards() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.snr_towards_;
}

// repeated fixed32 route_back = 3;
inline int RouteDiscovery::_internal_route_back_size() const {
  return _internal_route_back().size();
}
inline int RouteDiscovery::route_back_size() const {
  return _internal_route_back_size();
}
inline void RouteDiscovery::clear_route_back() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.route_back_.Clear();
}
inline ::uint32_t RouteDiscovery::route_back(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.RouteDiscovery.route_back)
  return _internal_route_back().Get(index);
}
inline void RouteDiscovery::set_route_back(int index, ::uint32_t value) {
  _internal_mutable_route_back()->Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.RouteDiscovery.route_back)
}
inline void RouteDiscovery::add_route_back(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_route_back()->Add(value);
  // @@protoc_insertion_point(field_add:meshtastic.RouteDiscovery.route_back)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& RouteDiscovery::route_back() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.RouteDiscovery.route_back)
  return _internal_route_back();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* RouteDiscovery::mutable_route_back()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.RouteDiscovery.route_back)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_route_back();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
RouteDiscovery::_internal_route_back() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.route_back_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* RouteDiscovery::_internal_mutable_route_back() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.route_back_;
}

// repeated int32 snr_back = 4;
inline int RouteDiscovery::_internal_snr_back_size() const {
  return _internal_snr_back().size();
}
inline int RouteDiscovery::snr_back_size() const {
  return _internal_snr_back_size();
}
inline void RouteDiscovery::clear_snr_back() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snr_back_.Clear();
}
inline ::int32_t RouteDiscovery::snr_back(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.RouteDiscovery.snr_back)
  return _internal_snr_back().Get(index);
}
inline void RouteDiscovery::set_snr_back(int index, ::int32_t value) {
  _internal_mutable_snr_back()->Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.RouteDiscovery.snr_back)
}
inline void RouteDiscovery::add_snr_back(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_snr_back()->Add(value);
  // @@protoc_insertion_point(field_add:meshtastic.RouteDiscovery.snr_back)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& RouteDiscovery::snr_back() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.RouteDiscovery.snr_back)
  return _internal_snr_back();
}
inline ::google::protobuf::RepeatedField<::int32_t>* RouteDiscovery::mutable_snr_back()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.RouteDiscovery.snr_back)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_snr_back();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
RouteDiscovery::_internal_snr_back() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snr_back_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* RouteDiscovery::_internal_mutable_snr_back() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.snr_back_;
}

// -------------------------------------------------------------------

// Routing

// .meshtastic.RouteDiscovery route_request = 1;
inline bool Routing::has_route_request() const {
  return variant_case() == kRouteRequest;
}
inline bool Routing::_internal_has_route_request() const {
  return variant_case() == kRouteRequest;
}
inline void Routing::set_has_route_request() {
  _impl_._oneof_case_[0] = kRouteRequest;
}
inline void Routing::clear_route_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kRouteRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.route_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.route_request_);
    }
    clear_has_variant();
  }
}
inline ::meshtastic::RouteDiscovery* Routing::release_route_request() {
  // @@protoc_insertion_point(field_release:meshtastic.Routing.route_request)
  if (variant_case() == kRouteRequest) {
    clear_has_variant();
    auto* temp = _impl_.variant_.route_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.route_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::RouteDiscovery& Routing::_internal_route_request() const {
  return variant_case() == kRouteRequest ? *_impl_.variant_.route_request_ : reinterpret_cast<::meshtastic::RouteDiscovery&>(::meshtastic::_RouteDiscovery_default_instance_);
}
inline const ::meshtastic::RouteDiscovery& Routing::route_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Routing.route_request)
  return _internal_route_request();
}
inline ::meshtastic::RouteDiscovery* Routing::unsafe_arena_release_route_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Routing.route_request)
  if (variant_case() == kRouteRequest) {
    clear_has_variant();
    auto* temp = _impl_.variant_.route_request_;
    _impl_.variant_.route_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Routing::unsafe_arena_set_allocated_route_request(::meshtastic::RouteDiscovery* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_route_request();
    _impl_.variant_.route_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Routing.route_request)
}
inline ::meshtastic::RouteDiscovery* Routing::_internal_mutable_route_request() {
  if (variant_case() != kRouteRequest) {
    clear_variant();
    set_has_route_request();
    _impl_.variant_.route_request_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::RouteDiscovery>(GetArena());
  }
  return _impl_.variant_.route_request_;
}
inline ::meshtastic::RouteDiscovery* Routing::mutable_route_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::RouteDiscovery* _msg = _internal_mutable_route_request();
  // @@protoc_insertion_point(field_mutable:meshtastic.Routing.route_request)
  return _msg;
}

// .meshtastic.RouteDiscovery route_reply = 2;
inline bool Routing::has_route_reply() const {
  return variant_case() == kRouteReply;
}
inline bool Routing::_internal_has_route_reply() const {
  return variant_case() == kRouteReply;
}
inline void Routing::set_has_route_reply() {
  _impl_._oneof_case_[0] = kRouteReply;
}
inline void Routing::clear_route_reply() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kRouteReply) {
    if (GetArena() == nullptr) {
      delete _impl_.variant_.route_reply_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.route_reply_);
    }
    clear_has_variant();
  }
}
inline ::meshtastic::RouteDiscovery* Routing::release_route_reply() {
  // @@protoc_insertion_point(field_release:meshtastic.Routing.route_reply)
  if (variant_case() == kRouteReply) {
    clear_has_variant();
    auto* temp = _impl_.variant_.route_reply_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.route_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::RouteDiscovery& Routing::_internal_route_reply() const {
  return variant_case() == kRouteReply ? *_impl_.variant_.route_reply_ : reinterpret_cast<::meshtastic::RouteDiscovery&>(::meshtastic::_RouteDiscovery_default_instance_);
}
inline const ::meshtastic::RouteDiscovery& Routing::route_reply() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Routing.route_reply)
  return _internal_route_reply();
}
inline ::meshtastic::RouteDiscovery* Routing::unsafe_arena_release_route_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Routing.route_reply)
  if (variant_case() == kRouteReply) {
    clear_has_variant();
    auto* temp = _impl_.variant_.route_reply_;
    _impl_.variant_.route_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Routing::unsafe_arena_set_allocated_route_reply(::meshtastic::RouteDiscovery* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_variant();
  if (value) {
    set_has_route_reply();
    _impl_.variant_.route_reply_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Routing.route_reply)
}
inline ::meshtastic::RouteDiscovery* Routing::_internal_mutable_route_reply() {
  if (variant_case() != kRouteReply) {
    clear_variant();
    set_has_route_reply();
    _impl_.variant_.route_reply_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::RouteDiscovery>(GetArena());
  }
  return _impl_.variant_.route_reply_;
}
inline ::meshtastic::RouteDiscovery* Routing::mutable_route_reply() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::RouteDiscovery* _msg = _internal_mutable_route_reply();
  // @@protoc_insertion_point(field_mutable:meshtastic.Routing.route_reply)
  return _msg;
}

// .meshtastic.Routing.Error error_reason = 3;
inline bool Routing::has_error_reason() const {
  return variant_case() == kErrorReason;
}
inline void Routing::set_has_error_reason() {
  _impl_._oneof_case_[0] = kErrorReason;
}
inline void Routing::clear_error_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (variant_case() == kErrorReason) {
    _impl_.variant_.error_reason_ = 0;
    clear_has_variant();
  }
}
inline ::meshtastic::Routing_Error Routing::error_reason() const {
  // @@protoc_insertion_point(field_get:meshtastic.Routing.error_reason)
  return _internal_error_reason();
}
inline void Routing::set_error_reason(::meshtastic::Routing_Error value) {
  if (variant_case() != kErrorReason) {
    clear_variant();
    set_has_error_reason();
  }
  _impl_.variant_.error_reason_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.Routing.error_reason)
}
inline ::meshtastic::Routing_Error Routing::_internal_error_reason() const {
  if (variant_case() == kErrorReason) {
    return static_cast<::meshtastic::Routing_Error>(_impl_.variant_.error_reason_);
  }
  return static_cast<::meshtastic::Routing_Error>(0);
}

inline bool Routing::has_variant() const {
  return variant_case() != VARIANT_NOT_SET;
}
inline void Routing::clear_has_variant() {
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}
inline Routing::VariantCase Routing::variant_case() const {
  return Routing::VariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Data

// .meshtastic.PortNum portnum = 1;
inline void Data::clear_portnum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.portnum_ = 0;
}
inline ::meshtastic::PortNum Data::portnum() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.portnum)
  return _internal_portnum();
}
inline void Data::set_portnum(::meshtastic::PortNum value) {
  _internal_set_portnum(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.portnum)
}
inline ::meshtastic::PortNum Data::_internal_portnum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::PortNum>(_impl_.portnum_);
}
inline void Data::_internal_set_portnum(::meshtastic::PortNum value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.portnum_ = value;
}

// bytes payload = 2;
inline void Data::clear_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& Data::payload() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Data.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Data::set_payload(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.Data.payload)
}
inline std::string* Data::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:meshtastic.Data.payload)
  return _s;
}
inline const std::string& Data::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.Get();
}
inline void Data::_internal_set_payload(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.Set(value, GetArena());
}
inline std::string* Data::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_.Mutable( GetArena());
}
inline std::string* Data::release_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Data.payload)
  return _impl_.payload_.Release();
}
inline void Data::set_allocated_payload(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Data.payload)
}

// bool want_response = 3;
inline void Data::clear_want_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.want_response_ = false;
}
inline bool Data::want_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.want_response)
  return _internal_want_response();
}
inline void Data::set_want_response(bool value) {
  _internal_set_want_response(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.want_response)
}
inline bool Data::_internal_want_response() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.want_response_;
}
inline void Data::_internal_set_want_response(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.want_response_ = value;
}

// fixed32 dest = 4;
inline void Data::clear_dest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dest_ = 0u;
}
inline ::uint32_t Data::dest() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.dest)
  return _internal_dest();
}
inline void Data::set_dest(::uint32_t value) {
  _internal_set_dest(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.dest)
}
inline ::uint32_t Data::_internal_dest() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dest_;
}
inline void Data::_internal_set_dest(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dest_ = value;
}

// fixed32 source = 5;
inline void Data::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = 0u;
}
inline ::uint32_t Data::source() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.source)
  return _internal_source();
}
inline void Data::set_source(::uint32_t value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.source)
}
inline ::uint32_t Data::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_;
}
inline void Data::_internal_set_source(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = value;
}

// fixed32 request_id = 6;
inline void Data::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = 0u;
}
inline ::uint32_t Data::request_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.request_id)
  return _internal_request_id();
}
inline void Data::set_request_id(::uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.request_id)
}
inline ::uint32_t Data::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_;
}
inline void Data::_internal_set_request_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = value;
}

// fixed32 reply_id = 7;
inline void Data::clear_reply_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reply_id_ = 0u;
}
inline ::uint32_t Data::reply_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.reply_id)
  return _internal_reply_id();
}
inline void Data::set_reply_id(::uint32_t value) {
  _internal_set_reply_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.reply_id)
}
inline ::uint32_t Data::_internal_reply_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reply_id_;
}
inline void Data::_internal_set_reply_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reply_id_ = value;
}

// fixed32 emoji = 8;
inline void Data::clear_emoji() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emoji_ = 0u;
}
inline ::uint32_t Data::emoji() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.emoji)
  return _internal_emoji();
}
inline void Data::set_emoji(::uint32_t value) {
  _internal_set_emoji(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.emoji)
}
inline ::uint32_t Data::_internal_emoji() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.emoji_;
}
inline void Data::_internal_set_emoji(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emoji_ = value;
}

// optional uint32 bitfield = 9;
inline bool Data::has_bitfield() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Data::clear_bitfield() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bitfield_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Data::bitfield() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.bitfield)
  return _internal_bitfield();
}
inline void Data::set_bitfield(::uint32_t value) {
  _internal_set_bitfield(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.Data.bitfield)
}
inline ::uint32_t Data::_internal_bitfield() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bitfield_;
}
inline void Data::_internal_set_bitfield(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bitfield_ = value;
}

// -------------------------------------------------------------------

// KeyVerification

// uint64 nonce = 1;
inline void KeyVerification::clear_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t KeyVerification::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerification.nonce)
  return _internal_nonce();
}
inline void KeyVerification::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerification.nonce)
}
inline ::uint64_t KeyVerification::_internal_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nonce_;
}
inline void KeyVerification::_internal_set_nonce(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = value;
}

// bytes hash1 = 2;
inline void KeyVerification::clear_hash1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash1_.ClearToEmpty();
}
inline const std::string& KeyVerification::hash1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerification.hash1)
  return _internal_hash1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyVerification::set_hash1(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash1_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerification.hash1)
}
inline std::string* KeyVerification::mutable_hash1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash1();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerification.hash1)
  return _s;
}
inline const std::string& KeyVerification::_internal_hash1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash1_.Get();
}
inline void KeyVerification::_internal_set_hash1(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash1_.Set(value, GetArena());
}
inline std::string* KeyVerification::_internal_mutable_hash1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hash1_.Mutable( GetArena());
}
inline std::string* KeyVerification::release_hash1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerification.hash1)
  return _impl_.hash1_.Release();
}
inline void KeyVerification::set_allocated_hash1(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash1_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash1_.IsDefault()) {
    _impl_.hash1_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerification.hash1)
}

// bytes hash2 = 3;
inline void KeyVerification::clear_hash2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash2_.ClearToEmpty();
}
inline const std::string& KeyVerification::hash2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerification.hash2)
  return _internal_hash2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyVerification::set_hash2(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash2_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerification.hash2)
}
inline std::string* KeyVerification::mutable_hash2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash2();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerification.hash2)
  return _s;
}
inline const std::string& KeyVerification::_internal_hash2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash2_.Get();
}
inline void KeyVerification::_internal_set_hash2(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash2_.Set(value, GetArena());
}
inline std::string* KeyVerification::_internal_mutable_hash2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hash2_.Mutable( GetArena());
}
inline std::string* KeyVerification::release_hash2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerification.hash2)
  return _impl_.hash2_.Release();
}
inline void KeyVerification::set_allocated_hash2(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash2_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash2_.IsDefault()) {
    _impl_.hash2_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerification.hash2)
}

// -------------------------------------------------------------------

// Waypoint

// uint32 id = 1;
inline void Waypoint::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t Waypoint::id() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.id)
  return _internal_id();
}
inline void Waypoint::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.id)
}
inline ::uint32_t Waypoint::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Waypoint::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// optional sfixed32 latitude_i = 2;
inline bool Waypoint::has_latitude_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Waypoint::clear_latitude_i() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Waypoint::latitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.latitude_i)
  return _internal_latitude_i();
}
inline void Waypoint::set_latitude_i(::int32_t value) {
  _internal_set_latitude_i(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.latitude_i)
}
inline ::int32_t Waypoint::_internal_latitude_i() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latitude_i_;
}
inline void Waypoint::_internal_set_latitude_i(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_i_ = value;
}

// optional sfixed32 longitude_i = 3;
inline bool Waypoint::has_longitude_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Waypoint::clear_longitude_i() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Waypoint::longitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.longitude_i)
  return _internal_longitude_i();
}
inline void Waypoint::set_longitude_i(::int32_t value) {
  _internal_set_longitude_i(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.longitude_i)
}
inline ::int32_t Waypoint::_internal_longitude_i() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.longitude_i_;
}
inline void Waypoint::_internal_set_longitude_i(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_i_ = value;
}

// uint32 expire = 4;
inline void Waypoint::clear_expire() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expire_ = 0u;
}
inline ::uint32_t Waypoint::expire() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.expire)
  return _internal_expire();
}
inline void Waypoint::set_expire(::uint32_t value) {
  _internal_set_expire(value);
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.expire)
}
inline ::uint32_t Waypoint::_internal_expire() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expire_;
}
inline void Waypoint::_internal_set_expire(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expire_ = value;
}

// uint32 locked_to = 5;
inline void Waypoint::clear_locked_to() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locked_to_ = 0u;
}
inline ::uint32_t Waypoint::locked_to() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.locked_to)
  return _internal_locked_to();
}
inline void Waypoint::set_locked_to(::uint32_t value) {
  _internal_set_locked_to(value);
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.locked_to)
}
inline ::uint32_t Waypoint::_internal_locked_to() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.locked_to_;
}
inline void Waypoint::_internal_set_locked_to(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locked_to_ = value;
}

// string name = 6;
inline void Waypoint::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Waypoint::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Waypoint::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.name)
}
inline std::string* Waypoint::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.Waypoint.name)
  return _s;
}
inline const std::string& Waypoint::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Waypoint::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Waypoint::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Waypoint::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Waypoint.name)
  return _impl_.name_.Release();
}
inline void Waypoint::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Waypoint.name)
}

// string description = 7;
inline void Waypoint::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Waypoint::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Waypoint::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.description)
}
inline std::string* Waypoint::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:meshtastic.Waypoint.description)
  return _s;
}
inline const std::string& Waypoint::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void Waypoint::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* Waypoint::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* Waypoint::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Waypoint.description)
  return _impl_.description_.Release();
}
inline void Waypoint::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Waypoint.description)
}

// fixed32 icon = 8;
inline void Waypoint::clear_icon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.icon_ = 0u;
}
inline ::uint32_t Waypoint::icon() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.icon)
  return _internal_icon();
}
inline void Waypoint::set_icon(::uint32_t value) {
  _internal_set_icon(value);
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.icon)
}
inline ::uint32_t Waypoint::_internal_icon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.icon_;
}
inline void Waypoint::_internal_set_icon(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.icon_ = value;
}

// -------------------------------------------------------------------

// MqttClientProxyMessage

// string topic = 1;
inline void MqttClientProxyMessage::clear_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& MqttClientProxyMessage::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.MqttClientProxyMessage.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MqttClientProxyMessage::set_topic(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.MqttClientProxyMessage.topic)
}
inline std::string* MqttClientProxyMessage::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:meshtastic.MqttClientProxyMessage.topic)
  return _s;
}
inline const std::string& MqttClientProxyMessage::_internal_topic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.topic_.Get();
}
inline void MqttClientProxyMessage::_internal_set_topic(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* MqttClientProxyMessage::_internal_mutable_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* MqttClientProxyMessage::release_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.MqttClientProxyMessage.topic)
  return _impl_.topic_.Release();
}
inline void MqttClientProxyMessage::set_allocated_topic(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MqttClientProxyMessage.topic)
}

// bytes data = 2;
inline bool MqttClientProxyMessage::has_data() const {
  return payload_variant_case() == kData;
}
inline void MqttClientProxyMessage::set_has_data() {
  _impl_._oneof_case_[0] = kData;
}
inline void MqttClientProxyMessage::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kData) {
    _impl_.payload_variant_.data_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& MqttClientProxyMessage::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.MqttClientProxyMessage.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MqttClientProxyMessage::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kData) {
    clear_payload_variant();

    set_has_data();
    _impl_.payload_variant_.data_.InitDefault();
  }
  _impl_.payload_variant_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.MqttClientProxyMessage.data)
}
inline std::string* MqttClientProxyMessage::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:meshtastic.MqttClientProxyMessage.data)
  return _s;
}
inline const std::string& MqttClientProxyMessage::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (payload_variant_case() != kData) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.payload_variant_.data_.Get();
}
inline void MqttClientProxyMessage::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kData) {
    clear_payload_variant();

    set_has_data();
    _impl_.payload_variant_.data_.InitDefault();
  }
  _impl_.payload_variant_.data_.Set(value, GetArena());
}
inline std::string* MqttClientProxyMessage::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kData) {
    clear_payload_variant();

    set_has_data();
    _impl_.payload_variant_.data_.InitDefault();
  }
  return _impl_.payload_variant_.data_.Mutable( GetArena());
}
inline std::string* MqttClientProxyMessage::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.MqttClientProxyMessage.data)
  if (payload_variant_case() != kData) {
    return nullptr;
  }
  clear_has_payload_variant();
  return _impl_.payload_variant_.data_.Release();
}
inline void MqttClientProxyMessage::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (value != nullptr) {
    set_has_data();
    _impl_.payload_variant_.data_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MqttClientProxyMessage.data)
}

// string text = 3;
inline bool MqttClientProxyMessage::has_text() const {
  return payload_variant_case() == kText;
}
inline void MqttClientProxyMessage::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void MqttClientProxyMessage::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kText) {
    _impl_.payload_variant_.text_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& MqttClientProxyMessage::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.MqttClientProxyMessage.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MqttClientProxyMessage::set_text(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kText) {
    clear_payload_variant();

    set_has_text();
    _impl_.payload_variant_.text_.InitDefault();
  }
  _impl_.payload_variant_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.MqttClientProxyMessage.text)
}
inline std::string* MqttClientProxyMessage::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:meshtastic.MqttClientProxyMessage.text)
  return _s;
}
inline const std::string& MqttClientProxyMessage::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (payload_variant_case() != kText) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.payload_variant_.text_.Get();
}
inline void MqttClientProxyMessage::_internal_set_text(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kText) {
    clear_payload_variant();

    set_has_text();
    _impl_.payload_variant_.text_.InitDefault();
  }
  _impl_.payload_variant_.text_.Set(value, GetArena());
}
inline std::string* MqttClientProxyMessage::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kText) {
    clear_payload_variant();

    set_has_text();
    _impl_.payload_variant_.text_.InitDefault();
  }
  return _impl_.payload_variant_.text_.Mutable( GetArena());
}
inline std::string* MqttClientProxyMessage::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.MqttClientProxyMessage.text)
  if (payload_variant_case() != kText) {
    return nullptr;
  }
  clear_has_payload_variant();
  return _impl_.payload_variant_.text_.Release();
}
inline void MqttClientProxyMessage::set_allocated_text(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (value != nullptr) {
    set_has_text();
    _impl_.payload_variant_.text_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MqttClientProxyMessage.text)
}

// bool retained = 4;
inline void MqttClientProxyMessage::clear_retained() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retained_ = false;
}
inline bool MqttClientProxyMessage::retained() const {
  // @@protoc_insertion_point(field_get:meshtastic.MqttClientProxyMessage.retained)
  return _internal_retained();
}
inline void MqttClientProxyMessage::set_retained(bool value) {
  _internal_set_retained(value);
  // @@protoc_insertion_point(field_set:meshtastic.MqttClientProxyMessage.retained)
}
inline bool MqttClientProxyMessage::_internal_retained() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.retained_;
}
inline void MqttClientProxyMessage::_internal_set_retained(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retained_ = value;
}

inline bool MqttClientProxyMessage::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void MqttClientProxyMessage::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline MqttClientProxyMessage::PayloadVariantCase MqttClientProxyMessage::payload_variant_case() const {
  return MqttClientProxyMessage::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MeshPacket

// fixed32 from = 1;
inline void MeshPacket::clear_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_ = 0u;
}
inline ::uint32_t MeshPacket::from() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.from)
  return _internal_from();
}
inline void MeshPacket::set_from(::uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.from)
}
inline ::uint32_t MeshPacket::_internal_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_;
}
inline void MeshPacket::_internal_set_from(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_ = value;
}

// fixed32 to = 2;
inline void MeshPacket::clear_to() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_ = 0u;
}
inline ::uint32_t MeshPacket::to() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.to)
  return _internal_to();
}
inline void MeshPacket::set_to(::uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.to)
}
inline ::uint32_t MeshPacket::_internal_to() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_;
}
inline void MeshPacket::_internal_set_to(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_ = value;
}

// uint32 channel = 3;
inline void MeshPacket::clear_channel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_ = 0u;
}
inline ::uint32_t MeshPacket::channel() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.channel)
  return _internal_channel();
}
inline void MeshPacket::set_channel(::uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.channel)
}
inline ::uint32_t MeshPacket::_internal_channel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_;
}
inline void MeshPacket::_internal_set_channel(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_ = value;
}

// .meshtastic.Data decoded = 4;
inline bool MeshPacket::has_decoded() const {
  return payload_variant_case() == kDecoded;
}
inline bool MeshPacket::_internal_has_decoded() const {
  return payload_variant_case() == kDecoded;
}
inline void MeshPacket::set_has_decoded() {
  _impl_._oneof_case_[0] = kDecoded;
}
inline void MeshPacket::clear_decoded() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kDecoded) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.decoded_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.decoded_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Data* MeshPacket::release_decoded() {
  // @@protoc_insertion_point(field_release:meshtastic.MeshPacket.decoded)
  if (payload_variant_case() == kDecoded) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.decoded_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.decoded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Data& MeshPacket::_internal_decoded() const {
  return payload_variant_case() == kDecoded ? *_impl_.payload_variant_.decoded_ : reinterpret_cast<::meshtastic::Data&>(::meshtastic::_Data_default_instance_);
}
inline const ::meshtastic::Data& MeshPacket::decoded() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.decoded)
  return _internal_decoded();
}
inline ::meshtastic::Data* MeshPacket::unsafe_arena_release_decoded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.MeshPacket.decoded)
  if (payload_variant_case() == kDecoded) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.decoded_;
    _impl_.payload_variant_.decoded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MeshPacket::unsafe_arena_set_allocated_decoded(::meshtastic::Data* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_decoded();
    _impl_.payload_variant_.decoded_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.MeshPacket.decoded)
}
inline ::meshtastic::Data* MeshPacket::_internal_mutable_decoded() {
  if (payload_variant_case() != kDecoded) {
    clear_payload_variant();
    set_has_decoded();
    _impl_.payload_variant_.decoded_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Data>(GetArena());
  }
  return _impl_.payload_variant_.decoded_;
}
inline ::meshtastic::Data* MeshPacket::mutable_decoded() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Data* _msg = _internal_mutable_decoded();
  // @@protoc_insertion_point(field_mutable:meshtastic.MeshPacket.decoded)
  return _msg;
}

// bytes encrypted = 5;
inline bool MeshPacket::has_encrypted() const {
  return payload_variant_case() == kEncrypted;
}
inline void MeshPacket::set_has_encrypted() {
  _impl_._oneof_case_[0] = kEncrypted;
}
inline void MeshPacket::clear_encrypted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kEncrypted) {
    _impl_.payload_variant_.encrypted_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& MeshPacket::encrypted() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.encrypted)
  return _internal_encrypted();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshPacket::set_encrypted(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kEncrypted) {
    clear_payload_variant();

    set_has_encrypted();
    _impl_.payload_variant_.encrypted_.InitDefault();
  }
  _impl_.payload_variant_.encrypted_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.encrypted)
}
inline std::string* MeshPacket::mutable_encrypted() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_encrypted();
  // @@protoc_insertion_point(field_mutable:meshtastic.MeshPacket.encrypted)
  return _s;
}
inline const std::string& MeshPacket::_internal_encrypted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (payload_variant_case() != kEncrypted) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.payload_variant_.encrypted_.Get();
}
inline void MeshPacket::_internal_set_encrypted(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kEncrypted) {
    clear_payload_variant();

    set_has_encrypted();
    _impl_.payload_variant_.encrypted_.InitDefault();
  }
  _impl_.payload_variant_.encrypted_.Set(value, GetArena());
}
inline std::string* MeshPacket::_internal_mutable_encrypted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() != kEncrypted) {
    clear_payload_variant();

    set_has_encrypted();
    _impl_.payload_variant_.encrypted_.InitDefault();
  }
  return _impl_.payload_variant_.encrypted_.Mutable( GetArena());
}
inline std::string* MeshPacket::release_encrypted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.MeshPacket.encrypted)
  if (payload_variant_case() != kEncrypted) {
    return nullptr;
  }
  clear_has_payload_variant();
  return _impl_.payload_variant_.encrypted_.Release();
}
inline void MeshPacket::set_allocated_encrypted(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (value != nullptr) {
    set_has_encrypted();
    _impl_.payload_variant_.encrypted_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MeshPacket.encrypted)
}

// fixed32 id = 6;
inline void MeshPacket::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t MeshPacket::id() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.id)
  return _internal_id();
}
inline void MeshPacket::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.id)
}
inline ::uint32_t MeshPacket::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void MeshPacket::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// fixed32 rx_time = 7;
inline void MeshPacket::clear_rx_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rx_time_ = 0u;
}
inline ::uint32_t MeshPacket::rx_time() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.rx_time)
  return _internal_rx_time();
}
inline void MeshPacket::set_rx_time(::uint32_t value) {
  _internal_set_rx_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.rx_time)
}
inline ::uint32_t MeshPacket::_internal_rx_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rx_time_;
}
inline void MeshPacket::_internal_set_rx_time(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rx_time_ = value;
}

// float rx_snr = 8;
inline void MeshPacket::clear_rx_snr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rx_snr_ = 0;
}
inline float MeshPacket::rx_snr() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.rx_snr)
  return _internal_rx_snr();
}
inline void MeshPacket::set_rx_snr(float value) {
  _internal_set_rx_snr(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.rx_snr)
}
inline float MeshPacket::_internal_rx_snr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rx_snr_;
}
inline void MeshPacket::_internal_set_rx_snr(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rx_snr_ = value;
}

// uint32 hop_limit = 9;
inline void MeshPacket::clear_hop_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_limit_ = 0u;
}
inline ::uint32_t MeshPacket::hop_limit() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.hop_limit)
  return _internal_hop_limit();
}
inline void MeshPacket::set_hop_limit(::uint32_t value) {
  _internal_set_hop_limit(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.hop_limit)
}
inline ::uint32_t MeshPacket::_internal_hop_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hop_limit_;
}
inline void MeshPacket::_internal_set_hop_limit(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_limit_ = value;
}

// bool want_ack = 10;
inline void MeshPacket::clear_want_ack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.want_ack_ = false;
}
inline bool MeshPacket::want_ack() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.want_ack)
  return _internal_want_ack();
}
inline void MeshPacket::set_want_ack(bool value) {
  _internal_set_want_ack(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.want_ack)
}
inline bool MeshPacket::_internal_want_ack() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.want_ack_;
}
inline void MeshPacket::_internal_set_want_ack(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.want_ack_ = value;
}

// .meshtastic.MeshPacket.Priority priority = 11;
inline void MeshPacket::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::meshtastic::MeshPacket_Priority MeshPacket::priority() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.priority)
  return _internal_priority();
}
inline void MeshPacket::set_priority(::meshtastic::MeshPacket_Priority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.priority)
}
inline ::meshtastic::MeshPacket_Priority MeshPacket::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::MeshPacket_Priority>(_impl_.priority_);
}
inline void MeshPacket::_internal_set_priority(::meshtastic::MeshPacket_Priority value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// int32 rx_rssi = 12;
inline void MeshPacket::clear_rx_rssi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rx_rssi_ = 0;
}
inline ::int32_t MeshPacket::rx_rssi() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.rx_rssi)
  return _internal_rx_rssi();
}
inline void MeshPacket::set_rx_rssi(::int32_t value) {
  _internal_set_rx_rssi(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.rx_rssi)
}
inline ::int32_t MeshPacket::_internal_rx_rssi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rx_rssi_;
}
inline void MeshPacket::_internal_set_rx_rssi(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rx_rssi_ = value;
}

// .meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
inline void MeshPacket::clear_delayed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delayed_ = 0;
}
inline ::meshtastic::MeshPacket_Delayed MeshPacket::delayed() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.delayed)
  return _internal_delayed();
}
inline void MeshPacket::set_delayed(::meshtastic::MeshPacket_Delayed value) {
  _internal_set_delayed(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.delayed)
}
inline ::meshtastic::MeshPacket_Delayed MeshPacket::_internal_delayed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::MeshPacket_Delayed>(_impl_.delayed_);
}
inline void MeshPacket::_internal_set_delayed(::meshtastic::MeshPacket_Delayed value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delayed_ = value;
}

// bool via_mqtt = 14;
inline void MeshPacket::clear_via_mqtt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.via_mqtt_ = false;
}
inline bool MeshPacket::via_mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.via_mqtt)
  return _internal_via_mqtt();
}
inline void MeshPacket::set_via_mqtt(bool value) {
  _internal_set_via_mqtt(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.via_mqtt)
}
inline bool MeshPacket::_internal_via_mqtt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.via_mqtt_;
}
inline void MeshPacket::_internal_set_via_mqtt(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.via_mqtt_ = value;
}

// uint32 hop_start = 15;
inline void MeshPacket::clear_hop_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_start_ = 0u;
}
inline ::uint32_t MeshPacket::hop_start() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.hop_start)
  return _internal_hop_start();
}
inline void MeshPacket::set_hop_start(::uint32_t value) {
  _internal_set_hop_start(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.hop_start)
}
inline ::uint32_t MeshPacket::_internal_hop_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hop_start_;
}
inline void MeshPacket::_internal_set_hop_start(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_start_ = value;
}

// bytes public_key = 16;
inline void MeshPacket::clear_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& MeshPacket::public_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.public_key)
  return _internal_public_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshPacket::set_public_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.public_key)
}
inline std::string* MeshPacket::mutable_public_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.MeshPacket.public_key)
  return _s;
}
inline const std::string& MeshPacket::_internal_public_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.public_key_.Get();
}
inline void MeshPacket::_internal_set_public_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.Set(value, GetArena());
}
inline std::string* MeshPacket::_internal_mutable_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.public_key_.Mutable( GetArena());
}
inline std::string* MeshPacket::release_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.MeshPacket.public_key)
  return _impl_.public_key_.Release();
}
inline void MeshPacket::set_allocated_public_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MeshPacket.public_key)
}

// bool pki_encrypted = 17;
inline void MeshPacket::clear_pki_encrypted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pki_encrypted_ = false;
}
inline bool MeshPacket::pki_encrypted() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.pki_encrypted)
  return _internal_pki_encrypted();
}
inline void MeshPacket::set_pki_encrypted(bool value) {
  _internal_set_pki_encrypted(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.pki_encrypted)
}
inline bool MeshPacket::_internal_pki_encrypted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pki_encrypted_;
}
inline void MeshPacket::_internal_set_pki_encrypted(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pki_encrypted_ = value;
}

// uint32 next_hop = 18;
inline void MeshPacket::clear_next_hop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_ = 0u;
}
inline ::uint32_t MeshPacket::next_hop() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.next_hop)
  return _internal_next_hop();
}
inline void MeshPacket::set_next_hop(::uint32_t value) {
  _internal_set_next_hop(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.next_hop)
}
inline ::uint32_t MeshPacket::_internal_next_hop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_hop_;
}
inline void MeshPacket::_internal_set_next_hop(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_ = value;
}

// uint32 relay_node = 19;
inline void MeshPacket::clear_relay_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.relay_node_ = 0u;
}
inline ::uint32_t MeshPacket::relay_node() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.relay_node)
  return _internal_relay_node();
}
inline void MeshPacket::set_relay_node(::uint32_t value) {
  _internal_set_relay_node(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.relay_node)
}
inline ::uint32_t MeshPacket::_internal_relay_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.relay_node_;
}
inline void MeshPacket::_internal_set_relay_node(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.relay_node_ = value;
}

// uint32 tx_after = 20;
inline void MeshPacket::clear_tx_after() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_after_ = 0u;
}
inline ::uint32_t MeshPacket::tx_after() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.tx_after)
  return _internal_tx_after();
}
inline void MeshPacket::set_tx_after(::uint32_t value) {
  _internal_set_tx_after(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.tx_after)
}
inline ::uint32_t MeshPacket::_internal_tx_after() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tx_after_;
}
inline void MeshPacket::_internal_set_tx_after(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_after_ = value;
}

// .meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;
inline void MeshPacket::clear_transport_mechanism() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transport_mechanism_ = 0;
}
inline ::meshtastic::MeshPacket_TransportMechanism MeshPacket::transport_mechanism() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.transport_mechanism)
  return _internal_transport_mechanism();
}
inline void MeshPacket::set_transport_mechanism(::meshtastic::MeshPacket_TransportMechanism value) {
  _internal_set_transport_mechanism(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.transport_mechanism)
}
inline ::meshtastic::MeshPacket_TransportMechanism MeshPacket::_internal_transport_mechanism() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::MeshPacket_TransportMechanism>(_impl_.transport_mechanism_);
}
inline void MeshPacket::_internal_set_transport_mechanism(::meshtastic::MeshPacket_TransportMechanism value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transport_mechanism_ = value;
}

inline bool MeshPacket::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void MeshPacket::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline MeshPacket::PayloadVariantCase MeshPacket::payload_variant_case() const {
  return MeshPacket::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NodeInfo

// uint32 num = 1;
inline void NodeInfo::clear_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_ = 0u;
}
inline ::uint32_t NodeInfo::num() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.num)
  return _internal_num();
}
inline void NodeInfo::set_num(::uint32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.num)
}
inline ::uint32_t NodeInfo::_internal_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_;
}
inline void NodeInfo::_internal_set_num(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_ = value;
}

// .meshtastic.User user = 2;
inline bool NodeInfo::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void NodeInfo::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::meshtastic::User& NodeInfo::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::User&>(::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& NodeInfo::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.user)
  return _internal_user();
}
inline void NodeInfo::unsafe_arena_set_allocated_user(::meshtastic::User* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::meshtastic::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfo.user)
}
inline ::meshtastic::User* NodeInfo::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::meshtastic::User* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::User* NodeInfo::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfo.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::meshtastic::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::meshtastic::User* NodeInfo::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::User>(GetArena());
    _impl_.user_ = reinterpret_cast<::meshtastic::User*>(p);
  }
  return _impl_.user_;
}
inline ::meshtastic::User* NodeInfo::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::meshtastic::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfo.user)
  return _msg;
}
inline void NodeInfo::set_allocated_user(::meshtastic::User* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::meshtastic::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfo.user)
}

// .meshtastic.Position position = 3;
inline bool NodeInfo::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void NodeInfo::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::meshtastic::Position& NodeInfo::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Position&>(::meshtastic::_Position_default_instance_);
}
inline const ::meshtastic::Position& NodeInfo::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.position)
  return _internal_position();
}
inline void NodeInfo::unsafe_arena_set_allocated_position(::meshtastic::Position* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::meshtastic::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfo.position)
}
inline ::meshtastic::Position* NodeInfo::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::meshtastic::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::Position* NodeInfo::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfo.position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::meshtastic::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::meshtastic::Position* NodeInfo::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::meshtastic::Position*>(p);
  }
  return _impl_.position_;
}
inline ::meshtastic::Position* NodeInfo::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::meshtastic::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfo.position)
  return _msg;
}
inline void NodeInfo::set_allocated_position(::meshtastic::Position* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_ = reinterpret_cast<::meshtastic::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfo.position)
}

// float snr = 4;
inline void NodeInfo::clear_snr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snr_ = 0;
}
inline float NodeInfo::snr() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.snr)
  return _internal_snr();
}
inline void NodeInfo::set_snr(float value) {
  _internal_set_snr(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.snr)
}
inline float NodeInfo::_internal_snr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snr_;
}
inline void NodeInfo::_internal_set_snr(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snr_ = value;
}

// fixed32 last_heard = 5;
inline void NodeInfo::clear_last_heard() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_heard_ = 0u;
}
inline ::uint32_t NodeInfo::last_heard() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.last_heard)
  return _internal_last_heard();
}
inline void NodeInfo::set_last_heard(::uint32_t value) {
  _internal_set_last_heard(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.last_heard)
}
inline ::uint32_t NodeInfo::_internal_last_heard() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_heard_;
}
inline void NodeInfo::_internal_set_last_heard(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_heard_ = value;
}

// .meshtastic.DeviceMetrics device_metrics = 6;
inline bool NodeInfo::has_device_metrics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_metrics_ != nullptr);
  return value;
}
inline const ::meshtastic::DeviceMetrics& NodeInfo::_internal_device_metrics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::DeviceMetrics* p = _impl_.device_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::DeviceMetrics&>(::meshtastic::_DeviceMetrics_default_instance_);
}
inline const ::meshtastic::DeviceMetrics& NodeInfo::device_metrics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.device_metrics)
  return _internal_device_metrics();
}
inline void NodeInfo::unsafe_arena_set_allocated_device_metrics(::meshtastic::DeviceMetrics* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_metrics_);
  }
  _impl_.device_metrics_ = reinterpret_cast<::meshtastic::DeviceMetrics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfo.device_metrics)
}
inline ::meshtastic::DeviceMetrics* NodeInfo::release_device_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::meshtastic::DeviceMetrics* released = _impl_.device_metrics_;
  _impl_.device_metrics_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::DeviceMetrics* NodeInfo::unsafe_arena_release_device_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfo.device_metrics)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::meshtastic::DeviceMetrics* temp = _impl_.device_metrics_;
  _impl_.device_metrics_ = nullptr;
  return temp;
}
inline ::meshtastic::DeviceMetrics* NodeInfo::_internal_mutable_device_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_metrics_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::DeviceMetrics>(GetArena());
    _impl_.device_metrics_ = reinterpret_cast<::meshtastic::DeviceMetrics*>(p);
  }
  return _impl_.device_metrics_;
}
inline ::meshtastic::DeviceMetrics* NodeInfo::mutable_device_metrics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::meshtastic::DeviceMetrics* _msg = _internal_mutable_device_metrics();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfo.device_metrics)
  return _msg;
}
inline void NodeInfo::set_allocated_device_metrics(::meshtastic::DeviceMetrics* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_metrics_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.device_metrics_ = reinterpret_cast<::meshtastic::DeviceMetrics*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfo.device_metrics)
}

// uint32 channel = 7;
inline void NodeInfo::clear_channel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_ = 0u;
}
inline ::uint32_t NodeInfo::channel() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.channel)
  return _internal_channel();
}
inline void NodeInfo::set_channel(::uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.channel)
}
inline ::uint32_t NodeInfo::_internal_channel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_;
}
inline void NodeInfo::_internal_set_channel(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_ = value;
}

// bool via_mqtt = 8;
inline void NodeInfo::clear_via_mqtt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.via_mqtt_ = false;
}
inline bool NodeInfo::via_mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.via_mqtt)
  return _internal_via_mqtt();
}
inline void NodeInfo::set_via_mqtt(bool value) {
  _internal_set_via_mqtt(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.via_mqtt)
}
inline bool NodeInfo::_internal_via_mqtt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.via_mqtt_;
}
inline void NodeInfo::_internal_set_via_mqtt(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.via_mqtt_ = value;
}

// optional uint32 hops_away = 9;
inline bool NodeInfo::has_hops_away() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NodeInfo::clear_hops_away() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hops_away_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t NodeInfo::hops_away() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.hops_away)
  return _internal_hops_away();
}
inline void NodeInfo::set_hops_away(::uint32_t value) {
  _internal_set_hops_away(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.hops_away)
}
inline ::uint32_t NodeInfo::_internal_hops_away() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hops_away_;
}
inline void NodeInfo::_internal_set_hops_away(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hops_away_ = value;
}

// bool is_favorite = 10;
inline void NodeInfo::clear_is_favorite() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_favorite_ = false;
}
inline bool NodeInfo::is_favorite() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.is_favorite)
  return _internal_is_favorite();
}
inline void NodeInfo::set_is_favorite(bool value) {
  _internal_set_is_favorite(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.is_favorite)
}
inline bool NodeInfo::_internal_is_favorite() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_favorite_;
}
inline void NodeInfo::_internal_set_is_favorite(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_favorite_ = value;
}

// bool is_ignored = 11;
inline void NodeInfo::clear_is_ignored() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ignored_ = false;
}
inline bool NodeInfo::is_ignored() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.is_ignored)
  return _internal_is_ignored();
}
inline void NodeInfo::set_is_ignored(bool value) {
  _internal_set_is_ignored(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.is_ignored)
}
inline bool NodeInfo::_internal_is_ignored() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_ignored_;
}
inline void NodeInfo::_internal_set_is_ignored(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ignored_ = value;
}

// bool is_key_manually_verified = 12;
inline void NodeInfo::clear_is_key_manually_verified() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_key_manually_verified_ = false;
}
inline bool NodeInfo::is_key_manually_verified() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.is_key_manually_verified)
  return _internal_is_key_manually_verified();
}
inline void NodeInfo::set_is_key_manually_verified(bool value) {
  _internal_set_is_key_manually_verified(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.is_key_manually_verified)
}
inline bool NodeInfo::_internal_is_key_manually_verified() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_key_manually_verified_;
}
inline void NodeInfo::_internal_set_is_key_manually_verified(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_key_manually_verified_ = value;
}

// -------------------------------------------------------------------

// MyNodeInfo

// uint32 my_node_num = 1;
inline void MyNodeInfo::clear_my_node_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.my_node_num_ = 0u;
}
inline ::uint32_t MyNodeInfo::my_node_num() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.my_node_num)
  return _internal_my_node_num();
}
inline void MyNodeInfo::set_my_node_num(::uint32_t value) {
  _internal_set_my_node_num(value);
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.my_node_num)
}
inline ::uint32_t MyNodeInfo::_internal_my_node_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.my_node_num_;
}
inline void MyNodeInfo::_internal_set_my_node_num(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.my_node_num_ = value;
}

// uint32 reboot_count = 8;
inline void MyNodeInfo::clear_reboot_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reboot_count_ = 0u;
}
inline ::uint32_t MyNodeInfo::reboot_count() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.reboot_count)
  return _internal_reboot_count();
}
inline void MyNodeInfo::set_reboot_count(::uint32_t value) {
  _internal_set_reboot_count(value);
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.reboot_count)
}
inline ::uint32_t MyNodeInfo::_internal_reboot_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reboot_count_;
}
inline void MyNodeInfo::_internal_set_reboot_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reboot_count_ = value;
}

// uint32 min_app_version = 11;
inline void MyNodeInfo::clear_min_app_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_app_version_ = 0u;
}
inline ::uint32_t MyNodeInfo::min_app_version() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.min_app_version)
  return _internal_min_app_version();
}
inline void MyNodeInfo::set_min_app_version(::uint32_t value) {
  _internal_set_min_app_version(value);
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.min_app_version)
}
inline ::uint32_t MyNodeInfo::_internal_min_app_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_app_version_;
}
inline void MyNodeInfo::_internal_set_min_app_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_app_version_ = value;
}

// bytes device_id = 12;
inline void MyNodeInfo::clear_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& MyNodeInfo::device_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.device_id)
  return _internal_device_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MyNodeInfo::set_device_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.device_id)
}
inline std::string* MyNodeInfo::mutable_device_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:meshtastic.MyNodeInfo.device_id)
  return _s;
}
inline const std::string& MyNodeInfo::_internal_device_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_id_.Get();
}
inline void MyNodeInfo::_internal_set_device_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.Set(value, GetArena());
}
inline std::string* MyNodeInfo::_internal_mutable_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_id_.Mutable( GetArena());
}
inline std::string* MyNodeInfo::release_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.MyNodeInfo.device_id)
  return _impl_.device_id_.Release();
}
inline void MyNodeInfo::set_allocated_device_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MyNodeInfo.device_id)
}

// string pio_env = 13;
inline void MyNodeInfo::clear_pio_env() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pio_env_.ClearToEmpty();
}
inline const std::string& MyNodeInfo::pio_env() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.pio_env)
  return _internal_pio_env();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MyNodeInfo::set_pio_env(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pio_env_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.pio_env)
}
inline std::string* MyNodeInfo::mutable_pio_env() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pio_env();
  // @@protoc_insertion_point(field_mutable:meshtastic.MyNodeInfo.pio_env)
  return _s;
}
inline const std::string& MyNodeInfo::_internal_pio_env() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pio_env_.Get();
}
inline void MyNodeInfo::_internal_set_pio_env(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pio_env_.Set(value, GetArena());
}
inline std::string* MyNodeInfo::_internal_mutable_pio_env() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pio_env_.Mutable( GetArena());
}
inline std::string* MyNodeInfo::release_pio_env() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.MyNodeInfo.pio_env)
  return _impl_.pio_env_.Release();
}
inline void MyNodeInfo::set_allocated_pio_env(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pio_env_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pio_env_.IsDefault()) {
    _impl_.pio_env_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MyNodeInfo.pio_env)
}

// .meshtastic.FirmwareEdition firmware_edition = 14;
inline void MyNodeInfo::clear_firmware_edition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.firmware_edition_ = 0;
}
inline ::meshtastic::FirmwareEdition MyNodeInfo::firmware_edition() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.firmware_edition)
  return _internal_firmware_edition();
}
inline void MyNodeInfo::set_firmware_edition(::meshtastic::FirmwareEdition value) {
  _internal_set_firmware_edition(value);
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.firmware_edition)
}
inline ::meshtastic::FirmwareEdition MyNodeInfo::_internal_firmware_edition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::FirmwareEdition>(_impl_.firmware_edition_);
}
inline void MyNodeInfo::_internal_set_firmware_edition(::meshtastic::FirmwareEdition value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.firmware_edition_ = value;
}

// uint32 nodedb_count = 15;
inline void MyNodeInfo::clear_nodedb_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nodedb_count_ = 0u;
}
inline ::uint32_t MyNodeInfo::nodedb_count() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.nodedb_count)
  return _internal_nodedb_count();
}
inline void MyNodeInfo::set_nodedb_count(::uint32_t value) {
  _internal_set_nodedb_count(value);
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.nodedb_count)
}
inline ::uint32_t MyNodeInfo::_internal_nodedb_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nodedb_count_;
}
inline void MyNodeInfo::_internal_set_nodedb_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nodedb_count_ = value;
}

// -------------------------------------------------------------------

// LogRecord

// string message = 1;
inline void LogRecord::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LogRecord::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.LogRecord.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LogRecord::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.LogRecord.message)
}
inline std::string* LogRecord::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:meshtastic.LogRecord.message)
  return _s;
}
inline const std::string& LogRecord::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void LogRecord::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* LogRecord::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* LogRecord::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.LogRecord.message)
  return _impl_.message_.Release();
}
inline void LogRecord::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LogRecord.message)
}

// fixed32 time = 2;
inline void LogRecord::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0u;
}
inline ::uint32_t LogRecord::time() const {
  // @@protoc_insertion_point(field_get:meshtastic.LogRecord.time)
  return _internal_time();
}
inline void LogRecord::set_time(::uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.LogRecord.time)
}
inline ::uint32_t LogRecord::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void LogRecord::_internal_set_time(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// string source = 3;
inline void LogRecord::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_.ClearToEmpty();
}
inline const std::string& LogRecord::source() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.LogRecord.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LogRecord::set_source(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.LogRecord.source)
}
inline std::string* LogRecord::mutable_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:meshtastic.LogRecord.source)
  return _s;
}
inline const std::string& LogRecord::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_.Get();
}
inline void LogRecord::_internal_set_source(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_.Set(value, GetArena());
}
inline std::string* LogRecord::_internal_mutable_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.source_.Mutable( GetArena());
}
inline std::string* LogRecord::release_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.LogRecord.source)
  return _impl_.source_.Release();
}
inline void LogRecord::set_allocated_source(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LogRecord.source)
}

// .meshtastic.LogRecord.Level level = 4;
inline void LogRecord::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0;
}
inline ::meshtastic::LogRecord_Level LogRecord::level() const {
  // @@protoc_insertion_point(field_get:meshtastic.LogRecord.level)
  return _internal_level();
}
inline void LogRecord::set_level(::meshtastic::LogRecord_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:meshtastic.LogRecord.level)
}
inline ::meshtastic::LogRecord_Level LogRecord::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::LogRecord_Level>(_impl_.level_);
}
inline void LogRecord::_internal_set_level(::meshtastic::LogRecord_Level value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// -------------------------------------------------------------------

// QueueStatus

// int32 res = 1;
inline void QueueStatus::clear_res() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.res_ = 0;
}
inline ::int32_t QueueStatus::res() const {
  // @@protoc_insertion_point(field_get:meshtastic.QueueStatus.res)
  return _internal_res();
}
inline void QueueStatus::set_res(::int32_t value) {
  _internal_set_res(value);
  // @@protoc_insertion_point(field_set:meshtastic.QueueStatus.res)
}
inline ::int32_t QueueStatus::_internal_res() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.res_;
}
inline void QueueStatus::_internal_set_res(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.res_ = value;
}

// uint32 free = 2;
inline void QueueStatus::clear_free() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_ = 0u;
}
inline ::uint32_t QueueStatus::free() const {
  // @@protoc_insertion_point(field_get:meshtastic.QueueStatus.free)
  return _internal_free();
}
inline void QueueStatus::set_free(::uint32_t value) {
  _internal_set_free(value);
  // @@protoc_insertion_point(field_set:meshtastic.QueueStatus.free)
}
inline ::uint32_t QueueStatus::_internal_free() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.free_;
}
inline void QueueStatus::_internal_set_free(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_ = value;
}

// uint32 maxlen = 3;
inline void QueueStatus::clear_maxlen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maxlen_ = 0u;
}
inline ::uint32_t QueueStatus::maxlen() const {
  // @@protoc_insertion_point(field_get:meshtastic.QueueStatus.maxlen)
  return _internal_maxlen();
}
inline void QueueStatus::set_maxlen(::uint32_t value) {
  _internal_set_maxlen(value);
  // @@protoc_insertion_point(field_set:meshtastic.QueueStatus.maxlen)
}
inline ::uint32_t QueueStatus::_internal_maxlen() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.maxlen_;
}
inline void QueueStatus::_internal_set_maxlen(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maxlen_ = value;
}

// uint32 mesh_packet_id = 4;
inline void QueueStatus::clear_mesh_packet_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mesh_packet_id_ = 0u;
}
inline ::uint32_t QueueStatus::mesh_packet_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.QueueStatus.mesh_packet_id)
  return _internal_mesh_packet_id();
}
inline void QueueStatus::set_mesh_packet_id(::uint32_t value) {
  _internal_set_mesh_packet_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.QueueStatus.mesh_packet_id)
}
inline ::uint32_t QueueStatus::_internal_mesh_packet_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mesh_packet_id_;
}
inline void QueueStatus::_internal_set_mesh_packet_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mesh_packet_id_ = value;
}

// -------------------------------------------------------------------

// FromRadio

// uint32 id = 1;
inline void FromRadio::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t FromRadio::id() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.id)
  return _internal_id();
}
inline void FromRadio::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.FromRadio.id)
}
inline ::uint32_t FromRadio::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void FromRadio::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .meshtastic.MeshPacket packet = 2;
inline bool FromRadio::has_packet() const {
  return payload_variant_case() == kPacket;
}
inline bool FromRadio::_internal_has_packet() const {
  return payload_variant_case() == kPacket;
}
inline void FromRadio::set_has_packet() {
  _impl_._oneof_case_[0] = kPacket;
}
inline void FromRadio::clear_packet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kPacket) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.packet_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.packet_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::MeshPacket* FromRadio::release_packet() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.packet)
  if (payload_variant_case() == kPacket) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.packet_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::MeshPacket& FromRadio::_internal_packet() const {
  return payload_variant_case() == kPacket ? *_impl_.payload_variant_.packet_ : reinterpret_cast<::meshtastic::MeshPacket&>(::meshtastic::_MeshPacket_default_instance_);
}
inline const ::meshtastic::MeshPacket& FromRadio::packet() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.packet)
  return _internal_packet();
}
inline ::meshtastic::MeshPacket* FromRadio::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.packet)
  if (payload_variant_case() == kPacket) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.packet_;
    _impl_.payload_variant_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_packet(::meshtastic::MeshPacket* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_packet();
    _impl_.payload_variant_.packet_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.packet)
}
inline ::meshtastic::MeshPacket* FromRadio::_internal_mutable_packet() {
  if (payload_variant_case() != kPacket) {
    clear_payload_variant();
    set_has_packet();
    _impl_.payload_variant_.packet_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::MeshPacket>(GetArena());
  }
  return _impl_.payload_variant_.packet_;
}
inline ::meshtastic::MeshPacket* FromRadio::mutable_packet() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::MeshPacket* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.packet)
  return _msg;
}

// .meshtastic.MyNodeInfo my_info = 3;
inline bool FromRadio::has_my_info() const {
  return payload_variant_case() == kMyInfo;
}
inline bool FromRadio::_internal_has_my_info() const {
  return payload_variant_case() == kMyInfo;
}
inline void FromRadio::set_has_my_info() {
  _impl_._oneof_case_[0] = kMyInfo;
}
inline void FromRadio::clear_my_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kMyInfo) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.my_info_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.my_info_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::MyNodeInfo* FromRadio::release_my_info() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.my_info)
  if (payload_variant_case() == kMyInfo) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.my_info_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.my_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::MyNodeInfo& FromRadio::_internal_my_info() const {
  return payload_variant_case() == kMyInfo ? *_impl_.payload_variant_.my_info_ : reinterpret_cast<::meshtastic::MyNodeInfo&>(::meshtastic::_MyNodeInfo_default_instance_);
}
inline const ::meshtastic::MyNodeInfo& FromRadio::my_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.my_info)
  return _internal_my_info();
}
inline ::meshtastic::MyNodeInfo* FromRadio::unsafe_arena_release_my_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.my_info)
  if (payload_variant_case() == kMyInfo) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.my_info_;
    _impl_.payload_variant_.my_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_my_info(::meshtastic::MyNodeInfo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_my_info();
    _impl_.payload_variant_.my_info_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.my_info)
}
inline ::meshtastic::MyNodeInfo* FromRadio::_internal_mutable_my_info() {
  if (payload_variant_case() != kMyInfo) {
    clear_payload_variant();
    set_has_my_info();
    _impl_.payload_variant_.my_info_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::MyNodeInfo>(GetArena());
  }
  return _impl_.payload_variant_.my_info_;
}
inline ::meshtastic::MyNodeInfo* FromRadio::mutable_my_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::MyNodeInfo* _msg = _internal_mutable_my_info();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.my_info)
  return _msg;
}

// .meshtastic.NodeInfo node_info = 4;
inline bool FromRadio::has_node_info() const {
  return payload_variant_case() == kNodeInfo;
}
inline bool FromRadio::_internal_has_node_info() const {
  return payload_variant_case() == kNodeInfo;
}
inline void FromRadio::set_has_node_info() {
  _impl_._oneof_case_[0] = kNodeInfo;
}
inline void FromRadio::clear_node_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kNodeInfo) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.node_info_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.node_info_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::NodeInfo* FromRadio::release_node_info() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.node_info)
  if (payload_variant_case() == kNodeInfo) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.node_info_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.node_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::NodeInfo& FromRadio::_internal_node_info() const {
  return payload_variant_case() == kNodeInfo ? *_impl_.payload_variant_.node_info_ : reinterpret_cast<::meshtastic::NodeInfo&>(::meshtastic::_NodeInfo_default_instance_);
}
inline const ::meshtastic::NodeInfo& FromRadio::node_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.node_info)
  return _internal_node_info();
}
inline ::meshtastic::NodeInfo* FromRadio::unsafe_arena_release_node_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.node_info)
  if (payload_variant_case() == kNodeInfo) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.node_info_;
    _impl_.payload_variant_.node_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_node_info(::meshtastic::NodeInfo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_node_info();
    _impl_.payload_variant_.node_info_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.node_info)
}
inline ::meshtastic::NodeInfo* FromRadio::_internal_mutable_node_info() {
  if (payload_variant_case() != kNodeInfo) {
    clear_payload_variant();
    set_has_node_info();
    _impl_.payload_variant_.node_info_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::NodeInfo>(GetArena());
  }
  return _impl_.payload_variant_.node_info_;
}
inline ::meshtastic::NodeInfo* FromRadio::mutable_node_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::NodeInfo* _msg = _internal_mutable_node_info();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.node_info)
  return _msg;
}

// .meshtastic.Config config = 5;
inline bool FromRadio::has_config() const {
  return payload_variant_case() == kConfig;
}
inline bool FromRadio::_internal_has_config() const {
  return payload_variant_case() == kConfig;
}
inline void FromRadio::set_has_config() {
  _impl_._oneof_case_[0] = kConfig;
}
inline ::meshtastic::Config* FromRadio::release_config() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.config)
  if (payload_variant_case() == kConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.config_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config& FromRadio::_internal_config() const {
  return payload_variant_case() == kConfig ? *_impl_.payload_variant_.config_ : reinterpret_cast<::meshtastic::Config&>(::meshtastic::_Config_default_instance_);
}
inline const ::meshtastic::Config& FromRadio::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.config)
  return _internal_config();
}
inline ::meshtastic::Config* FromRadio::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.config)
  if (payload_variant_case() == kConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.config_;
    _impl_.payload_variant_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_config(::meshtastic::Config* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_config();
    _impl_.payload_variant_.config_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.config)
}
inline ::meshtastic::Config* FromRadio::_internal_mutable_config() {
  if (payload_variant_case() != kConfig) {
    clear_payload_variant();
    set_has_config();
    _impl_.payload_variant_.config_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config>(GetArena());
  }
  return _impl_.payload_variant_.config_;
}
inline ::meshtastic::Config* FromRadio::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.config)
  return _msg;
}

// .meshtastic.LogRecord log_record = 6;
inline bool FromRadio::has_log_record() const {
  return payload_variant_case() == kLogRecord;
}
inline bool FromRadio::_internal_has_log_record() const {
  return payload_variant_case() == kLogRecord;
}
inline void FromRadio::set_has_log_record() {
  _impl_._oneof_case_[0] = kLogRecord;
}
inline void FromRadio::clear_log_record() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kLogRecord) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.log_record_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.log_record_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::LogRecord* FromRadio::release_log_record() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.log_record)
  if (payload_variant_case() == kLogRecord) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.log_record_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.log_record_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::LogRecord& FromRadio::_internal_log_record() const {
  return payload_variant_case() == kLogRecord ? *_impl_.payload_variant_.log_record_ : reinterpret_cast<::meshtastic::LogRecord&>(::meshtastic::_LogRecord_default_instance_);
}
inline const ::meshtastic::LogRecord& FromRadio::log_record() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.log_record)
  return _internal_log_record();
}
inline ::meshtastic::LogRecord* FromRadio::unsafe_arena_release_log_record() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.log_record)
  if (payload_variant_case() == kLogRecord) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.log_record_;
    _impl_.payload_variant_.log_record_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_log_record(::meshtastic::LogRecord* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_log_record();
    _impl_.payload_variant_.log_record_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.log_record)
}
inline ::meshtastic::LogRecord* FromRadio::_internal_mutable_log_record() {
  if (payload_variant_case() != kLogRecord) {
    clear_payload_variant();
    set_has_log_record();
    _impl_.payload_variant_.log_record_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::LogRecord>(GetArena());
  }
  return _impl_.payload_variant_.log_record_;
}
inline ::meshtastic::LogRecord* FromRadio::mutable_log_record() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::LogRecord* _msg = _internal_mutable_log_record();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.log_record)
  return _msg;
}

// uint32 config_complete_id = 7;
inline bool FromRadio::has_config_complete_id() const {
  return payload_variant_case() == kConfigCompleteId;
}
inline void FromRadio::set_has_config_complete_id() {
  _impl_._oneof_case_[0] = kConfigCompleteId;
}
inline void FromRadio::clear_config_complete_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kConfigCompleteId) {
    _impl_.payload_variant_.config_complete_id_ = 0u;
    clear_has_payload_variant();
  }
}
inline ::uint32_t FromRadio::config_complete_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.config_complete_id)
  return _internal_config_complete_id();
}
inline void FromRadio::set_config_complete_id(::uint32_t value) {
  if (payload_variant_case() != kConfigCompleteId) {
    clear_payload_variant();
    set_has_config_complete_id();
  }
  _impl_.payload_variant_.config_complete_id_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.FromRadio.config_complete_id)
}
inline ::uint32_t FromRadio::_internal_config_complete_id() const {
  if (payload_variant_case() == kConfigCompleteId) {
    return _impl_.payload_variant_.config_complete_id_;
  }
  return 0u;
}

// bool rebooted = 8;
inline bool FromRadio::has_rebooted() const {
  return payload_variant_case() == kRebooted;
}
inline void FromRadio::set_has_rebooted() {
  _impl_._oneof_case_[0] = kRebooted;
}
inline void FromRadio::clear_rebooted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kRebooted) {
    _impl_.payload_variant_.rebooted_ = false;
    clear_has_payload_variant();
  }
}
inline bool FromRadio::rebooted() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.rebooted)
  return _internal_rebooted();
}
inline void FromRadio::set_rebooted(bool value) {
  if (payload_variant_case() != kRebooted) {
    clear_payload_variant();
    set_has_rebooted();
  }
  _impl_.payload_variant_.rebooted_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.FromRadio.rebooted)
}
inline bool FromRadio::_internal_rebooted() const {
  if (payload_variant_case() == kRebooted) {
    return _impl_.payload_variant_.rebooted_;
  }
  return false;
}

// .meshtastic.ModuleConfig moduleConfig = 9;
inline bool FromRadio::has_moduleconfig() const {
  return payload_variant_case() == kModuleConfig;
}
inline bool FromRadio::_internal_has_moduleconfig() const {
  return payload_variant_case() == kModuleConfig;
}
inline void FromRadio::set_has_moduleconfig() {
  _impl_._oneof_case_[0] = kModuleConfig;
}
inline ::meshtastic::ModuleConfig* FromRadio::release_moduleconfig() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.moduleConfig)
  if (payload_variant_case() == kModuleConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.moduleconfig_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.moduleconfig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig& FromRadio::_internal_moduleconfig() const {
  return payload_variant_case() == kModuleConfig ? *_impl_.payload_variant_.moduleconfig_ : reinterpret_cast<::meshtastic::ModuleConfig&>(::meshtastic::_ModuleConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig& FromRadio::moduleconfig() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.moduleConfig)
  return _internal_moduleconfig();
}
inline ::meshtastic::ModuleConfig* FromRadio::unsafe_arena_release_moduleconfig() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.moduleConfig)
  if (payload_variant_case() == kModuleConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.moduleconfig_;
    _impl_.payload_variant_.moduleconfig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_moduleconfig(::meshtastic::ModuleConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_moduleconfig();
    _impl_.payload_variant_.moduleconfig_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.moduleConfig)
}
inline ::meshtastic::ModuleConfig* FromRadio::_internal_mutable_moduleconfig() {
  if (payload_variant_case() != kModuleConfig) {
    clear_payload_variant();
    set_has_moduleconfig();
    _impl_.payload_variant_.moduleconfig_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::ModuleConfig>(GetArena());
  }
  return _impl_.payload_variant_.moduleconfig_;
}
inline ::meshtastic::ModuleConfig* FromRadio::mutable_moduleconfig() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::ModuleConfig* _msg = _internal_mutable_moduleconfig();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.moduleConfig)
  return _msg;
}

// .meshtastic.Channel channel = 10;
inline bool FromRadio::has_channel() const {
  return payload_variant_case() == kChannel;
}
inline bool FromRadio::_internal_has_channel() const {
  return payload_variant_case() == kChannel;
}
inline void FromRadio::set_has_channel() {
  _impl_._oneof_case_[0] = kChannel;
}
inline ::meshtastic::Channel* FromRadio::release_channel() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.channel)
  if (payload_variant_case() == kChannel) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.channel_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Channel& FromRadio::_internal_channel() const {
  return payload_variant_case() == kChannel ? *_impl_.payload_variant_.channel_ : reinterpret_cast<::meshtastic::Channel&>(::meshtastic::_Channel_default_instance_);
}
inline const ::meshtastic::Channel& FromRadio::channel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.channel)
  return _internal_channel();
}
inline ::meshtastic::Channel* FromRadio::unsafe_arena_release_channel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.channel)
  if (payload_variant_case() == kChannel) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.channel_;
    _impl_.payload_variant_.channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_channel(::meshtastic::Channel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_channel();
    _impl_.payload_variant_.channel_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.channel)
}
inline ::meshtastic::Channel* FromRadio::_internal_mutable_channel() {
  if (payload_variant_case() != kChannel) {
    clear_payload_variant();
    set_has_channel();
    _impl_.payload_variant_.channel_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Channel>(GetArena());
  }
  return _impl_.payload_variant_.channel_;
}
inline ::meshtastic::Channel* FromRadio::mutable_channel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Channel* _msg = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.channel)
  return _msg;
}

// .meshtastic.QueueStatus queueStatus = 11;
inline bool FromRadio::has_queuestatus() const {
  return payload_variant_case() == kQueueStatus;
}
inline bool FromRadio::_internal_has_queuestatus() const {
  return payload_variant_case() == kQueueStatus;
}
inline void FromRadio::set_has_queuestatus() {
  _impl_._oneof_case_[0] = kQueueStatus;
}
inline void FromRadio::clear_queuestatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kQueueStatus) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.queuestatus_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.queuestatus_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::QueueStatus* FromRadio::release_queuestatus() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.queueStatus)
  if (payload_variant_case() == kQueueStatus) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.queuestatus_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.queuestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::QueueStatus& FromRadio::_internal_queuestatus() const {
  return payload_variant_case() == kQueueStatus ? *_impl_.payload_variant_.queuestatus_ : reinterpret_cast<::meshtastic::QueueStatus&>(::meshtastic::_QueueStatus_default_instance_);
}
inline const ::meshtastic::QueueStatus& FromRadio::queuestatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.queueStatus)
  return _internal_queuestatus();
}
inline ::meshtastic::QueueStatus* FromRadio::unsafe_arena_release_queuestatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.queueStatus)
  if (payload_variant_case() == kQueueStatus) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.queuestatus_;
    _impl_.payload_variant_.queuestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_queuestatus(::meshtastic::QueueStatus* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_queuestatus();
    _impl_.payload_variant_.queuestatus_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.queueStatus)
}
inline ::meshtastic::QueueStatus* FromRadio::_internal_mutable_queuestatus() {
  if (payload_variant_case() != kQueueStatus) {
    clear_payload_variant();
    set_has_queuestatus();
    _impl_.payload_variant_.queuestatus_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::QueueStatus>(GetArena());
  }
  return _impl_.payload_variant_.queuestatus_;
}
inline ::meshtastic::QueueStatus* FromRadio::mutable_queuestatus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::QueueStatus* _msg = _internal_mutable_queuestatus();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.queueStatus)
  return _msg;
}

// .meshtastic.XModem xmodemPacket = 12;
inline bool FromRadio::has_xmodempacket() const {
  return payload_variant_case() == kXmodemPacket;
}
inline bool FromRadio::_internal_has_xmodempacket() const {
  return payload_variant_case() == kXmodemPacket;
}
inline void FromRadio::set_has_xmodempacket() {
  _impl_._oneof_case_[0] = kXmodemPacket;
}
inline ::meshtastic::XModem* FromRadio::release_xmodempacket() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.xmodemPacket)
  if (payload_variant_case() == kXmodemPacket) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.xmodempacket_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.xmodempacket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::XModem& FromRadio::_internal_xmodempacket() const {
  return payload_variant_case() == kXmodemPacket ? *_impl_.payload_variant_.xmodempacket_ : reinterpret_cast<::meshtastic::XModem&>(::meshtastic::_XModem_default_instance_);
}
inline const ::meshtastic::XModem& FromRadio::xmodempacket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.xmodemPacket)
  return _internal_xmodempacket();
}
inline ::meshtastic::XModem* FromRadio::unsafe_arena_release_xmodempacket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.xmodemPacket)
  if (payload_variant_case() == kXmodemPacket) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.xmodempacket_;
    _impl_.payload_variant_.xmodempacket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_xmodempacket(::meshtastic::XModem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.xmodemPacket)
}
inline ::meshtastic::XModem* FromRadio::_internal_mutable_xmodempacket() {
  if (payload_variant_case() != kXmodemPacket) {
    clear_payload_variant();
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::XModem>(GetArena());
  }
  return _impl_.payload_variant_.xmodempacket_;
}
inline ::meshtastic::XModem* FromRadio::mutable_xmodempacket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::XModem* _msg = _internal_mutable_xmodempacket();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.xmodemPacket)
  return _msg;
}

// .meshtastic.DeviceMetadata metadata = 13;
inline bool FromRadio::has_metadata() const {
  return payload_variant_case() == kMetadata;
}
inline bool FromRadio::_internal_has_metadata() const {
  return payload_variant_case() == kMetadata;
}
inline void FromRadio::set_has_metadata() {
  _impl_._oneof_case_[0] = kMetadata;
}
inline void FromRadio::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kMetadata) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.metadata_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.metadata_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::DeviceMetadata* FromRadio::release_metadata() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.metadata)
  if (payload_variant_case() == kMetadata) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.metadata_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceMetadata& FromRadio::_internal_metadata() const {
  return payload_variant_case() == kMetadata ? *_impl_.payload_variant_.metadata_ : reinterpret_cast<::meshtastic::DeviceMetadata&>(::meshtastic::_DeviceMetadata_default_instance_);
}
inline const ::meshtastic::DeviceMetadata& FromRadio::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.metadata)
  return _internal_metadata();
}
inline ::meshtastic::DeviceMetadata* FromRadio::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.metadata)
  if (payload_variant_case() == kMetadata) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.metadata_;
    _impl_.payload_variant_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_metadata(::meshtastic::DeviceMetadata* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_metadata();
    _impl_.payload_variant_.metadata_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.metadata)
}
inline ::meshtastic::DeviceMetadata* FromRadio::_internal_mutable_metadata() {
  if (payload_variant_case() != kMetadata) {
    clear_payload_variant();
    set_has_metadata();
    _impl_.payload_variant_.metadata_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::DeviceMetadata>(GetArena());
  }
  return _impl_.payload_variant_.metadata_;
}
inline ::meshtastic::DeviceMetadata* FromRadio::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::DeviceMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.metadata)
  return _msg;
}

// .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 14;
inline bool FromRadio::has_mqttclientproxymessage() const {
  return payload_variant_case() == kMqttClientProxyMessage;
}
inline bool FromRadio::_internal_has_mqttclientproxymessage() const {
  return payload_variant_case() == kMqttClientProxyMessage;
}
inline void FromRadio::set_has_mqttclientproxymessage() {
  _impl_._oneof_case_[0] = kMqttClientProxyMessage;
}
inline void FromRadio::clear_mqttclientproxymessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kMqttClientProxyMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.mqttclientproxymessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.mqttclientproxymessage_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::MqttClientProxyMessage* FromRadio::release_mqttclientproxymessage() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.mqttClientProxyMessage)
  if (payload_variant_case() == kMqttClientProxyMessage) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.mqttclientproxymessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.mqttclientproxymessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::MqttClientProxyMessage& FromRadio::_internal_mqttclientproxymessage() const {
  return payload_variant_case() == kMqttClientProxyMessage ? *_impl_.payload_variant_.mqttclientproxymessage_ : reinterpret_cast<::meshtastic::MqttClientProxyMessage&>(::meshtastic::_MqttClientProxyMessage_default_instance_);
}
inline const ::meshtastic::MqttClientProxyMessage& FromRadio::mqttclientproxymessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.mqttClientProxyMessage)
  return _internal_mqttclientproxymessage();
}
inline ::meshtastic::MqttClientProxyMessage* FromRadio::unsafe_arena_release_mqttclientproxymessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.mqttClientProxyMessage)
  if (payload_variant_case() == kMqttClientProxyMessage) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.mqttclientproxymessage_;
    _impl_.payload_variant_.mqttclientproxymessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.mqttClientProxyMessage)
}
inline ::meshtastic::MqttClientProxyMessage* FromRadio::_internal_mutable_mqttclientproxymessage() {
  if (payload_variant_case() != kMqttClientProxyMessage) {
    clear_payload_variant();
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::MqttClientProxyMessage>(GetArena());
  }
  return _impl_.payload_variant_.mqttclientproxymessage_;
}
inline ::meshtastic::MqttClientProxyMessage* FromRadio::mutable_mqttclientproxymessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::MqttClientProxyMessage* _msg = _internal_mutable_mqttclientproxymessage();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.mqttClientProxyMessage)
  return _msg;
}

// .meshtastic.FileInfo fileInfo = 15;
inline bool FromRadio::has_fileinfo() const {
  return payload_variant_case() == kFileInfo;
}
inline bool FromRadio::_internal_has_fileinfo() const {
  return payload_variant_case() == kFileInfo;
}
inline void FromRadio::set_has_fileinfo() {
  _impl_._oneof_case_[0] = kFileInfo;
}
inline void FromRadio::clear_fileinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kFileInfo) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.fileinfo_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.fileinfo_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::FileInfo* FromRadio::release_fileinfo() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.fileInfo)
  if (payload_variant_case() == kFileInfo) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.fileinfo_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.fileinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::FileInfo& FromRadio::_internal_fileinfo() const {
  return payload_variant_case() == kFileInfo ? *_impl_.payload_variant_.fileinfo_ : reinterpret_cast<::meshtastic::FileInfo&>(::meshtastic::_FileInfo_default_instance_);
}
inline const ::meshtastic::FileInfo& FromRadio::fileinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.fileInfo)
  return _internal_fileinfo();
}
inline ::meshtastic::FileInfo* FromRadio::unsafe_arena_release_fileinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.fileInfo)
  if (payload_variant_case() == kFileInfo) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.fileinfo_;
    _impl_.payload_variant_.fileinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_fileinfo(::meshtastic::FileInfo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_fileinfo();
    _impl_.payload_variant_.fileinfo_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.fileInfo)
}
inline ::meshtastic::FileInfo* FromRadio::_internal_mutable_fileinfo() {
  if (payload_variant_case() != kFileInfo) {
    clear_payload_variant();
    set_has_fileinfo();
    _impl_.payload_variant_.fileinfo_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::FileInfo>(GetArena());
  }
  return _impl_.payload_variant_.fileinfo_;
}
inline ::meshtastic::FileInfo* FromRadio::mutable_fileinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::FileInfo* _msg = _internal_mutable_fileinfo();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.fileInfo)
  return _msg;
}

// .meshtastic.ClientNotification clientNotification = 16;
inline bool FromRadio::has_clientnotification() const {
  return payload_variant_case() == kClientNotification;
}
inline bool FromRadio::_internal_has_clientnotification() const {
  return payload_variant_case() == kClientNotification;
}
inline void FromRadio::set_has_clientnotification() {
  _impl_._oneof_case_[0] = kClientNotification;
}
inline void FromRadio::clear_clientnotification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kClientNotification) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.clientnotification_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.clientnotification_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ClientNotification* FromRadio::release_clientnotification() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.clientNotification)
  if (payload_variant_case() == kClientNotification) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.clientnotification_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.clientnotification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ClientNotification& FromRadio::_internal_clientnotification() const {
  return payload_variant_case() == kClientNotification ? *_impl_.payload_variant_.clientnotification_ : reinterpret_cast<::meshtastic::ClientNotification&>(::meshtastic::_ClientNotification_default_instance_);
}
inline const ::meshtastic::ClientNotification& FromRadio::clientnotification() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.clientNotification)
  return _internal_clientnotification();
}
inline ::meshtastic::ClientNotification* FromRadio::unsafe_arena_release_clientnotification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.clientNotification)
  if (payload_variant_case() == kClientNotification) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.clientnotification_;
    _impl_.payload_variant_.clientnotification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_clientnotification(::meshtastic::ClientNotification* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_clientnotification();
    _impl_.payload_variant_.clientnotification_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.clientNotification)
}
inline ::meshtastic::ClientNotification* FromRadio::_internal_mutable_clientnotification() {
  if (payload_variant_case() != kClientNotification) {
    clear_payload_variant();
    set_has_clientnotification();
    _impl_.payload_variant_.clientnotification_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::ClientNotification>(GetArena());
  }
  return _impl_.payload_variant_.clientnotification_;
}
inline ::meshtastic::ClientNotification* FromRadio::mutable_clientnotification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::ClientNotification* _msg = _internal_mutable_clientnotification();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.clientNotification)
  return _msg;
}

// .meshtastic.DeviceUIConfig deviceuiConfig = 17;
inline bool FromRadio::has_deviceuiconfig() const {
  return payload_variant_case() == kDeviceuiConfig;
}
inline bool FromRadio::_internal_has_deviceuiconfig() const {
  return payload_variant_case() == kDeviceuiConfig;
}
inline void FromRadio::set_has_deviceuiconfig() {
  _impl_._oneof_case_[0] = kDeviceuiConfig;
}
inline ::meshtastic::DeviceUIConfig* FromRadio::release_deviceuiconfig() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.deviceuiConfig)
  if (payload_variant_case() == kDeviceuiConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.deviceuiconfig_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.deviceuiconfig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceUIConfig& FromRadio::_internal_deviceuiconfig() const {
  return payload_variant_case() == kDeviceuiConfig ? *_impl_.payload_variant_.deviceuiconfig_ : reinterpret_cast<::meshtastic::DeviceUIConfig&>(::meshtastic::_DeviceUIConfig_default_instance_);
}
inline const ::meshtastic::DeviceUIConfig& FromRadio::deviceuiconfig() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.deviceuiConfig)
  return _internal_deviceuiconfig();
}
inline ::meshtastic::DeviceUIConfig* FromRadio::unsafe_arena_release_deviceuiconfig() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.deviceuiConfig)
  if (payload_variant_case() == kDeviceuiConfig) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.deviceuiconfig_;
    _impl_.payload_variant_.deviceuiconfig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_deviceuiconfig(::meshtastic::DeviceUIConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_deviceuiconfig();
    _impl_.payload_variant_.deviceuiconfig_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.deviceuiConfig)
}
inline ::meshtastic::DeviceUIConfig* FromRadio::_internal_mutable_deviceuiconfig() {
  if (payload_variant_case() != kDeviceuiConfig) {
    clear_payload_variant();
    set_has_deviceuiconfig();
    _impl_.payload_variant_.deviceuiconfig_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::DeviceUIConfig>(GetArena());
  }
  return _impl_.payload_variant_.deviceuiconfig_;
}
inline ::meshtastic::DeviceUIConfig* FromRadio::mutable_deviceuiconfig() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::DeviceUIConfig* _msg = _internal_mutable_deviceuiconfig();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.deviceuiConfig)
  return _msg;
}

inline bool FromRadio::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void FromRadio::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline FromRadio::PayloadVariantCase FromRadio::payload_variant_case() const {
  return FromRadio::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientNotification

// optional uint32 reply_id = 1;
inline bool ClientNotification::has_reply_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ClientNotification::clear_reply_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reply_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t ClientNotification::reply_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.reply_id)
  return _internal_reply_id();
}
inline void ClientNotification::set_reply_id(::uint32_t value) {
  _internal_set_reply_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.ClientNotification.reply_id)
}
inline ::uint32_t ClientNotification::_internal_reply_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reply_id_;
}
inline void ClientNotification::_internal_set_reply_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reply_id_ = value;
}

// fixed32 time = 2;
inline void ClientNotification::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0u;
}
inline ::uint32_t ClientNotification::time() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.time)
  return _internal_time();
}
inline void ClientNotification::set_time(::uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.ClientNotification.time)
}
inline ::uint32_t ClientNotification::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void ClientNotification::_internal_set_time(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// .meshtastic.LogRecord.Level level = 3;
inline void ClientNotification::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0;
}
inline ::meshtastic::LogRecord_Level ClientNotification::level() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.level)
  return _internal_level();
}
inline void ClientNotification::set_level(::meshtastic::LogRecord_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:meshtastic.ClientNotification.level)
}
inline ::meshtastic::LogRecord_Level ClientNotification::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::LogRecord_Level>(_impl_.level_);
}
inline void ClientNotification::_internal_set_level(::meshtastic::LogRecord_Level value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// string message = 4;
inline void ClientNotification::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ClientNotification::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientNotification::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.ClientNotification.message)
}
inline std::string* ClientNotification::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.message)
  return _s;
}
inline const std::string& ClientNotification::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void ClientNotification::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ClientNotification::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ClientNotification::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.message)
  return _impl_.message_.Release();
}
inline void ClientNotification::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.message)
}

// .meshtastic.KeyVerificationNumberInform key_verification_number_inform = 11;
inline bool ClientNotification::has_key_verification_number_inform() const {
  return payload_variant_case() == kKeyVerificationNumberInform;
}
inline bool ClientNotification::_internal_has_key_verification_number_inform() const {
  return payload_variant_case() == kKeyVerificationNumberInform;
}
inline void ClientNotification::set_has_key_verification_number_inform() {
  _impl_._oneof_case_[0] = kKeyVerificationNumberInform;
}
inline void ClientNotification::clear_key_verification_number_inform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kKeyVerificationNumberInform) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.key_verification_number_inform_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.key_verification_number_inform_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::KeyVerificationNumberInform* ClientNotification::release_key_verification_number_inform() {
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.key_verification_number_inform)
  if (payload_variant_case() == kKeyVerificationNumberInform) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.key_verification_number_inform_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.key_verification_number_inform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::KeyVerificationNumberInform& ClientNotification::_internal_key_verification_number_inform() const {
  return payload_variant_case() == kKeyVerificationNumberInform ? *_impl_.payload_variant_.key_verification_number_inform_ : reinterpret_cast<::meshtastic::KeyVerificationNumberInform&>(::meshtastic::_KeyVerificationNumberInform_default_instance_);
}
inline const ::meshtastic::KeyVerificationNumberInform& ClientNotification::key_verification_number_inform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.key_verification_number_inform)
  return _internal_key_verification_number_inform();
}
inline ::meshtastic::KeyVerificationNumberInform* ClientNotification::unsafe_arena_release_key_verification_number_inform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ClientNotification.key_verification_number_inform)
  if (payload_variant_case() == kKeyVerificationNumberInform) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.key_verification_number_inform_;
    _impl_.payload_variant_.key_verification_number_inform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientNotification::unsafe_arena_set_allocated_key_verification_number_inform(::meshtastic::KeyVerificationNumberInform* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_key_verification_number_inform();
    _impl_.payload_variant_.key_verification_number_inform_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ClientNotification.key_verification_number_inform)
}
inline ::meshtastic::KeyVerificationNumberInform* ClientNotification::_internal_mutable_key_verification_number_inform() {
  if (payload_variant_case() != kKeyVerificationNumberInform) {
    clear_payload_variant();
    set_has_key_verification_number_inform();
    _impl_.payload_variant_.key_verification_number_inform_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::KeyVerificationNumberInform>(GetArena());
  }
  return _impl_.payload_variant_.key_verification_number_inform_;
}
inline ::meshtastic::KeyVerificationNumberInform* ClientNotification::mutable_key_verification_number_inform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::KeyVerificationNumberInform* _msg = _internal_mutable_key_verification_number_inform();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.key_verification_number_inform)
  return _msg;
}

// .meshtastic.KeyVerificationNumberRequest key_verification_number_request = 12;
inline bool ClientNotification::has_key_verification_number_request() const {
  return payload_variant_case() == kKeyVerificationNumberRequest;
}
inline bool ClientNotification::_internal_has_key_verification_number_request() const {
  return payload_variant_case() == kKeyVerificationNumberRequest;
}
inline void ClientNotification::set_has_key_verification_number_request() {
  _impl_._oneof_case_[0] = kKeyVerificationNumberRequest;
}
inline void ClientNotification::clear_key_verification_number_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kKeyVerificationNumberRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.key_verification_number_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.key_verification_number_request_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::KeyVerificationNumberRequest* ClientNotification::release_key_verification_number_request() {
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.key_verification_number_request)
  if (payload_variant_case() == kKeyVerificationNumberRequest) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.key_verification_number_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.key_verification_number_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::KeyVerificationNumberRequest& ClientNotification::_internal_key_verification_number_request() const {
  return payload_variant_case() == kKeyVerificationNumberRequest ? *_impl_.payload_variant_.key_verification_number_request_ : reinterpret_cast<::meshtastic::KeyVerificationNumberRequest&>(::meshtastic::_KeyVerificationNumberRequest_default_instance_);
}
inline const ::meshtastic::KeyVerificationNumberRequest& ClientNotification::key_verification_number_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.key_verification_number_request)
  return _internal_key_verification_number_request();
}
inline ::meshtastic::KeyVerificationNumberRequest* ClientNotification::unsafe_arena_release_key_verification_number_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ClientNotification.key_verification_number_request)
  if (payload_variant_case() == kKeyVerificationNumberRequest) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.key_verification_number_request_;
    _impl_.payload_variant_.key_verification_number_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientNotification::unsafe_arena_set_allocated_key_verification_number_request(::meshtastic::KeyVerificationNumberRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_key_verification_number_request();
    _impl_.payload_variant_.key_verification_number_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ClientNotification.key_verification_number_request)
}
inline ::meshtastic::KeyVerificationNumberRequest* ClientNotification::_internal_mutable_key_verification_number_request() {
  if (payload_variant_case() != kKeyVerificationNumberRequest) {
    clear_payload_variant();
    set_has_key_verification_number_request();
    _impl_.payload_variant_.key_verification_number_request_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::KeyVerificationNumberRequest>(GetArena());
  }
  return _impl_.payload_variant_.key_verification_number_request_;
}
inline ::meshtastic::KeyVerificationNumberRequest* ClientNotification::mutable_key_verification_number_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::KeyVerificationNumberRequest* _msg = _internal_mutable_key_verification_number_request();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.key_verification_number_request)
  return _msg;
}

// .meshtastic.KeyVerificationFinal key_verification_final = 13;
inline bool ClientNotification::has_key_verification_final() const {
  return payload_variant_case() == kKeyVerificationFinal;
}
inline bool ClientNotification::_internal_has_key_verification_final() const {
  return payload_variant_case() == kKeyVerificationFinal;
}
inline void ClientNotification::set_has_key_verification_final() {
  _impl_._oneof_case_[0] = kKeyVerificationFinal;
}
inline void ClientNotification::clear_key_verification_final() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kKeyVerificationFinal) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.key_verification_final_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.key_verification_final_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::KeyVerificationFinal* ClientNotification::release_key_verification_final() {
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.key_verification_final)
  if (payload_variant_case() == kKeyVerificationFinal) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.key_verification_final_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.key_verification_final_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::KeyVerificationFinal& ClientNotification::_internal_key_verification_final() const {
  return payload_variant_case() == kKeyVerificationFinal ? *_impl_.payload_variant_.key_verification_final_ : reinterpret_cast<::meshtastic::KeyVerificationFinal&>(::meshtastic::_KeyVerificationFinal_default_instance_);
}
inline const ::meshtastic::KeyVerificationFinal& ClientNotification::key_verification_final() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.key_verification_final)
  return _internal_key_verification_final();
}
inline ::meshtastic::KeyVerificationFinal* ClientNotification::unsafe_arena_release_key_verification_final() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ClientNotification.key_verification_final)
  if (payload_variant_case() == kKeyVerificationFinal) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.key_verification_final_;
    _impl_.payload_variant_.key_verification_final_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientNotification::unsafe_arena_set_allocated_key_verification_final(::meshtastic::KeyVerificationFinal* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_key_verification_final();
    _impl_.payload_variant_.key_verification_final_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ClientNotification.key_verification_final)
}
inline ::meshtastic::KeyVerificationFinal* ClientNotification::_internal_mutable_key_verification_final() {
  if (payload_variant_case() != kKeyVerificationFinal) {
    clear_payload_variant();
    set_has_key_verification_final();
    _impl_.payload_variant_.key_verification_final_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::KeyVerificationFinal>(GetArena());
  }
  return _impl_.payload_variant_.key_verification_final_;
}
inline ::meshtastic::KeyVerificationFinal* ClientNotification::mutable_key_verification_final() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::KeyVerificationFinal* _msg = _internal_mutable_key_verification_final();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.key_verification_final)
  return _msg;
}

// .meshtastic.DuplicatedPublicKey duplicated_public_key = 14;
inline bool ClientNotification::has_duplicated_public_key() const {
  return payload_variant_case() == kDuplicatedPublicKey;
}
inline bool ClientNotification::_internal_has_duplicated_public_key() const {
  return payload_variant_case() == kDuplicatedPublicKey;
}
inline void ClientNotification::set_has_duplicated_public_key() {
  _impl_._oneof_case_[0] = kDuplicatedPublicKey;
}
inline void ClientNotification::clear_duplicated_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kDuplicatedPublicKey) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.duplicated_public_key_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.duplicated_public_key_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::DuplicatedPublicKey* ClientNotification::release_duplicated_public_key() {
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.duplicated_public_key)
  if (payload_variant_case() == kDuplicatedPublicKey) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.duplicated_public_key_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.duplicated_public_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DuplicatedPublicKey& ClientNotification::_internal_duplicated_public_key() const {
  return payload_variant_case() == kDuplicatedPublicKey ? *_impl_.payload_variant_.duplicated_public_key_ : reinterpret_cast<::meshtastic::DuplicatedPublicKey&>(::meshtastic::_DuplicatedPublicKey_default_instance_);
}
inline const ::meshtastic::DuplicatedPublicKey& ClientNotification::duplicated_public_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.duplicated_public_key)
  return _internal_duplicated_public_key();
}
inline ::meshtastic::DuplicatedPublicKey* ClientNotification::unsafe_arena_release_duplicated_public_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ClientNotification.duplicated_public_key)
  if (payload_variant_case() == kDuplicatedPublicKey) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.duplicated_public_key_;
    _impl_.payload_variant_.duplicated_public_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientNotification::unsafe_arena_set_allocated_duplicated_public_key(::meshtastic::DuplicatedPublicKey* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_duplicated_public_key();
    _impl_.payload_variant_.duplicated_public_key_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ClientNotification.duplicated_public_key)
}
inline ::meshtastic::DuplicatedPublicKey* ClientNotification::_internal_mutable_duplicated_public_key() {
  if (payload_variant_case() != kDuplicatedPublicKey) {
    clear_payload_variant();
    set_has_duplicated_public_key();
    _impl_.payload_variant_.duplicated_public_key_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::DuplicatedPublicKey>(GetArena());
  }
  return _impl_.payload_variant_.duplicated_public_key_;
}
inline ::meshtastic::DuplicatedPublicKey* ClientNotification::mutable_duplicated_public_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::DuplicatedPublicKey* _msg = _internal_mutable_duplicated_public_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.duplicated_public_key)
  return _msg;
}

// .meshtastic.LowEntropyKey low_entropy_key = 15;
inline bool ClientNotification::has_low_entropy_key() const {
  return payload_variant_case() == kLowEntropyKey;
}
inline bool ClientNotification::_internal_has_low_entropy_key() const {
  return payload_variant_case() == kLowEntropyKey;
}
inline void ClientNotification::set_has_low_entropy_key() {
  _impl_._oneof_case_[0] = kLowEntropyKey;
}
inline void ClientNotification::clear_low_entropy_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kLowEntropyKey) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.low_entropy_key_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.low_entropy_key_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::LowEntropyKey* ClientNotification::release_low_entropy_key() {
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.low_entropy_key)
  if (payload_variant_case() == kLowEntropyKey) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.low_entropy_key_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.low_entropy_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::LowEntropyKey& ClientNotification::_internal_low_entropy_key() const {
  return payload_variant_case() == kLowEntropyKey ? *_impl_.payload_variant_.low_entropy_key_ : reinterpret_cast<::meshtastic::LowEntropyKey&>(::meshtastic::_LowEntropyKey_default_instance_);
}
inline const ::meshtastic::LowEntropyKey& ClientNotification::low_entropy_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.low_entropy_key)
  return _internal_low_entropy_key();
}
inline ::meshtastic::LowEntropyKey* ClientNotification::unsafe_arena_release_low_entropy_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ClientNotification.low_entropy_key)
  if (payload_variant_case() == kLowEntropyKey) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.low_entropy_key_;
    _impl_.payload_variant_.low_entropy_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientNotification::unsafe_arena_set_allocated_low_entropy_key(::meshtastic::LowEntropyKey* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_low_entropy_key();
    _impl_.payload_variant_.low_entropy_key_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ClientNotification.low_entropy_key)
}
inline ::meshtastic::LowEntropyKey* ClientNotification::_internal_mutable_low_entropy_key() {
  if (payload_variant_case() != kLowEntropyKey) {
    clear_payload_variant();
    set_has_low_entropy_key();
    _impl_.payload_variant_.low_entropy_key_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::LowEntropyKey>(GetArena());
  }
  return _impl_.payload_variant_.low_entropy_key_;
}
inline ::meshtastic::LowEntropyKey* ClientNotification::mutable_low_entropy_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::LowEntropyKey* _msg = _internal_mutable_low_entropy_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.low_entropy_key)
  return _msg;
}

inline bool ClientNotification::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void ClientNotification::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline ClientNotification::PayloadVariantCase ClientNotification::payload_variant_case() const {
  return ClientNotification::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// KeyVerificationNumberInform

// uint64 nonce = 1;
inline void KeyVerificationNumberInform::clear_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t KeyVerificationNumberInform::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationNumberInform.nonce)
  return _internal_nonce();
}
inline void KeyVerificationNumberInform::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationNumberInform.nonce)
}
inline ::uint64_t KeyVerificationNumberInform::_internal_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nonce_;
}
inline void KeyVerificationNumberInform::_internal_set_nonce(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = value;
}

// string remote_longname = 2;
inline void KeyVerificationNumberInform::clear_remote_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.ClearToEmpty();
}
inline const std::string& KeyVerificationNumberInform::remote_longname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationNumberInform.remote_longname)
  return _internal_remote_longname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyVerificationNumberInform::set_remote_longname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationNumberInform.remote_longname)
}
inline std::string* KeyVerificationNumberInform::mutable_remote_longname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_remote_longname();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerificationNumberInform.remote_longname)
  return _s;
}
inline const std::string& KeyVerificationNumberInform::_internal_remote_longname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remote_longname_.Get();
}
inline void KeyVerificationNumberInform::_internal_set_remote_longname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.Set(value, GetArena());
}
inline std::string* KeyVerificationNumberInform::_internal_mutable_remote_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.remote_longname_.Mutable( GetArena());
}
inline std::string* KeyVerificationNumberInform::release_remote_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerificationNumberInform.remote_longname)
  return _impl_.remote_longname_.Release();
}
inline void KeyVerificationNumberInform::set_allocated_remote_longname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.remote_longname_.IsDefault()) {
    _impl_.remote_longname_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerificationNumberInform.remote_longname)
}

// uint32 security_number = 3;
inline void KeyVerificationNumberInform::clear_security_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.security_number_ = 0u;
}
inline ::uint32_t KeyVerificationNumberInform::security_number() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationNumberInform.security_number)
  return _internal_security_number();
}
inline void KeyVerificationNumberInform::set_security_number(::uint32_t value) {
  _internal_set_security_number(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationNumberInform.security_number)
}
inline ::uint32_t KeyVerificationNumberInform::_internal_security_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.security_number_;
}
inline void KeyVerificationNumberInform::_internal_set_security_number(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.security_number_ = value;
}

// -------------------------------------------------------------------

// KeyVerificationNumberRequest

// uint64 nonce = 1;
inline void KeyVerificationNumberRequest::clear_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t KeyVerificationNumberRequest::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationNumberRequest.nonce)
  return _internal_nonce();
}
inline void KeyVerificationNumberRequest::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationNumberRequest.nonce)
}
inline ::uint64_t KeyVerificationNumberRequest::_internal_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nonce_;
}
inline void KeyVerificationNumberRequest::_internal_set_nonce(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = value;
}

// string remote_longname = 2;
inline void KeyVerificationNumberRequest::clear_remote_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.ClearToEmpty();
}
inline const std::string& KeyVerificationNumberRequest::remote_longname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationNumberRequest.remote_longname)
  return _internal_remote_longname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyVerificationNumberRequest::set_remote_longname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationNumberRequest.remote_longname)
}
inline std::string* KeyVerificationNumberRequest::mutable_remote_longname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_remote_longname();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerificationNumberRequest.remote_longname)
  return _s;
}
inline const std::string& KeyVerificationNumberRequest::_internal_remote_longname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remote_longname_.Get();
}
inline void KeyVerificationNumberRequest::_internal_set_remote_longname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.Set(value, GetArena());
}
inline std::string* KeyVerificationNumberRequest::_internal_mutable_remote_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.remote_longname_.Mutable( GetArena());
}
inline std::string* KeyVerificationNumberRequest::release_remote_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerificationNumberRequest.remote_longname)
  return _impl_.remote_longname_.Release();
}
inline void KeyVerificationNumberRequest::set_allocated_remote_longname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.remote_longname_.IsDefault()) {
    _impl_.remote_longname_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerificationNumberRequest.remote_longname)
}

// -------------------------------------------------------------------

// KeyVerificationFinal

// uint64 nonce = 1;
inline void KeyVerificationFinal::clear_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t KeyVerificationFinal::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationFinal.nonce)
  return _internal_nonce();
}
inline void KeyVerificationFinal::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationFinal.nonce)
}
inline ::uint64_t KeyVerificationFinal::_internal_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nonce_;
}
inline void KeyVerificationFinal::_internal_set_nonce(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = value;
}

// string remote_longname = 2;
inline void KeyVerificationFinal::clear_remote_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.ClearToEmpty();
}
inline const std::string& KeyVerificationFinal::remote_longname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationFinal.remote_longname)
  return _internal_remote_longname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyVerificationFinal::set_remote_longname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationFinal.remote_longname)
}
inline std::string* KeyVerificationFinal::mutable_remote_longname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_remote_longname();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerificationFinal.remote_longname)
  return _s;
}
inline const std::string& KeyVerificationFinal::_internal_remote_longname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remote_longname_.Get();
}
inline void KeyVerificationFinal::_internal_set_remote_longname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.Set(value, GetArena());
}
inline std::string* KeyVerificationFinal::_internal_mutable_remote_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.remote_longname_.Mutable( GetArena());
}
inline std::string* KeyVerificationFinal::release_remote_longname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerificationFinal.remote_longname)
  return _impl_.remote_longname_.Release();
}
inline void KeyVerificationFinal::set_allocated_remote_longname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_longname_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.remote_longname_.IsDefault()) {
    _impl_.remote_longname_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerificationFinal.remote_longname)
}

// bool isSender = 3;
inline void KeyVerificationFinal::clear_issender() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issender_ = false;
}
inline bool KeyVerificationFinal::issender() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationFinal.isSender)
  return _internal_issender();
}
inline void KeyVerificationFinal::set_issender(bool value) {
  _internal_set_issender(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationFinal.isSender)
}
inline bool KeyVerificationFinal::_internal_issender() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.issender_;
}
inline void KeyVerificationFinal::_internal_set_issender(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issender_ = value;
}

// string verification_characters = 4;
inline void KeyVerificationFinal::clear_verification_characters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_characters_.ClearToEmpty();
}
inline const std::string& KeyVerificationFinal::verification_characters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationFinal.verification_characters)
  return _internal_verification_characters();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyVerificationFinal::set_verification_characters(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_characters_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationFinal.verification_characters)
}
inline std::string* KeyVerificationFinal::mutable_verification_characters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verification_characters();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerificationFinal.verification_characters)
  return _s;
}
inline const std::string& KeyVerificationFinal::_internal_verification_characters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verification_characters_.Get();
}
inline void KeyVerificationFinal::_internal_set_verification_characters(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_characters_.Set(value, GetArena());
}
inline std::string* KeyVerificationFinal::_internal_mutable_verification_characters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.verification_characters_.Mutable( GetArena());
}
inline std::string* KeyVerificationFinal::release_verification_characters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerificationFinal.verification_characters)
  return _impl_.verification_characters_.Release();
}
inline void KeyVerificationFinal::set_allocated_verification_characters(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_characters_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.verification_characters_.IsDefault()) {
    _impl_.verification_characters_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerificationFinal.verification_characters)
}

// -------------------------------------------------------------------

// DuplicatedPublicKey

// -------------------------------------------------------------------

// LowEntropyKey

// -------------------------------------------------------------------

// FileInfo

// string file_name = 1;
inline void FileInfo::clear_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& FileInfo::file_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.FileInfo.file_name)
  return _internal_file_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FileInfo::set_file_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.FileInfo.file_name)
}
inline std::string* FileInfo::mutable_file_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.FileInfo.file_name)
  return _s;
}
inline const std::string& FileInfo::_internal_file_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_name_.Get();
}
inline void FileInfo::_internal_set_file_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.Set(value, GetArena());
}
inline std::string* FileInfo::_internal_mutable_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.file_name_.Mutable( GetArena());
}
inline std::string* FileInfo::release_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.FileInfo.file_name)
  return _impl_.file_name_.Release();
}
inline void FileInfo::set_allocated_file_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FileInfo.file_name)
}

// uint32 size_bytes = 2;
inline void FileInfo::clear_size_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_bytes_ = 0u;
}
inline ::uint32_t FileInfo::size_bytes() const {
  // @@protoc_insertion_point(field_get:meshtastic.FileInfo.size_bytes)
  return _internal_size_bytes();
}
inline void FileInfo::set_size_bytes(::uint32_t value) {
  _internal_set_size_bytes(value);
  // @@protoc_insertion_point(field_set:meshtastic.FileInfo.size_bytes)
}
inline ::uint32_t FileInfo::_internal_size_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_bytes_;
}
inline void FileInfo::_internal_set_size_bytes(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_bytes_ = value;
}

// -------------------------------------------------------------------

// ToRadio

// .meshtastic.MeshPacket packet = 1;
inline bool ToRadio::has_packet() const {
  return payload_variant_case() == kPacket;
}
inline bool ToRadio::_internal_has_packet() const {
  return payload_variant_case() == kPacket;
}
inline void ToRadio::set_has_packet() {
  _impl_._oneof_case_[0] = kPacket;
}
inline void ToRadio::clear_packet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kPacket) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.packet_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.packet_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::MeshPacket* ToRadio::release_packet() {
  // @@protoc_insertion_point(field_release:meshtastic.ToRadio.packet)
  if (payload_variant_case() == kPacket) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.packet_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::MeshPacket& ToRadio::_internal_packet() const {
  return payload_variant_case() == kPacket ? *_impl_.payload_variant_.packet_ : reinterpret_cast<::meshtastic::MeshPacket&>(::meshtastic::_MeshPacket_default_instance_);
}
inline const ::meshtastic::MeshPacket& ToRadio::packet() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.packet)
  return _internal_packet();
}
inline ::meshtastic::MeshPacket* ToRadio::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ToRadio.packet)
  if (payload_variant_case() == kPacket) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.packet_;
    _impl_.payload_variant_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToRadio::unsafe_arena_set_allocated_packet(::meshtastic::MeshPacket* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_packet();
    _impl_.payload_variant_.packet_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ToRadio.packet)
}
inline ::meshtastic::MeshPacket* ToRadio::_internal_mutable_packet() {
  if (payload_variant_case() != kPacket) {
    clear_payload_variant();
    set_has_packet();
    _impl_.payload_variant_.packet_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::MeshPacket>(GetArena());
  }
  return _impl_.payload_variant_.packet_;
}
inline ::meshtastic::MeshPacket* ToRadio::mutable_packet() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::MeshPacket* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:meshtastic.ToRadio.packet)
  return _msg;
}

// uint32 want_config_id = 3;
inline bool ToRadio::has_want_config_id() const {
  return payload_variant_case() == kWantConfigId;
}
inline void ToRadio::set_has_want_config_id() {
  _impl_._oneof_case_[0] = kWantConfigId;
}
inline void ToRadio::clear_want_config_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kWantConfigId) {
    _impl_.payload_variant_.want_config_id_ = 0u;
    clear_has_payload_variant();
  }
}
inline ::uint32_t ToRadio::want_config_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.want_config_id)
  return _internal_want_config_id();
}
inline void ToRadio::set_want_config_id(::uint32_t value) {
  if (payload_variant_case() != kWantConfigId) {
    clear_payload_variant();
    set_has_want_config_id();
  }
  _impl_.payload_variant_.want_config_id_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.ToRadio.want_config_id)
}
inline ::uint32_t ToRadio::_internal_want_config_id() const {
  if (payload_variant_case() == kWantConfigId) {
    return _impl_.payload_variant_.want_config_id_;
  }
  return 0u;
}

// bool disconnect = 4;
inline bool ToRadio::has_disconnect() const {
  return payload_variant_case() == kDisconnect;
}
inline void ToRadio::set_has_disconnect() {
  _impl_._oneof_case_[0] = kDisconnect;
}
inline void ToRadio::clear_disconnect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kDisconnect) {
    _impl_.payload_variant_.disconnect_ = false;
    clear_has_payload_variant();
  }
}
inline bool ToRadio::disconnect() const {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.disconnect)
  return _internal_disconnect();
}
inline void ToRadio::set_disconnect(bool value) {
  if (payload_variant_case() != kDisconnect) {
    clear_payload_variant();
    set_has_disconnect();
  }
  _impl_.payload_variant_.disconnect_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.ToRadio.disconnect)
}
inline bool ToRadio::_internal_disconnect() const {
  if (payload_variant_case() == kDisconnect) {
    return _impl_.payload_variant_.disconnect_;
  }
  return false;
}

// .meshtastic.XModem xmodemPacket = 5;
inline bool ToRadio::has_xmodempacket() const {
  return payload_variant_case() == kXmodemPacket;
}
inline bool ToRadio::_internal_has_xmodempacket() const {
  return payload_variant_case() == kXmodemPacket;
}
inline void ToRadio::set_has_xmodempacket() {
  _impl_._oneof_case_[0] = kXmodemPacket;
}
inline ::meshtastic::XModem* ToRadio::release_xmodempacket() {
  // @@protoc_insertion_point(field_release:meshtastic.ToRadio.xmodemPacket)
  if (payload_variant_case() == kXmodemPacket) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.xmodempacket_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.xmodempacket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::XModem& ToRadio::_internal_xmodempacket() const {
  return payload_variant_case() == kXmodemPacket ? *_impl_.payload_variant_.xmodempacket_ : reinterpret_cast<::meshtastic::XModem&>(::meshtastic::_XModem_default_instance_);
}
inline const ::meshtastic::XModem& ToRadio::xmodempacket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.xmodemPacket)
  return _internal_xmodempacket();
}
inline ::meshtastic::XModem* ToRadio::unsafe_arena_release_xmodempacket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ToRadio.xmodemPacket)
  if (payload_variant_case() == kXmodemPacket) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.xmodempacket_;
    _impl_.payload_variant_.xmodempacket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToRadio::unsafe_arena_set_allocated_xmodempacket(::meshtastic::XModem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ToRadio.xmodemPacket)
}
inline ::meshtastic::XModem* ToRadio::_internal_mutable_xmodempacket() {
  if (payload_variant_case() != kXmodemPacket) {
    clear_payload_variant();
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::XModem>(GetArena());
  }
  return _impl_.payload_variant_.xmodempacket_;
}
inline ::meshtastic::XModem* ToRadio::mutable_xmodempacket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::XModem* _msg = _internal_mutable_xmodempacket();
  // @@protoc_insertion_point(field_mutable:meshtastic.ToRadio.xmodemPacket)
  return _msg;
}

// .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 6;
inline bool ToRadio::has_mqttclientproxymessage() const {
  return payload_variant_case() == kMqttClientProxyMessage;
}
inline bool ToRadio::_internal_has_mqttclientproxymessage() const {
  return payload_variant_case() == kMqttClientProxyMessage;
}
inline void ToRadio::set_has_mqttclientproxymessage() {
  _impl_._oneof_case_[0] = kMqttClientProxyMessage;
}
inline void ToRadio::clear_mqttclientproxymessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kMqttClientProxyMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.mqttclientproxymessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.mqttclientproxymessage_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::MqttClientProxyMessage* ToRadio::release_mqttclientproxymessage() {
  // @@protoc_insertion_point(field_release:meshtastic.ToRadio.mqttClientProxyMessage)
  if (payload_variant_case() == kMqttClientProxyMessage) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.mqttclientproxymessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.mqttclientproxymessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::MqttClientProxyMessage& ToRadio::_internal_mqttclientproxymessage() const {
  return payload_variant_case() == kMqttClientProxyMessage ? *_impl_.payload_variant_.mqttclientproxymessage_ : reinterpret_cast<::meshtastic::MqttClientProxyMessage&>(::meshtastic::_MqttClientProxyMessage_default_instance_);
}
inline const ::meshtastic::MqttClientProxyMessage& ToRadio::mqttclientproxymessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.mqttClientProxyMessage)
  return _internal_mqttclientproxymessage();
}
inline ::meshtastic::MqttClientProxyMessage* ToRadio::unsafe_arena_release_mqttclientproxymessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ToRadio.mqttClientProxyMessage)
  if (payload_variant_case() == kMqttClientProxyMessage) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.mqttclientproxymessage_;
    _impl_.payload_variant_.mqttclientproxymessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToRadio::unsafe_arena_set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ToRadio.mqttClientProxyMessage)
}
inline ::meshtastic::MqttClientProxyMessage* ToRadio::_internal_mutable_mqttclientproxymessage() {
  if (payload_variant_case() != kMqttClientProxyMessage) {
    clear_payload_variant();
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::MqttClientProxyMessage>(GetArena());
  }
  return _impl_.payload_variant_.mqttclientproxymessage_;
}
inline ::meshtastic::MqttClientProxyMessage* ToRadio::mutable_mqttclientproxymessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::MqttClientProxyMessage* _msg = _internal_mutable_mqttclientproxymessage();
  // @@protoc_insertion_point(field_mutable:meshtastic.ToRadio.mqttClientProxyMessage)
  return _msg;
}

// .meshtastic.Heartbeat heartbeat = 7;
inline bool ToRadio::has_heartbeat() const {
  return payload_variant_case() == kHeartbeat;
}
inline bool ToRadio::_internal_has_heartbeat() const {
  return payload_variant_case() == kHeartbeat;
}
inline void ToRadio::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void ToRadio::clear_heartbeat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kHeartbeat) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.heartbeat_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.heartbeat_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Heartbeat* ToRadio::release_heartbeat() {
  // @@protoc_insertion_point(field_release:meshtastic.ToRadio.heartbeat)
  if (payload_variant_case() == kHeartbeat) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.heartbeat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Heartbeat& ToRadio::_internal_heartbeat() const {
  return payload_variant_case() == kHeartbeat ? *_impl_.payload_variant_.heartbeat_ : reinterpret_cast<::meshtastic::Heartbeat&>(::meshtastic::_Heartbeat_default_instance_);
}
inline const ::meshtastic::Heartbeat& ToRadio::heartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.heartbeat)
  return _internal_heartbeat();
}
inline ::meshtastic::Heartbeat* ToRadio::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ToRadio.heartbeat)
  if (payload_variant_case() == kHeartbeat) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.heartbeat_;
    _impl_.payload_variant_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToRadio::unsafe_arena_set_allocated_heartbeat(::meshtastic::Heartbeat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_heartbeat();
    _impl_.payload_variant_.heartbeat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ToRadio.heartbeat)
}
inline ::meshtastic::Heartbeat* ToRadio::_internal_mutable_heartbeat() {
  if (payload_variant_case() != kHeartbeat) {
    clear_payload_variant();
    set_has_heartbeat();
    _impl_.payload_variant_.heartbeat_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Heartbeat>(GetArena());
  }
  return _impl_.payload_variant_.heartbeat_;
}
inline ::meshtastic::Heartbeat* ToRadio::mutable_heartbeat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:meshtastic.ToRadio.heartbeat)
  return _msg;
}

inline bool ToRadio::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void ToRadio::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline ToRadio::PayloadVariantCase ToRadio::payload_variant_case() const {
  return ToRadio::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Compressed

// .meshtastic.PortNum portnum = 1;
inline void Compressed::clear_portnum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.portnum_ = 0;
}
inline ::meshtastic::PortNum Compressed::portnum() const {
  // @@protoc_insertion_point(field_get:meshtastic.Compressed.portnum)
  return _internal_portnum();
}
inline void Compressed::set_portnum(::meshtastic::PortNum value) {
  _internal_set_portnum(value);
  // @@protoc_insertion_point(field_set:meshtastic.Compressed.portnum)
}
inline ::meshtastic::PortNum Compressed::_internal_portnum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::PortNum>(_impl_.portnum_);
}
inline void Compressed::_internal_set_portnum(::meshtastic::PortNum value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.portnum_ = value;
}

// bytes data = 2;
inline void Compressed::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Compressed::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Compressed.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Compressed::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.Compressed.data)
}
inline std::string* Compressed::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:meshtastic.Compressed.data)
  return _s;
}
inline const std::string& Compressed::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void Compressed::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* Compressed::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* Compressed::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Compressed.data)
  return _impl_.data_.Release();
}
inline void Compressed::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Compressed.data)
}

// -------------------------------------------------------------------

// NeighborInfo

// uint32 node_id = 1;
inline void NeighborInfo::clear_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_ = 0u;
}
inline ::uint32_t NeighborInfo::node_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.NeighborInfo.node_id)
  return _internal_node_id();
}
inline void NeighborInfo::set_node_id(::uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.NeighborInfo.node_id)
}
inline ::uint32_t NeighborInfo::_internal_node_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_id_;
}
inline void NeighborInfo::_internal_set_node_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_ = value;
}

// uint32 last_sent_by_id = 2;
inline void NeighborInfo::clear_last_sent_by_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_sent_by_id_ = 0u;
}
inline ::uint32_t NeighborInfo::last_sent_by_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.NeighborInfo.last_sent_by_id)
  return _internal_last_sent_by_id();
}
inline void NeighborInfo::set_last_sent_by_id(::uint32_t value) {
  _internal_set_last_sent_by_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.NeighborInfo.last_sent_by_id)
}
inline ::uint32_t NeighborInfo::_internal_last_sent_by_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_sent_by_id_;
}
inline void NeighborInfo::_internal_set_last_sent_by_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_sent_by_id_ = value;
}

// uint32 node_broadcast_interval_secs = 3;
inline void NeighborInfo::clear_node_broadcast_interval_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_broadcast_interval_secs_ = 0u;
}
inline ::uint32_t NeighborInfo::node_broadcast_interval_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.NeighborInfo.node_broadcast_interval_secs)
  return _internal_node_broadcast_interval_secs();
}
inline void NeighborInfo::set_node_broadcast_interval_secs(::uint32_t value) {
  _internal_set_node_broadcast_interval_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.NeighborInfo.node_broadcast_interval_secs)
}
inline ::uint32_t NeighborInfo::_internal_node_broadcast_interval_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_broadcast_interval_secs_;
}
inline void NeighborInfo::_internal_set_node_broadcast_interval_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_broadcast_interval_secs_ = value;
}

// repeated .meshtastic.Neighbor neighbors = 4;
inline int NeighborInfo::_internal_neighbors_size() const {
  return _internal_neighbors().size();
}
inline int NeighborInfo::neighbors_size() const {
  return _internal_neighbors_size();
}
inline void NeighborInfo::clear_neighbors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.neighbors_.Clear();
}
inline ::meshtastic::Neighbor* NeighborInfo::mutable_neighbors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:meshtastic.NeighborInfo.neighbors)
  return _internal_mutable_neighbors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::Neighbor>* NeighborInfo::mutable_neighbors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.NeighborInfo.neighbors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_neighbors();
}
inline const ::meshtastic::Neighbor& NeighborInfo::neighbors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.NeighborInfo.neighbors)
  return _internal_neighbors().Get(index);
}
inline ::meshtastic::Neighbor* NeighborInfo::add_neighbors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::meshtastic::Neighbor* _add = _internal_mutable_neighbors()->Add();
  // @@protoc_insertion_point(field_add:meshtastic.NeighborInfo.neighbors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::Neighbor>& NeighborInfo::neighbors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.NeighborInfo.neighbors)
  return _internal_neighbors();
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::Neighbor>&
NeighborInfo::_internal_neighbors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.neighbors_;
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::Neighbor>*
NeighborInfo::_internal_mutable_neighbors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.neighbors_;
}

// -------------------------------------------------------------------

// Neighbor

// uint32 node_id = 1;
inline void Neighbor::clear_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_ = 0u;
}
inline ::uint32_t Neighbor::node_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.Neighbor.node_id)
  return _internal_node_id();
}
inline void Neighbor::set_node_id(::uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.Neighbor.node_id)
}
inline ::uint32_t Neighbor::_internal_node_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_id_;
}
inline void Neighbor::_internal_set_node_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_ = value;
}

// float snr = 2;
inline void Neighbor::clear_snr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snr_ = 0;
}
inline float Neighbor::snr() const {
  // @@protoc_insertion_point(field_get:meshtastic.Neighbor.snr)
  return _internal_snr();
}
inline void Neighbor::set_snr(float value) {
  _internal_set_snr(value);
  // @@protoc_insertion_point(field_set:meshtastic.Neighbor.snr)
}
inline float Neighbor::_internal_snr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snr_;
}
inline void Neighbor::_internal_set_snr(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snr_ = value;
}

// fixed32 last_rx_time = 3;
inline void Neighbor::clear_last_rx_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_rx_time_ = 0u;
}
inline ::uint32_t Neighbor::last_rx_time() const {
  // @@protoc_insertion_point(field_get:meshtastic.Neighbor.last_rx_time)
  return _internal_last_rx_time();
}
inline void Neighbor::set_last_rx_time(::uint32_t value) {
  _internal_set_last_rx_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.Neighbor.last_rx_time)
}
inline ::uint32_t Neighbor::_internal_last_rx_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_rx_time_;
}
inline void Neighbor::_internal_set_last_rx_time(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_rx_time_ = value;
}

// uint32 node_broadcast_interval_secs = 4;
inline void Neighbor::clear_node_broadcast_interval_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_broadcast_interval_secs_ = 0u;
}
inline ::uint32_t Neighbor::node_broadcast_interval_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Neighbor.node_broadcast_interval_secs)
  return _internal_node_broadcast_interval_secs();
}
inline void Neighbor::set_node_broadcast_interval_secs(::uint32_t value) {
  _internal_set_node_broadcast_interval_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Neighbor.node_broadcast_interval_secs)
}
inline ::uint32_t Neighbor::_internal_node_broadcast_interval_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_broadcast_interval_secs_;
}
inline void Neighbor::_internal_set_node_broadcast_interval_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_broadcast_interval_secs_ = value;
}

// -------------------------------------------------------------------

// DeviceMetadata

// string firmware_version = 1;
inline void DeviceMetadata::clear_firmware_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.firmware_version_.ClearToEmpty();
}
inline const std::string& DeviceMetadata::firmware_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.firmware_version)
  return _internal_firmware_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceMetadata::set_firmware_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.firmware_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.firmware_version)
}
inline std::string* DeviceMetadata::mutable_firmware_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_firmware_version();
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceMetadata.firmware_version)
  return _s;
}
inline const std::string& DeviceMetadata::_internal_firmware_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.firmware_version_.Get();
}
inline void DeviceMetadata::_internal_set_firmware_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.firmware_version_.Set(value, GetArena());
}
inline std::string* DeviceMetadata::_internal_mutable_firmware_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.firmware_version_.Mutable( GetArena());
}
inline std::string* DeviceMetadata::release_firmware_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.DeviceMetadata.firmware_version)
  return _impl_.firmware_version_.Release();
}
inline void DeviceMetadata::set_allocated_firmware_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.firmware_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.firmware_version_.IsDefault()) {
    _impl_.firmware_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.DeviceMetadata.firmware_version)
}

// uint32 device_state_version = 2;
inline void DeviceMetadata::clear_device_state_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_state_version_ = 0u;
}
inline ::uint32_t DeviceMetadata::device_state_version() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.device_state_version)
  return _internal_device_state_version();
}
inline void DeviceMetadata::set_device_state_version(::uint32_t value) {
  _internal_set_device_state_version(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.device_state_version)
}
inline ::uint32_t DeviceMetadata::_internal_device_state_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_state_version_;
}
inline void DeviceMetadata::_internal_set_device_state_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_state_version_ = value;
}

// bool canShutdown = 3;
inline void DeviceMetadata::clear_canshutdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.canshutdown_ = false;
}
inline bool DeviceMetadata::canshutdown() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.canShutdown)
  return _internal_canshutdown();
}
inline void DeviceMetadata::set_canshutdown(bool value) {
  _internal_set_canshutdown(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.canShutdown)
}
inline bool DeviceMetadata::_internal_canshutdown() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.canshutdown_;
}
inline void DeviceMetadata::_internal_set_canshutdown(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.canshutdown_ = value;
}

// bool hasWifi = 4;
inline void DeviceMetadata::clear_haswifi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.haswifi_ = false;
}
inline bool DeviceMetadata::haswifi() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hasWifi)
  return _internal_haswifi();
}
inline void DeviceMetadata::set_haswifi(bool value) {
  _internal_set_haswifi(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hasWifi)
}
inline bool DeviceMetadata::_internal_haswifi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.haswifi_;
}
inline void DeviceMetadata::_internal_set_haswifi(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.haswifi_ = value;
}

// bool hasBluetooth = 5;
inline void DeviceMetadata::clear_hasbluetooth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hasbluetooth_ = false;
}
inline bool DeviceMetadata::hasbluetooth() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hasBluetooth)
  return _internal_hasbluetooth();
}
inline void DeviceMetadata::set_hasbluetooth(bool value) {
  _internal_set_hasbluetooth(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hasBluetooth)
}
inline bool DeviceMetadata::_internal_hasbluetooth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hasbluetooth_;
}
inline void DeviceMetadata::_internal_set_hasbluetooth(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hasbluetooth_ = value;
}

// bool hasEthernet = 6;
inline void DeviceMetadata::clear_hasethernet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hasethernet_ = false;
}
inline bool DeviceMetadata::hasethernet() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hasEthernet)
  return _internal_hasethernet();
}
inline void DeviceMetadata::set_hasethernet(bool value) {
  _internal_set_hasethernet(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hasEthernet)
}
inline bool DeviceMetadata::_internal_hasethernet() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hasethernet_;
}
inline void DeviceMetadata::_internal_set_hasethernet(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hasethernet_ = value;
}

// .meshtastic.Config.DeviceConfig.Role role = 7;
inline void DeviceMetadata::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = 0;
}
inline ::meshtastic::Config_DeviceConfig_Role DeviceMetadata::role() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.role)
  return _internal_role();
}
inline void DeviceMetadata::set_role(::meshtastic::Config_DeviceConfig_Role value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.role)
}
inline ::meshtastic::Config_DeviceConfig_Role DeviceMetadata::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_DeviceConfig_Role>(_impl_.role_);
}
inline void DeviceMetadata::_internal_set_role(::meshtastic::Config_DeviceConfig_Role value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = value;
}

// uint32 position_flags = 8;
inline void DeviceMetadata::clear_position_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_flags_ = 0u;
}
inline ::uint32_t DeviceMetadata::position_flags() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.position_flags)
  return _internal_position_flags();
}
inline void DeviceMetadata::set_position_flags(::uint32_t value) {
  _internal_set_position_flags(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.position_flags)
}
inline ::uint32_t DeviceMetadata::_internal_position_flags() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.position_flags_;
}
inline void DeviceMetadata::_internal_set_position_flags(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_flags_ = value;
}

// .meshtastic.HardwareModel hw_model = 9;
inline void DeviceMetadata::clear_hw_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hw_model_ = 0;
}
inline ::meshtastic::HardwareModel DeviceMetadata::hw_model() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hw_model)
  return _internal_hw_model();
}
inline void DeviceMetadata::set_hw_model(::meshtastic::HardwareModel value) {
  _internal_set_hw_model(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hw_model)
}
inline ::meshtastic::HardwareModel DeviceMetadata::_internal_hw_model() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::HardwareModel>(_impl_.hw_model_);
}
inline void DeviceMetadata::_internal_set_hw_model(::meshtastic::HardwareModel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hw_model_ = value;
}

// bool hasRemoteHardware = 10;
inline void DeviceMetadata::clear_hasremotehardware() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hasremotehardware_ = false;
}
inline bool DeviceMetadata::hasremotehardware() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hasRemoteHardware)
  return _internal_hasremotehardware();
}
inline void DeviceMetadata::set_hasremotehardware(bool value) {
  _internal_set_hasremotehardware(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hasRemoteHardware)
}
inline bool DeviceMetadata::_internal_hasremotehardware() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hasremotehardware_;
}
inline void DeviceMetadata::_internal_set_hasremotehardware(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hasremotehardware_ = value;
}

// bool hasPKC = 11;
inline void DeviceMetadata::clear_haspkc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.haspkc_ = false;
}
inline bool DeviceMetadata::haspkc() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hasPKC)
  return _internal_haspkc();
}
inline void DeviceMetadata::set_haspkc(bool value) {
  _internal_set_haspkc(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hasPKC)
}
inline bool DeviceMetadata::_internal_haspkc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.haspkc_;
}
inline void DeviceMetadata::_internal_set_haspkc(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.haspkc_ = value;
}

// uint32 excluded_modules = 12;
inline void DeviceMetadata::clear_excluded_modules() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.excluded_modules_ = 0u;
}
inline ::uint32_t DeviceMetadata::excluded_modules() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.excluded_modules)
  return _internal_excluded_modules();
}
inline void DeviceMetadata::set_excluded_modules(::uint32_t value) {
  _internal_set_excluded_modules(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.excluded_modules)
}
inline ::uint32_t DeviceMetadata::_internal_excluded_modules() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.excluded_modules_;
}
inline void DeviceMetadata::_internal_set_excluded_modules(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.excluded_modules_ = value;
}

// -------------------------------------------------------------------

// Heartbeat

// uint32 nonce = 1;
inline void Heartbeat::clear_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = 0u;
}
inline ::uint32_t Heartbeat::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.Heartbeat.nonce)
  return _internal_nonce();
}
inline void Heartbeat::set_nonce(::uint32_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.Heartbeat.nonce)
}
inline ::uint32_t Heartbeat::_internal_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nonce_;
}
inline void Heartbeat::_internal_set_nonce(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = value;
}

// -------------------------------------------------------------------

// NodeRemoteHardwarePin

// uint32 node_num = 1;
inline void NodeRemoteHardwarePin::clear_node_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_num_ = 0u;
}
inline ::uint32_t NodeRemoteHardwarePin::node_num() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeRemoteHardwarePin.node_num)
  return _internal_node_num();
}
inline void NodeRemoteHardwarePin::set_node_num(::uint32_t value) {
  _internal_set_node_num(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeRemoteHardwarePin.node_num)
}
inline ::uint32_t NodeRemoteHardwarePin::_internal_node_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_num_;
}
inline void NodeRemoteHardwarePin::_internal_set_node_num(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_num_ = value;
}

// .meshtastic.RemoteHardwarePin pin = 2;
inline bool NodeRemoteHardwarePin::has_pin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pin_ != nullptr);
  return value;
}
inline const ::meshtastic::RemoteHardwarePin& NodeRemoteHardwarePin::_internal_pin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::RemoteHardwarePin* p = _impl_.pin_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::RemoteHardwarePin&>(::meshtastic::_RemoteHardwarePin_default_instance_);
}
inline const ::meshtastic::RemoteHardwarePin& NodeRemoteHardwarePin::pin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.NodeRemoteHardwarePin.pin)
  return _internal_pin();
}
inline void NodeRemoteHardwarePin::unsafe_arena_set_allocated_pin(::meshtastic::RemoteHardwarePin* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pin_);
  }
  _impl_.pin_ = reinterpret_cast<::meshtastic::RemoteHardwarePin*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeRemoteHardwarePin.pin)
}
inline ::meshtastic::RemoteHardwarePin* NodeRemoteHardwarePin::release_pin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::meshtastic::RemoteHardwarePin* released = _impl_.pin_;
  _impl_.pin_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::RemoteHardwarePin* NodeRemoteHardwarePin::unsafe_arena_release_pin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.NodeRemoteHardwarePin.pin)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::meshtastic::RemoteHardwarePin* temp = _impl_.pin_;
  _impl_.pin_ = nullptr;
  return temp;
}
inline ::meshtastic::RemoteHardwarePin* NodeRemoteHardwarePin::_internal_mutable_pin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pin_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::RemoteHardwarePin>(GetArena());
    _impl_.pin_ = reinterpret_cast<::meshtastic::RemoteHardwarePin*>(p);
  }
  return _impl_.pin_;
}
inline ::meshtastic::RemoteHardwarePin* NodeRemoteHardwarePin::mutable_pin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::meshtastic::RemoteHardwarePin* _msg = _internal_mutable_pin();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeRemoteHardwarePin.pin)
  return _msg;
}
inline void NodeRemoteHardwarePin::set_allocated_pin(::meshtastic::RemoteHardwarePin* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pin_ = reinterpret_cast<::meshtastic::RemoteHardwarePin*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeRemoteHardwarePin.pin)
}

// -------------------------------------------------------------------

// ChunkedPayload

// uint32 payload_id = 1;
inline void ChunkedPayload::clear_payload_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_id_ = 0u;
}
inline ::uint32_t ChunkedPayload::payload_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayload.payload_id)
  return _internal_payload_id();
}
inline void ChunkedPayload::set_payload_id(::uint32_t value) {
  _internal_set_payload_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayload.payload_id)
}
inline ::uint32_t ChunkedPayload::_internal_payload_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_id_;
}
inline void ChunkedPayload::_internal_set_payload_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_id_ = value;
}

// uint32 chunk_count = 2;
inline void ChunkedPayload::clear_chunk_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunk_count_ = 0u;
}
inline ::uint32_t ChunkedPayload::chunk_count() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayload.chunk_count)
  return _internal_chunk_count();
}
inline void ChunkedPayload::set_chunk_count(::uint32_t value) {
  _internal_set_chunk_count(value);
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayload.chunk_count)
}
inline ::uint32_t ChunkedPayload::_internal_chunk_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.chunk_count_;
}
inline void ChunkedPayload::_internal_set_chunk_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunk_count_ = value;
}

// uint32 chunk_index = 3;
inline void ChunkedPayload::clear_chunk_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunk_index_ = 0u;
}
inline ::uint32_t ChunkedPayload::chunk_index() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayload.chunk_index)
  return _internal_chunk_index();
}
inline void ChunkedPayload::set_chunk_index(::uint32_t value) {
  _internal_set_chunk_index(value);
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayload.chunk_index)
}
inline ::uint32_t ChunkedPayload::_internal_chunk_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.chunk_index_;
}
inline void ChunkedPayload::_internal_set_chunk_index(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunk_index_ = value;
}

// bytes payload_chunk = 4;
inline void ChunkedPayload::clear_payload_chunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_chunk_.ClearToEmpty();
}
inline const std::string& ChunkedPayload::payload_chunk() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayload.payload_chunk)
  return _internal_payload_chunk();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChunkedPayload::set_payload_chunk(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_chunk_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayload.payload_chunk)
}
inline std::string* ChunkedPayload::mutable_payload_chunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload_chunk();
  // @@protoc_insertion_point(field_mutable:meshtastic.ChunkedPayload.payload_chunk)
  return _s;
}
inline const std::string& ChunkedPayload::_internal_payload_chunk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_chunk_.Get();
}
inline void ChunkedPayload::_internal_set_payload_chunk(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_chunk_.Set(value, GetArena());
}
inline std::string* ChunkedPayload::_internal_mutable_payload_chunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_chunk_.Mutable( GetArena());
}
inline std::string* ChunkedPayload::release_payload_chunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.ChunkedPayload.payload_chunk)
  return _impl_.payload_chunk_.Release();
}
inline void ChunkedPayload::set_allocated_payload_chunk(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_chunk_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.payload_chunk_.IsDefault()) {
    _impl_.payload_chunk_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ChunkedPayload.payload_chunk)
}

// -------------------------------------------------------------------

// resend_chunks

// repeated uint32 chunks = 1;
inline int resend_chunks::_internal_chunks_size() const {
  return _internal_chunks().size();
}
inline int resend_chunks::chunks_size() const {
  return _internal_chunks_size();
}
inline void resend_chunks::clear_chunks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunks_.Clear();
}
inline ::uint32_t resend_chunks::chunks(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.resend_chunks.chunks)
  return _internal_chunks().Get(index);
}
inline void resend_chunks::set_chunks(int index, ::uint32_t value) {
  _internal_mutable_chunks()->Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.resend_chunks.chunks)
}
inline void resend_chunks::add_chunks(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_chunks()->Add(value);
  // @@protoc_insertion_point(field_add:meshtastic.resend_chunks.chunks)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& resend_chunks::chunks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.resend_chunks.chunks)
  return _internal_chunks();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* resend_chunks::mutable_chunks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.resend_chunks.chunks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_chunks();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
resend_chunks::_internal_chunks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.chunks_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* resend_chunks::_internal_mutable_chunks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.chunks_;
}

// -------------------------------------------------------------------

// ChunkedPayloadResponse

// uint32 payload_id = 1;
inline void ChunkedPayloadResponse::clear_payload_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_id_ = 0u;
}
inline ::uint32_t ChunkedPayloadResponse::payload_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayloadResponse.payload_id)
  return _internal_payload_id();
}
inline void ChunkedPayloadResponse::set_payload_id(::uint32_t value) {
  _internal_set_payload_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayloadResponse.payload_id)
}
inline ::uint32_t ChunkedPayloadResponse::_internal_payload_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_id_;
}
inline void ChunkedPayloadResponse::_internal_set_payload_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_id_ = value;
}

// bool request_transfer = 2;
inline bool ChunkedPayloadResponse::has_request_transfer() const {
  return payload_variant_case() == kRequestTransfer;
}
inline void ChunkedPayloadResponse::set_has_request_transfer() {
  _impl_._oneof_case_[0] = kRequestTransfer;
}
inline void ChunkedPayloadResponse::clear_request_transfer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kRequestTransfer) {
    _impl_.payload_variant_.request_transfer_ = false;
    clear_has_payload_variant();
  }
}
inline bool ChunkedPayloadResponse::request_transfer() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayloadResponse.request_transfer)
  return _internal_request_transfer();
}
inline void ChunkedPayloadResponse::set_request_transfer(bool value) {
  if (payload_variant_case() != kRequestTransfer) {
    clear_payload_variant();
    set_has_request_transfer();
  }
  _impl_.payload_variant_.request_transfer_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayloadResponse.request_transfer)
}
inline bool ChunkedPayloadResponse::_internal_request_transfer() const {
  if (payload_variant_case() == kRequestTransfer) {
    return _impl_.payload_variant_.request_transfer_;
  }
  return false;
}

// bool accept_transfer = 3;
inline bool ChunkedPayloadResponse::has_accept_transfer() const {
  return payload_variant_case() == kAcceptTransfer;
}
inline void ChunkedPayloadResponse::set_has_accept_transfer() {
  _impl_._oneof_case_[0] = kAcceptTransfer;
}
inline void ChunkedPayloadResponse::clear_accept_transfer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kAcceptTransfer) {
    _impl_.payload_variant_.accept_transfer_ = false;
    clear_has_payload_variant();
  }
}
inline bool ChunkedPayloadResponse::accept_transfer() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayloadResponse.accept_transfer)
  return _internal_accept_transfer();
}
inline void ChunkedPayloadResponse::set_accept_transfer(bool value) {
  if (payload_variant_case() != kAcceptTransfer) {
    clear_payload_variant();
    set_has_accept_transfer();
  }
  _impl_.payload_variant_.accept_transfer_ = value;
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayloadResponse.accept_transfer)
}
inline bool ChunkedPayloadResponse::_internal_accept_transfer() const {
  if (payload_variant_case() == kAcceptTransfer) {
    return _impl_.payload_variant_.accept_transfer_;
  }
  return false;
}

// .meshtastic.resend_chunks resend_chunks = 4;
inline bool ChunkedPayloadResponse::has_resend_chunks() const {
  return payload_variant_case() == kResendChunks;
}
inline bool ChunkedPayloadResponse::_internal_has_resend_chunks() const {
  return payload_variant_case() == kResendChunks;
}
inline void ChunkedPayloadResponse::set_has_resend_chunks() {
  _impl_._oneof_case_[0] = kResendChunks;
}
inline void ChunkedPayloadResponse::clear_resend_chunks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kResendChunks) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.resend_chunks_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.resend_chunks_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::resend_chunks* ChunkedPayloadResponse::release_resend_chunks() {
  // @@protoc_insertion_point(field_release:meshtastic.ChunkedPayloadResponse.resend_chunks)
  if (payload_variant_case() == kResendChunks) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.resend_chunks_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.resend_chunks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::resend_chunks& ChunkedPayloadResponse::_internal_resend_chunks() const {
  return payload_variant_case() == kResendChunks ? *_impl_.payload_variant_.resend_chunks_ : reinterpret_cast<::meshtastic::resend_chunks&>(::meshtastic::_resend_chunks_default_instance_);
}
inline const ::meshtastic::resend_chunks& ChunkedPayloadResponse::resend_chunks() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayloadResponse.resend_chunks)
  return _internal_resend_chunks();
}
inline ::meshtastic::resend_chunks* ChunkedPayloadResponse::unsafe_arena_release_resend_chunks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ChunkedPayloadResponse.resend_chunks)
  if (payload_variant_case() == kResendChunks) {
    clear_has_payload_variant();
    auto* temp = _impl_.payload_variant_.resend_chunks_;
    _impl_.payload_variant_.resend_chunks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChunkedPayloadResponse::unsafe_arena_set_allocated_resend_chunks(::meshtastic::resend_chunks* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_resend_chunks();
    _impl_.payload_variant_.resend_chunks_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ChunkedPayloadResponse.resend_chunks)
}
inline ::meshtastic::resend_chunks* ChunkedPayloadResponse::_internal_mutable_resend_chunks() {
  if (payload_variant_case() != kResendChunks) {
    clear_payload_variant();
    set_has_resend_chunks();
    _impl_.payload_variant_.resend_chunks_ =
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::resend_chunks>(GetArena());
  }
  return _impl_.payload_variant_.resend_chunks_;
}
inline ::meshtastic::resend_chunks* ChunkedPayloadResponse::mutable_resend_chunks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::resend_chunks* _msg = _internal_mutable_resend_chunks();
  // @@protoc_insertion_point(field_mutable:meshtastic.ChunkedPayloadResponse.resend_chunks)
  return _msg;
}

inline bool ChunkedPayloadResponse::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void ChunkedPayloadResponse::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline ChunkedPayloadResponse::PayloadVariantCase ChunkedPayloadResponse::payload_variant_case() const {
  return ChunkedPayloadResponse::PayloadVariantCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace meshtastic


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::meshtastic::Position_LocSource> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::Position_LocSource>() {
  return ::meshtastic::Position_LocSource_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Position_AltSource> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::Position_AltSource>() {
  return ::meshtastic::Position_AltSource_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Routing_Error> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::Routing_Error>() {
  return ::meshtastic::Routing_Error_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::MeshPacket_Priority> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::MeshPacket_Priority>() {
  return ::meshtastic::MeshPacket_Priority_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::MeshPacket_Delayed> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::MeshPacket_Delayed>() {
  return ::meshtastic::MeshPacket_Delayed_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::MeshPacket_TransportMechanism> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::MeshPacket_TransportMechanism>() {
  return ::meshtastic::MeshPacket_TransportMechanism_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::LogRecord_Level> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::LogRecord_Level>() {
  return ::meshtastic::LogRecord_Level_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::HardwareModel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::HardwareModel>() {
  return ::meshtastic::HardwareModel_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Constants> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::Constants>() {
  return ::meshtastic::Constants_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::CriticalErrorCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::CriticalErrorCode>() {
  return ::meshtastic::CriticalErrorCode_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::FirmwareEdition> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::FirmwareEdition>() {
  return ::meshtastic::FirmwareEdition_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::ExcludedModules> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::meshtastic::ExcludedModules>() {
  return ::meshtastic::ExcludedModules_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // meshtastic_2fmesh_2eproto_2epb_2eh
