// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meshtastic/mesh.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fmesh_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fmesh_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "meshtastic/channel.pb.h"
#include "meshtastic/config.pb.h"
#include "meshtastic/device_ui.pb.h"
#include "meshtastic/module_config.pb.h"
#include "meshtastic/portnums.pb.h"
#include "meshtastic/telemetry.pb.h"
#include "meshtastic/xmodem.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_meshtastic_2fmesh_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_meshtastic_2fmesh_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_meshtastic_2fmesh_2eproto;
namespace meshtastic {
class ChunkedPayload;
struct ChunkedPayloadDefaultTypeInternal;
extern ChunkedPayloadDefaultTypeInternal _ChunkedPayload_default_instance_;
class ChunkedPayloadResponse;
struct ChunkedPayloadResponseDefaultTypeInternal;
extern ChunkedPayloadResponseDefaultTypeInternal _ChunkedPayloadResponse_default_instance_;
class ClientNotification;
struct ClientNotificationDefaultTypeInternal;
extern ClientNotificationDefaultTypeInternal _ClientNotification_default_instance_;
class Compressed;
struct CompressedDefaultTypeInternal;
extern CompressedDefaultTypeInternal _Compressed_default_instance_;
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class DeviceMetadata;
struct DeviceMetadataDefaultTypeInternal;
extern DeviceMetadataDefaultTypeInternal _DeviceMetadata_default_instance_;
class DuplicatedPublicKey;
struct DuplicatedPublicKeyDefaultTypeInternal;
extern DuplicatedPublicKeyDefaultTypeInternal _DuplicatedPublicKey_default_instance_;
class FileInfo;
struct FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class FromRadio;
struct FromRadioDefaultTypeInternal;
extern FromRadioDefaultTypeInternal _FromRadio_default_instance_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class KeyVerification;
struct KeyVerificationDefaultTypeInternal;
extern KeyVerificationDefaultTypeInternal _KeyVerification_default_instance_;
class KeyVerificationFinal;
struct KeyVerificationFinalDefaultTypeInternal;
extern KeyVerificationFinalDefaultTypeInternal _KeyVerificationFinal_default_instance_;
class KeyVerificationNumberInform;
struct KeyVerificationNumberInformDefaultTypeInternal;
extern KeyVerificationNumberInformDefaultTypeInternal _KeyVerificationNumberInform_default_instance_;
class KeyVerificationNumberRequest;
struct KeyVerificationNumberRequestDefaultTypeInternal;
extern KeyVerificationNumberRequestDefaultTypeInternal _KeyVerificationNumberRequest_default_instance_;
class LogRecord;
struct LogRecordDefaultTypeInternal;
extern LogRecordDefaultTypeInternal _LogRecord_default_instance_;
class LowEntropyKey;
struct LowEntropyKeyDefaultTypeInternal;
extern LowEntropyKeyDefaultTypeInternal _LowEntropyKey_default_instance_;
class MeshPacket;
struct MeshPacketDefaultTypeInternal;
extern MeshPacketDefaultTypeInternal _MeshPacket_default_instance_;
class MqttClientProxyMessage;
struct MqttClientProxyMessageDefaultTypeInternal;
extern MqttClientProxyMessageDefaultTypeInternal _MqttClientProxyMessage_default_instance_;
class MyNodeInfo;
struct MyNodeInfoDefaultTypeInternal;
extern MyNodeInfoDefaultTypeInternal _MyNodeInfo_default_instance_;
class Neighbor;
struct NeighborDefaultTypeInternal;
extern NeighborDefaultTypeInternal _Neighbor_default_instance_;
class NeighborInfo;
struct NeighborInfoDefaultTypeInternal;
extern NeighborInfoDefaultTypeInternal _NeighborInfo_default_instance_;
class NodeInfo;
struct NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class NodeRemoteHardwarePin;
struct NodeRemoteHardwarePinDefaultTypeInternal;
extern NodeRemoteHardwarePinDefaultTypeInternal _NodeRemoteHardwarePin_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class QueueStatus;
struct QueueStatusDefaultTypeInternal;
extern QueueStatusDefaultTypeInternal _QueueStatus_default_instance_;
class RouteDiscovery;
struct RouteDiscoveryDefaultTypeInternal;
extern RouteDiscoveryDefaultTypeInternal _RouteDiscovery_default_instance_;
class Routing;
struct RoutingDefaultTypeInternal;
extern RoutingDefaultTypeInternal _Routing_default_instance_;
class ToRadio;
struct ToRadioDefaultTypeInternal;
extern ToRadioDefaultTypeInternal _ToRadio_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class Waypoint;
struct WaypointDefaultTypeInternal;
extern WaypointDefaultTypeInternal _Waypoint_default_instance_;
class resend_chunks;
struct resend_chunksDefaultTypeInternal;
extern resend_chunksDefaultTypeInternal _resend_chunks_default_instance_;
}  // namespace meshtastic
PROTOBUF_NAMESPACE_OPEN
template<> ::meshtastic::ChunkedPayload* Arena::CreateMaybeMessage<::meshtastic::ChunkedPayload>(Arena*);
template<> ::meshtastic::ChunkedPayloadResponse* Arena::CreateMaybeMessage<::meshtastic::ChunkedPayloadResponse>(Arena*);
template<> ::meshtastic::ClientNotification* Arena::CreateMaybeMessage<::meshtastic::ClientNotification>(Arena*);
template<> ::meshtastic::Compressed* Arena::CreateMaybeMessage<::meshtastic::Compressed>(Arena*);
template<> ::meshtastic::Data* Arena::CreateMaybeMessage<::meshtastic::Data>(Arena*);
template<> ::meshtastic::DeviceMetadata* Arena::CreateMaybeMessage<::meshtastic::DeviceMetadata>(Arena*);
template<> ::meshtastic::DuplicatedPublicKey* Arena::CreateMaybeMessage<::meshtastic::DuplicatedPublicKey>(Arena*);
template<> ::meshtastic::FileInfo* Arena::CreateMaybeMessage<::meshtastic::FileInfo>(Arena*);
template<> ::meshtastic::FromRadio* Arena::CreateMaybeMessage<::meshtastic::FromRadio>(Arena*);
template<> ::meshtastic::Heartbeat* Arena::CreateMaybeMessage<::meshtastic::Heartbeat>(Arena*);
template<> ::meshtastic::KeyVerification* Arena::CreateMaybeMessage<::meshtastic::KeyVerification>(Arena*);
template<> ::meshtastic::KeyVerificationFinal* Arena::CreateMaybeMessage<::meshtastic::KeyVerificationFinal>(Arena*);
template<> ::meshtastic::KeyVerificationNumberInform* Arena::CreateMaybeMessage<::meshtastic::KeyVerificationNumberInform>(Arena*);
template<> ::meshtastic::KeyVerificationNumberRequest* Arena::CreateMaybeMessage<::meshtastic::KeyVerificationNumberRequest>(Arena*);
template<> ::meshtastic::LogRecord* Arena::CreateMaybeMessage<::meshtastic::LogRecord>(Arena*);
template<> ::meshtastic::LowEntropyKey* Arena::CreateMaybeMessage<::meshtastic::LowEntropyKey>(Arena*);
template<> ::meshtastic::MeshPacket* Arena::CreateMaybeMessage<::meshtastic::MeshPacket>(Arena*);
template<> ::meshtastic::MqttClientProxyMessage* Arena::CreateMaybeMessage<::meshtastic::MqttClientProxyMessage>(Arena*);
template<> ::meshtastic::MyNodeInfo* Arena::CreateMaybeMessage<::meshtastic::MyNodeInfo>(Arena*);
template<> ::meshtastic::Neighbor* Arena::CreateMaybeMessage<::meshtastic::Neighbor>(Arena*);
template<> ::meshtastic::NeighborInfo* Arena::CreateMaybeMessage<::meshtastic::NeighborInfo>(Arena*);
template<> ::meshtastic::NodeInfo* Arena::CreateMaybeMessage<::meshtastic::NodeInfo>(Arena*);
template<> ::meshtastic::NodeRemoteHardwarePin* Arena::CreateMaybeMessage<::meshtastic::NodeRemoteHardwarePin>(Arena*);
template<> ::meshtastic::Position* Arena::CreateMaybeMessage<::meshtastic::Position>(Arena*);
template<> ::meshtastic::QueueStatus* Arena::CreateMaybeMessage<::meshtastic::QueueStatus>(Arena*);
template<> ::meshtastic::RouteDiscovery* Arena::CreateMaybeMessage<::meshtastic::RouteDiscovery>(Arena*);
template<> ::meshtastic::Routing* Arena::CreateMaybeMessage<::meshtastic::Routing>(Arena*);
template<> ::meshtastic::ToRadio* Arena::CreateMaybeMessage<::meshtastic::ToRadio>(Arena*);
template<> ::meshtastic::User* Arena::CreateMaybeMessage<::meshtastic::User>(Arena*);
template<> ::meshtastic::Waypoint* Arena::CreateMaybeMessage<::meshtastic::Waypoint>(Arena*);
template<> ::meshtastic::resend_chunks* Arena::CreateMaybeMessage<::meshtastic::resend_chunks>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace meshtastic {

enum Position_LocSource : int {
  Position_LocSource_LOC_UNSET = 0,
  Position_LocSource_LOC_MANUAL = 1,
  Position_LocSource_LOC_INTERNAL = 2,
  Position_LocSource_LOC_EXTERNAL = 3,
  Position_LocSource_Position_LocSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Position_LocSource_Position_LocSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Position_LocSource_IsValid(int value);
constexpr Position_LocSource Position_LocSource_LocSource_MIN = Position_LocSource_LOC_UNSET;
constexpr Position_LocSource Position_LocSource_LocSource_MAX = Position_LocSource_LOC_EXTERNAL;
constexpr int Position_LocSource_LocSource_ARRAYSIZE = Position_LocSource_LocSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Position_LocSource_descriptor();
template<typename T>
inline const std::string& Position_LocSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Position_LocSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Position_LocSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Position_LocSource_descriptor(), enum_t_value);
}
inline bool Position_LocSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Position_LocSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Position_LocSource>(
    Position_LocSource_descriptor(), name, value);
}
enum Position_AltSource : int {
  Position_AltSource_ALT_UNSET = 0,
  Position_AltSource_ALT_MANUAL = 1,
  Position_AltSource_ALT_INTERNAL = 2,
  Position_AltSource_ALT_EXTERNAL = 3,
  Position_AltSource_ALT_BAROMETRIC = 4,
  Position_AltSource_Position_AltSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Position_AltSource_Position_AltSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Position_AltSource_IsValid(int value);
constexpr Position_AltSource Position_AltSource_AltSource_MIN = Position_AltSource_ALT_UNSET;
constexpr Position_AltSource Position_AltSource_AltSource_MAX = Position_AltSource_ALT_BAROMETRIC;
constexpr int Position_AltSource_AltSource_ARRAYSIZE = Position_AltSource_AltSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Position_AltSource_descriptor();
template<typename T>
inline const std::string& Position_AltSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Position_AltSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Position_AltSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Position_AltSource_descriptor(), enum_t_value);
}
inline bool Position_AltSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Position_AltSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Position_AltSource>(
    Position_AltSource_descriptor(), name, value);
}
enum Routing_Error : int {
  Routing_Error_NONE = 0,
  Routing_Error_NO_ROUTE = 1,
  Routing_Error_GOT_NAK = 2,
  Routing_Error_TIMEOUT = 3,
  Routing_Error_NO_INTERFACE = 4,
  Routing_Error_MAX_RETRANSMIT = 5,
  Routing_Error_NO_CHANNEL = 6,
  Routing_Error_TOO_LARGE = 7,
  Routing_Error_NO_RESPONSE = 8,
  Routing_Error_DUTY_CYCLE_LIMIT = 9,
  Routing_Error_BAD_REQUEST = 32,
  Routing_Error_NOT_AUTHORIZED = 33,
  Routing_Error_PKI_FAILED = 34,
  Routing_Error_PKI_UNKNOWN_PUBKEY = 35,
  Routing_Error_ADMIN_BAD_SESSION_KEY = 36,
  Routing_Error_ADMIN_PUBLIC_KEY_UNAUTHORIZED = 37,
  Routing_Error_RATE_LIMIT_EXCEEDED = 38,
  Routing_Error_Routing_Error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Routing_Error_Routing_Error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Routing_Error_IsValid(int value);
constexpr Routing_Error Routing_Error_Error_MIN = Routing_Error_NONE;
constexpr Routing_Error Routing_Error_Error_MAX = Routing_Error_RATE_LIMIT_EXCEEDED;
constexpr int Routing_Error_Error_ARRAYSIZE = Routing_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Routing_Error_descriptor();
template<typename T>
inline const std::string& Routing_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Routing_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Routing_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Routing_Error_descriptor(), enum_t_value);
}
inline bool Routing_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Routing_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Routing_Error>(
    Routing_Error_descriptor(), name, value);
}
enum MeshPacket_Priority : int {
  MeshPacket_Priority_UNSET = 0,
  MeshPacket_Priority_MIN = 1,
  MeshPacket_Priority_BACKGROUND = 10,
  MeshPacket_Priority_DEFAULT = 64,
  MeshPacket_Priority_RELIABLE = 70,
  MeshPacket_Priority_RESPONSE = 80,
  MeshPacket_Priority_HIGH = 100,
  MeshPacket_Priority_ALERT = 110,
  MeshPacket_Priority_ACK = 120,
  MeshPacket_Priority_MAX = 127,
  MeshPacket_Priority_MeshPacket_Priority_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MeshPacket_Priority_MeshPacket_Priority_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MeshPacket_Priority_IsValid(int value);
constexpr MeshPacket_Priority MeshPacket_Priority_Priority_MIN = MeshPacket_Priority_UNSET;
constexpr MeshPacket_Priority MeshPacket_Priority_Priority_MAX = MeshPacket_Priority_MAX;
constexpr int MeshPacket_Priority_Priority_ARRAYSIZE = MeshPacket_Priority_Priority_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MeshPacket_Priority_descriptor();
template<typename T>
inline const std::string& MeshPacket_Priority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MeshPacket_Priority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MeshPacket_Priority_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MeshPacket_Priority_descriptor(), enum_t_value);
}
inline bool MeshPacket_Priority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MeshPacket_Priority* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MeshPacket_Priority>(
    MeshPacket_Priority_descriptor(), name, value);
}
enum MeshPacket_Delayed : int {
  MeshPacket_Delayed_NO_DELAY = 0,
  MeshPacket_Delayed_DELAYED_BROADCAST = 1,
  MeshPacket_Delayed_DELAYED_DIRECT = 2,
  MeshPacket_Delayed_MeshPacket_Delayed_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MeshPacket_Delayed_MeshPacket_Delayed_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MeshPacket_Delayed_IsValid(int value);
constexpr MeshPacket_Delayed MeshPacket_Delayed_Delayed_MIN = MeshPacket_Delayed_NO_DELAY;
constexpr MeshPacket_Delayed MeshPacket_Delayed_Delayed_MAX = MeshPacket_Delayed_DELAYED_DIRECT;
constexpr int MeshPacket_Delayed_Delayed_ARRAYSIZE = MeshPacket_Delayed_Delayed_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MeshPacket_Delayed_descriptor();
template<typename T>
inline const std::string& MeshPacket_Delayed_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MeshPacket_Delayed>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MeshPacket_Delayed_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MeshPacket_Delayed_descriptor(), enum_t_value);
}
inline bool MeshPacket_Delayed_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MeshPacket_Delayed* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MeshPacket_Delayed>(
    MeshPacket_Delayed_descriptor(), name, value);
}
enum MeshPacket_TransportMechanism : int {
  MeshPacket_TransportMechanism_TRANSPORT_INTERNAL = 0,
  MeshPacket_TransportMechanism_TRANSPORT_LORA = 1,
  MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT1 = 2,
  MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT2 = 3,
  MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT3 = 4,
  MeshPacket_TransportMechanism_TRANSPORT_MQTT = 5,
  MeshPacket_TransportMechanism_TRANSPORT_MULTICAST_UDP = 6,
  MeshPacket_TransportMechanism_TRANSPORT_API = 7,
  MeshPacket_TransportMechanism_MeshPacket_TransportMechanism_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MeshPacket_TransportMechanism_MeshPacket_TransportMechanism_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MeshPacket_TransportMechanism_IsValid(int value);
constexpr MeshPacket_TransportMechanism MeshPacket_TransportMechanism_TransportMechanism_MIN = MeshPacket_TransportMechanism_TRANSPORT_INTERNAL;
constexpr MeshPacket_TransportMechanism MeshPacket_TransportMechanism_TransportMechanism_MAX = MeshPacket_TransportMechanism_TRANSPORT_API;
constexpr int MeshPacket_TransportMechanism_TransportMechanism_ARRAYSIZE = MeshPacket_TransportMechanism_TransportMechanism_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MeshPacket_TransportMechanism_descriptor();
template<typename T>
inline const std::string& MeshPacket_TransportMechanism_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MeshPacket_TransportMechanism>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MeshPacket_TransportMechanism_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MeshPacket_TransportMechanism_descriptor(), enum_t_value);
}
inline bool MeshPacket_TransportMechanism_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MeshPacket_TransportMechanism* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MeshPacket_TransportMechanism>(
    MeshPacket_TransportMechanism_descriptor(), name, value);
}
enum LogRecord_Level : int {
  LogRecord_Level_UNSET = 0,
  LogRecord_Level_CRITICAL = 50,
  LogRecord_Level_ERROR = 40,
  LogRecord_Level_WARNING = 30,
  LogRecord_Level_INFO = 20,
  LogRecord_Level_DEBUG = 10,
  LogRecord_Level_TRACE = 5,
  LogRecord_Level_LogRecord_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LogRecord_Level_LogRecord_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LogRecord_Level_IsValid(int value);
constexpr LogRecord_Level LogRecord_Level_Level_MIN = LogRecord_Level_UNSET;
constexpr LogRecord_Level LogRecord_Level_Level_MAX = LogRecord_Level_CRITICAL;
constexpr int LogRecord_Level_Level_ARRAYSIZE = LogRecord_Level_Level_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogRecord_Level_descriptor();
template<typename T>
inline const std::string& LogRecord_Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogRecord_Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogRecord_Level_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogRecord_Level_descriptor(), enum_t_value);
}
inline bool LogRecord_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogRecord_Level* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogRecord_Level>(
    LogRecord_Level_descriptor(), name, value);
}
enum HardwareModel : int {
  UNSET = 0,
  TLORA_V2 = 1,
  TLORA_V1 = 2,
  TLORA_V2_1_1P6 = 3,
  TBEAM = 4,
  HELTEC_V2_0 = 5,
  TBEAM_V0P7 = 6,
  T_ECHO = 7,
  TLORA_V1_1P3 = 8,
  RAK4631 = 9,
  HELTEC_V2_1 = 10,
  HELTEC_V1 = 11,
  LILYGO_TBEAM_S3_CORE = 12,
  RAK11200 = 13,
  NANO_G1 = 14,
  TLORA_V2_1_1P8 = 15,
  TLORA_T3_S3 = 16,
  NANO_G1_EXPLORER = 17,
  NANO_G2_ULTRA = 18,
  LORA_TYPE = 19,
  WIPHONE = 20,
  WIO_WM1110 = 21,
  RAK2560 = 22,
  HELTEC_HRU_3601 = 23,
  HELTEC_WIRELESS_BRIDGE = 24,
  STATION_G1 = 25,
  RAK11310 = 26,
  SENSELORA_RP2040 = 27,
  SENSELORA_S3 = 28,
  CANARYONE = 29,
  RP2040_LORA = 30,
  STATION_G2 = 31,
  LORA_RELAY_V1 = 32,
  NRF52840DK = 33,
  PPR = 34,
  GENIEBLOCKS = 35,
  NRF52_UNKNOWN = 36,
  PORTDUINO = 37,
  ANDROID_SIM = 38,
  DIY_V1 = 39,
  NRF52840_PCA10059 = 40,
  DR_DEV = 41,
  M5STACK = 42,
  HELTEC_V3 = 43,
  HELTEC_WSL_V3 = 44,
  BETAFPV_2400_TX = 45,
  BETAFPV_900_NANO_TX = 46,
  RPI_PICO = 47,
  HELTEC_WIRELESS_TRACKER = 48,
  HELTEC_WIRELESS_PAPER = 49,
  T_DECK = 50,
  T_WATCH_S3 = 51,
  PICOMPUTER_S3 = 52,
  HELTEC_HT62 = 53,
  EBYTE_ESP32_S3 = 54,
  ESP32_S3_PICO = 55,
  CHATTER_2 = 56,
  HELTEC_WIRELESS_PAPER_V1_0 = 57,
  HELTEC_WIRELESS_TRACKER_V1_0 = 58,
  UNPHONE = 59,
  TD_LORAC = 60,
  CDEBYTE_EORA_S3 = 61,
  TWC_MESH_V4 = 62,
  NRF52_PROMICRO_DIY = 63,
  RADIOMASTER_900_BANDIT_NANO = 64,
  HELTEC_CAPSULE_SENSOR_V3 = 65,
  HELTEC_VISION_MASTER_T190 = 66,
  HELTEC_VISION_MASTER_E213 = 67,
  HELTEC_VISION_MASTER_E290 = 68,
  HELTEC_MESH_NODE_T114 = 69,
  SENSECAP_INDICATOR = 70,
  TRACKER_T1000_E = 71,
  RAK3172 = 72,
  WIO_E5 = 73,
  RADIOMASTER_900_BANDIT = 74,
  ME25LS01_4Y10TD = 75,
  RP2040_FEATHER_RFM95 = 76,
  M5STACK_COREBASIC = 77,
  M5STACK_CORE2 = 78,
  RPI_PICO2 = 79,
  M5STACK_CORES3 = 80,
  SEEED_XIAO_S3 = 81,
  MS24SF1 = 82,
  TLORA_C6 = 83,
  WISMESH_TAP = 84,
  ROUTASTIC = 85,
  MESH_TAB = 86,
  MESHLINK = 87,
  XIAO_NRF52_KIT = 88,
  THINKNODE_M1 = 89,
  THINKNODE_M2 = 90,
  T_ETH_ELITE = 91,
  HELTEC_SENSOR_HUB = 92,
  RESERVED_FRIED_CHICKEN = 93,
  HELTEC_MESH_POCKET = 94,
  SEEED_SOLAR_NODE = 95,
  NOMADSTAR_METEOR_PRO = 96,
  CROWPANEL = 97,
  LINK_32 = 98,
  SEEED_WIO_TRACKER_L1 = 99,
  SEEED_WIO_TRACKER_L1_EINK = 100,
  QWANTZ_TINY_ARMS = 101,
  T_DECK_PRO = 102,
  T_LORA_PAGER = 103,
  M5STACK_RESERVED = 104,
  WISMESH_TAG = 105,
  RAK3312 = 106,
  THINKNODE_M5 = 107,
  HELTEC_MESH_SOLAR = 108,
  T_ECHO_LITE = 109,
  HELTEC_V4 = 110,
  M5STACK_C6L = 111,
  PRIVATE_HW = 255,
  HardwareModel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HardwareModel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HardwareModel_IsValid(int value);
constexpr HardwareModel HardwareModel_MIN = UNSET;
constexpr HardwareModel HardwareModel_MAX = PRIVATE_HW;
constexpr int HardwareModel_ARRAYSIZE = HardwareModel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HardwareModel_descriptor();
template<typename T>
inline const std::string& HardwareModel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HardwareModel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HardwareModel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HardwareModel_descriptor(), enum_t_value);
}
inline bool HardwareModel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HardwareModel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HardwareModel>(
    HardwareModel_descriptor(), name, value);
}
enum Constants : int {
  ZERO = 0,
  DATA_PAYLOAD_LEN = 233,
  Constants_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Constants_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Constants_IsValid(int value);
constexpr Constants Constants_MIN = ZERO;
constexpr Constants Constants_MAX = DATA_PAYLOAD_LEN;
constexpr int Constants_ARRAYSIZE = Constants_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Constants_descriptor();
template<typename T>
inline const std::string& Constants_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Constants>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Constants_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Constants_descriptor(), enum_t_value);
}
inline bool Constants_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Constants* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Constants>(
    Constants_descriptor(), name, value);
}
enum CriticalErrorCode : int {
  NONE = 0,
  TX_WATCHDOG = 1,
  SLEEP_ENTER_WAIT = 2,
  NO_RADIO = 3,
  UNSPECIFIED = 4,
  UBLOX_UNIT_FAILED = 5,
  NO_AXP192 = 6,
  INVALID_RADIO_SETTING = 7,
  TRANSMIT_FAILED = 8,
  BROWNOUT = 9,
  SX1262_FAILURE = 10,
  RADIO_SPI_BUG = 11,
  FLASH_CORRUPTION_RECOVERABLE = 12,
  FLASH_CORRUPTION_UNRECOVERABLE = 13,
  CriticalErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CriticalErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CriticalErrorCode_IsValid(int value);
constexpr CriticalErrorCode CriticalErrorCode_MIN = NONE;
constexpr CriticalErrorCode CriticalErrorCode_MAX = FLASH_CORRUPTION_UNRECOVERABLE;
constexpr int CriticalErrorCode_ARRAYSIZE = CriticalErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CriticalErrorCode_descriptor();
template<typename T>
inline const std::string& CriticalErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CriticalErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CriticalErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CriticalErrorCode_descriptor(), enum_t_value);
}
inline bool CriticalErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CriticalErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CriticalErrorCode>(
    CriticalErrorCode_descriptor(), name, value);
}
enum FirmwareEdition : int {
  VANILLA = 0,
  SMART_CITIZEN = 1,
  OPEN_SAUCE = 16,
  DEFCON = 17,
  BURNING_MAN = 18,
  HAMVENTION = 19,
  DIY_EDITION = 127,
  FirmwareEdition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FirmwareEdition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FirmwareEdition_IsValid(int value);
constexpr FirmwareEdition FirmwareEdition_MIN = VANILLA;
constexpr FirmwareEdition FirmwareEdition_MAX = DIY_EDITION;
constexpr int FirmwareEdition_ARRAYSIZE = FirmwareEdition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FirmwareEdition_descriptor();
template<typename T>
inline const std::string& FirmwareEdition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FirmwareEdition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FirmwareEdition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FirmwareEdition_descriptor(), enum_t_value);
}
inline bool FirmwareEdition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FirmwareEdition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FirmwareEdition>(
    FirmwareEdition_descriptor(), name, value);
}
enum ExcludedModules : int {
  EXCLUDED_NONE = 0,
  MQTT_CONFIG = 1,
  SERIAL_CONFIG = 2,
  EXTNOTIF_CONFIG = 4,
  STOREFORWARD_CONFIG = 8,
  RANGETEST_CONFIG = 16,
  TELEMETRY_CONFIG = 32,
  CANNEDMSG_CONFIG = 64,
  AUDIO_CONFIG = 128,
  REMOTEHARDWARE_CONFIG = 256,
  NEIGHBORINFO_CONFIG = 512,
  AMBIENTLIGHTING_CONFIG = 1024,
  DETECTIONSENSOR_CONFIG = 2048,
  PAXCOUNTER_CONFIG = 4096,
  BLUETOOTH_CONFIG = 8192,
  NETWORK_CONFIG = 16384,
  ExcludedModules_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExcludedModules_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExcludedModules_IsValid(int value);
constexpr ExcludedModules ExcludedModules_MIN = EXCLUDED_NONE;
constexpr ExcludedModules ExcludedModules_MAX = NETWORK_CONFIG;
constexpr int ExcludedModules_ARRAYSIZE = ExcludedModules_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExcludedModules_descriptor();
template<typename T>
inline const std::string& ExcludedModules_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExcludedModules>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExcludedModules_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExcludedModules_descriptor(), enum_t_value);
}
inline bool ExcludedModules_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExcludedModules* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExcludedModules>(
    ExcludedModules_descriptor(), name, value);
}
// ===================================================================

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Position_LocSource LocSource;
  static constexpr LocSource LOC_UNSET =
    Position_LocSource_LOC_UNSET;
  static constexpr LocSource LOC_MANUAL =
    Position_LocSource_LOC_MANUAL;
  static constexpr LocSource LOC_INTERNAL =
    Position_LocSource_LOC_INTERNAL;
  static constexpr LocSource LOC_EXTERNAL =
    Position_LocSource_LOC_EXTERNAL;
  static inline bool LocSource_IsValid(int value) {
    return Position_LocSource_IsValid(value);
  }
  static constexpr LocSource LocSource_MIN =
    Position_LocSource_LocSource_MIN;
  static constexpr LocSource LocSource_MAX =
    Position_LocSource_LocSource_MAX;
  static constexpr int LocSource_ARRAYSIZE =
    Position_LocSource_LocSource_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LocSource_descriptor() {
    return Position_LocSource_descriptor();
  }
  template<typename T>
  static inline const std::string& LocSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LocSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LocSource_Name.");
    return Position_LocSource_Name(enum_t_value);
  }
  static inline bool LocSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LocSource* value) {
    return Position_LocSource_Parse(name, value);
  }

  typedef Position_AltSource AltSource;
  static constexpr AltSource ALT_UNSET =
    Position_AltSource_ALT_UNSET;
  static constexpr AltSource ALT_MANUAL =
    Position_AltSource_ALT_MANUAL;
  static constexpr AltSource ALT_INTERNAL =
    Position_AltSource_ALT_INTERNAL;
  static constexpr AltSource ALT_EXTERNAL =
    Position_AltSource_ALT_EXTERNAL;
  static constexpr AltSource ALT_BAROMETRIC =
    Position_AltSource_ALT_BAROMETRIC;
  static inline bool AltSource_IsValid(int value) {
    return Position_AltSource_IsValid(value);
  }
  static constexpr AltSource AltSource_MIN =
    Position_AltSource_AltSource_MIN;
  static constexpr AltSource AltSource_MAX =
    Position_AltSource_AltSource_MAX;
  static constexpr int AltSource_ARRAYSIZE =
    Position_AltSource_AltSource_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AltSource_descriptor() {
    return Position_AltSource_descriptor();
  }
  template<typename T>
  static inline const std::string& AltSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AltSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AltSource_Name.");
    return Position_AltSource_Name(enum_t_value);
  }
  static inline bool AltSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AltSource* value) {
    return Position_AltSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeIFieldNumber = 1,
    kLongitudeIFieldNumber = 2,
    kAltitudeFieldNumber = 3,
    kTimeFieldNumber = 4,
    kLocationSourceFieldNumber = 5,
    kAltitudeSourceFieldNumber = 6,
    kTimestampFieldNumber = 7,
    kTimestampMillisAdjustFieldNumber = 8,
    kAltitudeHaeFieldNumber = 9,
    kAltitudeGeoidalSeparationFieldNumber = 10,
    kPDOPFieldNumber = 11,
    kHDOPFieldNumber = 12,
    kVDOPFieldNumber = 13,
    kGpsAccuracyFieldNumber = 14,
    kGroundSpeedFieldNumber = 15,
    kGroundTrackFieldNumber = 16,
    kFixQualityFieldNumber = 17,
    kFixTypeFieldNumber = 18,
    kSatsInViewFieldNumber = 19,
    kSensorIdFieldNumber = 20,
    kNextUpdateFieldNumber = 21,
    kSeqNumberFieldNumber = 22,
    kPrecisionBitsFieldNumber = 23,
  };
  // optional sfixed32 latitude_i = 1;
  bool has_latitude_i() const;
  private:
  bool _internal_has_latitude_i() const;
  public:
  void clear_latitude_i();
  int32_t latitude_i() const;
  void set_latitude_i(int32_t value);
  private:
  int32_t _internal_latitude_i() const;
  void _internal_set_latitude_i(int32_t value);
  public:

  // optional sfixed32 longitude_i = 2;
  bool has_longitude_i() const;
  private:
  bool _internal_has_longitude_i() const;
  public:
  void clear_longitude_i();
  int32_t longitude_i() const;
  void set_longitude_i(int32_t value);
  private:
  int32_t _internal_longitude_i() const;
  void _internal_set_longitude_i(int32_t value);
  public:

  // optional int32 altitude = 3;
  bool has_altitude() const;
  private:
  bool _internal_has_altitude() const;
  public:
  void clear_altitude();
  int32_t altitude() const;
  void set_altitude(int32_t value);
  private:
  int32_t _internal_altitude() const;
  void _internal_set_altitude(int32_t value);
  public:

  // fixed32 time = 4;
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // .meshtastic.Position.LocSource location_source = 5;
  void clear_location_source();
  ::meshtastic::Position_LocSource location_source() const;
  void set_location_source(::meshtastic::Position_LocSource value);
  private:
  ::meshtastic::Position_LocSource _internal_location_source() const;
  void _internal_set_location_source(::meshtastic::Position_LocSource value);
  public:

  // .meshtastic.Position.AltSource altitude_source = 6;
  void clear_altitude_source();
  ::meshtastic::Position_AltSource altitude_source() const;
  void set_altitude_source(::meshtastic::Position_AltSource value);
  private:
  ::meshtastic::Position_AltSource _internal_altitude_source() const;
  void _internal_set_altitude_source(::meshtastic::Position_AltSource value);
  public:

  // fixed32 timestamp = 7;
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // int32 timestamp_millis_adjust = 8;
  void clear_timestamp_millis_adjust();
  int32_t timestamp_millis_adjust() const;
  void set_timestamp_millis_adjust(int32_t value);
  private:
  int32_t _internal_timestamp_millis_adjust() const;
  void _internal_set_timestamp_millis_adjust(int32_t value);
  public:

  // optional sint32 altitude_hae = 9;
  bool has_altitude_hae() const;
  private:
  bool _internal_has_altitude_hae() const;
  public:
  void clear_altitude_hae();
  int32_t altitude_hae() const;
  void set_altitude_hae(int32_t value);
  private:
  int32_t _internal_altitude_hae() const;
  void _internal_set_altitude_hae(int32_t value);
  public:

  // optional sint32 altitude_geoidal_separation = 10;
  bool has_altitude_geoidal_separation() const;
  private:
  bool _internal_has_altitude_geoidal_separation() const;
  public:
  void clear_altitude_geoidal_separation();
  int32_t altitude_geoidal_separation() const;
  void set_altitude_geoidal_separation(int32_t value);
  private:
  int32_t _internal_altitude_geoidal_separation() const;
  void _internal_set_altitude_geoidal_separation(int32_t value);
  public:

  // uint32 PDOP = 11;
  void clear_pdop();
  uint32_t pdop() const;
  void set_pdop(uint32_t value);
  private:
  uint32_t _internal_pdop() const;
  void _internal_set_pdop(uint32_t value);
  public:

  // uint32 HDOP = 12;
  void clear_hdop();
  uint32_t hdop() const;
  void set_hdop(uint32_t value);
  private:
  uint32_t _internal_hdop() const;
  void _internal_set_hdop(uint32_t value);
  public:

  // uint32 VDOP = 13;
  void clear_vdop();
  uint32_t vdop() const;
  void set_vdop(uint32_t value);
  private:
  uint32_t _internal_vdop() const;
  void _internal_set_vdop(uint32_t value);
  public:

  // uint32 gps_accuracy = 14;
  void clear_gps_accuracy();
  uint32_t gps_accuracy() const;
  void set_gps_accuracy(uint32_t value);
  private:
  uint32_t _internal_gps_accuracy() const;
  void _internal_set_gps_accuracy(uint32_t value);
  public:

  // optional uint32 ground_speed = 15;
  bool has_ground_speed() const;
  private:
  bool _internal_has_ground_speed() const;
  public:
  void clear_ground_speed();
  uint32_t ground_speed() const;
  void set_ground_speed(uint32_t value);
  private:
  uint32_t _internal_ground_speed() const;
  void _internal_set_ground_speed(uint32_t value);
  public:

  // optional uint32 ground_track = 16;
  bool has_ground_track() const;
  private:
  bool _internal_has_ground_track() const;
  public:
  void clear_ground_track();
  uint32_t ground_track() const;
  void set_ground_track(uint32_t value);
  private:
  uint32_t _internal_ground_track() const;
  void _internal_set_ground_track(uint32_t value);
  public:

  // uint32 fix_quality = 17;
  void clear_fix_quality();
  uint32_t fix_quality() const;
  void set_fix_quality(uint32_t value);
  private:
  uint32_t _internal_fix_quality() const;
  void _internal_set_fix_quality(uint32_t value);
  public:

  // uint32 fix_type = 18;
  void clear_fix_type();
  uint32_t fix_type() const;
  void set_fix_type(uint32_t value);
  private:
  uint32_t _internal_fix_type() const;
  void _internal_set_fix_type(uint32_t value);
  public:

  // uint32 sats_in_view = 19;
  void clear_sats_in_view();
  uint32_t sats_in_view() const;
  void set_sats_in_view(uint32_t value);
  private:
  uint32_t _internal_sats_in_view() const;
  void _internal_set_sats_in_view(uint32_t value);
  public:

  // uint32 sensor_id = 20;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // uint32 next_update = 21;
  void clear_next_update();
  uint32_t next_update() const;
  void set_next_update(uint32_t value);
  private:
  uint32_t _internal_next_update() const;
  void _internal_set_next_update(uint32_t value);
  public:

  // uint32 seq_number = 22;
  void clear_seq_number();
  uint32_t seq_number() const;
  void set_seq_number(uint32_t value);
  private:
  uint32_t _internal_seq_number() const;
  void _internal_set_seq_number(uint32_t value);
  public:

  // uint32 precision_bits = 23;
  void clear_precision_bits();
  uint32_t precision_bits() const;
  void set_precision_bits(uint32_t value);
  private:
  uint32_t _internal_precision_bits() const;
  void _internal_set_precision_bits(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t latitude_i_;
    int32_t longitude_i_;
    int32_t altitude_;
    uint32_t time_;
    int location_source_;
    int altitude_source_;
    uint32_t timestamp_;
    int32_t timestamp_millis_adjust_;
    int32_t altitude_hae_;
    int32_t altitude_geoidal_separation_;
    uint32_t pdop_;
    uint32_t hdop_;
    uint32_t vdop_;
    uint32_t gps_accuracy_;
    uint32_t ground_speed_;
    uint32_t ground_track_;
    uint32_t fix_quality_;
    uint32_t fix_type_;
    uint32_t sats_in_view_;
    uint32_t sensor_id_;
    uint32_t next_update_;
    uint32_t seq_number_;
    uint32_t precision_bits_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLongNameFieldNumber = 2,
    kShortNameFieldNumber = 3,
    kMacaddrFieldNumber = 4,
    kPublicKeyFieldNumber = 8,
    kHwModelFieldNumber = 5,
    kRoleFieldNumber = 7,
    kIsLicensedFieldNumber = 6,
    kIsUnmessagableFieldNumber = 9,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string long_name = 2;
  void clear_long_name();
  const std::string& long_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_long_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_long_name();
  PROTOBUF_NODISCARD std::string* release_long_name();
  void set_allocated_long_name(std::string* long_name);
  private:
  const std::string& _internal_long_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_long_name(const std::string& value);
  std::string* _internal_mutable_long_name();
  public:

  // string short_name = 3;
  void clear_short_name();
  const std::string& short_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_short_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_short_name();
  PROTOBUF_NODISCARD std::string* release_short_name();
  void set_allocated_short_name(std::string* short_name);
  private:
  const std::string& _internal_short_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_short_name(const std::string& value);
  std::string* _internal_mutable_short_name();
  public:

  // bytes macaddr = 4 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_macaddr();
  PROTOBUF_DEPRECATED const std::string& macaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_macaddr(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_macaddr();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_macaddr();
  PROTOBUF_DEPRECATED void set_allocated_macaddr(std::string* macaddr);
  private:
  const std::string& _internal_macaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_macaddr(const std::string& value);
  std::string* _internal_mutable_macaddr();
  public:

  // bytes public_key = 8;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // .meshtastic.HardwareModel hw_model = 5;
  void clear_hw_model();
  ::meshtastic::HardwareModel hw_model() const;
  void set_hw_model(::meshtastic::HardwareModel value);
  private:
  ::meshtastic::HardwareModel _internal_hw_model() const;
  void _internal_set_hw_model(::meshtastic::HardwareModel value);
  public:

  // .meshtastic.Config.DeviceConfig.Role role = 7;
  void clear_role();
  ::meshtastic::Config_DeviceConfig_Role role() const;
  void set_role(::meshtastic::Config_DeviceConfig_Role value);
  private:
  ::meshtastic::Config_DeviceConfig_Role _internal_role() const;
  void _internal_set_role(::meshtastic::Config_DeviceConfig_Role value);
  public:

  // bool is_licensed = 6;
  void clear_is_licensed();
  bool is_licensed() const;
  void set_is_licensed(bool value);
  private:
  bool _internal_is_licensed() const;
  void _internal_set_is_licensed(bool value);
  public:

  // optional bool is_unmessagable = 9;
  bool has_is_unmessagable() const;
  private:
  bool _internal_has_is_unmessagable() const;
  public:
  void clear_is_unmessagable();
  bool is_unmessagable() const;
  void set_is_unmessagable(bool value);
  private:
  bool _internal_is_unmessagable() const;
  void _internal_set_is_unmessagable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr long_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr short_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macaddr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    int hw_model_;
    int role_;
    bool is_licensed_;
    bool is_unmessagable_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class RouteDiscovery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.RouteDiscovery) */ {
 public:
  inline RouteDiscovery() : RouteDiscovery(nullptr) {}
  ~RouteDiscovery() override;
  explicit PROTOBUF_CONSTEXPR RouteDiscovery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteDiscovery(const RouteDiscovery& from);
  RouteDiscovery(RouteDiscovery&& from) noexcept
    : RouteDiscovery() {
    *this = ::std::move(from);
  }

  inline RouteDiscovery& operator=(const RouteDiscovery& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteDiscovery& operator=(RouteDiscovery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteDiscovery& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteDiscovery* internal_default_instance() {
    return reinterpret_cast<const RouteDiscovery*>(
               &_RouteDiscovery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RouteDiscovery& a, RouteDiscovery& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteDiscovery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteDiscovery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteDiscovery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteDiscovery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteDiscovery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RouteDiscovery& from) {
    RouteDiscovery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteDiscovery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.RouteDiscovery";
  }
  protected:
  explicit RouteDiscovery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouteFieldNumber = 1,
    kSnrTowardsFieldNumber = 2,
    kRouteBackFieldNumber = 3,
    kSnrBackFieldNumber = 4,
  };
  // repeated fixed32 route = 1;
  int route_size() const;
  private:
  int _internal_route_size() const;
  public:
  void clear_route();
  private:
  uint32_t _internal_route(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_route() const;
  void _internal_add_route(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_route();
  public:
  uint32_t route(int index) const;
  void set_route(int index, uint32_t value);
  void add_route(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      route() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_route();

  // repeated int32 snr_towards = 2;
  int snr_towards_size() const;
  private:
  int _internal_snr_towards_size() const;
  public:
  void clear_snr_towards();
  private:
  int32_t _internal_snr_towards(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_snr_towards() const;
  void _internal_add_snr_towards(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_snr_towards();
  public:
  int32_t snr_towards(int index) const;
  void set_snr_towards(int index, int32_t value);
  void add_snr_towards(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      snr_towards() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_snr_towards();

  // repeated fixed32 route_back = 3;
  int route_back_size() const;
  private:
  int _internal_route_back_size() const;
  public:
  void clear_route_back();
  private:
  uint32_t _internal_route_back(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_route_back() const;
  void _internal_add_route_back(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_route_back();
  public:
  uint32_t route_back(int index) const;
  void set_route_back(int index, uint32_t value);
  void add_route_back(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      route_back() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_route_back();

  // repeated int32 snr_back = 4;
  int snr_back_size() const;
  private:
  int _internal_snr_back_size() const;
  public:
  void clear_snr_back();
  private:
  int32_t _internal_snr_back(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_snr_back() const;
  void _internal_add_snr_back(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_snr_back();
  public:
  int32_t snr_back(int index) const;
  void set_snr_back(int index, int32_t value);
  void add_snr_back(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      snr_back() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_snr_back();

  // @@protoc_insertion_point(class_scope:meshtastic.RouteDiscovery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > route_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > snr_towards_;
    mutable std::atomic<int> _snr_towards_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > route_back_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > snr_back_;
    mutable std::atomic<int> _snr_back_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Routing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Routing) */ {
 public:
  inline Routing() : Routing(nullptr) {}
  ~Routing() override;
  explicit PROTOBUF_CONSTEXPR Routing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Routing(const Routing& from);
  Routing(Routing&& from) noexcept
    : Routing() {
    *this = ::std::move(from);
  }

  inline Routing& operator=(const Routing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Routing& operator=(Routing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Routing& default_instance() {
    return *internal_default_instance();
  }
  enum VariantCase {
    kRouteRequest = 1,
    kRouteReply = 2,
    kErrorReason = 3,
    VARIANT_NOT_SET = 0,
  };

  static inline const Routing* internal_default_instance() {
    return reinterpret_cast<const Routing*>(
               &_Routing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Routing& a, Routing& b) {
    a.Swap(&b);
  }
  inline void Swap(Routing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Routing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Routing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Routing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Routing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Routing& from) {
    Routing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Routing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Routing";
  }
  protected:
  explicit Routing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Routing_Error Error;
  static constexpr Error NONE =
    Routing_Error_NONE;
  static constexpr Error NO_ROUTE =
    Routing_Error_NO_ROUTE;
  static constexpr Error GOT_NAK =
    Routing_Error_GOT_NAK;
  static constexpr Error TIMEOUT =
    Routing_Error_TIMEOUT;
  static constexpr Error NO_INTERFACE =
    Routing_Error_NO_INTERFACE;
  static constexpr Error MAX_RETRANSMIT =
    Routing_Error_MAX_RETRANSMIT;
  static constexpr Error NO_CHANNEL =
    Routing_Error_NO_CHANNEL;
  static constexpr Error TOO_LARGE =
    Routing_Error_TOO_LARGE;
  static constexpr Error NO_RESPONSE =
    Routing_Error_NO_RESPONSE;
  static constexpr Error DUTY_CYCLE_LIMIT =
    Routing_Error_DUTY_CYCLE_LIMIT;
  static constexpr Error BAD_REQUEST =
    Routing_Error_BAD_REQUEST;
  static constexpr Error NOT_AUTHORIZED =
    Routing_Error_NOT_AUTHORIZED;
  static constexpr Error PKI_FAILED =
    Routing_Error_PKI_FAILED;
  static constexpr Error PKI_UNKNOWN_PUBKEY =
    Routing_Error_PKI_UNKNOWN_PUBKEY;
  static constexpr Error ADMIN_BAD_SESSION_KEY =
    Routing_Error_ADMIN_BAD_SESSION_KEY;
  static constexpr Error ADMIN_PUBLIC_KEY_UNAUTHORIZED =
    Routing_Error_ADMIN_PUBLIC_KEY_UNAUTHORIZED;
  static constexpr Error RATE_LIMIT_EXCEEDED =
    Routing_Error_RATE_LIMIT_EXCEEDED;
  static inline bool Error_IsValid(int value) {
    return Routing_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    Routing_Error_Error_MIN;
  static constexpr Error Error_MAX =
    Routing_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    Routing_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return Routing_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return Routing_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return Routing_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRouteRequestFieldNumber = 1,
    kRouteReplyFieldNumber = 2,
    kErrorReasonFieldNumber = 3,
  };
  // .meshtastic.RouteDiscovery route_request = 1;
  bool has_route_request() const;
  private:
  bool _internal_has_route_request() const;
  public:
  void clear_route_request();
  const ::meshtastic::RouteDiscovery& route_request() const;
  PROTOBUF_NODISCARD ::meshtastic::RouteDiscovery* release_route_request();
  ::meshtastic::RouteDiscovery* mutable_route_request();
  void set_allocated_route_request(::meshtastic::RouteDiscovery* route_request);
  private:
  const ::meshtastic::RouteDiscovery& _internal_route_request() const;
  ::meshtastic::RouteDiscovery* _internal_mutable_route_request();
  public:
  void unsafe_arena_set_allocated_route_request(
      ::meshtastic::RouteDiscovery* route_request);
  ::meshtastic::RouteDiscovery* unsafe_arena_release_route_request();

  // .meshtastic.RouteDiscovery route_reply = 2;
  bool has_route_reply() const;
  private:
  bool _internal_has_route_reply() const;
  public:
  void clear_route_reply();
  const ::meshtastic::RouteDiscovery& route_reply() const;
  PROTOBUF_NODISCARD ::meshtastic::RouteDiscovery* release_route_reply();
  ::meshtastic::RouteDiscovery* mutable_route_reply();
  void set_allocated_route_reply(::meshtastic::RouteDiscovery* route_reply);
  private:
  const ::meshtastic::RouteDiscovery& _internal_route_reply() const;
  ::meshtastic::RouteDiscovery* _internal_mutable_route_reply();
  public:
  void unsafe_arena_set_allocated_route_reply(
      ::meshtastic::RouteDiscovery* route_reply);
  ::meshtastic::RouteDiscovery* unsafe_arena_release_route_reply();

  // .meshtastic.Routing.Error error_reason = 3;
  bool has_error_reason() const;
  private:
  bool _internal_has_error_reason() const;
  public:
  void clear_error_reason();
  ::meshtastic::Routing_Error error_reason() const;
  void set_error_reason(::meshtastic::Routing_Error value);
  private:
  ::meshtastic::Routing_Error _internal_error_reason() const;
  void _internal_set_error_reason(::meshtastic::Routing_Error value);
  public:

  void clear_variant();
  VariantCase variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.Routing)
 private:
  class _Internal;
  void set_has_route_request();
  void set_has_route_reply();
  void set_has_error_reason();

  inline bool has_variant() const;
  inline void clear_has_variant();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VariantUnion {
      constexpr VariantUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::meshtastic::RouteDiscovery* route_request_;
      ::meshtastic::RouteDiscovery* route_reply_;
      int error_reason_;
    } variant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() override;
  explicit PROTOBUF_CONSTEXPR Data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Data(const Data& from);
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }
  inline void Swap(Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Data& from) {
    Data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Data";
  }
  protected:
  explicit Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kPortnumFieldNumber = 1,
    kWantResponseFieldNumber = 3,
    kDestFieldNumber = 4,
    kSourceFieldNumber = 5,
    kRequestIdFieldNumber = 6,
    kReplyIdFieldNumber = 7,
    kEmojiFieldNumber = 8,
    kBitfieldFieldNumber = 9,
  };
  // bytes payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // .meshtastic.PortNum portnum = 1;
  void clear_portnum();
  ::meshtastic::PortNum portnum() const;
  void set_portnum(::meshtastic::PortNum value);
  private:
  ::meshtastic::PortNum _internal_portnum() const;
  void _internal_set_portnum(::meshtastic::PortNum value);
  public:

  // bool want_response = 3;
  void clear_want_response();
  bool want_response() const;
  void set_want_response(bool value);
  private:
  bool _internal_want_response() const;
  void _internal_set_want_response(bool value);
  public:

  // fixed32 dest = 4;
  void clear_dest();
  uint32_t dest() const;
  void set_dest(uint32_t value);
  private:
  uint32_t _internal_dest() const;
  void _internal_set_dest(uint32_t value);
  public:

  // fixed32 source = 5;
  void clear_source();
  uint32_t source() const;
  void set_source(uint32_t value);
  private:
  uint32_t _internal_source() const;
  void _internal_set_source(uint32_t value);
  public:

  // fixed32 request_id = 6;
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // fixed32 reply_id = 7;
  void clear_reply_id();
  uint32_t reply_id() const;
  void set_reply_id(uint32_t value);
  private:
  uint32_t _internal_reply_id() const;
  void _internal_set_reply_id(uint32_t value);
  public:

  // fixed32 emoji = 8;
  void clear_emoji();
  uint32_t emoji() const;
  void set_emoji(uint32_t value);
  private:
  uint32_t _internal_emoji() const;
  void _internal_set_emoji(uint32_t value);
  public:

  // optional uint32 bitfield = 9;
  bool has_bitfield() const;
  private:
  bool _internal_has_bitfield() const;
  public:
  void clear_bitfield();
  uint32_t bitfield() const;
  void set_bitfield(uint32_t value);
  private:
  uint32_t _internal_bitfield() const;
  void _internal_set_bitfield(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    int portnum_;
    bool want_response_;
    uint32_t dest_;
    uint32_t source_;
    uint32_t request_id_;
    uint32_t reply_id_;
    uint32_t emoji_;
    uint32_t bitfield_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class KeyVerification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.KeyVerification) */ {
 public:
  inline KeyVerification() : KeyVerification(nullptr) {}
  ~KeyVerification() override;
  explicit PROTOBUF_CONSTEXPR KeyVerification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyVerification(const KeyVerification& from);
  KeyVerification(KeyVerification&& from) noexcept
    : KeyVerification() {
    *this = ::std::move(from);
  }

  inline KeyVerification& operator=(const KeyVerification& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyVerification& operator=(KeyVerification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyVerification& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyVerification* internal_default_instance() {
    return reinterpret_cast<const KeyVerification*>(
               &_KeyVerification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(KeyVerification& a, KeyVerification& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyVerification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyVerification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyVerification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyVerification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyVerification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyVerification& from) {
    KeyVerification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyVerification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.KeyVerification";
  }
  protected:
  explicit KeyVerification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHash1FieldNumber = 2,
    kHash2FieldNumber = 3,
    kNonceFieldNumber = 1,
  };
  // bytes hash1 = 2;
  void clear_hash1();
  const std::string& hash1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash1();
  PROTOBUF_NODISCARD std::string* release_hash1();
  void set_allocated_hash1(std::string* hash1);
  private:
  const std::string& _internal_hash1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash1(const std::string& value);
  std::string* _internal_mutable_hash1();
  public:

  // bytes hash2 = 3;
  void clear_hash2();
  const std::string& hash2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash2();
  PROTOBUF_NODISCARD std::string* release_hash2();
  void set_allocated_hash2(std::string* hash2);
  private:
  const std::string& _internal_hash2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash2(const std::string& value);
  std::string* _internal_mutable_hash2();
  public:

  // uint64 nonce = 1;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.KeyVerification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash2_;
    uint64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Waypoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Waypoint) */ {
 public:
  inline Waypoint() : Waypoint(nullptr) {}
  ~Waypoint() override;
  explicit PROTOBUF_CONSTEXPR Waypoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Waypoint(const Waypoint& from);
  Waypoint(Waypoint&& from) noexcept
    : Waypoint() {
    *this = ::std::move(from);
  }

  inline Waypoint& operator=(const Waypoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Waypoint& operator=(Waypoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Waypoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Waypoint* internal_default_instance() {
    return reinterpret_cast<const Waypoint*>(
               &_Waypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Waypoint& a, Waypoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Waypoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Waypoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Waypoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Waypoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Waypoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Waypoint& from) {
    Waypoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Waypoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Waypoint";
  }
  protected:
  explicit Waypoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 6,
    kDescriptionFieldNumber = 7,
    kIdFieldNumber = 1,
    kLatitudeIFieldNumber = 2,
    kLongitudeIFieldNumber = 3,
    kExpireFieldNumber = 4,
    kLockedToFieldNumber = 5,
    kIconFieldNumber = 8,
  };
  // string name = 6;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 7;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // optional sfixed32 latitude_i = 2;
  bool has_latitude_i() const;
  private:
  bool _internal_has_latitude_i() const;
  public:
  void clear_latitude_i();
  int32_t latitude_i() const;
  void set_latitude_i(int32_t value);
  private:
  int32_t _internal_latitude_i() const;
  void _internal_set_latitude_i(int32_t value);
  public:

  // optional sfixed32 longitude_i = 3;
  bool has_longitude_i() const;
  private:
  bool _internal_has_longitude_i() const;
  public:
  void clear_longitude_i();
  int32_t longitude_i() const;
  void set_longitude_i(int32_t value);
  private:
  int32_t _internal_longitude_i() const;
  void _internal_set_longitude_i(int32_t value);
  public:

  // uint32 expire = 4;
  void clear_expire();
  uint32_t expire() const;
  void set_expire(uint32_t value);
  private:
  uint32_t _internal_expire() const;
  void _internal_set_expire(uint32_t value);
  public:

  // uint32 locked_to = 5;
  void clear_locked_to();
  uint32_t locked_to() const;
  void set_locked_to(uint32_t value);
  private:
  uint32_t _internal_locked_to() const;
  void _internal_set_locked_to(uint32_t value);
  public:

  // fixed32 icon = 8;
  void clear_icon();
  uint32_t icon() const;
  void set_icon(uint32_t value);
  private:
  uint32_t _internal_icon() const;
  void _internal_set_icon(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Waypoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    uint32_t id_;
    int32_t latitude_i_;
    int32_t longitude_i_;
    uint32_t expire_;
    uint32_t locked_to_;
    uint32_t icon_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class MqttClientProxyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.MqttClientProxyMessage) */ {
 public:
  inline MqttClientProxyMessage() : MqttClientProxyMessage(nullptr) {}
  ~MqttClientProxyMessage() override;
  explicit PROTOBUF_CONSTEXPR MqttClientProxyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MqttClientProxyMessage(const MqttClientProxyMessage& from);
  MqttClientProxyMessage(MqttClientProxyMessage&& from) noexcept
    : MqttClientProxyMessage() {
    *this = ::std::move(from);
  }

  inline MqttClientProxyMessage& operator=(const MqttClientProxyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MqttClientProxyMessage& operator=(MqttClientProxyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MqttClientProxyMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kData = 2,
    kText = 3,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };

  static inline const MqttClientProxyMessage* internal_default_instance() {
    return reinterpret_cast<const MqttClientProxyMessage*>(
               &_MqttClientProxyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MqttClientProxyMessage& a, MqttClientProxyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MqttClientProxyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MqttClientProxyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MqttClientProxyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MqttClientProxyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MqttClientProxyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MqttClientProxyMessage& from) {
    MqttClientProxyMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MqttClientProxyMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.MqttClientProxyMessage";
  }
  protected:
  explicit MqttClientProxyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kRetainedFieldNumber = 4,
    kDataFieldNumber = 2,
    kTextFieldNumber = 3,
  };
  // string topic = 1;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // bool retained = 4;
  void clear_retained();
  bool retained() const;
  void set_retained(bool value);
  private:
  bool _internal_retained() const;
  void _internal_set_retained(bool value);
  public:

  // bytes data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string text = 3;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.MqttClientProxyMessage)
 private:
  class _Internal;
  void set_has_data();
  void set_has_text();

  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    bool retained_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    } payload_variant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class MeshPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.MeshPacket) */ {
 public:
  inline MeshPacket() : MeshPacket(nullptr) {}
  ~MeshPacket() override;
  explicit PROTOBUF_CONSTEXPR MeshPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MeshPacket(const MeshPacket& from);
  MeshPacket(MeshPacket&& from) noexcept
    : MeshPacket() {
    *this = ::std::move(from);
  }

  inline MeshPacket& operator=(const MeshPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshPacket& operator=(MeshPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshPacket& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kDecoded = 4,
    kEncrypted = 5,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };

  static inline const MeshPacket* internal_default_instance() {
    return reinterpret_cast<const MeshPacket*>(
               &_MeshPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MeshPacket& a, MeshPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(MeshPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MeshPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MeshPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MeshPacket& from) {
    MeshPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeshPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.MeshPacket";
  }
  protected:
  explicit MeshPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MeshPacket_Priority Priority;
  static constexpr Priority UNSET =
    MeshPacket_Priority_UNSET;
  static constexpr Priority MIN =
    MeshPacket_Priority_MIN;
  static constexpr Priority BACKGROUND =
    MeshPacket_Priority_BACKGROUND;
  static constexpr Priority DEFAULT =
    MeshPacket_Priority_DEFAULT;
  static constexpr Priority RELIABLE =
    MeshPacket_Priority_RELIABLE;
  static constexpr Priority RESPONSE =
    MeshPacket_Priority_RESPONSE;
  static constexpr Priority HIGH =
    MeshPacket_Priority_HIGH;
  static constexpr Priority ALERT =
    MeshPacket_Priority_ALERT;
  static constexpr Priority ACK =
    MeshPacket_Priority_ACK;
  static constexpr Priority MAX =
    MeshPacket_Priority_MAX;
  static inline bool Priority_IsValid(int value) {
    return MeshPacket_Priority_IsValid(value);
  }
  static constexpr Priority Priority_MIN =
    MeshPacket_Priority_Priority_MIN;
  static constexpr Priority Priority_MAX =
    MeshPacket_Priority_Priority_MAX;
  static constexpr int Priority_ARRAYSIZE =
    MeshPacket_Priority_Priority_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Priority_descriptor() {
    return MeshPacket_Priority_descriptor();
  }
  template<typename T>
  static inline const std::string& Priority_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Priority>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Priority_Name.");
    return MeshPacket_Priority_Name(enum_t_value);
  }
  static inline bool Priority_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Priority* value) {
    return MeshPacket_Priority_Parse(name, value);
  }

  typedef MeshPacket_Delayed Delayed;
  static constexpr Delayed NO_DELAY =
    MeshPacket_Delayed_NO_DELAY;
  static constexpr Delayed DELAYED_BROADCAST =
    MeshPacket_Delayed_DELAYED_BROADCAST;
  static constexpr Delayed DELAYED_DIRECT =
    MeshPacket_Delayed_DELAYED_DIRECT;
  static inline bool Delayed_IsValid(int value) {
    return MeshPacket_Delayed_IsValid(value);
  }
  static constexpr Delayed Delayed_MIN =
    MeshPacket_Delayed_Delayed_MIN;
  static constexpr Delayed Delayed_MAX =
    MeshPacket_Delayed_Delayed_MAX;
  static constexpr int Delayed_ARRAYSIZE =
    MeshPacket_Delayed_Delayed_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Delayed_descriptor() {
    return MeshPacket_Delayed_descriptor();
  }
  template<typename T>
  static inline const std::string& Delayed_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Delayed>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Delayed_Name.");
    return MeshPacket_Delayed_Name(enum_t_value);
  }
  static inline bool Delayed_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Delayed* value) {
    return MeshPacket_Delayed_Parse(name, value);
  }

  typedef MeshPacket_TransportMechanism TransportMechanism;
  static constexpr TransportMechanism TRANSPORT_INTERNAL =
    MeshPacket_TransportMechanism_TRANSPORT_INTERNAL;
  static constexpr TransportMechanism TRANSPORT_LORA =
    MeshPacket_TransportMechanism_TRANSPORT_LORA;
  static constexpr TransportMechanism TRANSPORT_LORA_ALT1 =
    MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT1;
  static constexpr TransportMechanism TRANSPORT_LORA_ALT2 =
    MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT2;
  static constexpr TransportMechanism TRANSPORT_LORA_ALT3 =
    MeshPacket_TransportMechanism_TRANSPORT_LORA_ALT3;
  static constexpr TransportMechanism TRANSPORT_MQTT =
    MeshPacket_TransportMechanism_TRANSPORT_MQTT;
  static constexpr TransportMechanism TRANSPORT_MULTICAST_UDP =
    MeshPacket_TransportMechanism_TRANSPORT_MULTICAST_UDP;
  static constexpr TransportMechanism TRANSPORT_API =
    MeshPacket_TransportMechanism_TRANSPORT_API;
  static inline bool TransportMechanism_IsValid(int value) {
    return MeshPacket_TransportMechanism_IsValid(value);
  }
  static constexpr TransportMechanism TransportMechanism_MIN =
    MeshPacket_TransportMechanism_TransportMechanism_MIN;
  static constexpr TransportMechanism TransportMechanism_MAX =
    MeshPacket_TransportMechanism_TransportMechanism_MAX;
  static constexpr int TransportMechanism_ARRAYSIZE =
    MeshPacket_TransportMechanism_TransportMechanism_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TransportMechanism_descriptor() {
    return MeshPacket_TransportMechanism_descriptor();
  }
  template<typename T>
  static inline const std::string& TransportMechanism_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TransportMechanism>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TransportMechanism_Name.");
    return MeshPacket_TransportMechanism_Name(enum_t_value);
  }
  static inline bool TransportMechanism_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TransportMechanism* value) {
    return MeshPacket_TransportMechanism_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 16,
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kChannelFieldNumber = 3,
    kIdFieldNumber = 6,
    kRxTimeFieldNumber = 7,
    kRxSnrFieldNumber = 8,
    kHopLimitFieldNumber = 9,
    kPriorityFieldNumber = 11,
    kRxRssiFieldNumber = 12,
    kDelayedFieldNumber = 13,
    kWantAckFieldNumber = 10,
    kViaMqttFieldNumber = 14,
    kPkiEncryptedFieldNumber = 17,
    kHopStartFieldNumber = 15,
    kNextHopFieldNumber = 18,
    kRelayNodeFieldNumber = 19,
    kTxAfterFieldNumber = 20,
    kTransportMechanismFieldNumber = 21,
    kDecodedFieldNumber = 4,
    kEncryptedFieldNumber = 5,
  };
  // bytes public_key = 16;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // fixed32 from = 1;
  void clear_from();
  uint32_t from() const;
  void set_from(uint32_t value);
  private:
  uint32_t _internal_from() const;
  void _internal_set_from(uint32_t value);
  public:

  // fixed32 to = 2;
  void clear_to();
  uint32_t to() const;
  void set_to(uint32_t value);
  private:
  uint32_t _internal_to() const;
  void _internal_set_to(uint32_t value);
  public:

  // uint32 channel = 3;
  void clear_channel();
  uint32_t channel() const;
  void set_channel(uint32_t value);
  private:
  uint32_t _internal_channel() const;
  void _internal_set_channel(uint32_t value);
  public:

  // fixed32 id = 6;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // fixed32 rx_time = 7;
  void clear_rx_time();
  uint32_t rx_time() const;
  void set_rx_time(uint32_t value);
  private:
  uint32_t _internal_rx_time() const;
  void _internal_set_rx_time(uint32_t value);
  public:

  // float rx_snr = 8;
  void clear_rx_snr();
  float rx_snr() const;
  void set_rx_snr(float value);
  private:
  float _internal_rx_snr() const;
  void _internal_set_rx_snr(float value);
  public:

  // uint32 hop_limit = 9;
  void clear_hop_limit();
  uint32_t hop_limit() const;
  void set_hop_limit(uint32_t value);
  private:
  uint32_t _internal_hop_limit() const;
  void _internal_set_hop_limit(uint32_t value);
  public:

  // .meshtastic.MeshPacket.Priority priority = 11;
  void clear_priority();
  ::meshtastic::MeshPacket_Priority priority() const;
  void set_priority(::meshtastic::MeshPacket_Priority value);
  private:
  ::meshtastic::MeshPacket_Priority _internal_priority() const;
  void _internal_set_priority(::meshtastic::MeshPacket_Priority value);
  public:

  // int32 rx_rssi = 12;
  void clear_rx_rssi();
  int32_t rx_rssi() const;
  void set_rx_rssi(int32_t value);
  private:
  int32_t _internal_rx_rssi() const;
  void _internal_set_rx_rssi(int32_t value);
  public:

  // .meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_delayed();
  PROTOBUF_DEPRECATED ::meshtastic::MeshPacket_Delayed delayed() const;
  PROTOBUF_DEPRECATED void set_delayed(::meshtastic::MeshPacket_Delayed value);
  private:
  ::meshtastic::MeshPacket_Delayed _internal_delayed() const;
  void _internal_set_delayed(::meshtastic::MeshPacket_Delayed value);
  public:

  // bool want_ack = 10;
  void clear_want_ack();
  bool want_ack() const;
  void set_want_ack(bool value);
  private:
  bool _internal_want_ack() const;
  void _internal_set_want_ack(bool value);
  public:

  // bool via_mqtt = 14;
  void clear_via_mqtt();
  bool via_mqtt() const;
  void set_via_mqtt(bool value);
  private:
  bool _internal_via_mqtt() const;
  void _internal_set_via_mqtt(bool value);
  public:

  // bool pki_encrypted = 17;
  void clear_pki_encrypted();
  bool pki_encrypted() const;
  void set_pki_encrypted(bool value);
  private:
  bool _internal_pki_encrypted() const;
  void _internal_set_pki_encrypted(bool value);
  public:

  // uint32 hop_start = 15;
  void clear_hop_start();
  uint32_t hop_start() const;
  void set_hop_start(uint32_t value);
  private:
  uint32_t _internal_hop_start() const;
  void _internal_set_hop_start(uint32_t value);
  public:

  // uint32 next_hop = 18;
  void clear_next_hop();
  uint32_t next_hop() const;
  void set_next_hop(uint32_t value);
  private:
  uint32_t _internal_next_hop() const;
  void _internal_set_next_hop(uint32_t value);
  public:

  // uint32 relay_node = 19;
  void clear_relay_node();
  uint32_t relay_node() const;
  void set_relay_node(uint32_t value);
  private:
  uint32_t _internal_relay_node() const;
  void _internal_set_relay_node(uint32_t value);
  public:

  // uint32 tx_after = 20;
  void clear_tx_after();
  uint32_t tx_after() const;
  void set_tx_after(uint32_t value);
  private:
  uint32_t _internal_tx_after() const;
  void _internal_set_tx_after(uint32_t value);
  public:

  // .meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;
  void clear_transport_mechanism();
  ::meshtastic::MeshPacket_TransportMechanism transport_mechanism() const;
  void set_transport_mechanism(::meshtastic::MeshPacket_TransportMechanism value);
  private:
  ::meshtastic::MeshPacket_TransportMechanism _internal_transport_mechanism() const;
  void _internal_set_transport_mechanism(::meshtastic::MeshPacket_TransportMechanism value);
  public:

  // .meshtastic.Data decoded = 4;
  bool has_decoded() const;
  private:
  bool _internal_has_decoded() const;
  public:
  void clear_decoded();
  const ::meshtastic::Data& decoded() const;
  PROTOBUF_NODISCARD ::meshtastic::Data* release_decoded();
  ::meshtastic::Data* mutable_decoded();
  void set_allocated_decoded(::meshtastic::Data* decoded);
  private:
  const ::meshtastic::Data& _internal_decoded() const;
  ::meshtastic::Data* _internal_mutable_decoded();
  public:
  void unsafe_arena_set_allocated_decoded(
      ::meshtastic::Data* decoded);
  ::meshtastic::Data* unsafe_arena_release_decoded();

  // bytes encrypted = 5;
  bool has_encrypted() const;
  private:
  bool _internal_has_encrypted() const;
  public:
  void clear_encrypted();
  const std::string& encrypted() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted();
  PROTOBUF_NODISCARD std::string* release_encrypted();
  void set_allocated_encrypted(std::string* encrypted);
  private:
  const std::string& _internal_encrypted() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted(const std::string& value);
  std::string* _internal_mutable_encrypted();
  public:

  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.MeshPacket)
 private:
  class _Internal;
  void set_has_decoded();
  void set_has_encrypted();

  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    uint32_t from_;
    uint32_t to_;
    uint32_t channel_;
    uint32_t id_;
    uint32_t rx_time_;
    float rx_snr_;
    uint32_t hop_limit_;
    int priority_;
    int32_t rx_rssi_;
    int delayed_;
    bool want_ack_;
    bool via_mqtt_;
    bool pki_encrypted_;
    uint32_t hop_start_;
    uint32_t next_hop_;
    uint32_t relay_node_;
    uint32_t tx_after_;
    int transport_mechanism_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::meshtastic::Data* decoded_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_;
    } payload_variant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  ~NodeInfo() override;
  explicit PROTOBUF_CONSTEXPR NodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo(const NodeInfo& from);
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeInfo& from) {
    NodeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.NodeInfo";
  }
  protected:
  explicit NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 2,
    kPositionFieldNumber = 3,
    kDeviceMetricsFieldNumber = 6,
    kNumFieldNumber = 1,
    kSnrFieldNumber = 4,
    kLastHeardFieldNumber = 5,
    kChannelFieldNumber = 7,
    kHopsAwayFieldNumber = 9,
    kViaMqttFieldNumber = 8,
    kIsFavoriteFieldNumber = 10,
    kIsIgnoredFieldNumber = 11,
    kIsKeyManuallyVerifiedFieldNumber = 12,
  };
  // .meshtastic.User user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::meshtastic::User& user() const;
  PROTOBUF_NODISCARD ::meshtastic::User* release_user();
  ::meshtastic::User* mutable_user();
  void set_allocated_user(::meshtastic::User* user);
  private:
  const ::meshtastic::User& _internal_user() const;
  ::meshtastic::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::meshtastic::User* user);
  ::meshtastic::User* unsafe_arena_release_user();

  // .meshtastic.Position position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::meshtastic::Position& position() const;
  PROTOBUF_NODISCARD ::meshtastic::Position* release_position();
  ::meshtastic::Position* mutable_position();
  void set_allocated_position(::meshtastic::Position* position);
  private:
  const ::meshtastic::Position& _internal_position() const;
  ::meshtastic::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::meshtastic::Position* position);
  ::meshtastic::Position* unsafe_arena_release_position();

  // .meshtastic.DeviceMetrics device_metrics = 6;
  bool has_device_metrics() const;
  private:
  bool _internal_has_device_metrics() const;
  public:
  void clear_device_metrics();
  const ::meshtastic::DeviceMetrics& device_metrics() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceMetrics* release_device_metrics();
  ::meshtastic::DeviceMetrics* mutable_device_metrics();
  void set_allocated_device_metrics(::meshtastic::DeviceMetrics* device_metrics);
  private:
  const ::meshtastic::DeviceMetrics& _internal_device_metrics() const;
  ::meshtastic::DeviceMetrics* _internal_mutable_device_metrics();
  public:
  void unsafe_arena_set_allocated_device_metrics(
      ::meshtastic::DeviceMetrics* device_metrics);
  ::meshtastic::DeviceMetrics* unsafe_arena_release_device_metrics();

  // uint32 num = 1;
  void clear_num();
  uint32_t num() const;
  void set_num(uint32_t value);
  private:
  uint32_t _internal_num() const;
  void _internal_set_num(uint32_t value);
  public:

  // float snr = 4;
  void clear_snr();
  float snr() const;
  void set_snr(float value);
  private:
  float _internal_snr() const;
  void _internal_set_snr(float value);
  public:

  // fixed32 last_heard = 5;
  void clear_last_heard();
  uint32_t last_heard() const;
  void set_last_heard(uint32_t value);
  private:
  uint32_t _internal_last_heard() const;
  void _internal_set_last_heard(uint32_t value);
  public:

  // uint32 channel = 7;
  void clear_channel();
  uint32_t channel() const;
  void set_channel(uint32_t value);
  private:
  uint32_t _internal_channel() const;
  void _internal_set_channel(uint32_t value);
  public:

  // optional uint32 hops_away = 9;
  bool has_hops_away() const;
  private:
  bool _internal_has_hops_away() const;
  public:
  void clear_hops_away();
  uint32_t hops_away() const;
  void set_hops_away(uint32_t value);
  private:
  uint32_t _internal_hops_away() const;
  void _internal_set_hops_away(uint32_t value);
  public:

  // bool via_mqtt = 8;
  void clear_via_mqtt();
  bool via_mqtt() const;
  void set_via_mqtt(bool value);
  private:
  bool _internal_via_mqtt() const;
  void _internal_set_via_mqtt(bool value);
  public:

  // bool is_favorite = 10;
  void clear_is_favorite();
  bool is_favorite() const;
  void set_is_favorite(bool value);
  private:
  bool _internal_is_favorite() const;
  void _internal_set_is_favorite(bool value);
  public:

  // bool is_ignored = 11;
  void clear_is_ignored();
  bool is_ignored() const;
  void set_is_ignored(bool value);
  private:
  bool _internal_is_ignored() const;
  void _internal_set_is_ignored(bool value);
  public:

  // bool is_key_manually_verified = 12;
  void clear_is_key_manually_verified();
  bool is_key_manually_verified() const;
  void set_is_key_manually_verified(bool value);
  private:
  bool _internal_is_key_manually_verified() const;
  void _internal_set_is_key_manually_verified(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::meshtastic::User* user_;
    ::meshtastic::Position* position_;
    ::meshtastic::DeviceMetrics* device_metrics_;
    uint32_t num_;
    float snr_;
    uint32_t last_heard_;
    uint32_t channel_;
    uint32_t hops_away_;
    bool via_mqtt_;
    bool is_favorite_;
    bool is_ignored_;
    bool is_key_manually_verified_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class MyNodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.MyNodeInfo) */ {
 public:
  inline MyNodeInfo() : MyNodeInfo(nullptr) {}
  ~MyNodeInfo() override;
  explicit PROTOBUF_CONSTEXPR MyNodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MyNodeInfo(const MyNodeInfo& from);
  MyNodeInfo(MyNodeInfo&& from) noexcept
    : MyNodeInfo() {
    *this = ::std::move(from);
  }

  inline MyNodeInfo& operator=(const MyNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyNodeInfo& operator=(MyNodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MyNodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MyNodeInfo* internal_default_instance() {
    return reinterpret_cast<const MyNodeInfo*>(
               &_MyNodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MyNodeInfo& a, MyNodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MyNodeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyNodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MyNodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MyNodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MyNodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MyNodeInfo& from) {
    MyNodeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyNodeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.MyNodeInfo";
  }
  protected:
  explicit MyNodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 12,
    kPioEnvFieldNumber = 13,
    kMyNodeNumFieldNumber = 1,
    kRebootCountFieldNumber = 8,
    kMinAppVersionFieldNumber = 11,
    kFirmwareEditionFieldNumber = 14,
    kNodedbCountFieldNumber = 15,
  };
  // bytes device_id = 12;
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // string pio_env = 13;
  void clear_pio_env();
  const std::string& pio_env() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pio_env(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pio_env();
  PROTOBUF_NODISCARD std::string* release_pio_env();
  void set_allocated_pio_env(std::string* pio_env);
  private:
  const std::string& _internal_pio_env() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pio_env(const std::string& value);
  std::string* _internal_mutable_pio_env();
  public:

  // uint32 my_node_num = 1;
  void clear_my_node_num();
  uint32_t my_node_num() const;
  void set_my_node_num(uint32_t value);
  private:
  uint32_t _internal_my_node_num() const;
  void _internal_set_my_node_num(uint32_t value);
  public:

  // uint32 reboot_count = 8;
  void clear_reboot_count();
  uint32_t reboot_count() const;
  void set_reboot_count(uint32_t value);
  private:
  uint32_t _internal_reboot_count() const;
  void _internal_set_reboot_count(uint32_t value);
  public:

  // uint32 min_app_version = 11;
  void clear_min_app_version();
  uint32_t min_app_version() const;
  void set_min_app_version(uint32_t value);
  private:
  uint32_t _internal_min_app_version() const;
  void _internal_set_min_app_version(uint32_t value);
  public:

  // .meshtastic.FirmwareEdition firmware_edition = 14;
  void clear_firmware_edition();
  ::meshtastic::FirmwareEdition firmware_edition() const;
  void set_firmware_edition(::meshtastic::FirmwareEdition value);
  private:
  ::meshtastic::FirmwareEdition _internal_firmware_edition() const;
  void _internal_set_firmware_edition(::meshtastic::FirmwareEdition value);
  public:

  // uint32 nodedb_count = 15;
  void clear_nodedb_count();
  uint32_t nodedb_count() const;
  void set_nodedb_count(uint32_t value);
  private:
  uint32_t _internal_nodedb_count() const;
  void _internal_set_nodedb_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.MyNodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pio_env_;
    uint32_t my_node_num_;
    uint32_t reboot_count_;
    uint32_t min_app_version_;
    int firmware_edition_;
    uint32_t nodedb_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class LogRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.LogRecord) */ {
 public:
  inline LogRecord() : LogRecord(nullptr) {}
  ~LogRecord() override;
  explicit PROTOBUF_CONSTEXPR LogRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogRecord(const LogRecord& from);
  LogRecord(LogRecord&& from) noexcept
    : LogRecord() {
    *this = ::std::move(from);
  }

  inline LogRecord& operator=(const LogRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogRecord& operator=(LogRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogRecord* internal_default_instance() {
    return reinterpret_cast<const LogRecord*>(
               &_LogRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LogRecord& a, LogRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(LogRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogRecord& from) {
    LogRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.LogRecord";
  }
  protected:
  explicit LogRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogRecord_Level Level;
  static constexpr Level UNSET =
    LogRecord_Level_UNSET;
  static constexpr Level CRITICAL =
    LogRecord_Level_CRITICAL;
  static constexpr Level ERROR =
    LogRecord_Level_ERROR;
  static constexpr Level WARNING =
    LogRecord_Level_WARNING;
  static constexpr Level INFO =
    LogRecord_Level_INFO;
  static constexpr Level DEBUG =
    LogRecord_Level_DEBUG;
  static constexpr Level TRACE =
    LogRecord_Level_TRACE;
  static inline bool Level_IsValid(int value) {
    return LogRecord_Level_IsValid(value);
  }
  static constexpr Level Level_MIN =
    LogRecord_Level_Level_MIN;
  static constexpr Level Level_MAX =
    LogRecord_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE =
    LogRecord_Level_Level_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Level_descriptor() {
    return LogRecord_Level_descriptor();
  }
  template<typename T>
  static inline const std::string& Level_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Level>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Level_Name.");
    return LogRecord_Level_Name(enum_t_value);
  }
  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Level* value) {
    return LogRecord_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kSourceFieldNumber = 3,
    kTimeFieldNumber = 2,
    kLevelFieldNumber = 4,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string source = 3;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // fixed32 time = 2;
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // .meshtastic.LogRecord.Level level = 4;
  void clear_level();
  ::meshtastic::LogRecord_Level level() const;
  void set_level(::meshtastic::LogRecord_Level value);
  private:
  ::meshtastic::LogRecord_Level _internal_level() const;
  void _internal_set_level(::meshtastic::LogRecord_Level value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.LogRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    uint32_t time_;
    int level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class QueueStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.QueueStatus) */ {
 public:
  inline QueueStatus() : QueueStatus(nullptr) {}
  ~QueueStatus() override;
  explicit PROTOBUF_CONSTEXPR QueueStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueueStatus(const QueueStatus& from);
  QueueStatus(QueueStatus&& from) noexcept
    : QueueStatus() {
    *this = ::std::move(from);
  }

  inline QueueStatus& operator=(const QueueStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueueStatus& operator=(QueueStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueueStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueueStatus* internal_default_instance() {
    return reinterpret_cast<const QueueStatus*>(
               &_QueueStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(QueueStatus& a, QueueStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(QueueStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueueStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueueStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueueStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueueStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueueStatus& from) {
    QueueStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueueStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.QueueStatus";
  }
  protected:
  explicit QueueStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResFieldNumber = 1,
    kFreeFieldNumber = 2,
    kMaxlenFieldNumber = 3,
    kMeshPacketIdFieldNumber = 4,
  };
  // int32 res = 1;
  void clear_res();
  int32_t res() const;
  void set_res(int32_t value);
  private:
  int32_t _internal_res() const;
  void _internal_set_res(int32_t value);
  public:

  // uint32 free = 2;
  void clear_free();
  uint32_t free() const;
  void set_free(uint32_t value);
  private:
  uint32_t _internal_free() const;
  void _internal_set_free(uint32_t value);
  public:

  // uint32 maxlen = 3;
  void clear_maxlen();
  uint32_t maxlen() const;
  void set_maxlen(uint32_t value);
  private:
  uint32_t _internal_maxlen() const;
  void _internal_set_maxlen(uint32_t value);
  public:

  // uint32 mesh_packet_id = 4;
  void clear_mesh_packet_id();
  uint32_t mesh_packet_id() const;
  void set_mesh_packet_id(uint32_t value);
  private:
  uint32_t _internal_mesh_packet_id() const;
  void _internal_set_mesh_packet_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.QueueStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t res_;
    uint32_t free_;
    uint32_t maxlen_;
    uint32_t mesh_packet_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class FromRadio final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.FromRadio) */ {
 public:
  inline FromRadio() : FromRadio(nullptr) {}
  ~FromRadio() override;
  explicit PROTOBUF_CONSTEXPR FromRadio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FromRadio(const FromRadio& from);
  FromRadio(FromRadio&& from) noexcept
    : FromRadio() {
    *this = ::std::move(from);
  }

  inline FromRadio& operator=(const FromRadio& from) {
    CopyFrom(from);
    return *this;
  }
  inline FromRadio& operator=(FromRadio&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FromRadio& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kPacket = 2,
    kMyInfo = 3,
    kNodeInfo = 4,
    kConfig = 5,
    kLogRecord = 6,
    kConfigCompleteId = 7,
    kRebooted = 8,
    kModuleConfig = 9,
    kChannel = 10,
    kQueueStatus = 11,
    kXmodemPacket = 12,
    kMetadata = 13,
    kMqttClientProxyMessage = 14,
    kFileInfo = 15,
    kClientNotification = 16,
    kDeviceuiConfig = 17,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };

  static inline const FromRadio* internal_default_instance() {
    return reinterpret_cast<const FromRadio*>(
               &_FromRadio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FromRadio& a, FromRadio& b) {
    a.Swap(&b);
  }
  inline void Swap(FromRadio* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FromRadio* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FromRadio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FromRadio>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FromRadio& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FromRadio& from) {
    FromRadio::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FromRadio* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.FromRadio";
  }
  protected:
  explicit FromRadio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPacketFieldNumber = 2,
    kMyInfoFieldNumber = 3,
    kNodeInfoFieldNumber = 4,
    kConfigFieldNumber = 5,
    kLogRecordFieldNumber = 6,
    kConfigCompleteIdFieldNumber = 7,
    kRebootedFieldNumber = 8,
    kModuleConfigFieldNumber = 9,
    kChannelFieldNumber = 10,
    kQueueStatusFieldNumber = 11,
    kXmodemPacketFieldNumber = 12,
    kMetadataFieldNumber = 13,
    kMqttClientProxyMessageFieldNumber = 14,
    kFileInfoFieldNumber = 15,
    kClientNotificationFieldNumber = 16,
    kDeviceuiConfigFieldNumber = 17,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // .meshtastic.MeshPacket packet = 2;
  bool has_packet() const;
  private:
  bool _internal_has_packet() const;
  public:
  void clear_packet();
  const ::meshtastic::MeshPacket& packet() const;
  PROTOBUF_NODISCARD ::meshtastic::MeshPacket* release_packet();
  ::meshtastic::MeshPacket* mutable_packet();
  void set_allocated_packet(::meshtastic::MeshPacket* packet);
  private:
  const ::meshtastic::MeshPacket& _internal_packet() const;
  ::meshtastic::MeshPacket* _internal_mutable_packet();
  public:
  void unsafe_arena_set_allocated_packet(
      ::meshtastic::MeshPacket* packet);
  ::meshtastic::MeshPacket* unsafe_arena_release_packet();

  // .meshtastic.MyNodeInfo my_info = 3;
  bool has_my_info() const;
  private:
  bool _internal_has_my_info() const;
  public:
  void clear_my_info();
  const ::meshtastic::MyNodeInfo& my_info() const;
  PROTOBUF_NODISCARD ::meshtastic::MyNodeInfo* release_my_info();
  ::meshtastic::MyNodeInfo* mutable_my_info();
  void set_allocated_my_info(::meshtastic::MyNodeInfo* my_info);
  private:
  const ::meshtastic::MyNodeInfo& _internal_my_info() const;
  ::meshtastic::MyNodeInfo* _internal_mutable_my_info();
  public:
  void unsafe_arena_set_allocated_my_info(
      ::meshtastic::MyNodeInfo* my_info);
  ::meshtastic::MyNodeInfo* unsafe_arena_release_my_info();

  // .meshtastic.NodeInfo node_info = 4;
  bool has_node_info() const;
  private:
  bool _internal_has_node_info() const;
  public:
  void clear_node_info();
  const ::meshtastic::NodeInfo& node_info() const;
  PROTOBUF_NODISCARD ::meshtastic::NodeInfo* release_node_info();
  ::meshtastic::NodeInfo* mutable_node_info();
  void set_allocated_node_info(::meshtastic::NodeInfo* node_info);
  private:
  const ::meshtastic::NodeInfo& _internal_node_info() const;
  ::meshtastic::NodeInfo* _internal_mutable_node_info();
  public:
  void unsafe_arena_set_allocated_node_info(
      ::meshtastic::NodeInfo* node_info);
  ::meshtastic::NodeInfo* unsafe_arena_release_node_info();

  // .meshtastic.Config config = 5;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::meshtastic::Config& config() const;
  PROTOBUF_NODISCARD ::meshtastic::Config* release_config();
  ::meshtastic::Config* mutable_config();
  void set_allocated_config(::meshtastic::Config* config);
  private:
  const ::meshtastic::Config& _internal_config() const;
  ::meshtastic::Config* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::meshtastic::Config* config);
  ::meshtastic::Config* unsafe_arena_release_config();

  // .meshtastic.LogRecord log_record = 6;
  bool has_log_record() const;
  private:
  bool _internal_has_log_record() const;
  public:
  void clear_log_record();
  const ::meshtastic::LogRecord& log_record() const;
  PROTOBUF_NODISCARD ::meshtastic::LogRecord* release_log_record();
  ::meshtastic::LogRecord* mutable_log_record();
  void set_allocated_log_record(::meshtastic::LogRecord* log_record);
  private:
  const ::meshtastic::LogRecord& _internal_log_record() const;
  ::meshtastic::LogRecord* _internal_mutable_log_record();
  public:
  void unsafe_arena_set_allocated_log_record(
      ::meshtastic::LogRecord* log_record);
  ::meshtastic::LogRecord* unsafe_arena_release_log_record();

  // uint32 config_complete_id = 7;
  bool has_config_complete_id() const;
  private:
  bool _internal_has_config_complete_id() const;
  public:
  void clear_config_complete_id();
  uint32_t config_complete_id() const;
  void set_config_complete_id(uint32_t value);
  private:
  uint32_t _internal_config_complete_id() const;
  void _internal_set_config_complete_id(uint32_t value);
  public:

  // bool rebooted = 8;
  bool has_rebooted() const;
  private:
  bool _internal_has_rebooted() const;
  public:
  void clear_rebooted();
  bool rebooted() const;
  void set_rebooted(bool value);
  private:
  bool _internal_rebooted() const;
  void _internal_set_rebooted(bool value);
  public:

  // .meshtastic.ModuleConfig moduleConfig = 9;
  bool has_moduleconfig() const;
  private:
  bool _internal_has_moduleconfig() const;
  public:
  void clear_moduleconfig();
  const ::meshtastic::ModuleConfig& moduleconfig() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig* release_moduleconfig();
  ::meshtastic::ModuleConfig* mutable_moduleconfig();
  void set_allocated_moduleconfig(::meshtastic::ModuleConfig* moduleconfig);
  private:
  const ::meshtastic::ModuleConfig& _internal_moduleconfig() const;
  ::meshtastic::ModuleConfig* _internal_mutable_moduleconfig();
  public:
  void unsafe_arena_set_allocated_moduleconfig(
      ::meshtastic::ModuleConfig* moduleconfig);
  ::meshtastic::ModuleConfig* unsafe_arena_release_moduleconfig();

  // .meshtastic.Channel channel = 10;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  const ::meshtastic::Channel& channel() const;
  PROTOBUF_NODISCARD ::meshtastic::Channel* release_channel();
  ::meshtastic::Channel* mutable_channel();
  void set_allocated_channel(::meshtastic::Channel* channel);
  private:
  const ::meshtastic::Channel& _internal_channel() const;
  ::meshtastic::Channel* _internal_mutable_channel();
  public:
  void unsafe_arena_set_allocated_channel(
      ::meshtastic::Channel* channel);
  ::meshtastic::Channel* unsafe_arena_release_channel();

  // .meshtastic.QueueStatus queueStatus = 11;
  bool has_queuestatus() const;
  private:
  bool _internal_has_queuestatus() const;
  public:
  void clear_queuestatus();
  const ::meshtastic::QueueStatus& queuestatus() const;
  PROTOBUF_NODISCARD ::meshtastic::QueueStatus* release_queuestatus();
  ::meshtastic::QueueStatus* mutable_queuestatus();
  void set_allocated_queuestatus(::meshtastic::QueueStatus* queuestatus);
  private:
  const ::meshtastic::QueueStatus& _internal_queuestatus() const;
  ::meshtastic::QueueStatus* _internal_mutable_queuestatus();
  public:
  void unsafe_arena_set_allocated_queuestatus(
      ::meshtastic::QueueStatus* queuestatus);
  ::meshtastic::QueueStatus* unsafe_arena_release_queuestatus();

  // .meshtastic.XModem xmodemPacket = 12;
  bool has_xmodempacket() const;
  private:
  bool _internal_has_xmodempacket() const;
  public:
  void clear_xmodempacket();
  const ::meshtastic::XModem& xmodempacket() const;
  PROTOBUF_NODISCARD ::meshtastic::XModem* release_xmodempacket();
  ::meshtastic::XModem* mutable_xmodempacket();
  void set_allocated_xmodempacket(::meshtastic::XModem* xmodempacket);
  private:
  const ::meshtastic::XModem& _internal_xmodempacket() const;
  ::meshtastic::XModem* _internal_mutable_xmodempacket();
  public:
  void unsafe_arena_set_allocated_xmodempacket(
      ::meshtastic::XModem* xmodempacket);
  ::meshtastic::XModem* unsafe_arena_release_xmodempacket();

  // .meshtastic.DeviceMetadata metadata = 13;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::meshtastic::DeviceMetadata& metadata() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceMetadata* release_metadata();
  ::meshtastic::DeviceMetadata* mutable_metadata();
  void set_allocated_metadata(::meshtastic::DeviceMetadata* metadata);
  private:
  const ::meshtastic::DeviceMetadata& _internal_metadata() const;
  ::meshtastic::DeviceMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::meshtastic::DeviceMetadata* metadata);
  ::meshtastic::DeviceMetadata* unsafe_arena_release_metadata();

  // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 14;
  bool has_mqttclientproxymessage() const;
  private:
  bool _internal_has_mqttclientproxymessage() const;
  public:
  void clear_mqttclientproxymessage();
  const ::meshtastic::MqttClientProxyMessage& mqttclientproxymessage() const;
  PROTOBUF_NODISCARD ::meshtastic::MqttClientProxyMessage* release_mqttclientproxymessage();
  ::meshtastic::MqttClientProxyMessage* mutable_mqttclientproxymessage();
  void set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* mqttclientproxymessage);
  private:
  const ::meshtastic::MqttClientProxyMessage& _internal_mqttclientproxymessage() const;
  ::meshtastic::MqttClientProxyMessage* _internal_mutable_mqttclientproxymessage();
  public:
  void unsafe_arena_set_allocated_mqttclientproxymessage(
      ::meshtastic::MqttClientProxyMessage* mqttclientproxymessage);
  ::meshtastic::MqttClientProxyMessage* unsafe_arena_release_mqttclientproxymessage();

  // .meshtastic.FileInfo fileInfo = 15;
  bool has_fileinfo() const;
  private:
  bool _internal_has_fileinfo() const;
  public:
  void clear_fileinfo();
  const ::meshtastic::FileInfo& fileinfo() const;
  PROTOBUF_NODISCARD ::meshtastic::FileInfo* release_fileinfo();
  ::meshtastic::FileInfo* mutable_fileinfo();
  void set_allocated_fileinfo(::meshtastic::FileInfo* fileinfo);
  private:
  const ::meshtastic::FileInfo& _internal_fileinfo() const;
  ::meshtastic::FileInfo* _internal_mutable_fileinfo();
  public:
  void unsafe_arena_set_allocated_fileinfo(
      ::meshtastic::FileInfo* fileinfo);
  ::meshtastic::FileInfo* unsafe_arena_release_fileinfo();

  // .meshtastic.ClientNotification clientNotification = 16;
  bool has_clientnotification() const;
  private:
  bool _internal_has_clientnotification() const;
  public:
  void clear_clientnotification();
  const ::meshtastic::ClientNotification& clientnotification() const;
  PROTOBUF_NODISCARD ::meshtastic::ClientNotification* release_clientnotification();
  ::meshtastic::ClientNotification* mutable_clientnotification();
  void set_allocated_clientnotification(::meshtastic::ClientNotification* clientnotification);
  private:
  const ::meshtastic::ClientNotification& _internal_clientnotification() const;
  ::meshtastic::ClientNotification* _internal_mutable_clientnotification();
  public:
  void unsafe_arena_set_allocated_clientnotification(
      ::meshtastic::ClientNotification* clientnotification);
  ::meshtastic::ClientNotification* unsafe_arena_release_clientnotification();

  // .meshtastic.DeviceUIConfig deviceuiConfig = 17;
  bool has_deviceuiconfig() const;
  private:
  bool _internal_has_deviceuiconfig() const;
  public:
  void clear_deviceuiconfig();
  const ::meshtastic::DeviceUIConfig& deviceuiconfig() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceUIConfig* release_deviceuiconfig();
  ::meshtastic::DeviceUIConfig* mutable_deviceuiconfig();
  void set_allocated_deviceuiconfig(::meshtastic::DeviceUIConfig* deviceuiconfig);
  private:
  const ::meshtastic::DeviceUIConfig& _internal_deviceuiconfig() const;
  ::meshtastic::DeviceUIConfig* _internal_mutable_deviceuiconfig();
  public:
  void unsafe_arena_set_allocated_deviceuiconfig(
      ::meshtastic::DeviceUIConfig* deviceuiconfig);
  ::meshtastic::DeviceUIConfig* unsafe_arena_release_deviceuiconfig();

  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.FromRadio)
 private:
  class _Internal;
  void set_has_packet();
  void set_has_my_info();
  void set_has_node_info();
  void set_has_config();
  void set_has_log_record();
  void set_has_config_complete_id();
  void set_has_rebooted();
  void set_has_moduleconfig();
  void set_has_channel();
  void set_has_queuestatus();
  void set_has_xmodempacket();
  void set_has_metadata();
  void set_has_mqttclientproxymessage();
  void set_has_fileinfo();
  void set_has_clientnotification();
  void set_has_deviceuiconfig();

  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::meshtastic::MeshPacket* packet_;
      ::meshtastic::MyNodeInfo* my_info_;
      ::meshtastic::NodeInfo* node_info_;
      ::meshtastic::Config* config_;
      ::meshtastic::LogRecord* log_record_;
      uint32_t config_complete_id_;
      bool rebooted_;
      ::meshtastic::ModuleConfig* moduleconfig_;
      ::meshtastic::Channel* channel_;
      ::meshtastic::QueueStatus* queuestatus_;
      ::meshtastic::XModem* xmodempacket_;
      ::meshtastic::DeviceMetadata* metadata_;
      ::meshtastic::MqttClientProxyMessage* mqttclientproxymessage_;
      ::meshtastic::FileInfo* fileinfo_;
      ::meshtastic::ClientNotification* clientnotification_;
      ::meshtastic::DeviceUIConfig* deviceuiconfig_;
    } payload_variant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class ClientNotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ClientNotification) */ {
 public:
  inline ClientNotification() : ClientNotification(nullptr) {}
  ~ClientNotification() override;
  explicit PROTOBUF_CONSTEXPR ClientNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientNotification(const ClientNotification& from);
  ClientNotification(ClientNotification&& from) noexcept
    : ClientNotification() {
    *this = ::std::move(from);
  }

  inline ClientNotification& operator=(const ClientNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientNotification& operator=(ClientNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientNotification& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kKeyVerificationNumberInform = 11,
    kKeyVerificationNumberRequest = 12,
    kKeyVerificationFinal = 13,
    kDuplicatedPublicKey = 14,
    kLowEntropyKey = 15,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };

  static inline const ClientNotification* internal_default_instance() {
    return reinterpret_cast<const ClientNotification*>(
               &_ClientNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ClientNotification& a, ClientNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientNotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientNotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientNotification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientNotification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientNotification& from) {
    ClientNotification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientNotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ClientNotification";
  }
  protected:
  explicit ClientNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 4,
    kReplyIdFieldNumber = 1,
    kTimeFieldNumber = 2,
    kLevelFieldNumber = 3,
    kKeyVerificationNumberInformFieldNumber = 11,
    kKeyVerificationNumberRequestFieldNumber = 12,
    kKeyVerificationFinalFieldNumber = 13,
    kDuplicatedPublicKeyFieldNumber = 14,
    kLowEntropyKeyFieldNumber = 15,
  };
  // string message = 4;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional uint32 reply_id = 1;
  bool has_reply_id() const;
  private:
  bool _internal_has_reply_id() const;
  public:
  void clear_reply_id();
  uint32_t reply_id() const;
  void set_reply_id(uint32_t value);
  private:
  uint32_t _internal_reply_id() const;
  void _internal_set_reply_id(uint32_t value);
  public:

  // fixed32 time = 2;
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // .meshtastic.LogRecord.Level level = 3;
  void clear_level();
  ::meshtastic::LogRecord_Level level() const;
  void set_level(::meshtastic::LogRecord_Level value);
  private:
  ::meshtastic::LogRecord_Level _internal_level() const;
  void _internal_set_level(::meshtastic::LogRecord_Level value);
  public:

  // .meshtastic.KeyVerificationNumberInform key_verification_number_inform = 11;
  bool has_key_verification_number_inform() const;
  private:
  bool _internal_has_key_verification_number_inform() const;
  public:
  void clear_key_verification_number_inform();
  const ::meshtastic::KeyVerificationNumberInform& key_verification_number_inform() const;
  PROTOBUF_NODISCARD ::meshtastic::KeyVerificationNumberInform* release_key_verification_number_inform();
  ::meshtastic::KeyVerificationNumberInform* mutable_key_verification_number_inform();
  void set_allocated_key_verification_number_inform(::meshtastic::KeyVerificationNumberInform* key_verification_number_inform);
  private:
  const ::meshtastic::KeyVerificationNumberInform& _internal_key_verification_number_inform() const;
  ::meshtastic::KeyVerificationNumberInform* _internal_mutable_key_verification_number_inform();
  public:
  void unsafe_arena_set_allocated_key_verification_number_inform(
      ::meshtastic::KeyVerificationNumberInform* key_verification_number_inform);
  ::meshtastic::KeyVerificationNumberInform* unsafe_arena_release_key_verification_number_inform();

  // .meshtastic.KeyVerificationNumberRequest key_verification_number_request = 12;
  bool has_key_verification_number_request() const;
  private:
  bool _internal_has_key_verification_number_request() const;
  public:
  void clear_key_verification_number_request();
  const ::meshtastic::KeyVerificationNumberRequest& key_verification_number_request() const;
  PROTOBUF_NODISCARD ::meshtastic::KeyVerificationNumberRequest* release_key_verification_number_request();
  ::meshtastic::KeyVerificationNumberRequest* mutable_key_verification_number_request();
  void set_allocated_key_verification_number_request(::meshtastic::KeyVerificationNumberRequest* key_verification_number_request);
  private:
  const ::meshtastic::KeyVerificationNumberRequest& _internal_key_verification_number_request() const;
  ::meshtastic::KeyVerificationNumberRequest* _internal_mutable_key_verification_number_request();
  public:
  void unsafe_arena_set_allocated_key_verification_number_request(
      ::meshtastic::KeyVerificationNumberRequest* key_verification_number_request);
  ::meshtastic::KeyVerificationNumberRequest* unsafe_arena_release_key_verification_number_request();

  // .meshtastic.KeyVerificationFinal key_verification_final = 13;
  bool has_key_verification_final() const;
  private:
  bool _internal_has_key_verification_final() const;
  public:
  void clear_key_verification_final();
  const ::meshtastic::KeyVerificationFinal& key_verification_final() const;
  PROTOBUF_NODISCARD ::meshtastic::KeyVerificationFinal* release_key_verification_final();
  ::meshtastic::KeyVerificationFinal* mutable_key_verification_final();
  void set_allocated_key_verification_final(::meshtastic::KeyVerificationFinal* key_verification_final);
  private:
  const ::meshtastic::KeyVerificationFinal& _internal_key_verification_final() const;
  ::meshtastic::KeyVerificationFinal* _internal_mutable_key_verification_final();
  public:
  void unsafe_arena_set_allocated_key_verification_final(
      ::meshtastic::KeyVerificationFinal* key_verification_final);
  ::meshtastic::KeyVerificationFinal* unsafe_arena_release_key_verification_final();

  // .meshtastic.DuplicatedPublicKey duplicated_public_key = 14;
  bool has_duplicated_public_key() const;
  private:
  bool _internal_has_duplicated_public_key() const;
  public:
  void clear_duplicated_public_key();
  const ::meshtastic::DuplicatedPublicKey& duplicated_public_key() const;
  PROTOBUF_NODISCARD ::meshtastic::DuplicatedPublicKey* release_duplicated_public_key();
  ::meshtastic::DuplicatedPublicKey* mutable_duplicated_public_key();
  void set_allocated_duplicated_public_key(::meshtastic::DuplicatedPublicKey* duplicated_public_key);
  private:
  const ::meshtastic::DuplicatedPublicKey& _internal_duplicated_public_key() const;
  ::meshtastic::DuplicatedPublicKey* _internal_mutable_duplicated_public_key();
  public:
  void unsafe_arena_set_allocated_duplicated_public_key(
      ::meshtastic::DuplicatedPublicKey* duplicated_public_key);
  ::meshtastic::DuplicatedPublicKey* unsafe_arena_release_duplicated_public_key();

  // .meshtastic.LowEntropyKey low_entropy_key = 15;
  bool has_low_entropy_key() const;
  private:
  bool _internal_has_low_entropy_key() const;
  public:
  void clear_low_entropy_key();
  const ::meshtastic::LowEntropyKey& low_entropy_key() const;
  PROTOBUF_NODISCARD ::meshtastic::LowEntropyKey* release_low_entropy_key();
  ::meshtastic::LowEntropyKey* mutable_low_entropy_key();
  void set_allocated_low_entropy_key(::meshtastic::LowEntropyKey* low_entropy_key);
  private:
  const ::meshtastic::LowEntropyKey& _internal_low_entropy_key() const;
  ::meshtastic::LowEntropyKey* _internal_mutable_low_entropy_key();
  public:
  void unsafe_arena_set_allocated_low_entropy_key(
      ::meshtastic::LowEntropyKey* low_entropy_key);
  ::meshtastic::LowEntropyKey* unsafe_arena_release_low_entropy_key();

  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.ClientNotification)
 private:
  class _Internal;
  void set_has_key_verification_number_inform();
  void set_has_key_verification_number_request();
  void set_has_key_verification_final();
  void set_has_duplicated_public_key();
  void set_has_low_entropy_key();

  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint32_t reply_id_;
    uint32_t time_;
    int level_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::meshtastic::KeyVerificationNumberInform* key_verification_number_inform_;
      ::meshtastic::KeyVerificationNumberRequest* key_verification_number_request_;
      ::meshtastic::KeyVerificationFinal* key_verification_final_;
      ::meshtastic::DuplicatedPublicKey* duplicated_public_key_;
      ::meshtastic::LowEntropyKey* low_entropy_key_;
    } payload_variant_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class KeyVerificationNumberInform final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.KeyVerificationNumberInform) */ {
 public:
  inline KeyVerificationNumberInform() : KeyVerificationNumberInform(nullptr) {}
  ~KeyVerificationNumberInform() override;
  explicit PROTOBUF_CONSTEXPR KeyVerificationNumberInform(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyVerificationNumberInform(const KeyVerificationNumberInform& from);
  KeyVerificationNumberInform(KeyVerificationNumberInform&& from) noexcept
    : KeyVerificationNumberInform() {
    *this = ::std::move(from);
  }

  inline KeyVerificationNumberInform& operator=(const KeyVerificationNumberInform& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyVerificationNumberInform& operator=(KeyVerificationNumberInform&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyVerificationNumberInform& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyVerificationNumberInform* internal_default_instance() {
    return reinterpret_cast<const KeyVerificationNumberInform*>(
               &_KeyVerificationNumberInform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(KeyVerificationNumberInform& a, KeyVerificationNumberInform& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyVerificationNumberInform* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyVerificationNumberInform* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyVerificationNumberInform* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyVerificationNumberInform>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyVerificationNumberInform& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyVerificationNumberInform& from) {
    KeyVerificationNumberInform::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyVerificationNumberInform* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.KeyVerificationNumberInform";
  }
  protected:
  explicit KeyVerificationNumberInform(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteLongnameFieldNumber = 2,
    kNonceFieldNumber = 1,
    kSecurityNumberFieldNumber = 3,
  };
  // string remote_longname = 2;
  void clear_remote_longname();
  const std::string& remote_longname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_longname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_longname();
  PROTOBUF_NODISCARD std::string* release_remote_longname();
  void set_allocated_remote_longname(std::string* remote_longname);
  private:
  const std::string& _internal_remote_longname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_longname(const std::string& value);
  std::string* _internal_mutable_remote_longname();
  public:

  // uint64 nonce = 1;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // uint32 security_number = 3;
  void clear_security_number();
  uint32_t security_number() const;
  void set_security_number(uint32_t value);
  private:
  uint32_t _internal_security_number() const;
  void _internal_set_security_number(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.KeyVerificationNumberInform)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_longname_;
    uint64_t nonce_;
    uint32_t security_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class KeyVerificationNumberRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.KeyVerificationNumberRequest) */ {
 public:
  inline KeyVerificationNumberRequest() : KeyVerificationNumberRequest(nullptr) {}
  ~KeyVerificationNumberRequest() override;
  explicit PROTOBUF_CONSTEXPR KeyVerificationNumberRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyVerificationNumberRequest(const KeyVerificationNumberRequest& from);
  KeyVerificationNumberRequest(KeyVerificationNumberRequest&& from) noexcept
    : KeyVerificationNumberRequest() {
    *this = ::std::move(from);
  }

  inline KeyVerificationNumberRequest& operator=(const KeyVerificationNumberRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyVerificationNumberRequest& operator=(KeyVerificationNumberRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyVerificationNumberRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyVerificationNumberRequest* internal_default_instance() {
    return reinterpret_cast<const KeyVerificationNumberRequest*>(
               &_KeyVerificationNumberRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(KeyVerificationNumberRequest& a, KeyVerificationNumberRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyVerificationNumberRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyVerificationNumberRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyVerificationNumberRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyVerificationNumberRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyVerificationNumberRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyVerificationNumberRequest& from) {
    KeyVerificationNumberRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyVerificationNumberRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.KeyVerificationNumberRequest";
  }
  protected:
  explicit KeyVerificationNumberRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteLongnameFieldNumber = 2,
    kNonceFieldNumber = 1,
  };
  // string remote_longname = 2;
  void clear_remote_longname();
  const std::string& remote_longname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_longname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_longname();
  PROTOBUF_NODISCARD std::string* release_remote_longname();
  void set_allocated_remote_longname(std::string* remote_longname);
  private:
  const std::string& _internal_remote_longname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_longname(const std::string& value);
  std::string* _internal_mutable_remote_longname();
  public:

  // uint64 nonce = 1;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.KeyVerificationNumberRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_longname_;
    uint64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class KeyVerificationFinal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.KeyVerificationFinal) */ {
 public:
  inline KeyVerificationFinal() : KeyVerificationFinal(nullptr) {}
  ~KeyVerificationFinal() override;
  explicit PROTOBUF_CONSTEXPR KeyVerificationFinal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyVerificationFinal(const KeyVerificationFinal& from);
  KeyVerificationFinal(KeyVerificationFinal&& from) noexcept
    : KeyVerificationFinal() {
    *this = ::std::move(from);
  }

  inline KeyVerificationFinal& operator=(const KeyVerificationFinal& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyVerificationFinal& operator=(KeyVerificationFinal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyVerificationFinal& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyVerificationFinal* internal_default_instance() {
    return reinterpret_cast<const KeyVerificationFinal*>(
               &_KeyVerificationFinal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(KeyVerificationFinal& a, KeyVerificationFinal& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyVerificationFinal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyVerificationFinal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyVerificationFinal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyVerificationFinal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyVerificationFinal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyVerificationFinal& from) {
    KeyVerificationFinal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyVerificationFinal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.KeyVerificationFinal";
  }
  protected:
  explicit KeyVerificationFinal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteLongnameFieldNumber = 2,
    kVerificationCharactersFieldNumber = 4,
    kNonceFieldNumber = 1,
    kIsSenderFieldNumber = 3,
  };
  // string remote_longname = 2;
  void clear_remote_longname();
  const std::string& remote_longname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_longname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_longname();
  PROTOBUF_NODISCARD std::string* release_remote_longname();
  void set_allocated_remote_longname(std::string* remote_longname);
  private:
  const std::string& _internal_remote_longname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_longname(const std::string& value);
  std::string* _internal_mutable_remote_longname();
  public:

  // string verification_characters = 4;
  void clear_verification_characters();
  const std::string& verification_characters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verification_characters(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verification_characters();
  PROTOBUF_NODISCARD std::string* release_verification_characters();
  void set_allocated_verification_characters(std::string* verification_characters);
  private:
  const std::string& _internal_verification_characters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_characters(const std::string& value);
  std::string* _internal_mutable_verification_characters();
  public:

  // uint64 nonce = 1;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // bool isSender = 3;
  void clear_issender();
  bool issender() const;
  void set_issender(bool value);
  private:
  bool _internal_issender() const;
  void _internal_set_issender(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.KeyVerificationFinal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_longname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verification_characters_;
    uint64_t nonce_;
    bool issender_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class DuplicatedPublicKey final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:meshtastic.DuplicatedPublicKey) */ {
 public:
  inline DuplicatedPublicKey() : DuplicatedPublicKey(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DuplicatedPublicKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DuplicatedPublicKey(const DuplicatedPublicKey& from);
  DuplicatedPublicKey(DuplicatedPublicKey&& from) noexcept
    : DuplicatedPublicKey() {
    *this = ::std::move(from);
  }

  inline DuplicatedPublicKey& operator=(const DuplicatedPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline DuplicatedPublicKey& operator=(DuplicatedPublicKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DuplicatedPublicKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const DuplicatedPublicKey* internal_default_instance() {
    return reinterpret_cast<const DuplicatedPublicKey*>(
               &_DuplicatedPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DuplicatedPublicKey& a, DuplicatedPublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(DuplicatedPublicKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DuplicatedPublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DuplicatedPublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DuplicatedPublicKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DuplicatedPublicKey& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DuplicatedPublicKey& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.DuplicatedPublicKey";
  }
  protected:
  explicit DuplicatedPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:meshtastic.DuplicatedPublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class LowEntropyKey final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:meshtastic.LowEntropyKey) */ {
 public:
  inline LowEntropyKey() : LowEntropyKey(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LowEntropyKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LowEntropyKey(const LowEntropyKey& from);
  LowEntropyKey(LowEntropyKey&& from) noexcept
    : LowEntropyKey() {
    *this = ::std::move(from);
  }

  inline LowEntropyKey& operator=(const LowEntropyKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline LowEntropyKey& operator=(LowEntropyKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LowEntropyKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const LowEntropyKey* internal_default_instance() {
    return reinterpret_cast<const LowEntropyKey*>(
               &_LowEntropyKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LowEntropyKey& a, LowEntropyKey& b) {
    a.Swap(&b);
  }
  inline void Swap(LowEntropyKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LowEntropyKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LowEntropyKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LowEntropyKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LowEntropyKey& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LowEntropyKey& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.LowEntropyKey";
  }
  protected:
  explicit LowEntropyKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:meshtastic.LowEntropyKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class FileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.FileInfo) */ {
 public:
  inline FileInfo() : FileInfo(nullptr) {}
  ~FileInfo() override;
  explicit PROTOBUF_CONSTEXPR FileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileInfo(const FileInfo& from);
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileInfo& from) {
    FileInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.FileInfo";
  }
  protected:
  explicit FileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kSizeBytesFieldNumber = 2,
  };
  // string file_name = 1;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // uint32 size_bytes = 2;
  void clear_size_bytes();
  uint32_t size_bytes() const;
  void set_size_bytes(uint32_t value);
  private:
  uint32_t _internal_size_bytes() const;
  void _internal_set_size_bytes(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.FileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    uint32_t size_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class ToRadio final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ToRadio) */ {
 public:
  inline ToRadio() : ToRadio(nullptr) {}
  ~ToRadio() override;
  explicit PROTOBUF_CONSTEXPR ToRadio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToRadio(const ToRadio& from);
  ToRadio(ToRadio&& from) noexcept
    : ToRadio() {
    *this = ::std::move(from);
  }

  inline ToRadio& operator=(const ToRadio& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToRadio& operator=(ToRadio&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToRadio& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kPacket = 1,
    kWantConfigId = 3,
    kDisconnect = 4,
    kXmodemPacket = 5,
    kMqttClientProxyMessage = 6,
    kHeartbeat = 7,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };

  static inline const ToRadio* internal_default_instance() {
    return reinterpret_cast<const ToRadio*>(
               &_ToRadio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ToRadio& a, ToRadio& b) {
    a.Swap(&b);
  }
  inline void Swap(ToRadio* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToRadio* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToRadio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToRadio>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToRadio& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToRadio& from) {
    ToRadio::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToRadio* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ToRadio";
  }
  protected:
  explicit ToRadio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketFieldNumber = 1,
    kWantConfigIdFieldNumber = 3,
    kDisconnectFieldNumber = 4,
    kXmodemPacketFieldNumber = 5,
    kMqttClientProxyMessageFieldNumber = 6,
    kHeartbeatFieldNumber = 7,
  };
  // .meshtastic.MeshPacket packet = 1;
  bool has_packet() const;
  private:
  bool _internal_has_packet() const;
  public:
  void clear_packet();
  const ::meshtastic::MeshPacket& packet() const;
  PROTOBUF_NODISCARD ::meshtastic::MeshPacket* release_packet();
  ::meshtastic::MeshPacket* mutable_packet();
  void set_allocated_packet(::meshtastic::MeshPacket* packet);
  private:
  const ::meshtastic::MeshPacket& _internal_packet() const;
  ::meshtastic::MeshPacket* _internal_mutable_packet();
  public:
  void unsafe_arena_set_allocated_packet(
      ::meshtastic::MeshPacket* packet);
  ::meshtastic::MeshPacket* unsafe_arena_release_packet();

  // uint32 want_config_id = 3;
  bool has_want_config_id() const;
  private:
  bool _internal_has_want_config_id() const;
  public:
  void clear_want_config_id();
  uint32_t want_config_id() const;
  void set_want_config_id(uint32_t value);
  private:
  uint32_t _internal_want_config_id() const;
  void _internal_set_want_config_id(uint32_t value);
  public:

  // bool disconnect = 4;
  bool has_disconnect() const;
  private:
  bool _internal_has_disconnect() const;
  public:
  void clear_disconnect();
  bool disconnect() const;
  void set_disconnect(bool value);
  private:
  bool _internal_disconnect() const;
  void _internal_set_disconnect(bool value);
  public:

  // .meshtastic.XModem xmodemPacket = 5;
  bool has_xmodempacket() const;
  private:
  bool _internal_has_xmodempacket() const;
  public:
  void clear_xmodempacket();
  const ::meshtastic::XModem& xmodempacket() const;
  PROTOBUF_NODISCARD ::meshtastic::XModem* release_xmodempacket();
  ::meshtastic::XModem* mutable_xmodempacket();
  void set_allocated_xmodempacket(::meshtastic::XModem* xmodempacket);
  private:
  const ::meshtastic::XModem& _internal_xmodempacket() const;
  ::meshtastic::XModem* _internal_mutable_xmodempacket();
  public:
  void unsafe_arena_set_allocated_xmodempacket(
      ::meshtastic::XModem* xmodempacket);
  ::meshtastic::XModem* unsafe_arena_release_xmodempacket();

  // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 6;
  bool has_mqttclientproxymessage() const;
  private:
  bool _internal_has_mqttclientproxymessage() const;
  public:
  void clear_mqttclientproxymessage();
  const ::meshtastic::MqttClientProxyMessage& mqttclientproxymessage() const;
  PROTOBUF_NODISCARD ::meshtastic::MqttClientProxyMessage* release_mqttclientproxymessage();
  ::meshtastic::MqttClientProxyMessage* mutable_mqttclientproxymessage();
  void set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* mqttclientproxymessage);
  private:
  const ::meshtastic::MqttClientProxyMessage& _internal_mqttclientproxymessage() const;
  ::meshtastic::MqttClientProxyMessage* _internal_mutable_mqttclientproxymessage();
  public:
  void unsafe_arena_set_allocated_mqttclientproxymessage(
      ::meshtastic::MqttClientProxyMessage* mqttclientproxymessage);
  ::meshtastic::MqttClientProxyMessage* unsafe_arena_release_mqttclientproxymessage();

  // .meshtastic.Heartbeat heartbeat = 7;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;
  public:
  void clear_heartbeat();
  const ::meshtastic::Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::meshtastic::Heartbeat* release_heartbeat();
  ::meshtastic::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::meshtastic::Heartbeat* heartbeat);
  private:
  const ::meshtastic::Heartbeat& _internal_heartbeat() const;
  ::meshtastic::Heartbeat* _internal_mutable_heartbeat();
  public:
  void unsafe_arena_set_allocated_heartbeat(
      ::meshtastic::Heartbeat* heartbeat);
  ::meshtastic::Heartbeat* unsafe_arena_release_heartbeat();

  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.ToRadio)
 private:
  class _Internal;
  void set_has_packet();
  void set_has_want_config_id();
  void set_has_disconnect();
  void set_has_xmodempacket();
  void set_has_mqttclientproxymessage();
  void set_has_heartbeat();

  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::meshtastic::MeshPacket* packet_;
      uint32_t want_config_id_;
      bool disconnect_;
      ::meshtastic::XModem* xmodempacket_;
      ::meshtastic::MqttClientProxyMessage* mqttclientproxymessage_;
      ::meshtastic::Heartbeat* heartbeat_;
    } payload_variant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Compressed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Compressed) */ {
 public:
  inline Compressed() : Compressed(nullptr) {}
  ~Compressed() override;
  explicit PROTOBUF_CONSTEXPR Compressed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Compressed(const Compressed& from);
  Compressed(Compressed&& from) noexcept
    : Compressed() {
    *this = ::std::move(from);
  }

  inline Compressed& operator=(const Compressed& from) {
    CopyFrom(from);
    return *this;
  }
  inline Compressed& operator=(Compressed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Compressed& default_instance() {
    return *internal_default_instance();
  }
  static inline const Compressed* internal_default_instance() {
    return reinterpret_cast<const Compressed*>(
               &_Compressed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Compressed& a, Compressed& b) {
    a.Swap(&b);
  }
  inline void Swap(Compressed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Compressed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Compressed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Compressed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Compressed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Compressed& from) {
    Compressed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Compressed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Compressed";
  }
  protected:
  explicit Compressed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPortnumFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .meshtastic.PortNum portnum = 1;
  void clear_portnum();
  ::meshtastic::PortNum portnum() const;
  void set_portnum(::meshtastic::PortNum value);
  private:
  ::meshtastic::PortNum _internal_portnum() const;
  void _internal_set_portnum(::meshtastic::PortNum value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Compressed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int portnum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class NeighborInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.NeighborInfo) */ {
 public:
  inline NeighborInfo() : NeighborInfo(nullptr) {}
  ~NeighborInfo() override;
  explicit PROTOBUF_CONSTEXPR NeighborInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NeighborInfo(const NeighborInfo& from);
  NeighborInfo(NeighborInfo&& from) noexcept
    : NeighborInfo() {
    *this = ::std::move(from);
  }

  inline NeighborInfo& operator=(const NeighborInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NeighborInfo& operator=(NeighborInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NeighborInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NeighborInfo* internal_default_instance() {
    return reinterpret_cast<const NeighborInfo*>(
               &_NeighborInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(NeighborInfo& a, NeighborInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NeighborInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NeighborInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NeighborInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NeighborInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NeighborInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NeighborInfo& from) {
    NeighborInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NeighborInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.NeighborInfo";
  }
  protected:
  explicit NeighborInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNeighborsFieldNumber = 4,
    kNodeIdFieldNumber = 1,
    kLastSentByIdFieldNumber = 2,
    kNodeBroadcastIntervalSecsFieldNumber = 3,
  };
  // repeated .meshtastic.Neighbor neighbors = 4;
  int neighbors_size() const;
  private:
  int _internal_neighbors_size() const;
  public:
  void clear_neighbors();
  ::meshtastic::Neighbor* mutable_neighbors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::Neighbor >*
      mutable_neighbors();
  private:
  const ::meshtastic::Neighbor& _internal_neighbors(int index) const;
  ::meshtastic::Neighbor* _internal_add_neighbors();
  public:
  const ::meshtastic::Neighbor& neighbors(int index) const;
  ::meshtastic::Neighbor* add_neighbors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::Neighbor >&
      neighbors() const;

  // uint32 node_id = 1;
  void clear_node_id();
  uint32_t node_id() const;
  void set_node_id(uint32_t value);
  private:
  uint32_t _internal_node_id() const;
  void _internal_set_node_id(uint32_t value);
  public:

  // uint32 last_sent_by_id = 2;
  void clear_last_sent_by_id();
  uint32_t last_sent_by_id() const;
  void set_last_sent_by_id(uint32_t value);
  private:
  uint32_t _internal_last_sent_by_id() const;
  void _internal_set_last_sent_by_id(uint32_t value);
  public:

  // uint32 node_broadcast_interval_secs = 3;
  void clear_node_broadcast_interval_secs();
  uint32_t node_broadcast_interval_secs() const;
  void set_node_broadcast_interval_secs(uint32_t value);
  private:
  uint32_t _internal_node_broadcast_interval_secs() const;
  void _internal_set_node_broadcast_interval_secs(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.NeighborInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::Neighbor > neighbors_;
    uint32_t node_id_;
    uint32_t last_sent_by_id_;
    uint32_t node_broadcast_interval_secs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Neighbor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Neighbor) */ {
 public:
  inline Neighbor() : Neighbor(nullptr) {}
  ~Neighbor() override;
  explicit PROTOBUF_CONSTEXPR Neighbor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neighbor(const Neighbor& from);
  Neighbor(Neighbor&& from) noexcept
    : Neighbor() {
    *this = ::std::move(from);
  }

  inline Neighbor& operator=(const Neighbor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neighbor& operator=(Neighbor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neighbor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neighbor* internal_default_instance() {
    return reinterpret_cast<const Neighbor*>(
               &_Neighbor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Neighbor& a, Neighbor& b) {
    a.Swap(&b);
  }
  inline void Swap(Neighbor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neighbor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neighbor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neighbor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Neighbor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Neighbor& from) {
    Neighbor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Neighbor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Neighbor";
  }
  protected:
  explicit Neighbor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kSnrFieldNumber = 2,
    kLastRxTimeFieldNumber = 3,
    kNodeBroadcastIntervalSecsFieldNumber = 4,
  };
  // uint32 node_id = 1;
  void clear_node_id();
  uint32_t node_id() const;
  void set_node_id(uint32_t value);
  private:
  uint32_t _internal_node_id() const;
  void _internal_set_node_id(uint32_t value);
  public:

  // float snr = 2;
  void clear_snr();
  float snr() const;
  void set_snr(float value);
  private:
  float _internal_snr() const;
  void _internal_set_snr(float value);
  public:

  // fixed32 last_rx_time = 3;
  void clear_last_rx_time();
  uint32_t last_rx_time() const;
  void set_last_rx_time(uint32_t value);
  private:
  uint32_t _internal_last_rx_time() const;
  void _internal_set_last_rx_time(uint32_t value);
  public:

  // uint32 node_broadcast_interval_secs = 4;
  void clear_node_broadcast_interval_secs();
  uint32_t node_broadcast_interval_secs() const;
  void set_node_broadcast_interval_secs(uint32_t value);
  private:
  uint32_t _internal_node_broadcast_interval_secs() const;
  void _internal_set_node_broadcast_interval_secs(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Neighbor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t node_id_;
    float snr_;
    uint32_t last_rx_time_;
    uint32_t node_broadcast_interval_secs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class DeviceMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.DeviceMetadata) */ {
 public:
  inline DeviceMetadata() : DeviceMetadata(nullptr) {}
  ~DeviceMetadata() override;
  explicit PROTOBUF_CONSTEXPR DeviceMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceMetadata(const DeviceMetadata& from);
  DeviceMetadata(DeviceMetadata&& from) noexcept
    : DeviceMetadata() {
    *this = ::std::move(from);
  }

  inline DeviceMetadata& operator=(const DeviceMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceMetadata& operator=(DeviceMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceMetadata* internal_default_instance() {
    return reinterpret_cast<const DeviceMetadata*>(
               &_DeviceMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DeviceMetadata& a, DeviceMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceMetadata& from) {
    DeviceMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.DeviceMetadata";
  }
  protected:
  explicit DeviceMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirmwareVersionFieldNumber = 1,
    kDeviceStateVersionFieldNumber = 2,
    kCanShutdownFieldNumber = 3,
    kHasWifiFieldNumber = 4,
    kHasBluetoothFieldNumber = 5,
    kHasEthernetFieldNumber = 6,
    kRoleFieldNumber = 7,
    kPositionFlagsFieldNumber = 8,
    kHwModelFieldNumber = 9,
    kHasRemoteHardwareFieldNumber = 10,
    kHasPKCFieldNumber = 11,
    kExcludedModulesFieldNumber = 12,
  };
  // string firmware_version = 1;
  void clear_firmware_version();
  const std::string& firmware_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firmware_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firmware_version();
  PROTOBUF_NODISCARD std::string* release_firmware_version();
  void set_allocated_firmware_version(std::string* firmware_version);
  private:
  const std::string& _internal_firmware_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_version(const std::string& value);
  std::string* _internal_mutable_firmware_version();
  public:

  // uint32 device_state_version = 2;
  void clear_device_state_version();
  uint32_t device_state_version() const;
  void set_device_state_version(uint32_t value);
  private:
  uint32_t _internal_device_state_version() const;
  void _internal_set_device_state_version(uint32_t value);
  public:

  // bool canShutdown = 3;
  void clear_canshutdown();
  bool canshutdown() const;
  void set_canshutdown(bool value);
  private:
  bool _internal_canshutdown() const;
  void _internal_set_canshutdown(bool value);
  public:

  // bool hasWifi = 4;
  void clear_haswifi();
  bool haswifi() const;
  void set_haswifi(bool value);
  private:
  bool _internal_haswifi() const;
  void _internal_set_haswifi(bool value);
  public:

  // bool hasBluetooth = 5;
  void clear_hasbluetooth();
  bool hasbluetooth() const;
  void set_hasbluetooth(bool value);
  private:
  bool _internal_hasbluetooth() const;
  void _internal_set_hasbluetooth(bool value);
  public:

  // bool hasEthernet = 6;
  void clear_hasethernet();
  bool hasethernet() const;
  void set_hasethernet(bool value);
  private:
  bool _internal_hasethernet() const;
  void _internal_set_hasethernet(bool value);
  public:

  // .meshtastic.Config.DeviceConfig.Role role = 7;
  void clear_role();
  ::meshtastic::Config_DeviceConfig_Role role() const;
  void set_role(::meshtastic::Config_DeviceConfig_Role value);
  private:
  ::meshtastic::Config_DeviceConfig_Role _internal_role() const;
  void _internal_set_role(::meshtastic::Config_DeviceConfig_Role value);
  public:

  // uint32 position_flags = 8;
  void clear_position_flags();
  uint32_t position_flags() const;
  void set_position_flags(uint32_t value);
  private:
  uint32_t _internal_position_flags() const;
  void _internal_set_position_flags(uint32_t value);
  public:

  // .meshtastic.HardwareModel hw_model = 9;
  void clear_hw_model();
  ::meshtastic::HardwareModel hw_model() const;
  void set_hw_model(::meshtastic::HardwareModel value);
  private:
  ::meshtastic::HardwareModel _internal_hw_model() const;
  void _internal_set_hw_model(::meshtastic::HardwareModel value);
  public:

  // bool hasRemoteHardware = 10;
  void clear_hasremotehardware();
  bool hasremotehardware() const;
  void set_hasremotehardware(bool value);
  private:
  bool _internal_hasremotehardware() const;
  void _internal_set_hasremotehardware(bool value);
  public:

  // bool hasPKC = 11;
  void clear_haspkc();
  bool haspkc() const;
  void set_haspkc(bool value);
  private:
  bool _internal_haspkc() const;
  void _internal_set_haspkc(bool value);
  public:

  // uint32 excluded_modules = 12;
  void clear_excluded_modules();
  uint32_t excluded_modules() const;
  void set_excluded_modules(uint32_t value);
  private:
  uint32_t _internal_excluded_modules() const;
  void _internal_set_excluded_modules(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.DeviceMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firmware_version_;
    uint32_t device_state_version_;
    bool canshutdown_;
    bool haswifi_;
    bool hasbluetooth_;
    bool hasethernet_;
    int role_;
    uint32_t position_flags_;
    int hw_model_;
    bool hasremotehardware_;
    bool haspkc_;
    uint32_t excluded_modules_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class Heartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  ~Heartbeat() override;
  explicit PROTOBUF_CONSTEXPR Heartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Heartbeat(const Heartbeat& from);
  Heartbeat(Heartbeat&& from) noexcept
    : Heartbeat() {
    *this = ::std::move(from);
  }

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
               &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Heartbeat& a, Heartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Heartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Heartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Heartbeat& from) {
    Heartbeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Heartbeat";
  }
  protected:
  explicit Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // uint32 nonce = 1;
  void clear_nonce();
  uint32_t nonce() const;
  void set_nonce(uint32_t value);
  private:
  uint32_t _internal_nonce() const;
  void _internal_set_nonce(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Heartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class NodeRemoteHardwarePin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.NodeRemoteHardwarePin) */ {
 public:
  inline NodeRemoteHardwarePin() : NodeRemoteHardwarePin(nullptr) {}
  ~NodeRemoteHardwarePin() override;
  explicit PROTOBUF_CONSTEXPR NodeRemoteHardwarePin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeRemoteHardwarePin(const NodeRemoteHardwarePin& from);
  NodeRemoteHardwarePin(NodeRemoteHardwarePin&& from) noexcept
    : NodeRemoteHardwarePin() {
    *this = ::std::move(from);
  }

  inline NodeRemoteHardwarePin& operator=(const NodeRemoteHardwarePin& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRemoteHardwarePin& operator=(NodeRemoteHardwarePin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRemoteHardwarePin& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRemoteHardwarePin* internal_default_instance() {
    return reinterpret_cast<const NodeRemoteHardwarePin*>(
               &_NodeRemoteHardwarePin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(NodeRemoteHardwarePin& a, NodeRemoteHardwarePin& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeRemoteHardwarePin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRemoteHardwarePin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRemoteHardwarePin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeRemoteHardwarePin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeRemoteHardwarePin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeRemoteHardwarePin& from) {
    NodeRemoteHardwarePin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeRemoteHardwarePin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.NodeRemoteHardwarePin";
  }
  protected:
  explicit NodeRemoteHardwarePin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPinFieldNumber = 2,
    kNodeNumFieldNumber = 1,
  };
  // .meshtastic.RemoteHardwarePin pin = 2;
  bool has_pin() const;
  private:
  bool _internal_has_pin() const;
  public:
  void clear_pin();
  const ::meshtastic::RemoteHardwarePin& pin() const;
  PROTOBUF_NODISCARD ::meshtastic::RemoteHardwarePin* release_pin();
  ::meshtastic::RemoteHardwarePin* mutable_pin();
  void set_allocated_pin(::meshtastic::RemoteHardwarePin* pin);
  private:
  const ::meshtastic::RemoteHardwarePin& _internal_pin() const;
  ::meshtastic::RemoteHardwarePin* _internal_mutable_pin();
  public:
  void unsafe_arena_set_allocated_pin(
      ::meshtastic::RemoteHardwarePin* pin);
  ::meshtastic::RemoteHardwarePin* unsafe_arena_release_pin();

  // uint32 node_num = 1;
  void clear_node_num();
  uint32_t node_num() const;
  void set_node_num(uint32_t value);
  private:
  uint32_t _internal_node_num() const;
  void _internal_set_node_num(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.NodeRemoteHardwarePin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::meshtastic::RemoteHardwarePin* pin_;
    uint32_t node_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class ChunkedPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ChunkedPayload) */ {
 public:
  inline ChunkedPayload() : ChunkedPayload(nullptr) {}
  ~ChunkedPayload() override;
  explicit PROTOBUF_CONSTEXPR ChunkedPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChunkedPayload(const ChunkedPayload& from);
  ChunkedPayload(ChunkedPayload&& from) noexcept
    : ChunkedPayload() {
    *this = ::std::move(from);
  }

  inline ChunkedPayload& operator=(const ChunkedPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkedPayload& operator=(ChunkedPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChunkedPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChunkedPayload* internal_default_instance() {
    return reinterpret_cast<const ChunkedPayload*>(
               &_ChunkedPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ChunkedPayload& a, ChunkedPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(ChunkedPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkedPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChunkedPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChunkedPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChunkedPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChunkedPayload& from) {
    ChunkedPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkedPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ChunkedPayload";
  }
  protected:
  explicit ChunkedPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadChunkFieldNumber = 4,
    kPayloadIdFieldNumber = 1,
    kChunkCountFieldNumber = 2,
    kChunkIndexFieldNumber = 3,
  };
  // bytes payload_chunk = 4;
  void clear_payload_chunk();
  const std::string& payload_chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload_chunk();
  PROTOBUF_NODISCARD std::string* release_payload_chunk();
  void set_allocated_payload_chunk(std::string* payload_chunk);
  private:
  const std::string& _internal_payload_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_chunk(const std::string& value);
  std::string* _internal_mutable_payload_chunk();
  public:

  // uint32 payload_id = 1;
  void clear_payload_id();
  uint32_t payload_id() const;
  void set_payload_id(uint32_t value);
  private:
  uint32_t _internal_payload_id() const;
  void _internal_set_payload_id(uint32_t value);
  public:

  // uint32 chunk_count = 2;
  void clear_chunk_count();
  uint32_t chunk_count() const;
  void set_chunk_count(uint32_t value);
  private:
  uint32_t _internal_chunk_count() const;
  void _internal_set_chunk_count(uint32_t value);
  public:

  // uint32 chunk_index = 3;
  void clear_chunk_index();
  uint32_t chunk_index() const;
  void set_chunk_index(uint32_t value);
  private:
  uint32_t _internal_chunk_index() const;
  void _internal_set_chunk_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ChunkedPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_chunk_;
    uint32_t payload_id_;
    uint32_t chunk_count_;
    uint32_t chunk_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class resend_chunks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.resend_chunks) */ {
 public:
  inline resend_chunks() : resend_chunks(nullptr) {}
  ~resend_chunks() override;
  explicit PROTOBUF_CONSTEXPR resend_chunks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resend_chunks(const resend_chunks& from);
  resend_chunks(resend_chunks&& from) noexcept
    : resend_chunks() {
    *this = ::std::move(from);
  }

  inline resend_chunks& operator=(const resend_chunks& from) {
    CopyFrom(from);
    return *this;
  }
  inline resend_chunks& operator=(resend_chunks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resend_chunks& default_instance() {
    return *internal_default_instance();
  }
  static inline const resend_chunks* internal_default_instance() {
    return reinterpret_cast<const resend_chunks*>(
               &_resend_chunks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(resend_chunks& a, resend_chunks& b) {
    a.Swap(&b);
  }
  inline void Swap(resend_chunks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resend_chunks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resend_chunks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resend_chunks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resend_chunks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resend_chunks& from) {
    resend_chunks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resend_chunks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.resend_chunks";
  }
  protected:
  explicit resend_chunks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunksFieldNumber = 1,
  };
  // repeated uint32 chunks = 1;
  int chunks_size() const;
  private:
  int _internal_chunks_size() const;
  public:
  void clear_chunks();
  private:
  uint32_t _internal_chunks(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_chunks() const;
  void _internal_add_chunks(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_chunks();
  public:
  uint32_t chunks(int index) const;
  void set_chunks(int index, uint32_t value);
  void add_chunks(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      chunks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_chunks();

  // @@protoc_insertion_point(class_scope:meshtastic.resend_chunks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > chunks_;
    mutable std::atomic<int> _chunks_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// -------------------------------------------------------------------

class ChunkedPayloadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ChunkedPayloadResponse) */ {
 public:
  inline ChunkedPayloadResponse() : ChunkedPayloadResponse(nullptr) {}
  ~ChunkedPayloadResponse() override;
  explicit PROTOBUF_CONSTEXPR ChunkedPayloadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChunkedPayloadResponse(const ChunkedPayloadResponse& from);
  ChunkedPayloadResponse(ChunkedPayloadResponse&& from) noexcept
    : ChunkedPayloadResponse() {
    *this = ::std::move(from);
  }

  inline ChunkedPayloadResponse& operator=(const ChunkedPayloadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkedPayloadResponse& operator=(ChunkedPayloadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChunkedPayloadResponse& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kRequestTransfer = 2,
    kAcceptTransfer = 3,
    kResendChunks = 4,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };

  static inline const ChunkedPayloadResponse* internal_default_instance() {
    return reinterpret_cast<const ChunkedPayloadResponse*>(
               &_ChunkedPayloadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ChunkedPayloadResponse& a, ChunkedPayloadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChunkedPayloadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkedPayloadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChunkedPayloadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChunkedPayloadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChunkedPayloadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChunkedPayloadResponse& from) {
    ChunkedPayloadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkedPayloadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ChunkedPayloadResponse";
  }
  protected:
  explicit ChunkedPayloadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadIdFieldNumber = 1,
    kRequestTransferFieldNumber = 2,
    kAcceptTransferFieldNumber = 3,
    kResendChunksFieldNumber = 4,
  };
  // uint32 payload_id = 1;
  void clear_payload_id();
  uint32_t payload_id() const;
  void set_payload_id(uint32_t value);
  private:
  uint32_t _internal_payload_id() const;
  void _internal_set_payload_id(uint32_t value);
  public:

  // bool request_transfer = 2;
  bool has_request_transfer() const;
  private:
  bool _internal_has_request_transfer() const;
  public:
  void clear_request_transfer();
  bool request_transfer() const;
  void set_request_transfer(bool value);
  private:
  bool _internal_request_transfer() const;
  void _internal_set_request_transfer(bool value);
  public:

  // bool accept_transfer = 3;
  bool has_accept_transfer() const;
  private:
  bool _internal_has_accept_transfer() const;
  public:
  void clear_accept_transfer();
  bool accept_transfer() const;
  void set_accept_transfer(bool value);
  private:
  bool _internal_accept_transfer() const;
  void _internal_set_accept_transfer(bool value);
  public:

  // .meshtastic.resend_chunks resend_chunks = 4;
  bool has_resend_chunks() const;
  private:
  bool _internal_has_resend_chunks() const;
  public:
  void clear_resend_chunks();
  const ::meshtastic::resend_chunks& resend_chunks() const;
  PROTOBUF_NODISCARD ::meshtastic::resend_chunks* release_resend_chunks();
  ::meshtastic::resend_chunks* mutable_resend_chunks();
  void set_allocated_resend_chunks(::meshtastic::resend_chunks* resend_chunks);
  private:
  const ::meshtastic::resend_chunks& _internal_resend_chunks() const;
  ::meshtastic::resend_chunks* _internal_mutable_resend_chunks();
  public:
  void unsafe_arena_set_allocated_resend_chunks(
      ::meshtastic::resend_chunks* resend_chunks);
  ::meshtastic::resend_chunks* unsafe_arena_release_resend_chunks();

  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.ChunkedPayloadResponse)
 private:
  class _Internal;
  void set_has_request_transfer();
  void set_has_accept_transfer();
  void set_has_resend_chunks();

  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t payload_id_;
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool request_transfer_;
      bool accept_transfer_;
      ::meshtastic::resend_chunks* resend_chunks_;
    } payload_variant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmesh_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Position

// optional sfixed32 latitude_i = 1;
inline bool Position::_internal_has_latitude_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Position::has_latitude_i() const {
  return _internal_has_latitude_i();
}
inline void Position::clear_latitude_i() {
  _impl_.latitude_i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Position::_internal_latitude_i() const {
  return _impl_.latitude_i_;
}
inline int32_t Position::latitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.latitude_i)
  return _internal_latitude_i();
}
inline void Position::_internal_set_latitude_i(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.latitude_i_ = value;
}
inline void Position::set_latitude_i(int32_t value) {
  _internal_set_latitude_i(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.latitude_i)
}

// optional sfixed32 longitude_i = 2;
inline bool Position::_internal_has_longitude_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Position::has_longitude_i() const {
  return _internal_has_longitude_i();
}
inline void Position::clear_longitude_i() {
  _impl_.longitude_i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Position::_internal_longitude_i() const {
  return _impl_.longitude_i_;
}
inline int32_t Position::longitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.longitude_i)
  return _internal_longitude_i();
}
inline void Position::_internal_set_longitude_i(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.longitude_i_ = value;
}
inline void Position::set_longitude_i(int32_t value) {
  _internal_set_longitude_i(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.longitude_i)
}

// optional int32 altitude = 3;
inline bool Position::_internal_has_altitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Position::has_altitude() const {
  return _internal_has_altitude();
}
inline void Position::clear_altitude() {
  _impl_.altitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Position::_internal_altitude() const {
  return _impl_.altitude_;
}
inline int32_t Position::altitude() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.altitude)
  return _internal_altitude();
}
inline void Position::_internal_set_altitude(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.altitude_ = value;
}
inline void Position::set_altitude(int32_t value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.altitude)
}

// fixed32 time = 4;
inline void Position::clear_time() {
  _impl_.time_ = 0u;
}
inline uint32_t Position::_internal_time() const {
  return _impl_.time_;
}
inline uint32_t Position::time() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.time)
  return _internal_time();
}
inline void Position::_internal_set_time(uint32_t value) {
  
  _impl_.time_ = value;
}
inline void Position::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.time)
}

// .meshtastic.Position.LocSource location_source = 5;
inline void Position::clear_location_source() {
  _impl_.location_source_ = 0;
}
inline ::meshtastic::Position_LocSource Position::_internal_location_source() const {
  return static_cast< ::meshtastic::Position_LocSource >(_impl_.location_source_);
}
inline ::meshtastic::Position_LocSource Position::location_source() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.location_source)
  return _internal_location_source();
}
inline void Position::_internal_set_location_source(::meshtastic::Position_LocSource value) {
  
  _impl_.location_source_ = value;
}
inline void Position::set_location_source(::meshtastic::Position_LocSource value) {
  _internal_set_location_source(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.location_source)
}

// .meshtastic.Position.AltSource altitude_source = 6;
inline void Position::clear_altitude_source() {
  _impl_.altitude_source_ = 0;
}
inline ::meshtastic::Position_AltSource Position::_internal_altitude_source() const {
  return static_cast< ::meshtastic::Position_AltSource >(_impl_.altitude_source_);
}
inline ::meshtastic::Position_AltSource Position::altitude_source() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.altitude_source)
  return _internal_altitude_source();
}
inline void Position::_internal_set_altitude_source(::meshtastic::Position_AltSource value) {
  
  _impl_.altitude_source_ = value;
}
inline void Position::set_altitude_source(::meshtastic::Position_AltSource value) {
  _internal_set_altitude_source(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.altitude_source)
}

// fixed32 timestamp = 7;
inline void Position::clear_timestamp() {
  _impl_.timestamp_ = 0u;
}
inline uint32_t Position::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t Position::timestamp() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.timestamp)
  return _internal_timestamp();
}
inline void Position::_internal_set_timestamp(uint32_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Position::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.timestamp)
}

// int32 timestamp_millis_adjust = 8;
inline void Position::clear_timestamp_millis_adjust() {
  _impl_.timestamp_millis_adjust_ = 0;
}
inline int32_t Position::_internal_timestamp_millis_adjust() const {
  return _impl_.timestamp_millis_adjust_;
}
inline int32_t Position::timestamp_millis_adjust() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.timestamp_millis_adjust)
  return _internal_timestamp_millis_adjust();
}
inline void Position::_internal_set_timestamp_millis_adjust(int32_t value) {
  
  _impl_.timestamp_millis_adjust_ = value;
}
inline void Position::set_timestamp_millis_adjust(int32_t value) {
  _internal_set_timestamp_millis_adjust(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.timestamp_millis_adjust)
}

// optional sint32 altitude_hae = 9;
inline bool Position::_internal_has_altitude_hae() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Position::has_altitude_hae() const {
  return _internal_has_altitude_hae();
}
inline void Position::clear_altitude_hae() {
  _impl_.altitude_hae_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t Position::_internal_altitude_hae() const {
  return _impl_.altitude_hae_;
}
inline int32_t Position::altitude_hae() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.altitude_hae)
  return _internal_altitude_hae();
}
inline void Position::_internal_set_altitude_hae(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.altitude_hae_ = value;
}
inline void Position::set_altitude_hae(int32_t value) {
  _internal_set_altitude_hae(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.altitude_hae)
}

// optional sint32 altitude_geoidal_separation = 10;
inline bool Position::_internal_has_altitude_geoidal_separation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Position::has_altitude_geoidal_separation() const {
  return _internal_has_altitude_geoidal_separation();
}
inline void Position::clear_altitude_geoidal_separation() {
  _impl_.altitude_geoidal_separation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t Position::_internal_altitude_geoidal_separation() const {
  return _impl_.altitude_geoidal_separation_;
}
inline int32_t Position::altitude_geoidal_separation() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.altitude_geoidal_separation)
  return _internal_altitude_geoidal_separation();
}
inline void Position::_internal_set_altitude_geoidal_separation(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.altitude_geoidal_separation_ = value;
}
inline void Position::set_altitude_geoidal_separation(int32_t value) {
  _internal_set_altitude_geoidal_separation(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.altitude_geoidal_separation)
}

// uint32 PDOP = 11;
inline void Position::clear_pdop() {
  _impl_.pdop_ = 0u;
}
inline uint32_t Position::_internal_pdop() const {
  return _impl_.pdop_;
}
inline uint32_t Position::pdop() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.PDOP)
  return _internal_pdop();
}
inline void Position::_internal_set_pdop(uint32_t value) {
  
  _impl_.pdop_ = value;
}
inline void Position::set_pdop(uint32_t value) {
  _internal_set_pdop(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.PDOP)
}

// uint32 HDOP = 12;
inline void Position::clear_hdop() {
  _impl_.hdop_ = 0u;
}
inline uint32_t Position::_internal_hdop() const {
  return _impl_.hdop_;
}
inline uint32_t Position::hdop() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.HDOP)
  return _internal_hdop();
}
inline void Position::_internal_set_hdop(uint32_t value) {
  
  _impl_.hdop_ = value;
}
inline void Position::set_hdop(uint32_t value) {
  _internal_set_hdop(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.HDOP)
}

// uint32 VDOP = 13;
inline void Position::clear_vdop() {
  _impl_.vdop_ = 0u;
}
inline uint32_t Position::_internal_vdop() const {
  return _impl_.vdop_;
}
inline uint32_t Position::vdop() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.VDOP)
  return _internal_vdop();
}
inline void Position::_internal_set_vdop(uint32_t value) {
  
  _impl_.vdop_ = value;
}
inline void Position::set_vdop(uint32_t value) {
  _internal_set_vdop(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.VDOP)
}

// uint32 gps_accuracy = 14;
inline void Position::clear_gps_accuracy() {
  _impl_.gps_accuracy_ = 0u;
}
inline uint32_t Position::_internal_gps_accuracy() const {
  return _impl_.gps_accuracy_;
}
inline uint32_t Position::gps_accuracy() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.gps_accuracy)
  return _internal_gps_accuracy();
}
inline void Position::_internal_set_gps_accuracy(uint32_t value) {
  
  _impl_.gps_accuracy_ = value;
}
inline void Position::set_gps_accuracy(uint32_t value) {
  _internal_set_gps_accuracy(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.gps_accuracy)
}

// optional uint32 ground_speed = 15;
inline bool Position::_internal_has_ground_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Position::has_ground_speed() const {
  return _internal_has_ground_speed();
}
inline void Position::clear_ground_speed() {
  _impl_.ground_speed_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t Position::_internal_ground_speed() const {
  return _impl_.ground_speed_;
}
inline uint32_t Position::ground_speed() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.ground_speed)
  return _internal_ground_speed();
}
inline void Position::_internal_set_ground_speed(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ground_speed_ = value;
}
inline void Position::set_ground_speed(uint32_t value) {
  _internal_set_ground_speed(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.ground_speed)
}

// optional uint32 ground_track = 16;
inline bool Position::_internal_has_ground_track() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Position::has_ground_track() const {
  return _internal_has_ground_track();
}
inline void Position::clear_ground_track() {
  _impl_.ground_track_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t Position::_internal_ground_track() const {
  return _impl_.ground_track_;
}
inline uint32_t Position::ground_track() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.ground_track)
  return _internal_ground_track();
}
inline void Position::_internal_set_ground_track(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ground_track_ = value;
}
inline void Position::set_ground_track(uint32_t value) {
  _internal_set_ground_track(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.ground_track)
}

// uint32 fix_quality = 17;
inline void Position::clear_fix_quality() {
  _impl_.fix_quality_ = 0u;
}
inline uint32_t Position::_internal_fix_quality() const {
  return _impl_.fix_quality_;
}
inline uint32_t Position::fix_quality() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.fix_quality)
  return _internal_fix_quality();
}
inline void Position::_internal_set_fix_quality(uint32_t value) {
  
  _impl_.fix_quality_ = value;
}
inline void Position::set_fix_quality(uint32_t value) {
  _internal_set_fix_quality(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.fix_quality)
}

// uint32 fix_type = 18;
inline void Position::clear_fix_type() {
  _impl_.fix_type_ = 0u;
}
inline uint32_t Position::_internal_fix_type() const {
  return _impl_.fix_type_;
}
inline uint32_t Position::fix_type() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.fix_type)
  return _internal_fix_type();
}
inline void Position::_internal_set_fix_type(uint32_t value) {
  
  _impl_.fix_type_ = value;
}
inline void Position::set_fix_type(uint32_t value) {
  _internal_set_fix_type(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.fix_type)
}

// uint32 sats_in_view = 19;
inline void Position::clear_sats_in_view() {
  _impl_.sats_in_view_ = 0u;
}
inline uint32_t Position::_internal_sats_in_view() const {
  return _impl_.sats_in_view_;
}
inline uint32_t Position::sats_in_view() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.sats_in_view)
  return _internal_sats_in_view();
}
inline void Position::_internal_set_sats_in_view(uint32_t value) {
  
  _impl_.sats_in_view_ = value;
}
inline void Position::set_sats_in_view(uint32_t value) {
  _internal_set_sats_in_view(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.sats_in_view)
}

// uint32 sensor_id = 20;
inline void Position::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t Position::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t Position::sensor_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.sensor_id)
  return _internal_sensor_id();
}
inline void Position::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void Position::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.sensor_id)
}

// uint32 next_update = 21;
inline void Position::clear_next_update() {
  _impl_.next_update_ = 0u;
}
inline uint32_t Position::_internal_next_update() const {
  return _impl_.next_update_;
}
inline uint32_t Position::next_update() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.next_update)
  return _internal_next_update();
}
inline void Position::_internal_set_next_update(uint32_t value) {
  
  _impl_.next_update_ = value;
}
inline void Position::set_next_update(uint32_t value) {
  _internal_set_next_update(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.next_update)
}

// uint32 seq_number = 22;
inline void Position::clear_seq_number() {
  _impl_.seq_number_ = 0u;
}
inline uint32_t Position::_internal_seq_number() const {
  return _impl_.seq_number_;
}
inline uint32_t Position::seq_number() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.seq_number)
  return _internal_seq_number();
}
inline void Position::_internal_set_seq_number(uint32_t value) {
  
  _impl_.seq_number_ = value;
}
inline void Position::set_seq_number(uint32_t value) {
  _internal_set_seq_number(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.seq_number)
}

// uint32 precision_bits = 23;
inline void Position::clear_precision_bits() {
  _impl_.precision_bits_ = 0u;
}
inline uint32_t Position::_internal_precision_bits() const {
  return _impl_.precision_bits_;
}
inline uint32_t Position::precision_bits() const {
  // @@protoc_insertion_point(field_get:meshtastic.Position.precision_bits)
  return _internal_precision_bits();
}
inline void Position::_internal_set_precision_bits(uint32_t value) {
  
  _impl_.precision_bits_ = value;
}
inline void Position::set_precision_bits(uint32_t value) {
  _internal_set_precision_bits(value);
  // @@protoc_insertion_point(field_set:meshtastic.Position.precision_bits)
}

// -------------------------------------------------------------------

// User

// string id = 1;
inline void User::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& User::id() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.User.id)
}
inline std::string* User::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:meshtastic.User.id)
  return _s;
}
inline const std::string& User::_internal_id() const {
  return _impl_.id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:meshtastic.User.id)
  return _impl_.id_.Release();
}
inline void User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.User.id)
}

// string long_name = 2;
inline void User::clear_long_name() {
  _impl_.long_name_.ClearToEmpty();
}
inline const std::string& User::long_name() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.long_name)
  return _internal_long_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_long_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.long_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.User.long_name)
}
inline std::string* User::mutable_long_name() {
  std::string* _s = _internal_mutable_long_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.User.long_name)
  return _s;
}
inline const std::string& User::_internal_long_name() const {
  return _impl_.long_name_.Get();
}
inline void User::_internal_set_long_name(const std::string& value) {
  
  _impl_.long_name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_long_name() {
  
  return _impl_.long_name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_long_name() {
  // @@protoc_insertion_point(field_release:meshtastic.User.long_name)
  return _impl_.long_name_.Release();
}
inline void User::set_allocated_long_name(std::string* long_name) {
  if (long_name != nullptr) {
    
  } else {
    
  }
  _impl_.long_name_.SetAllocated(long_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.long_name_.IsDefault()) {
    _impl_.long_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.User.long_name)
}

// string short_name = 3;
inline void User::clear_short_name() {
  _impl_.short_name_.ClearToEmpty();
}
inline const std::string& User::short_name() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.short_name)
  return _internal_short_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_short_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.short_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.User.short_name)
}
inline std::string* User::mutable_short_name() {
  std::string* _s = _internal_mutable_short_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.User.short_name)
  return _s;
}
inline const std::string& User::_internal_short_name() const {
  return _impl_.short_name_.Get();
}
inline void User::_internal_set_short_name(const std::string& value) {
  
  _impl_.short_name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_short_name() {
  
  return _impl_.short_name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_short_name() {
  // @@protoc_insertion_point(field_release:meshtastic.User.short_name)
  return _impl_.short_name_.Release();
}
inline void User::set_allocated_short_name(std::string* short_name) {
  if (short_name != nullptr) {
    
  } else {
    
  }
  _impl_.short_name_.SetAllocated(short_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.short_name_.IsDefault()) {
    _impl_.short_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.User.short_name)
}

// bytes macaddr = 4 [deprecated = true];
inline void User::clear_macaddr() {
  _impl_.macaddr_.ClearToEmpty();
}
inline const std::string& User::macaddr() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.macaddr)
  return _internal_macaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_macaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.macaddr_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.User.macaddr)
}
inline std::string* User::mutable_macaddr() {
  std::string* _s = _internal_mutable_macaddr();
  // @@protoc_insertion_point(field_mutable:meshtastic.User.macaddr)
  return _s;
}
inline const std::string& User::_internal_macaddr() const {
  return _impl_.macaddr_.Get();
}
inline void User::_internal_set_macaddr(const std::string& value) {
  
  _impl_.macaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_macaddr() {
  
  return _impl_.macaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_macaddr() {
  // @@protoc_insertion_point(field_release:meshtastic.User.macaddr)
  return _impl_.macaddr_.Release();
}
inline void User::set_allocated_macaddr(std::string* macaddr) {
  if (macaddr != nullptr) {
    
  } else {
    
  }
  _impl_.macaddr_.SetAllocated(macaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.macaddr_.IsDefault()) {
    _impl_.macaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.User.macaddr)
}

// .meshtastic.HardwareModel hw_model = 5;
inline void User::clear_hw_model() {
  _impl_.hw_model_ = 0;
}
inline ::meshtastic::HardwareModel User::_internal_hw_model() const {
  return static_cast< ::meshtastic::HardwareModel >(_impl_.hw_model_);
}
inline ::meshtastic::HardwareModel User::hw_model() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.hw_model)
  return _internal_hw_model();
}
inline void User::_internal_set_hw_model(::meshtastic::HardwareModel value) {
  
  _impl_.hw_model_ = value;
}
inline void User::set_hw_model(::meshtastic::HardwareModel value) {
  _internal_set_hw_model(value);
  // @@protoc_insertion_point(field_set:meshtastic.User.hw_model)
}

// bool is_licensed = 6;
inline void User::clear_is_licensed() {
  _impl_.is_licensed_ = false;
}
inline bool User::_internal_is_licensed() const {
  return _impl_.is_licensed_;
}
inline bool User::is_licensed() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.is_licensed)
  return _internal_is_licensed();
}
inline void User::_internal_set_is_licensed(bool value) {
  
  _impl_.is_licensed_ = value;
}
inline void User::set_is_licensed(bool value) {
  _internal_set_is_licensed(value);
  // @@protoc_insertion_point(field_set:meshtastic.User.is_licensed)
}

// .meshtastic.Config.DeviceConfig.Role role = 7;
inline void User::clear_role() {
  _impl_.role_ = 0;
}
inline ::meshtastic::Config_DeviceConfig_Role User::_internal_role() const {
  return static_cast< ::meshtastic::Config_DeviceConfig_Role >(_impl_.role_);
}
inline ::meshtastic::Config_DeviceConfig_Role User::role() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.role)
  return _internal_role();
}
inline void User::_internal_set_role(::meshtastic::Config_DeviceConfig_Role value) {
  
  _impl_.role_ = value;
}
inline void User::set_role(::meshtastic::Config_DeviceConfig_Role value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:meshtastic.User.role)
}

// bytes public_key = 8;
inline void User::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& User::public_key() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.User.public_key)
}
inline std::string* User::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.User.public_key)
  return _s;
}
inline const std::string& User::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void User::_internal_set_public_key(const std::string& value) {
  
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_public_key() {
  
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_public_key() {
  // @@protoc_insertion_point(field_release:meshtastic.User.public_key)
  return _impl_.public_key_.Release();
}
inline void User::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.User.public_key)
}

// optional bool is_unmessagable = 9;
inline bool User::_internal_has_is_unmessagable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool User::has_is_unmessagable() const {
  return _internal_has_is_unmessagable();
}
inline void User::clear_is_unmessagable() {
  _impl_.is_unmessagable_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool User::_internal_is_unmessagable() const {
  return _impl_.is_unmessagable_;
}
inline bool User::is_unmessagable() const {
  // @@protoc_insertion_point(field_get:meshtastic.User.is_unmessagable)
  return _internal_is_unmessagable();
}
inline void User::_internal_set_is_unmessagable(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.is_unmessagable_ = value;
}
inline void User::set_is_unmessagable(bool value) {
  _internal_set_is_unmessagable(value);
  // @@protoc_insertion_point(field_set:meshtastic.User.is_unmessagable)
}

// -------------------------------------------------------------------

// RouteDiscovery

// repeated fixed32 route = 1;
inline int RouteDiscovery::_internal_route_size() const {
  return _impl_.route_.size();
}
inline int RouteDiscovery::route_size() const {
  return _internal_route_size();
}
inline void RouteDiscovery::clear_route() {
  _impl_.route_.Clear();
}
inline uint32_t RouteDiscovery::_internal_route(int index) const {
  return _impl_.route_.Get(index);
}
inline uint32_t RouteDiscovery::route(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.RouteDiscovery.route)
  return _internal_route(index);
}
inline void RouteDiscovery::set_route(int index, uint32_t value) {
  _impl_.route_.Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.RouteDiscovery.route)
}
inline void RouteDiscovery::_internal_add_route(uint32_t value) {
  _impl_.route_.Add(value);
}
inline void RouteDiscovery::add_route(uint32_t value) {
  _internal_add_route(value);
  // @@protoc_insertion_point(field_add:meshtastic.RouteDiscovery.route)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
RouteDiscovery::_internal_route() const {
  return _impl_.route_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
RouteDiscovery::route() const {
  // @@protoc_insertion_point(field_list:meshtastic.RouteDiscovery.route)
  return _internal_route();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
RouteDiscovery::_internal_mutable_route() {
  return &_impl_.route_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
RouteDiscovery::mutable_route() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.RouteDiscovery.route)
  return _internal_mutable_route();
}

// repeated int32 snr_towards = 2;
inline int RouteDiscovery::_internal_snr_towards_size() const {
  return _impl_.snr_towards_.size();
}
inline int RouteDiscovery::snr_towards_size() const {
  return _internal_snr_towards_size();
}
inline void RouteDiscovery::clear_snr_towards() {
  _impl_.snr_towards_.Clear();
}
inline int32_t RouteDiscovery::_internal_snr_towards(int index) const {
  return _impl_.snr_towards_.Get(index);
}
inline int32_t RouteDiscovery::snr_towards(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.RouteDiscovery.snr_towards)
  return _internal_snr_towards(index);
}
inline void RouteDiscovery::set_snr_towards(int index, int32_t value) {
  _impl_.snr_towards_.Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.RouteDiscovery.snr_towards)
}
inline void RouteDiscovery::_internal_add_snr_towards(int32_t value) {
  _impl_.snr_towards_.Add(value);
}
inline void RouteDiscovery::add_snr_towards(int32_t value) {
  _internal_add_snr_towards(value);
  // @@protoc_insertion_point(field_add:meshtastic.RouteDiscovery.snr_towards)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RouteDiscovery::_internal_snr_towards() const {
  return _impl_.snr_towards_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RouteDiscovery::snr_towards() const {
  // @@protoc_insertion_point(field_list:meshtastic.RouteDiscovery.snr_towards)
  return _internal_snr_towards();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RouteDiscovery::_internal_mutable_snr_towards() {
  return &_impl_.snr_towards_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RouteDiscovery::mutable_snr_towards() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.RouteDiscovery.snr_towards)
  return _internal_mutable_snr_towards();
}

// repeated fixed32 route_back = 3;
inline int RouteDiscovery::_internal_route_back_size() const {
  return _impl_.route_back_.size();
}
inline int RouteDiscovery::route_back_size() const {
  return _internal_route_back_size();
}
inline void RouteDiscovery::clear_route_back() {
  _impl_.route_back_.Clear();
}
inline uint32_t RouteDiscovery::_internal_route_back(int index) const {
  return _impl_.route_back_.Get(index);
}
inline uint32_t RouteDiscovery::route_back(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.RouteDiscovery.route_back)
  return _internal_route_back(index);
}
inline void RouteDiscovery::set_route_back(int index, uint32_t value) {
  _impl_.route_back_.Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.RouteDiscovery.route_back)
}
inline void RouteDiscovery::_internal_add_route_back(uint32_t value) {
  _impl_.route_back_.Add(value);
}
inline void RouteDiscovery::add_route_back(uint32_t value) {
  _internal_add_route_back(value);
  // @@protoc_insertion_point(field_add:meshtastic.RouteDiscovery.route_back)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
RouteDiscovery::_internal_route_back() const {
  return _impl_.route_back_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
RouteDiscovery::route_back() const {
  // @@protoc_insertion_point(field_list:meshtastic.RouteDiscovery.route_back)
  return _internal_route_back();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
RouteDiscovery::_internal_mutable_route_back() {
  return &_impl_.route_back_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
RouteDiscovery::mutable_route_back() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.RouteDiscovery.route_back)
  return _internal_mutable_route_back();
}

// repeated int32 snr_back = 4;
inline int RouteDiscovery::_internal_snr_back_size() const {
  return _impl_.snr_back_.size();
}
inline int RouteDiscovery::snr_back_size() const {
  return _internal_snr_back_size();
}
inline void RouteDiscovery::clear_snr_back() {
  _impl_.snr_back_.Clear();
}
inline int32_t RouteDiscovery::_internal_snr_back(int index) const {
  return _impl_.snr_back_.Get(index);
}
inline int32_t RouteDiscovery::snr_back(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.RouteDiscovery.snr_back)
  return _internal_snr_back(index);
}
inline void RouteDiscovery::set_snr_back(int index, int32_t value) {
  _impl_.snr_back_.Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.RouteDiscovery.snr_back)
}
inline void RouteDiscovery::_internal_add_snr_back(int32_t value) {
  _impl_.snr_back_.Add(value);
}
inline void RouteDiscovery::add_snr_back(int32_t value) {
  _internal_add_snr_back(value);
  // @@protoc_insertion_point(field_add:meshtastic.RouteDiscovery.snr_back)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RouteDiscovery::_internal_snr_back() const {
  return _impl_.snr_back_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RouteDiscovery::snr_back() const {
  // @@protoc_insertion_point(field_list:meshtastic.RouteDiscovery.snr_back)
  return _internal_snr_back();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RouteDiscovery::_internal_mutable_snr_back() {
  return &_impl_.snr_back_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RouteDiscovery::mutable_snr_back() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.RouteDiscovery.snr_back)
  return _internal_mutable_snr_back();
}

// -------------------------------------------------------------------

// Routing

// .meshtastic.RouteDiscovery route_request = 1;
inline bool Routing::_internal_has_route_request() const {
  return variant_case() == kRouteRequest;
}
inline bool Routing::has_route_request() const {
  return _internal_has_route_request();
}
inline void Routing::set_has_route_request() {
  _impl_._oneof_case_[0] = kRouteRequest;
}
inline void Routing::clear_route_request() {
  if (_internal_has_route_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.variant_.route_request_;
    }
    clear_has_variant();
  }
}
inline ::meshtastic::RouteDiscovery* Routing::release_route_request() {
  // @@protoc_insertion_point(field_release:meshtastic.Routing.route_request)
  if (_internal_has_route_request()) {
    clear_has_variant();
    ::meshtastic::RouteDiscovery* temp = _impl_.variant_.route_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.route_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::RouteDiscovery& Routing::_internal_route_request() const {
  return _internal_has_route_request()
      ? *_impl_.variant_.route_request_
      : reinterpret_cast< ::meshtastic::RouteDiscovery&>(::meshtastic::_RouteDiscovery_default_instance_);
}
inline const ::meshtastic::RouteDiscovery& Routing::route_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.Routing.route_request)
  return _internal_route_request();
}
inline ::meshtastic::RouteDiscovery* Routing::unsafe_arena_release_route_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Routing.route_request)
  if (_internal_has_route_request()) {
    clear_has_variant();
    ::meshtastic::RouteDiscovery* temp = _impl_.variant_.route_request_;
    _impl_.variant_.route_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Routing::unsafe_arena_set_allocated_route_request(::meshtastic::RouteDiscovery* route_request) {
  clear_variant();
  if (route_request) {
    set_has_route_request();
    _impl_.variant_.route_request_ = route_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Routing.route_request)
}
inline ::meshtastic::RouteDiscovery* Routing::_internal_mutable_route_request() {
  if (!_internal_has_route_request()) {
    clear_variant();
    set_has_route_request();
    _impl_.variant_.route_request_ = CreateMaybeMessage< ::meshtastic::RouteDiscovery >(GetArenaForAllocation());
  }
  return _impl_.variant_.route_request_;
}
inline ::meshtastic::RouteDiscovery* Routing::mutable_route_request() {
  ::meshtastic::RouteDiscovery* _msg = _internal_mutable_route_request();
  // @@protoc_insertion_point(field_mutable:meshtastic.Routing.route_request)
  return _msg;
}

// .meshtastic.RouteDiscovery route_reply = 2;
inline bool Routing::_internal_has_route_reply() const {
  return variant_case() == kRouteReply;
}
inline bool Routing::has_route_reply() const {
  return _internal_has_route_reply();
}
inline void Routing::set_has_route_reply() {
  _impl_._oneof_case_[0] = kRouteReply;
}
inline void Routing::clear_route_reply() {
  if (_internal_has_route_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.variant_.route_reply_;
    }
    clear_has_variant();
  }
}
inline ::meshtastic::RouteDiscovery* Routing::release_route_reply() {
  // @@protoc_insertion_point(field_release:meshtastic.Routing.route_reply)
  if (_internal_has_route_reply()) {
    clear_has_variant();
    ::meshtastic::RouteDiscovery* temp = _impl_.variant_.route_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.variant_.route_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::RouteDiscovery& Routing::_internal_route_reply() const {
  return _internal_has_route_reply()
      ? *_impl_.variant_.route_reply_
      : reinterpret_cast< ::meshtastic::RouteDiscovery&>(::meshtastic::_RouteDiscovery_default_instance_);
}
inline const ::meshtastic::RouteDiscovery& Routing::route_reply() const {
  // @@protoc_insertion_point(field_get:meshtastic.Routing.route_reply)
  return _internal_route_reply();
}
inline ::meshtastic::RouteDiscovery* Routing::unsafe_arena_release_route_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Routing.route_reply)
  if (_internal_has_route_reply()) {
    clear_has_variant();
    ::meshtastic::RouteDiscovery* temp = _impl_.variant_.route_reply_;
    _impl_.variant_.route_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Routing::unsafe_arena_set_allocated_route_reply(::meshtastic::RouteDiscovery* route_reply) {
  clear_variant();
  if (route_reply) {
    set_has_route_reply();
    _impl_.variant_.route_reply_ = route_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Routing.route_reply)
}
inline ::meshtastic::RouteDiscovery* Routing::_internal_mutable_route_reply() {
  if (!_internal_has_route_reply()) {
    clear_variant();
    set_has_route_reply();
    _impl_.variant_.route_reply_ = CreateMaybeMessage< ::meshtastic::RouteDiscovery >(GetArenaForAllocation());
  }
  return _impl_.variant_.route_reply_;
}
inline ::meshtastic::RouteDiscovery* Routing::mutable_route_reply() {
  ::meshtastic::RouteDiscovery* _msg = _internal_mutable_route_reply();
  // @@protoc_insertion_point(field_mutable:meshtastic.Routing.route_reply)
  return _msg;
}

// .meshtastic.Routing.Error error_reason = 3;
inline bool Routing::_internal_has_error_reason() const {
  return variant_case() == kErrorReason;
}
inline bool Routing::has_error_reason() const {
  return _internal_has_error_reason();
}
inline void Routing::set_has_error_reason() {
  _impl_._oneof_case_[0] = kErrorReason;
}
inline void Routing::clear_error_reason() {
  if (_internal_has_error_reason()) {
    _impl_.variant_.error_reason_ = 0;
    clear_has_variant();
  }
}
inline ::meshtastic::Routing_Error Routing::_internal_error_reason() const {
  if (_internal_has_error_reason()) {
    return static_cast< ::meshtastic::Routing_Error >(_impl_.variant_.error_reason_);
  }
  return static_cast< ::meshtastic::Routing_Error >(0);
}
inline ::meshtastic::Routing_Error Routing::error_reason() const {
  // @@protoc_insertion_point(field_get:meshtastic.Routing.error_reason)
  return _internal_error_reason();
}
inline void Routing::_internal_set_error_reason(::meshtastic::Routing_Error value) {
  if (!_internal_has_error_reason()) {
    clear_variant();
    set_has_error_reason();
  }
  _impl_.variant_.error_reason_ = value;
}
inline void Routing::set_error_reason(::meshtastic::Routing_Error value) {
  _internal_set_error_reason(value);
  // @@protoc_insertion_point(field_set:meshtastic.Routing.error_reason)
}

inline bool Routing::has_variant() const {
  return variant_case() != VARIANT_NOT_SET;
}
inline void Routing::clear_has_variant() {
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}
inline Routing::VariantCase Routing::variant_case() const {
  return Routing::VariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Data

// .meshtastic.PortNum portnum = 1;
inline void Data::clear_portnum() {
  _impl_.portnum_ = 0;
}
inline ::meshtastic::PortNum Data::_internal_portnum() const {
  return static_cast< ::meshtastic::PortNum >(_impl_.portnum_);
}
inline ::meshtastic::PortNum Data::portnum() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.portnum)
  return _internal_portnum();
}
inline void Data::_internal_set_portnum(::meshtastic::PortNum value) {
  
  _impl_.portnum_ = value;
}
inline void Data::set_portnum(::meshtastic::PortNum value) {
  _internal_set_portnum(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.portnum)
}

// bytes payload = 2;
inline void Data::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& Data::payload() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Data::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.Data.payload)
}
inline std::string* Data::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:meshtastic.Data.payload)
  return _s;
}
inline const std::string& Data::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void Data::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* Data::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* Data::release_payload() {
  // @@protoc_insertion_point(field_release:meshtastic.Data.payload)
  return _impl_.payload_.Release();
}
inline void Data::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Data.payload)
}

// bool want_response = 3;
inline void Data::clear_want_response() {
  _impl_.want_response_ = false;
}
inline bool Data::_internal_want_response() const {
  return _impl_.want_response_;
}
inline bool Data::want_response() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.want_response)
  return _internal_want_response();
}
inline void Data::_internal_set_want_response(bool value) {
  
  _impl_.want_response_ = value;
}
inline void Data::set_want_response(bool value) {
  _internal_set_want_response(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.want_response)
}

// fixed32 dest = 4;
inline void Data::clear_dest() {
  _impl_.dest_ = 0u;
}
inline uint32_t Data::_internal_dest() const {
  return _impl_.dest_;
}
inline uint32_t Data::dest() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.dest)
  return _internal_dest();
}
inline void Data::_internal_set_dest(uint32_t value) {
  
  _impl_.dest_ = value;
}
inline void Data::set_dest(uint32_t value) {
  _internal_set_dest(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.dest)
}

// fixed32 source = 5;
inline void Data::clear_source() {
  _impl_.source_ = 0u;
}
inline uint32_t Data::_internal_source() const {
  return _impl_.source_;
}
inline uint32_t Data::source() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.source)
  return _internal_source();
}
inline void Data::_internal_set_source(uint32_t value) {
  
  _impl_.source_ = value;
}
inline void Data::set_source(uint32_t value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.source)
}

// fixed32 request_id = 6;
inline void Data::clear_request_id() {
  _impl_.request_id_ = 0u;
}
inline uint32_t Data::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t Data::request_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.request_id)
  return _internal_request_id();
}
inline void Data::_internal_set_request_id(uint32_t value) {
  
  _impl_.request_id_ = value;
}
inline void Data::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.request_id)
}

// fixed32 reply_id = 7;
inline void Data::clear_reply_id() {
  _impl_.reply_id_ = 0u;
}
inline uint32_t Data::_internal_reply_id() const {
  return _impl_.reply_id_;
}
inline uint32_t Data::reply_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.reply_id)
  return _internal_reply_id();
}
inline void Data::_internal_set_reply_id(uint32_t value) {
  
  _impl_.reply_id_ = value;
}
inline void Data::set_reply_id(uint32_t value) {
  _internal_set_reply_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.reply_id)
}

// fixed32 emoji = 8;
inline void Data::clear_emoji() {
  _impl_.emoji_ = 0u;
}
inline uint32_t Data::_internal_emoji() const {
  return _impl_.emoji_;
}
inline uint32_t Data::emoji() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.emoji)
  return _internal_emoji();
}
inline void Data::_internal_set_emoji(uint32_t value) {
  
  _impl_.emoji_ = value;
}
inline void Data::set_emoji(uint32_t value) {
  _internal_set_emoji(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.emoji)
}

// optional uint32 bitfield = 9;
inline bool Data::_internal_has_bitfield() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Data::has_bitfield() const {
  return _internal_has_bitfield();
}
inline void Data::clear_bitfield() {
  _impl_.bitfield_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Data::_internal_bitfield() const {
  return _impl_.bitfield_;
}
inline uint32_t Data::bitfield() const {
  // @@protoc_insertion_point(field_get:meshtastic.Data.bitfield)
  return _internal_bitfield();
}
inline void Data::_internal_set_bitfield(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bitfield_ = value;
}
inline void Data::set_bitfield(uint32_t value) {
  _internal_set_bitfield(value);
  // @@protoc_insertion_point(field_set:meshtastic.Data.bitfield)
}

// -------------------------------------------------------------------

// KeyVerification

// uint64 nonce = 1;
inline void KeyVerification::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t KeyVerification::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t KeyVerification::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerification.nonce)
  return _internal_nonce();
}
inline void KeyVerification::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void KeyVerification::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerification.nonce)
}

// bytes hash1 = 2;
inline void KeyVerification::clear_hash1() {
  _impl_.hash1_.ClearToEmpty();
}
inline const std::string& KeyVerification::hash1() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerification.hash1)
  return _internal_hash1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyVerification::set_hash1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash1_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerification.hash1)
}
inline std::string* KeyVerification::mutable_hash1() {
  std::string* _s = _internal_mutable_hash1();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerification.hash1)
  return _s;
}
inline const std::string& KeyVerification::_internal_hash1() const {
  return _impl_.hash1_.Get();
}
inline void KeyVerification::_internal_set_hash1(const std::string& value) {
  
  _impl_.hash1_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyVerification::_internal_mutable_hash1() {
  
  return _impl_.hash1_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyVerification::release_hash1() {
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerification.hash1)
  return _impl_.hash1_.Release();
}
inline void KeyVerification::set_allocated_hash1(std::string* hash1) {
  if (hash1 != nullptr) {
    
  } else {
    
  }
  _impl_.hash1_.SetAllocated(hash1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash1_.IsDefault()) {
    _impl_.hash1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerification.hash1)
}

// bytes hash2 = 3;
inline void KeyVerification::clear_hash2() {
  _impl_.hash2_.ClearToEmpty();
}
inline const std::string& KeyVerification::hash2() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerification.hash2)
  return _internal_hash2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyVerification::set_hash2(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash2_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerification.hash2)
}
inline std::string* KeyVerification::mutable_hash2() {
  std::string* _s = _internal_mutable_hash2();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerification.hash2)
  return _s;
}
inline const std::string& KeyVerification::_internal_hash2() const {
  return _impl_.hash2_.Get();
}
inline void KeyVerification::_internal_set_hash2(const std::string& value) {
  
  _impl_.hash2_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyVerification::_internal_mutable_hash2() {
  
  return _impl_.hash2_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyVerification::release_hash2() {
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerification.hash2)
  return _impl_.hash2_.Release();
}
inline void KeyVerification::set_allocated_hash2(std::string* hash2) {
  if (hash2 != nullptr) {
    
  } else {
    
  }
  _impl_.hash2_.SetAllocated(hash2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash2_.IsDefault()) {
    _impl_.hash2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerification.hash2)
}

// -------------------------------------------------------------------

// Waypoint

// uint32 id = 1;
inline void Waypoint::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t Waypoint::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t Waypoint::id() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.id)
  return _internal_id();
}
inline void Waypoint::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void Waypoint::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.id)
}

// optional sfixed32 latitude_i = 2;
inline bool Waypoint::_internal_has_latitude_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Waypoint::has_latitude_i() const {
  return _internal_has_latitude_i();
}
inline void Waypoint::clear_latitude_i() {
  _impl_.latitude_i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Waypoint::_internal_latitude_i() const {
  return _impl_.latitude_i_;
}
inline int32_t Waypoint::latitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.latitude_i)
  return _internal_latitude_i();
}
inline void Waypoint::_internal_set_latitude_i(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.latitude_i_ = value;
}
inline void Waypoint::set_latitude_i(int32_t value) {
  _internal_set_latitude_i(value);
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.latitude_i)
}

// optional sfixed32 longitude_i = 3;
inline bool Waypoint::_internal_has_longitude_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Waypoint::has_longitude_i() const {
  return _internal_has_longitude_i();
}
inline void Waypoint::clear_longitude_i() {
  _impl_.longitude_i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Waypoint::_internal_longitude_i() const {
  return _impl_.longitude_i_;
}
inline int32_t Waypoint::longitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.longitude_i)
  return _internal_longitude_i();
}
inline void Waypoint::_internal_set_longitude_i(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.longitude_i_ = value;
}
inline void Waypoint::set_longitude_i(int32_t value) {
  _internal_set_longitude_i(value);
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.longitude_i)
}

// uint32 expire = 4;
inline void Waypoint::clear_expire() {
  _impl_.expire_ = 0u;
}
inline uint32_t Waypoint::_internal_expire() const {
  return _impl_.expire_;
}
inline uint32_t Waypoint::expire() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.expire)
  return _internal_expire();
}
inline void Waypoint::_internal_set_expire(uint32_t value) {
  
  _impl_.expire_ = value;
}
inline void Waypoint::set_expire(uint32_t value) {
  _internal_set_expire(value);
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.expire)
}

// uint32 locked_to = 5;
inline void Waypoint::clear_locked_to() {
  _impl_.locked_to_ = 0u;
}
inline uint32_t Waypoint::_internal_locked_to() const {
  return _impl_.locked_to_;
}
inline uint32_t Waypoint::locked_to() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.locked_to)
  return _internal_locked_to();
}
inline void Waypoint::_internal_set_locked_to(uint32_t value) {
  
  _impl_.locked_to_ = value;
}
inline void Waypoint::set_locked_to(uint32_t value) {
  _internal_set_locked_to(value);
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.locked_to)
}

// string name = 6;
inline void Waypoint::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Waypoint::name() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Waypoint::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.name)
}
inline std::string* Waypoint::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.Waypoint.name)
  return _s;
}
inline const std::string& Waypoint::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Waypoint::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Waypoint::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Waypoint::release_name() {
  // @@protoc_insertion_point(field_release:meshtastic.Waypoint.name)
  return _impl_.name_.Release();
}
inline void Waypoint::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Waypoint.name)
}

// string description = 7;
inline void Waypoint::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Waypoint::description() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Waypoint::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.description)
}
inline std::string* Waypoint::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:meshtastic.Waypoint.description)
  return _s;
}
inline const std::string& Waypoint::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Waypoint::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Waypoint::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Waypoint::release_description() {
  // @@protoc_insertion_point(field_release:meshtastic.Waypoint.description)
  return _impl_.description_.Release();
}
inline void Waypoint::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Waypoint.description)
}

// fixed32 icon = 8;
inline void Waypoint::clear_icon() {
  _impl_.icon_ = 0u;
}
inline uint32_t Waypoint::_internal_icon() const {
  return _impl_.icon_;
}
inline uint32_t Waypoint::icon() const {
  // @@protoc_insertion_point(field_get:meshtastic.Waypoint.icon)
  return _internal_icon();
}
inline void Waypoint::_internal_set_icon(uint32_t value) {
  
  _impl_.icon_ = value;
}
inline void Waypoint::set_icon(uint32_t value) {
  _internal_set_icon(value);
  // @@protoc_insertion_point(field_set:meshtastic.Waypoint.icon)
}

// -------------------------------------------------------------------

// MqttClientProxyMessage

// string topic = 1;
inline void MqttClientProxyMessage::clear_topic() {
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& MqttClientProxyMessage::topic() const {
  // @@protoc_insertion_point(field_get:meshtastic.MqttClientProxyMessage.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MqttClientProxyMessage::set_topic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.MqttClientProxyMessage.topic)
}
inline std::string* MqttClientProxyMessage::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:meshtastic.MqttClientProxyMessage.topic)
  return _s;
}
inline const std::string& MqttClientProxyMessage::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void MqttClientProxyMessage::_internal_set_topic(const std::string& value) {
  
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* MqttClientProxyMessage::_internal_mutable_topic() {
  
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* MqttClientProxyMessage::release_topic() {
  // @@protoc_insertion_point(field_release:meshtastic.MqttClientProxyMessage.topic)
  return _impl_.topic_.Release();
}
inline void MqttClientProxyMessage::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MqttClientProxyMessage.topic)
}

// bytes data = 2;
inline bool MqttClientProxyMessage::_internal_has_data() const {
  return payload_variant_case() == kData;
}
inline bool MqttClientProxyMessage::has_data() const {
  return _internal_has_data();
}
inline void MqttClientProxyMessage::set_has_data() {
  _impl_._oneof_case_[0] = kData;
}
inline void MqttClientProxyMessage::clear_data() {
  if (_internal_has_data()) {
    _impl_.payload_variant_.data_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& MqttClientProxyMessage::data() const {
  // @@protoc_insertion_point(field_get:meshtastic.MqttClientProxyMessage.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline void MqttClientProxyMessage::set_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_data()) {
    clear_payload_variant();
    set_has_data();
    _impl_.payload_variant_.data_.InitDefault();
  }
  _impl_.payload_variant_.data_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.MqttClientProxyMessage.data)
}
inline std::string* MqttClientProxyMessage::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:meshtastic.MqttClientProxyMessage.data)
  return _s;
}
inline const std::string& MqttClientProxyMessage::_internal_data() const {
  if (_internal_has_data()) {
    return _impl_.payload_variant_.data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MqttClientProxyMessage::_internal_set_data(const std::string& value) {
  if (!_internal_has_data()) {
    clear_payload_variant();
    set_has_data();
    _impl_.payload_variant_.data_.InitDefault();
  }
  _impl_.payload_variant_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* MqttClientProxyMessage::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_payload_variant();
    set_has_data();
    _impl_.payload_variant_.data_.InitDefault();
  }
  return _impl_.payload_variant_.data_.Mutable(      GetArenaForAllocation());
}
inline std::string* MqttClientProxyMessage::release_data() {
  // @@protoc_insertion_point(field_release:meshtastic.MqttClientProxyMessage.data)
  if (_internal_has_data()) {
    clear_has_payload_variant();
    return _impl_.payload_variant_.data_.Release();
  } else {
    return nullptr;
  }
}
inline void MqttClientProxyMessage::set_allocated_data(std::string* data) {
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (data != nullptr) {
    set_has_data();
    _impl_.payload_variant_.data_.InitAllocated(data, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MqttClientProxyMessage.data)
}

// string text = 3;
inline bool MqttClientProxyMessage::_internal_has_text() const {
  return payload_variant_case() == kText;
}
inline bool MqttClientProxyMessage::has_text() const {
  return _internal_has_text();
}
inline void MqttClientProxyMessage::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void MqttClientProxyMessage::clear_text() {
  if (_internal_has_text()) {
    _impl_.payload_variant_.text_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& MqttClientProxyMessage::text() const {
  // @@protoc_insertion_point(field_get:meshtastic.MqttClientProxyMessage.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void MqttClientProxyMessage::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_payload_variant();
    set_has_text();
    _impl_.payload_variant_.text_.InitDefault();
  }
  _impl_.payload_variant_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.MqttClientProxyMessage.text)
}
inline std::string* MqttClientProxyMessage::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:meshtastic.MqttClientProxyMessage.text)
  return _s;
}
inline const std::string& MqttClientProxyMessage::_internal_text() const {
  if (_internal_has_text()) {
    return _impl_.payload_variant_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MqttClientProxyMessage::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_payload_variant();
    set_has_text();
    _impl_.payload_variant_.text_.InitDefault();
  }
  _impl_.payload_variant_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* MqttClientProxyMessage::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_payload_variant();
    set_has_text();
    _impl_.payload_variant_.text_.InitDefault();
  }
  return _impl_.payload_variant_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* MqttClientProxyMessage::release_text() {
  // @@protoc_insertion_point(field_release:meshtastic.MqttClientProxyMessage.text)
  if (_internal_has_text()) {
    clear_has_payload_variant();
    return _impl_.payload_variant_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void MqttClientProxyMessage::set_allocated_text(std::string* text) {
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (text != nullptr) {
    set_has_text();
    _impl_.payload_variant_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MqttClientProxyMessage.text)
}

// bool retained = 4;
inline void MqttClientProxyMessage::clear_retained() {
  _impl_.retained_ = false;
}
inline bool MqttClientProxyMessage::_internal_retained() const {
  return _impl_.retained_;
}
inline bool MqttClientProxyMessage::retained() const {
  // @@protoc_insertion_point(field_get:meshtastic.MqttClientProxyMessage.retained)
  return _internal_retained();
}
inline void MqttClientProxyMessage::_internal_set_retained(bool value) {
  
  _impl_.retained_ = value;
}
inline void MqttClientProxyMessage::set_retained(bool value) {
  _internal_set_retained(value);
  // @@protoc_insertion_point(field_set:meshtastic.MqttClientProxyMessage.retained)
}

inline bool MqttClientProxyMessage::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void MqttClientProxyMessage::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline MqttClientProxyMessage::PayloadVariantCase MqttClientProxyMessage::payload_variant_case() const {
  return MqttClientProxyMessage::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MeshPacket

// fixed32 from = 1;
inline void MeshPacket::clear_from() {
  _impl_.from_ = 0u;
}
inline uint32_t MeshPacket::_internal_from() const {
  return _impl_.from_;
}
inline uint32_t MeshPacket::from() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.from)
  return _internal_from();
}
inline void MeshPacket::_internal_set_from(uint32_t value) {
  
  _impl_.from_ = value;
}
inline void MeshPacket::set_from(uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.from)
}

// fixed32 to = 2;
inline void MeshPacket::clear_to() {
  _impl_.to_ = 0u;
}
inline uint32_t MeshPacket::_internal_to() const {
  return _impl_.to_;
}
inline uint32_t MeshPacket::to() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.to)
  return _internal_to();
}
inline void MeshPacket::_internal_set_to(uint32_t value) {
  
  _impl_.to_ = value;
}
inline void MeshPacket::set_to(uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.to)
}

// uint32 channel = 3;
inline void MeshPacket::clear_channel() {
  _impl_.channel_ = 0u;
}
inline uint32_t MeshPacket::_internal_channel() const {
  return _impl_.channel_;
}
inline uint32_t MeshPacket::channel() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.channel)
  return _internal_channel();
}
inline void MeshPacket::_internal_set_channel(uint32_t value) {
  
  _impl_.channel_ = value;
}
inline void MeshPacket::set_channel(uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.channel)
}

// .meshtastic.Data decoded = 4;
inline bool MeshPacket::_internal_has_decoded() const {
  return payload_variant_case() == kDecoded;
}
inline bool MeshPacket::has_decoded() const {
  return _internal_has_decoded();
}
inline void MeshPacket::set_has_decoded() {
  _impl_._oneof_case_[0] = kDecoded;
}
inline void MeshPacket::clear_decoded() {
  if (_internal_has_decoded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.decoded_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Data* MeshPacket::release_decoded() {
  // @@protoc_insertion_point(field_release:meshtastic.MeshPacket.decoded)
  if (_internal_has_decoded()) {
    clear_has_payload_variant();
    ::meshtastic::Data* temp = _impl_.payload_variant_.decoded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.decoded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Data& MeshPacket::_internal_decoded() const {
  return _internal_has_decoded()
      ? *_impl_.payload_variant_.decoded_
      : reinterpret_cast< ::meshtastic::Data&>(::meshtastic::_Data_default_instance_);
}
inline const ::meshtastic::Data& MeshPacket::decoded() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.decoded)
  return _internal_decoded();
}
inline ::meshtastic::Data* MeshPacket::unsafe_arena_release_decoded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.MeshPacket.decoded)
  if (_internal_has_decoded()) {
    clear_has_payload_variant();
    ::meshtastic::Data* temp = _impl_.payload_variant_.decoded_;
    _impl_.payload_variant_.decoded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MeshPacket::unsafe_arena_set_allocated_decoded(::meshtastic::Data* decoded) {
  clear_payload_variant();
  if (decoded) {
    set_has_decoded();
    _impl_.payload_variant_.decoded_ = decoded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.MeshPacket.decoded)
}
inline ::meshtastic::Data* MeshPacket::_internal_mutable_decoded() {
  if (!_internal_has_decoded()) {
    clear_payload_variant();
    set_has_decoded();
    _impl_.payload_variant_.decoded_ = CreateMaybeMessage< ::meshtastic::Data >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.decoded_;
}
inline ::meshtastic::Data* MeshPacket::mutable_decoded() {
  ::meshtastic::Data* _msg = _internal_mutable_decoded();
  // @@protoc_insertion_point(field_mutable:meshtastic.MeshPacket.decoded)
  return _msg;
}

// bytes encrypted = 5;
inline bool MeshPacket::_internal_has_encrypted() const {
  return payload_variant_case() == kEncrypted;
}
inline bool MeshPacket::has_encrypted() const {
  return _internal_has_encrypted();
}
inline void MeshPacket::set_has_encrypted() {
  _impl_._oneof_case_[0] = kEncrypted;
}
inline void MeshPacket::clear_encrypted() {
  if (_internal_has_encrypted()) {
    _impl_.payload_variant_.encrypted_.Destroy();
    clear_has_payload_variant();
  }
}
inline const std::string& MeshPacket::encrypted() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.encrypted)
  return _internal_encrypted();
}
template <typename ArgT0, typename... ArgT>
inline void MeshPacket::set_encrypted(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_encrypted()) {
    clear_payload_variant();
    set_has_encrypted();
    _impl_.payload_variant_.encrypted_.InitDefault();
  }
  _impl_.payload_variant_.encrypted_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.encrypted)
}
inline std::string* MeshPacket::mutable_encrypted() {
  std::string* _s = _internal_mutable_encrypted();
  // @@protoc_insertion_point(field_mutable:meshtastic.MeshPacket.encrypted)
  return _s;
}
inline const std::string& MeshPacket::_internal_encrypted() const {
  if (_internal_has_encrypted()) {
    return _impl_.payload_variant_.encrypted_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MeshPacket::_internal_set_encrypted(const std::string& value) {
  if (!_internal_has_encrypted()) {
    clear_payload_variant();
    set_has_encrypted();
    _impl_.payload_variant_.encrypted_.InitDefault();
  }
  _impl_.payload_variant_.encrypted_.Set(value, GetArenaForAllocation());
}
inline std::string* MeshPacket::_internal_mutable_encrypted() {
  if (!_internal_has_encrypted()) {
    clear_payload_variant();
    set_has_encrypted();
    _impl_.payload_variant_.encrypted_.InitDefault();
  }
  return _impl_.payload_variant_.encrypted_.Mutable(      GetArenaForAllocation());
}
inline std::string* MeshPacket::release_encrypted() {
  // @@protoc_insertion_point(field_release:meshtastic.MeshPacket.encrypted)
  if (_internal_has_encrypted()) {
    clear_has_payload_variant();
    return _impl_.payload_variant_.encrypted_.Release();
  } else {
    return nullptr;
  }
}
inline void MeshPacket::set_allocated_encrypted(std::string* encrypted) {
  if (has_payload_variant()) {
    clear_payload_variant();
  }
  if (encrypted != nullptr) {
    set_has_encrypted();
    _impl_.payload_variant_.encrypted_.InitAllocated(encrypted, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MeshPacket.encrypted)
}

// fixed32 id = 6;
inline void MeshPacket::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t MeshPacket::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t MeshPacket::id() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.id)
  return _internal_id();
}
inline void MeshPacket::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void MeshPacket::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.id)
}

// fixed32 rx_time = 7;
inline void MeshPacket::clear_rx_time() {
  _impl_.rx_time_ = 0u;
}
inline uint32_t MeshPacket::_internal_rx_time() const {
  return _impl_.rx_time_;
}
inline uint32_t MeshPacket::rx_time() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.rx_time)
  return _internal_rx_time();
}
inline void MeshPacket::_internal_set_rx_time(uint32_t value) {
  
  _impl_.rx_time_ = value;
}
inline void MeshPacket::set_rx_time(uint32_t value) {
  _internal_set_rx_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.rx_time)
}

// float rx_snr = 8;
inline void MeshPacket::clear_rx_snr() {
  _impl_.rx_snr_ = 0;
}
inline float MeshPacket::_internal_rx_snr() const {
  return _impl_.rx_snr_;
}
inline float MeshPacket::rx_snr() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.rx_snr)
  return _internal_rx_snr();
}
inline void MeshPacket::_internal_set_rx_snr(float value) {
  
  _impl_.rx_snr_ = value;
}
inline void MeshPacket::set_rx_snr(float value) {
  _internal_set_rx_snr(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.rx_snr)
}

// uint32 hop_limit = 9;
inline void MeshPacket::clear_hop_limit() {
  _impl_.hop_limit_ = 0u;
}
inline uint32_t MeshPacket::_internal_hop_limit() const {
  return _impl_.hop_limit_;
}
inline uint32_t MeshPacket::hop_limit() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.hop_limit)
  return _internal_hop_limit();
}
inline void MeshPacket::_internal_set_hop_limit(uint32_t value) {
  
  _impl_.hop_limit_ = value;
}
inline void MeshPacket::set_hop_limit(uint32_t value) {
  _internal_set_hop_limit(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.hop_limit)
}

// bool want_ack = 10;
inline void MeshPacket::clear_want_ack() {
  _impl_.want_ack_ = false;
}
inline bool MeshPacket::_internal_want_ack() const {
  return _impl_.want_ack_;
}
inline bool MeshPacket::want_ack() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.want_ack)
  return _internal_want_ack();
}
inline void MeshPacket::_internal_set_want_ack(bool value) {
  
  _impl_.want_ack_ = value;
}
inline void MeshPacket::set_want_ack(bool value) {
  _internal_set_want_ack(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.want_ack)
}

// .meshtastic.MeshPacket.Priority priority = 11;
inline void MeshPacket::clear_priority() {
  _impl_.priority_ = 0;
}
inline ::meshtastic::MeshPacket_Priority MeshPacket::_internal_priority() const {
  return static_cast< ::meshtastic::MeshPacket_Priority >(_impl_.priority_);
}
inline ::meshtastic::MeshPacket_Priority MeshPacket::priority() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.priority)
  return _internal_priority();
}
inline void MeshPacket::_internal_set_priority(::meshtastic::MeshPacket_Priority value) {
  
  _impl_.priority_ = value;
}
inline void MeshPacket::set_priority(::meshtastic::MeshPacket_Priority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.priority)
}

// int32 rx_rssi = 12;
inline void MeshPacket::clear_rx_rssi() {
  _impl_.rx_rssi_ = 0;
}
inline int32_t MeshPacket::_internal_rx_rssi() const {
  return _impl_.rx_rssi_;
}
inline int32_t MeshPacket::rx_rssi() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.rx_rssi)
  return _internal_rx_rssi();
}
inline void MeshPacket::_internal_set_rx_rssi(int32_t value) {
  
  _impl_.rx_rssi_ = value;
}
inline void MeshPacket::set_rx_rssi(int32_t value) {
  _internal_set_rx_rssi(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.rx_rssi)
}

// .meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
inline void MeshPacket::clear_delayed() {
  _impl_.delayed_ = 0;
}
inline ::meshtastic::MeshPacket_Delayed MeshPacket::_internal_delayed() const {
  return static_cast< ::meshtastic::MeshPacket_Delayed >(_impl_.delayed_);
}
inline ::meshtastic::MeshPacket_Delayed MeshPacket::delayed() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.delayed)
  return _internal_delayed();
}
inline void MeshPacket::_internal_set_delayed(::meshtastic::MeshPacket_Delayed value) {
  
  _impl_.delayed_ = value;
}
inline void MeshPacket::set_delayed(::meshtastic::MeshPacket_Delayed value) {
  _internal_set_delayed(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.delayed)
}

// bool via_mqtt = 14;
inline void MeshPacket::clear_via_mqtt() {
  _impl_.via_mqtt_ = false;
}
inline bool MeshPacket::_internal_via_mqtt() const {
  return _impl_.via_mqtt_;
}
inline bool MeshPacket::via_mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.via_mqtt)
  return _internal_via_mqtt();
}
inline void MeshPacket::_internal_set_via_mqtt(bool value) {
  
  _impl_.via_mqtt_ = value;
}
inline void MeshPacket::set_via_mqtt(bool value) {
  _internal_set_via_mqtt(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.via_mqtt)
}

// uint32 hop_start = 15;
inline void MeshPacket::clear_hop_start() {
  _impl_.hop_start_ = 0u;
}
inline uint32_t MeshPacket::_internal_hop_start() const {
  return _impl_.hop_start_;
}
inline uint32_t MeshPacket::hop_start() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.hop_start)
  return _internal_hop_start();
}
inline void MeshPacket::_internal_set_hop_start(uint32_t value) {
  
  _impl_.hop_start_ = value;
}
inline void MeshPacket::set_hop_start(uint32_t value) {
  _internal_set_hop_start(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.hop_start)
}

// bytes public_key = 16;
inline void MeshPacket::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& MeshPacket::public_key() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MeshPacket::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.public_key)
}
inline std::string* MeshPacket::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.MeshPacket.public_key)
  return _s;
}
inline const std::string& MeshPacket::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void MeshPacket::_internal_set_public_key(const std::string& value) {
  
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MeshPacket::_internal_mutable_public_key() {
  
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MeshPacket::release_public_key() {
  // @@protoc_insertion_point(field_release:meshtastic.MeshPacket.public_key)
  return _impl_.public_key_.Release();
}
inline void MeshPacket::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MeshPacket.public_key)
}

// bool pki_encrypted = 17;
inline void MeshPacket::clear_pki_encrypted() {
  _impl_.pki_encrypted_ = false;
}
inline bool MeshPacket::_internal_pki_encrypted() const {
  return _impl_.pki_encrypted_;
}
inline bool MeshPacket::pki_encrypted() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.pki_encrypted)
  return _internal_pki_encrypted();
}
inline void MeshPacket::_internal_set_pki_encrypted(bool value) {
  
  _impl_.pki_encrypted_ = value;
}
inline void MeshPacket::set_pki_encrypted(bool value) {
  _internal_set_pki_encrypted(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.pki_encrypted)
}

// uint32 next_hop = 18;
inline void MeshPacket::clear_next_hop() {
  _impl_.next_hop_ = 0u;
}
inline uint32_t MeshPacket::_internal_next_hop() const {
  return _impl_.next_hop_;
}
inline uint32_t MeshPacket::next_hop() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.next_hop)
  return _internal_next_hop();
}
inline void MeshPacket::_internal_set_next_hop(uint32_t value) {
  
  _impl_.next_hop_ = value;
}
inline void MeshPacket::set_next_hop(uint32_t value) {
  _internal_set_next_hop(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.next_hop)
}

// uint32 relay_node = 19;
inline void MeshPacket::clear_relay_node() {
  _impl_.relay_node_ = 0u;
}
inline uint32_t MeshPacket::_internal_relay_node() const {
  return _impl_.relay_node_;
}
inline uint32_t MeshPacket::relay_node() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.relay_node)
  return _internal_relay_node();
}
inline void MeshPacket::_internal_set_relay_node(uint32_t value) {
  
  _impl_.relay_node_ = value;
}
inline void MeshPacket::set_relay_node(uint32_t value) {
  _internal_set_relay_node(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.relay_node)
}

// uint32 tx_after = 20;
inline void MeshPacket::clear_tx_after() {
  _impl_.tx_after_ = 0u;
}
inline uint32_t MeshPacket::_internal_tx_after() const {
  return _impl_.tx_after_;
}
inline uint32_t MeshPacket::tx_after() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.tx_after)
  return _internal_tx_after();
}
inline void MeshPacket::_internal_set_tx_after(uint32_t value) {
  
  _impl_.tx_after_ = value;
}
inline void MeshPacket::set_tx_after(uint32_t value) {
  _internal_set_tx_after(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.tx_after)
}

// .meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;
inline void MeshPacket::clear_transport_mechanism() {
  _impl_.transport_mechanism_ = 0;
}
inline ::meshtastic::MeshPacket_TransportMechanism MeshPacket::_internal_transport_mechanism() const {
  return static_cast< ::meshtastic::MeshPacket_TransportMechanism >(_impl_.transport_mechanism_);
}
inline ::meshtastic::MeshPacket_TransportMechanism MeshPacket::transport_mechanism() const {
  // @@protoc_insertion_point(field_get:meshtastic.MeshPacket.transport_mechanism)
  return _internal_transport_mechanism();
}
inline void MeshPacket::_internal_set_transport_mechanism(::meshtastic::MeshPacket_TransportMechanism value) {
  
  _impl_.transport_mechanism_ = value;
}
inline void MeshPacket::set_transport_mechanism(::meshtastic::MeshPacket_TransportMechanism value) {
  _internal_set_transport_mechanism(value);
  // @@protoc_insertion_point(field_set:meshtastic.MeshPacket.transport_mechanism)
}

inline bool MeshPacket::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void MeshPacket::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline MeshPacket::PayloadVariantCase MeshPacket::payload_variant_case() const {
  return MeshPacket::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NodeInfo

// uint32 num = 1;
inline void NodeInfo::clear_num() {
  _impl_.num_ = 0u;
}
inline uint32_t NodeInfo::_internal_num() const {
  return _impl_.num_;
}
inline uint32_t NodeInfo::num() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.num)
  return _internal_num();
}
inline void NodeInfo::_internal_set_num(uint32_t value) {
  
  _impl_.num_ = value;
}
inline void NodeInfo::set_num(uint32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.num)
}

// .meshtastic.User user = 2;
inline bool NodeInfo::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool NodeInfo::has_user() const {
  return _internal_has_user();
}
inline void NodeInfo::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::meshtastic::User& NodeInfo::_internal_user() const {
  const ::meshtastic::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::User&>(
      ::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& NodeInfo::user() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.user)
  return _internal_user();
}
inline void NodeInfo::unsafe_arena_set_allocated_user(
    ::meshtastic::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfo.user)
}
inline ::meshtastic::User* NodeInfo::release_user() {
  
  ::meshtastic::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::User* NodeInfo::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfo.user)
  
  ::meshtastic::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::meshtastic::User* NodeInfo::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::meshtastic::User* NodeInfo::mutable_user() {
  ::meshtastic::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfo.user)
  return _msg;
}
inline void NodeInfo::set_allocated_user(::meshtastic::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfo.user)
}

// .meshtastic.Position position = 3;
inline bool NodeInfo::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool NodeInfo::has_position() const {
  return _internal_has_position();
}
inline void NodeInfo::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::meshtastic::Position& NodeInfo::_internal_position() const {
  const ::meshtastic::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Position&>(
      ::meshtastic::_Position_default_instance_);
}
inline const ::meshtastic::Position& NodeInfo::position() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.position)
  return _internal_position();
}
inline void NodeInfo::unsafe_arena_set_allocated_position(
    ::meshtastic::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfo.position)
}
inline ::meshtastic::Position* NodeInfo::release_position() {
  
  ::meshtastic::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::Position* NodeInfo::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfo.position)
  
  ::meshtastic::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::meshtastic::Position* NodeInfo::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::meshtastic::Position* NodeInfo::mutable_position() {
  ::meshtastic::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfo.position)
  return _msg;
}
inline void NodeInfo::set_allocated_position(::meshtastic::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfo.position)
}

// float snr = 4;
inline void NodeInfo::clear_snr() {
  _impl_.snr_ = 0;
}
inline float NodeInfo::_internal_snr() const {
  return _impl_.snr_;
}
inline float NodeInfo::snr() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.snr)
  return _internal_snr();
}
inline void NodeInfo::_internal_set_snr(float value) {
  
  _impl_.snr_ = value;
}
inline void NodeInfo::set_snr(float value) {
  _internal_set_snr(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.snr)
}

// fixed32 last_heard = 5;
inline void NodeInfo::clear_last_heard() {
  _impl_.last_heard_ = 0u;
}
inline uint32_t NodeInfo::_internal_last_heard() const {
  return _impl_.last_heard_;
}
inline uint32_t NodeInfo::last_heard() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.last_heard)
  return _internal_last_heard();
}
inline void NodeInfo::_internal_set_last_heard(uint32_t value) {
  
  _impl_.last_heard_ = value;
}
inline void NodeInfo::set_last_heard(uint32_t value) {
  _internal_set_last_heard(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.last_heard)
}

// .meshtastic.DeviceMetrics device_metrics = 6;
inline bool NodeInfo::_internal_has_device_metrics() const {
  return this != internal_default_instance() && _impl_.device_metrics_ != nullptr;
}
inline bool NodeInfo::has_device_metrics() const {
  return _internal_has_device_metrics();
}
inline const ::meshtastic::DeviceMetrics& NodeInfo::_internal_device_metrics() const {
  const ::meshtastic::DeviceMetrics* p = _impl_.device_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::DeviceMetrics&>(
      ::meshtastic::_DeviceMetrics_default_instance_);
}
inline const ::meshtastic::DeviceMetrics& NodeInfo::device_metrics() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.device_metrics)
  return _internal_device_metrics();
}
inline void NodeInfo::unsafe_arena_set_allocated_device_metrics(
    ::meshtastic::DeviceMetrics* device_metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_metrics_);
  }
  _impl_.device_metrics_ = device_metrics;
  if (device_metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfo.device_metrics)
}
inline ::meshtastic::DeviceMetrics* NodeInfo::release_device_metrics() {
  
  ::meshtastic::DeviceMetrics* temp = _impl_.device_metrics_;
  _impl_.device_metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::DeviceMetrics* NodeInfo::unsafe_arena_release_device_metrics() {
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfo.device_metrics)
  
  ::meshtastic::DeviceMetrics* temp = _impl_.device_metrics_;
  _impl_.device_metrics_ = nullptr;
  return temp;
}
inline ::meshtastic::DeviceMetrics* NodeInfo::_internal_mutable_device_metrics() {
  
  if (_impl_.device_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::DeviceMetrics>(GetArenaForAllocation());
    _impl_.device_metrics_ = p;
  }
  return _impl_.device_metrics_;
}
inline ::meshtastic::DeviceMetrics* NodeInfo::mutable_device_metrics() {
  ::meshtastic::DeviceMetrics* _msg = _internal_mutable_device_metrics();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfo.device_metrics)
  return _msg;
}
inline void NodeInfo::set_allocated_device_metrics(::meshtastic::DeviceMetrics* device_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_metrics_);
  }
  if (device_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_metrics));
    if (message_arena != submessage_arena) {
      device_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_metrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_metrics_ = device_metrics;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfo.device_metrics)
}

// uint32 channel = 7;
inline void NodeInfo::clear_channel() {
  _impl_.channel_ = 0u;
}
inline uint32_t NodeInfo::_internal_channel() const {
  return _impl_.channel_;
}
inline uint32_t NodeInfo::channel() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.channel)
  return _internal_channel();
}
inline void NodeInfo::_internal_set_channel(uint32_t value) {
  
  _impl_.channel_ = value;
}
inline void NodeInfo::set_channel(uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.channel)
}

// bool via_mqtt = 8;
inline void NodeInfo::clear_via_mqtt() {
  _impl_.via_mqtt_ = false;
}
inline bool NodeInfo::_internal_via_mqtt() const {
  return _impl_.via_mqtt_;
}
inline bool NodeInfo::via_mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.via_mqtt)
  return _internal_via_mqtt();
}
inline void NodeInfo::_internal_set_via_mqtt(bool value) {
  
  _impl_.via_mqtt_ = value;
}
inline void NodeInfo::set_via_mqtt(bool value) {
  _internal_set_via_mqtt(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.via_mqtt)
}

// optional uint32 hops_away = 9;
inline bool NodeInfo::_internal_has_hops_away() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NodeInfo::has_hops_away() const {
  return _internal_has_hops_away();
}
inline void NodeInfo::clear_hops_away() {
  _impl_.hops_away_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t NodeInfo::_internal_hops_away() const {
  return _impl_.hops_away_;
}
inline uint32_t NodeInfo::hops_away() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.hops_away)
  return _internal_hops_away();
}
inline void NodeInfo::_internal_set_hops_away(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hops_away_ = value;
}
inline void NodeInfo::set_hops_away(uint32_t value) {
  _internal_set_hops_away(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.hops_away)
}

// bool is_favorite = 10;
inline void NodeInfo::clear_is_favorite() {
  _impl_.is_favorite_ = false;
}
inline bool NodeInfo::_internal_is_favorite() const {
  return _impl_.is_favorite_;
}
inline bool NodeInfo::is_favorite() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.is_favorite)
  return _internal_is_favorite();
}
inline void NodeInfo::_internal_set_is_favorite(bool value) {
  
  _impl_.is_favorite_ = value;
}
inline void NodeInfo::set_is_favorite(bool value) {
  _internal_set_is_favorite(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.is_favorite)
}

// bool is_ignored = 11;
inline void NodeInfo::clear_is_ignored() {
  _impl_.is_ignored_ = false;
}
inline bool NodeInfo::_internal_is_ignored() const {
  return _impl_.is_ignored_;
}
inline bool NodeInfo::is_ignored() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.is_ignored)
  return _internal_is_ignored();
}
inline void NodeInfo::_internal_set_is_ignored(bool value) {
  
  _impl_.is_ignored_ = value;
}
inline void NodeInfo::set_is_ignored(bool value) {
  _internal_set_is_ignored(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.is_ignored)
}

// bool is_key_manually_verified = 12;
inline void NodeInfo::clear_is_key_manually_verified() {
  _impl_.is_key_manually_verified_ = false;
}
inline bool NodeInfo::_internal_is_key_manually_verified() const {
  return _impl_.is_key_manually_verified_;
}
inline bool NodeInfo::is_key_manually_verified() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfo.is_key_manually_verified)
  return _internal_is_key_manually_verified();
}
inline void NodeInfo::_internal_set_is_key_manually_verified(bool value) {
  
  _impl_.is_key_manually_verified_ = value;
}
inline void NodeInfo::set_is_key_manually_verified(bool value) {
  _internal_set_is_key_manually_verified(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfo.is_key_manually_verified)
}

// -------------------------------------------------------------------

// MyNodeInfo

// uint32 my_node_num = 1;
inline void MyNodeInfo::clear_my_node_num() {
  _impl_.my_node_num_ = 0u;
}
inline uint32_t MyNodeInfo::_internal_my_node_num() const {
  return _impl_.my_node_num_;
}
inline uint32_t MyNodeInfo::my_node_num() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.my_node_num)
  return _internal_my_node_num();
}
inline void MyNodeInfo::_internal_set_my_node_num(uint32_t value) {
  
  _impl_.my_node_num_ = value;
}
inline void MyNodeInfo::set_my_node_num(uint32_t value) {
  _internal_set_my_node_num(value);
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.my_node_num)
}

// uint32 reboot_count = 8;
inline void MyNodeInfo::clear_reboot_count() {
  _impl_.reboot_count_ = 0u;
}
inline uint32_t MyNodeInfo::_internal_reboot_count() const {
  return _impl_.reboot_count_;
}
inline uint32_t MyNodeInfo::reboot_count() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.reboot_count)
  return _internal_reboot_count();
}
inline void MyNodeInfo::_internal_set_reboot_count(uint32_t value) {
  
  _impl_.reboot_count_ = value;
}
inline void MyNodeInfo::set_reboot_count(uint32_t value) {
  _internal_set_reboot_count(value);
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.reboot_count)
}

// uint32 min_app_version = 11;
inline void MyNodeInfo::clear_min_app_version() {
  _impl_.min_app_version_ = 0u;
}
inline uint32_t MyNodeInfo::_internal_min_app_version() const {
  return _impl_.min_app_version_;
}
inline uint32_t MyNodeInfo::min_app_version() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.min_app_version)
  return _internal_min_app_version();
}
inline void MyNodeInfo::_internal_set_min_app_version(uint32_t value) {
  
  _impl_.min_app_version_ = value;
}
inline void MyNodeInfo::set_min_app_version(uint32_t value) {
  _internal_set_min_app_version(value);
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.min_app_version)
}

// bytes device_id = 12;
inline void MyNodeInfo::clear_device_id() {
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& MyNodeInfo::device_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MyNodeInfo::set_device_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.device_id)
}
inline std::string* MyNodeInfo::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:meshtastic.MyNodeInfo.device_id)
  return _s;
}
inline const std::string& MyNodeInfo::_internal_device_id() const {
  return _impl_.device_id_.Get();
}
inline void MyNodeInfo::_internal_set_device_id(const std::string& value) {
  
  _impl_.device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MyNodeInfo::_internal_mutable_device_id() {
  
  return _impl_.device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MyNodeInfo::release_device_id() {
  // @@protoc_insertion_point(field_release:meshtastic.MyNodeInfo.device_id)
  return _impl_.device_id_.Release();
}
inline void MyNodeInfo::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    
  } else {
    
  }
  _impl_.device_id_.SetAllocated(device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MyNodeInfo.device_id)
}

// string pio_env = 13;
inline void MyNodeInfo::clear_pio_env() {
  _impl_.pio_env_.ClearToEmpty();
}
inline const std::string& MyNodeInfo::pio_env() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.pio_env)
  return _internal_pio_env();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MyNodeInfo::set_pio_env(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pio_env_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.pio_env)
}
inline std::string* MyNodeInfo::mutable_pio_env() {
  std::string* _s = _internal_mutable_pio_env();
  // @@protoc_insertion_point(field_mutable:meshtastic.MyNodeInfo.pio_env)
  return _s;
}
inline const std::string& MyNodeInfo::_internal_pio_env() const {
  return _impl_.pio_env_.Get();
}
inline void MyNodeInfo::_internal_set_pio_env(const std::string& value) {
  
  _impl_.pio_env_.Set(value, GetArenaForAllocation());
}
inline std::string* MyNodeInfo::_internal_mutable_pio_env() {
  
  return _impl_.pio_env_.Mutable(GetArenaForAllocation());
}
inline std::string* MyNodeInfo::release_pio_env() {
  // @@protoc_insertion_point(field_release:meshtastic.MyNodeInfo.pio_env)
  return _impl_.pio_env_.Release();
}
inline void MyNodeInfo::set_allocated_pio_env(std::string* pio_env) {
  if (pio_env != nullptr) {
    
  } else {
    
  }
  _impl_.pio_env_.SetAllocated(pio_env, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pio_env_.IsDefault()) {
    _impl_.pio_env_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MyNodeInfo.pio_env)
}

// .meshtastic.FirmwareEdition firmware_edition = 14;
inline void MyNodeInfo::clear_firmware_edition() {
  _impl_.firmware_edition_ = 0;
}
inline ::meshtastic::FirmwareEdition MyNodeInfo::_internal_firmware_edition() const {
  return static_cast< ::meshtastic::FirmwareEdition >(_impl_.firmware_edition_);
}
inline ::meshtastic::FirmwareEdition MyNodeInfo::firmware_edition() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.firmware_edition)
  return _internal_firmware_edition();
}
inline void MyNodeInfo::_internal_set_firmware_edition(::meshtastic::FirmwareEdition value) {
  
  _impl_.firmware_edition_ = value;
}
inline void MyNodeInfo::set_firmware_edition(::meshtastic::FirmwareEdition value) {
  _internal_set_firmware_edition(value);
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.firmware_edition)
}

// uint32 nodedb_count = 15;
inline void MyNodeInfo::clear_nodedb_count() {
  _impl_.nodedb_count_ = 0u;
}
inline uint32_t MyNodeInfo::_internal_nodedb_count() const {
  return _impl_.nodedb_count_;
}
inline uint32_t MyNodeInfo::nodedb_count() const {
  // @@protoc_insertion_point(field_get:meshtastic.MyNodeInfo.nodedb_count)
  return _internal_nodedb_count();
}
inline void MyNodeInfo::_internal_set_nodedb_count(uint32_t value) {
  
  _impl_.nodedb_count_ = value;
}
inline void MyNodeInfo::set_nodedb_count(uint32_t value) {
  _internal_set_nodedb_count(value);
  // @@protoc_insertion_point(field_set:meshtastic.MyNodeInfo.nodedb_count)
}

// -------------------------------------------------------------------

// LogRecord

// string message = 1;
inline void LogRecord::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LogRecord::message() const {
  // @@protoc_insertion_point(field_get:meshtastic.LogRecord.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogRecord::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.LogRecord.message)
}
inline std::string* LogRecord::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:meshtastic.LogRecord.message)
  return _s;
}
inline const std::string& LogRecord::_internal_message() const {
  return _impl_.message_.Get();
}
inline void LogRecord::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LogRecord::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* LogRecord::release_message() {
  // @@protoc_insertion_point(field_release:meshtastic.LogRecord.message)
  return _impl_.message_.Release();
}
inline void LogRecord::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LogRecord.message)
}

// fixed32 time = 2;
inline void LogRecord::clear_time() {
  _impl_.time_ = 0u;
}
inline uint32_t LogRecord::_internal_time() const {
  return _impl_.time_;
}
inline uint32_t LogRecord::time() const {
  // @@protoc_insertion_point(field_get:meshtastic.LogRecord.time)
  return _internal_time();
}
inline void LogRecord::_internal_set_time(uint32_t value) {
  
  _impl_.time_ = value;
}
inline void LogRecord::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.LogRecord.time)
}

// string source = 3;
inline void LogRecord::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& LogRecord::source() const {
  // @@protoc_insertion_point(field_get:meshtastic.LogRecord.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogRecord::set_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.LogRecord.source)
}
inline std::string* LogRecord::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:meshtastic.LogRecord.source)
  return _s;
}
inline const std::string& LogRecord::_internal_source() const {
  return _impl_.source_.Get();
}
inline void LogRecord::_internal_set_source(const std::string& value) {
  
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* LogRecord::_internal_mutable_source() {
  
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* LogRecord::release_source() {
  // @@protoc_insertion_point(field_release:meshtastic.LogRecord.source)
  return _impl_.source_.Release();
}
inline void LogRecord::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.LogRecord.source)
}

// .meshtastic.LogRecord.Level level = 4;
inline void LogRecord::clear_level() {
  _impl_.level_ = 0;
}
inline ::meshtastic::LogRecord_Level LogRecord::_internal_level() const {
  return static_cast< ::meshtastic::LogRecord_Level >(_impl_.level_);
}
inline ::meshtastic::LogRecord_Level LogRecord::level() const {
  // @@protoc_insertion_point(field_get:meshtastic.LogRecord.level)
  return _internal_level();
}
inline void LogRecord::_internal_set_level(::meshtastic::LogRecord_Level value) {
  
  _impl_.level_ = value;
}
inline void LogRecord::set_level(::meshtastic::LogRecord_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:meshtastic.LogRecord.level)
}

// -------------------------------------------------------------------

// QueueStatus

// int32 res = 1;
inline void QueueStatus::clear_res() {
  _impl_.res_ = 0;
}
inline int32_t QueueStatus::_internal_res() const {
  return _impl_.res_;
}
inline int32_t QueueStatus::res() const {
  // @@protoc_insertion_point(field_get:meshtastic.QueueStatus.res)
  return _internal_res();
}
inline void QueueStatus::_internal_set_res(int32_t value) {
  
  _impl_.res_ = value;
}
inline void QueueStatus::set_res(int32_t value) {
  _internal_set_res(value);
  // @@protoc_insertion_point(field_set:meshtastic.QueueStatus.res)
}

// uint32 free = 2;
inline void QueueStatus::clear_free() {
  _impl_.free_ = 0u;
}
inline uint32_t QueueStatus::_internal_free() const {
  return _impl_.free_;
}
inline uint32_t QueueStatus::free() const {
  // @@protoc_insertion_point(field_get:meshtastic.QueueStatus.free)
  return _internal_free();
}
inline void QueueStatus::_internal_set_free(uint32_t value) {
  
  _impl_.free_ = value;
}
inline void QueueStatus::set_free(uint32_t value) {
  _internal_set_free(value);
  // @@protoc_insertion_point(field_set:meshtastic.QueueStatus.free)
}

// uint32 maxlen = 3;
inline void QueueStatus::clear_maxlen() {
  _impl_.maxlen_ = 0u;
}
inline uint32_t QueueStatus::_internal_maxlen() const {
  return _impl_.maxlen_;
}
inline uint32_t QueueStatus::maxlen() const {
  // @@protoc_insertion_point(field_get:meshtastic.QueueStatus.maxlen)
  return _internal_maxlen();
}
inline void QueueStatus::_internal_set_maxlen(uint32_t value) {
  
  _impl_.maxlen_ = value;
}
inline void QueueStatus::set_maxlen(uint32_t value) {
  _internal_set_maxlen(value);
  // @@protoc_insertion_point(field_set:meshtastic.QueueStatus.maxlen)
}

// uint32 mesh_packet_id = 4;
inline void QueueStatus::clear_mesh_packet_id() {
  _impl_.mesh_packet_id_ = 0u;
}
inline uint32_t QueueStatus::_internal_mesh_packet_id() const {
  return _impl_.mesh_packet_id_;
}
inline uint32_t QueueStatus::mesh_packet_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.QueueStatus.mesh_packet_id)
  return _internal_mesh_packet_id();
}
inline void QueueStatus::_internal_set_mesh_packet_id(uint32_t value) {
  
  _impl_.mesh_packet_id_ = value;
}
inline void QueueStatus::set_mesh_packet_id(uint32_t value) {
  _internal_set_mesh_packet_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.QueueStatus.mesh_packet_id)
}

// -------------------------------------------------------------------

// FromRadio

// uint32 id = 1;
inline void FromRadio::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t FromRadio::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t FromRadio::id() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.id)
  return _internal_id();
}
inline void FromRadio::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void FromRadio::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.FromRadio.id)
}

// .meshtastic.MeshPacket packet = 2;
inline bool FromRadio::_internal_has_packet() const {
  return payload_variant_case() == kPacket;
}
inline bool FromRadio::has_packet() const {
  return _internal_has_packet();
}
inline void FromRadio::set_has_packet() {
  _impl_._oneof_case_[0] = kPacket;
}
inline void FromRadio::clear_packet() {
  if (_internal_has_packet()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.packet_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::MeshPacket* FromRadio::release_packet() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.packet)
  if (_internal_has_packet()) {
    clear_has_payload_variant();
    ::meshtastic::MeshPacket* temp = _impl_.payload_variant_.packet_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::MeshPacket& FromRadio::_internal_packet() const {
  return _internal_has_packet()
      ? *_impl_.payload_variant_.packet_
      : reinterpret_cast< ::meshtastic::MeshPacket&>(::meshtastic::_MeshPacket_default_instance_);
}
inline const ::meshtastic::MeshPacket& FromRadio::packet() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.packet)
  return _internal_packet();
}
inline ::meshtastic::MeshPacket* FromRadio::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.packet)
  if (_internal_has_packet()) {
    clear_has_payload_variant();
    ::meshtastic::MeshPacket* temp = _impl_.payload_variant_.packet_;
    _impl_.payload_variant_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_packet(::meshtastic::MeshPacket* packet) {
  clear_payload_variant();
  if (packet) {
    set_has_packet();
    _impl_.payload_variant_.packet_ = packet;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.packet)
}
inline ::meshtastic::MeshPacket* FromRadio::_internal_mutable_packet() {
  if (!_internal_has_packet()) {
    clear_payload_variant();
    set_has_packet();
    _impl_.payload_variant_.packet_ = CreateMaybeMessage< ::meshtastic::MeshPacket >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.packet_;
}
inline ::meshtastic::MeshPacket* FromRadio::mutable_packet() {
  ::meshtastic::MeshPacket* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.packet)
  return _msg;
}

// .meshtastic.MyNodeInfo my_info = 3;
inline bool FromRadio::_internal_has_my_info() const {
  return payload_variant_case() == kMyInfo;
}
inline bool FromRadio::has_my_info() const {
  return _internal_has_my_info();
}
inline void FromRadio::set_has_my_info() {
  _impl_._oneof_case_[0] = kMyInfo;
}
inline void FromRadio::clear_my_info() {
  if (_internal_has_my_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.my_info_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::MyNodeInfo* FromRadio::release_my_info() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.my_info)
  if (_internal_has_my_info()) {
    clear_has_payload_variant();
    ::meshtastic::MyNodeInfo* temp = _impl_.payload_variant_.my_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.my_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::MyNodeInfo& FromRadio::_internal_my_info() const {
  return _internal_has_my_info()
      ? *_impl_.payload_variant_.my_info_
      : reinterpret_cast< ::meshtastic::MyNodeInfo&>(::meshtastic::_MyNodeInfo_default_instance_);
}
inline const ::meshtastic::MyNodeInfo& FromRadio::my_info() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.my_info)
  return _internal_my_info();
}
inline ::meshtastic::MyNodeInfo* FromRadio::unsafe_arena_release_my_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.my_info)
  if (_internal_has_my_info()) {
    clear_has_payload_variant();
    ::meshtastic::MyNodeInfo* temp = _impl_.payload_variant_.my_info_;
    _impl_.payload_variant_.my_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_my_info(::meshtastic::MyNodeInfo* my_info) {
  clear_payload_variant();
  if (my_info) {
    set_has_my_info();
    _impl_.payload_variant_.my_info_ = my_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.my_info)
}
inline ::meshtastic::MyNodeInfo* FromRadio::_internal_mutable_my_info() {
  if (!_internal_has_my_info()) {
    clear_payload_variant();
    set_has_my_info();
    _impl_.payload_variant_.my_info_ = CreateMaybeMessage< ::meshtastic::MyNodeInfo >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.my_info_;
}
inline ::meshtastic::MyNodeInfo* FromRadio::mutable_my_info() {
  ::meshtastic::MyNodeInfo* _msg = _internal_mutable_my_info();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.my_info)
  return _msg;
}

// .meshtastic.NodeInfo node_info = 4;
inline bool FromRadio::_internal_has_node_info() const {
  return payload_variant_case() == kNodeInfo;
}
inline bool FromRadio::has_node_info() const {
  return _internal_has_node_info();
}
inline void FromRadio::set_has_node_info() {
  _impl_._oneof_case_[0] = kNodeInfo;
}
inline void FromRadio::clear_node_info() {
  if (_internal_has_node_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.node_info_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::NodeInfo* FromRadio::release_node_info() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.node_info)
  if (_internal_has_node_info()) {
    clear_has_payload_variant();
    ::meshtastic::NodeInfo* temp = _impl_.payload_variant_.node_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.node_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::NodeInfo& FromRadio::_internal_node_info() const {
  return _internal_has_node_info()
      ? *_impl_.payload_variant_.node_info_
      : reinterpret_cast< ::meshtastic::NodeInfo&>(::meshtastic::_NodeInfo_default_instance_);
}
inline const ::meshtastic::NodeInfo& FromRadio::node_info() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.node_info)
  return _internal_node_info();
}
inline ::meshtastic::NodeInfo* FromRadio::unsafe_arena_release_node_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.node_info)
  if (_internal_has_node_info()) {
    clear_has_payload_variant();
    ::meshtastic::NodeInfo* temp = _impl_.payload_variant_.node_info_;
    _impl_.payload_variant_.node_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_node_info(::meshtastic::NodeInfo* node_info) {
  clear_payload_variant();
  if (node_info) {
    set_has_node_info();
    _impl_.payload_variant_.node_info_ = node_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.node_info)
}
inline ::meshtastic::NodeInfo* FromRadio::_internal_mutable_node_info() {
  if (!_internal_has_node_info()) {
    clear_payload_variant();
    set_has_node_info();
    _impl_.payload_variant_.node_info_ = CreateMaybeMessage< ::meshtastic::NodeInfo >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.node_info_;
}
inline ::meshtastic::NodeInfo* FromRadio::mutable_node_info() {
  ::meshtastic::NodeInfo* _msg = _internal_mutable_node_info();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.node_info)
  return _msg;
}

// .meshtastic.Config config = 5;
inline bool FromRadio::_internal_has_config() const {
  return payload_variant_case() == kConfig;
}
inline bool FromRadio::has_config() const {
  return _internal_has_config();
}
inline void FromRadio::set_has_config() {
  _impl_._oneof_case_[0] = kConfig;
}
inline ::meshtastic::Config* FromRadio::release_config() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.config)
  if (_internal_has_config()) {
    clear_has_payload_variant();
    ::meshtastic::Config* temp = _impl_.payload_variant_.config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config& FromRadio::_internal_config() const {
  return _internal_has_config()
      ? *_impl_.payload_variant_.config_
      : reinterpret_cast< ::meshtastic::Config&>(::meshtastic::_Config_default_instance_);
}
inline const ::meshtastic::Config& FromRadio::config() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.config)
  return _internal_config();
}
inline ::meshtastic::Config* FromRadio::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.config)
  if (_internal_has_config()) {
    clear_has_payload_variant();
    ::meshtastic::Config* temp = _impl_.payload_variant_.config_;
    _impl_.payload_variant_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_config(::meshtastic::Config* config) {
  clear_payload_variant();
  if (config) {
    set_has_config();
    _impl_.payload_variant_.config_ = config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.config)
}
inline ::meshtastic::Config* FromRadio::_internal_mutable_config() {
  if (!_internal_has_config()) {
    clear_payload_variant();
    set_has_config();
    _impl_.payload_variant_.config_ = CreateMaybeMessage< ::meshtastic::Config >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.config_;
}
inline ::meshtastic::Config* FromRadio::mutable_config() {
  ::meshtastic::Config* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.config)
  return _msg;
}

// .meshtastic.LogRecord log_record = 6;
inline bool FromRadio::_internal_has_log_record() const {
  return payload_variant_case() == kLogRecord;
}
inline bool FromRadio::has_log_record() const {
  return _internal_has_log_record();
}
inline void FromRadio::set_has_log_record() {
  _impl_._oneof_case_[0] = kLogRecord;
}
inline void FromRadio::clear_log_record() {
  if (_internal_has_log_record()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.log_record_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::LogRecord* FromRadio::release_log_record() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.log_record)
  if (_internal_has_log_record()) {
    clear_has_payload_variant();
    ::meshtastic::LogRecord* temp = _impl_.payload_variant_.log_record_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.log_record_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::LogRecord& FromRadio::_internal_log_record() const {
  return _internal_has_log_record()
      ? *_impl_.payload_variant_.log_record_
      : reinterpret_cast< ::meshtastic::LogRecord&>(::meshtastic::_LogRecord_default_instance_);
}
inline const ::meshtastic::LogRecord& FromRadio::log_record() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.log_record)
  return _internal_log_record();
}
inline ::meshtastic::LogRecord* FromRadio::unsafe_arena_release_log_record() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.log_record)
  if (_internal_has_log_record()) {
    clear_has_payload_variant();
    ::meshtastic::LogRecord* temp = _impl_.payload_variant_.log_record_;
    _impl_.payload_variant_.log_record_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_log_record(::meshtastic::LogRecord* log_record) {
  clear_payload_variant();
  if (log_record) {
    set_has_log_record();
    _impl_.payload_variant_.log_record_ = log_record;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.log_record)
}
inline ::meshtastic::LogRecord* FromRadio::_internal_mutable_log_record() {
  if (!_internal_has_log_record()) {
    clear_payload_variant();
    set_has_log_record();
    _impl_.payload_variant_.log_record_ = CreateMaybeMessage< ::meshtastic::LogRecord >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.log_record_;
}
inline ::meshtastic::LogRecord* FromRadio::mutable_log_record() {
  ::meshtastic::LogRecord* _msg = _internal_mutable_log_record();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.log_record)
  return _msg;
}

// uint32 config_complete_id = 7;
inline bool FromRadio::_internal_has_config_complete_id() const {
  return payload_variant_case() == kConfigCompleteId;
}
inline bool FromRadio::has_config_complete_id() const {
  return _internal_has_config_complete_id();
}
inline void FromRadio::set_has_config_complete_id() {
  _impl_._oneof_case_[0] = kConfigCompleteId;
}
inline void FromRadio::clear_config_complete_id() {
  if (_internal_has_config_complete_id()) {
    _impl_.payload_variant_.config_complete_id_ = 0u;
    clear_has_payload_variant();
  }
}
inline uint32_t FromRadio::_internal_config_complete_id() const {
  if (_internal_has_config_complete_id()) {
    return _impl_.payload_variant_.config_complete_id_;
  }
  return 0u;
}
inline void FromRadio::_internal_set_config_complete_id(uint32_t value) {
  if (!_internal_has_config_complete_id()) {
    clear_payload_variant();
    set_has_config_complete_id();
  }
  _impl_.payload_variant_.config_complete_id_ = value;
}
inline uint32_t FromRadio::config_complete_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.config_complete_id)
  return _internal_config_complete_id();
}
inline void FromRadio::set_config_complete_id(uint32_t value) {
  _internal_set_config_complete_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.FromRadio.config_complete_id)
}

// bool rebooted = 8;
inline bool FromRadio::_internal_has_rebooted() const {
  return payload_variant_case() == kRebooted;
}
inline bool FromRadio::has_rebooted() const {
  return _internal_has_rebooted();
}
inline void FromRadio::set_has_rebooted() {
  _impl_._oneof_case_[0] = kRebooted;
}
inline void FromRadio::clear_rebooted() {
  if (_internal_has_rebooted()) {
    _impl_.payload_variant_.rebooted_ = false;
    clear_has_payload_variant();
  }
}
inline bool FromRadio::_internal_rebooted() const {
  if (_internal_has_rebooted()) {
    return _impl_.payload_variant_.rebooted_;
  }
  return false;
}
inline void FromRadio::_internal_set_rebooted(bool value) {
  if (!_internal_has_rebooted()) {
    clear_payload_variant();
    set_has_rebooted();
  }
  _impl_.payload_variant_.rebooted_ = value;
}
inline bool FromRadio::rebooted() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.rebooted)
  return _internal_rebooted();
}
inline void FromRadio::set_rebooted(bool value) {
  _internal_set_rebooted(value);
  // @@protoc_insertion_point(field_set:meshtastic.FromRadio.rebooted)
}

// .meshtastic.ModuleConfig moduleConfig = 9;
inline bool FromRadio::_internal_has_moduleconfig() const {
  return payload_variant_case() == kModuleConfig;
}
inline bool FromRadio::has_moduleconfig() const {
  return _internal_has_moduleconfig();
}
inline void FromRadio::set_has_moduleconfig() {
  _impl_._oneof_case_[0] = kModuleConfig;
}
inline ::meshtastic::ModuleConfig* FromRadio::release_moduleconfig() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.moduleConfig)
  if (_internal_has_moduleconfig()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig* temp = _impl_.payload_variant_.moduleconfig_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.moduleconfig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig& FromRadio::_internal_moduleconfig() const {
  return _internal_has_moduleconfig()
      ? *_impl_.payload_variant_.moduleconfig_
      : reinterpret_cast< ::meshtastic::ModuleConfig&>(::meshtastic::_ModuleConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig& FromRadio::moduleconfig() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.moduleConfig)
  return _internal_moduleconfig();
}
inline ::meshtastic::ModuleConfig* FromRadio::unsafe_arena_release_moduleconfig() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.moduleConfig)
  if (_internal_has_moduleconfig()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig* temp = _impl_.payload_variant_.moduleconfig_;
    _impl_.payload_variant_.moduleconfig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_moduleconfig(::meshtastic::ModuleConfig* moduleconfig) {
  clear_payload_variant();
  if (moduleconfig) {
    set_has_moduleconfig();
    _impl_.payload_variant_.moduleconfig_ = moduleconfig;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.moduleConfig)
}
inline ::meshtastic::ModuleConfig* FromRadio::_internal_mutable_moduleconfig() {
  if (!_internal_has_moduleconfig()) {
    clear_payload_variant();
    set_has_moduleconfig();
    _impl_.payload_variant_.moduleconfig_ = CreateMaybeMessage< ::meshtastic::ModuleConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.moduleconfig_;
}
inline ::meshtastic::ModuleConfig* FromRadio::mutable_moduleconfig() {
  ::meshtastic::ModuleConfig* _msg = _internal_mutable_moduleconfig();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.moduleConfig)
  return _msg;
}

// .meshtastic.Channel channel = 10;
inline bool FromRadio::_internal_has_channel() const {
  return payload_variant_case() == kChannel;
}
inline bool FromRadio::has_channel() const {
  return _internal_has_channel();
}
inline void FromRadio::set_has_channel() {
  _impl_._oneof_case_[0] = kChannel;
}
inline ::meshtastic::Channel* FromRadio::release_channel() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.channel)
  if (_internal_has_channel()) {
    clear_has_payload_variant();
    ::meshtastic::Channel* temp = _impl_.payload_variant_.channel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Channel& FromRadio::_internal_channel() const {
  return _internal_has_channel()
      ? *_impl_.payload_variant_.channel_
      : reinterpret_cast< ::meshtastic::Channel&>(::meshtastic::_Channel_default_instance_);
}
inline const ::meshtastic::Channel& FromRadio::channel() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.channel)
  return _internal_channel();
}
inline ::meshtastic::Channel* FromRadio::unsafe_arena_release_channel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.channel)
  if (_internal_has_channel()) {
    clear_has_payload_variant();
    ::meshtastic::Channel* temp = _impl_.payload_variant_.channel_;
    _impl_.payload_variant_.channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_channel(::meshtastic::Channel* channel) {
  clear_payload_variant();
  if (channel) {
    set_has_channel();
    _impl_.payload_variant_.channel_ = channel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.channel)
}
inline ::meshtastic::Channel* FromRadio::_internal_mutable_channel() {
  if (!_internal_has_channel()) {
    clear_payload_variant();
    set_has_channel();
    _impl_.payload_variant_.channel_ = CreateMaybeMessage< ::meshtastic::Channel >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.channel_;
}
inline ::meshtastic::Channel* FromRadio::mutable_channel() {
  ::meshtastic::Channel* _msg = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.channel)
  return _msg;
}

// .meshtastic.QueueStatus queueStatus = 11;
inline bool FromRadio::_internal_has_queuestatus() const {
  return payload_variant_case() == kQueueStatus;
}
inline bool FromRadio::has_queuestatus() const {
  return _internal_has_queuestatus();
}
inline void FromRadio::set_has_queuestatus() {
  _impl_._oneof_case_[0] = kQueueStatus;
}
inline void FromRadio::clear_queuestatus() {
  if (_internal_has_queuestatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.queuestatus_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::QueueStatus* FromRadio::release_queuestatus() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.queueStatus)
  if (_internal_has_queuestatus()) {
    clear_has_payload_variant();
    ::meshtastic::QueueStatus* temp = _impl_.payload_variant_.queuestatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.queuestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::QueueStatus& FromRadio::_internal_queuestatus() const {
  return _internal_has_queuestatus()
      ? *_impl_.payload_variant_.queuestatus_
      : reinterpret_cast< ::meshtastic::QueueStatus&>(::meshtastic::_QueueStatus_default_instance_);
}
inline const ::meshtastic::QueueStatus& FromRadio::queuestatus() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.queueStatus)
  return _internal_queuestatus();
}
inline ::meshtastic::QueueStatus* FromRadio::unsafe_arena_release_queuestatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.queueStatus)
  if (_internal_has_queuestatus()) {
    clear_has_payload_variant();
    ::meshtastic::QueueStatus* temp = _impl_.payload_variant_.queuestatus_;
    _impl_.payload_variant_.queuestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_queuestatus(::meshtastic::QueueStatus* queuestatus) {
  clear_payload_variant();
  if (queuestatus) {
    set_has_queuestatus();
    _impl_.payload_variant_.queuestatus_ = queuestatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.queueStatus)
}
inline ::meshtastic::QueueStatus* FromRadio::_internal_mutable_queuestatus() {
  if (!_internal_has_queuestatus()) {
    clear_payload_variant();
    set_has_queuestatus();
    _impl_.payload_variant_.queuestatus_ = CreateMaybeMessage< ::meshtastic::QueueStatus >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.queuestatus_;
}
inline ::meshtastic::QueueStatus* FromRadio::mutable_queuestatus() {
  ::meshtastic::QueueStatus* _msg = _internal_mutable_queuestatus();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.queueStatus)
  return _msg;
}

// .meshtastic.XModem xmodemPacket = 12;
inline bool FromRadio::_internal_has_xmodempacket() const {
  return payload_variant_case() == kXmodemPacket;
}
inline bool FromRadio::has_xmodempacket() const {
  return _internal_has_xmodempacket();
}
inline void FromRadio::set_has_xmodempacket() {
  _impl_._oneof_case_[0] = kXmodemPacket;
}
inline ::meshtastic::XModem* FromRadio::release_xmodempacket() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.xmodemPacket)
  if (_internal_has_xmodempacket()) {
    clear_has_payload_variant();
    ::meshtastic::XModem* temp = _impl_.payload_variant_.xmodempacket_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.xmodempacket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::XModem& FromRadio::_internal_xmodempacket() const {
  return _internal_has_xmodempacket()
      ? *_impl_.payload_variant_.xmodempacket_
      : reinterpret_cast< ::meshtastic::XModem&>(::meshtastic::_XModem_default_instance_);
}
inline const ::meshtastic::XModem& FromRadio::xmodempacket() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.xmodemPacket)
  return _internal_xmodempacket();
}
inline ::meshtastic::XModem* FromRadio::unsafe_arena_release_xmodempacket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.xmodemPacket)
  if (_internal_has_xmodempacket()) {
    clear_has_payload_variant();
    ::meshtastic::XModem* temp = _impl_.payload_variant_.xmodempacket_;
    _impl_.payload_variant_.xmodempacket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_xmodempacket(::meshtastic::XModem* xmodempacket) {
  clear_payload_variant();
  if (xmodempacket) {
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ = xmodempacket;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.xmodemPacket)
}
inline ::meshtastic::XModem* FromRadio::_internal_mutable_xmodempacket() {
  if (!_internal_has_xmodempacket()) {
    clear_payload_variant();
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ = CreateMaybeMessage< ::meshtastic::XModem >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.xmodempacket_;
}
inline ::meshtastic::XModem* FromRadio::mutable_xmodempacket() {
  ::meshtastic::XModem* _msg = _internal_mutable_xmodempacket();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.xmodemPacket)
  return _msg;
}

// .meshtastic.DeviceMetadata metadata = 13;
inline bool FromRadio::_internal_has_metadata() const {
  return payload_variant_case() == kMetadata;
}
inline bool FromRadio::has_metadata() const {
  return _internal_has_metadata();
}
inline void FromRadio::set_has_metadata() {
  _impl_._oneof_case_[0] = kMetadata;
}
inline void FromRadio::clear_metadata() {
  if (_internal_has_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.metadata_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::DeviceMetadata* FromRadio::release_metadata() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.metadata)
  if (_internal_has_metadata()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceMetadata* temp = _impl_.payload_variant_.metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceMetadata& FromRadio::_internal_metadata() const {
  return _internal_has_metadata()
      ? *_impl_.payload_variant_.metadata_
      : reinterpret_cast< ::meshtastic::DeviceMetadata&>(::meshtastic::_DeviceMetadata_default_instance_);
}
inline const ::meshtastic::DeviceMetadata& FromRadio::metadata() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.metadata)
  return _internal_metadata();
}
inline ::meshtastic::DeviceMetadata* FromRadio::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.metadata)
  if (_internal_has_metadata()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceMetadata* temp = _impl_.payload_variant_.metadata_;
    _impl_.payload_variant_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_metadata(::meshtastic::DeviceMetadata* metadata) {
  clear_payload_variant();
  if (metadata) {
    set_has_metadata();
    _impl_.payload_variant_.metadata_ = metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.metadata)
}
inline ::meshtastic::DeviceMetadata* FromRadio::_internal_mutable_metadata() {
  if (!_internal_has_metadata()) {
    clear_payload_variant();
    set_has_metadata();
    _impl_.payload_variant_.metadata_ = CreateMaybeMessage< ::meshtastic::DeviceMetadata >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.metadata_;
}
inline ::meshtastic::DeviceMetadata* FromRadio::mutable_metadata() {
  ::meshtastic::DeviceMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.metadata)
  return _msg;
}

// .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 14;
inline bool FromRadio::_internal_has_mqttclientproxymessage() const {
  return payload_variant_case() == kMqttClientProxyMessage;
}
inline bool FromRadio::has_mqttclientproxymessage() const {
  return _internal_has_mqttclientproxymessage();
}
inline void FromRadio::set_has_mqttclientproxymessage() {
  _impl_._oneof_case_[0] = kMqttClientProxyMessage;
}
inline void FromRadio::clear_mqttclientproxymessage() {
  if (_internal_has_mqttclientproxymessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.mqttclientproxymessage_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::MqttClientProxyMessage* FromRadio::release_mqttclientproxymessage() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.mqttClientProxyMessage)
  if (_internal_has_mqttclientproxymessage()) {
    clear_has_payload_variant();
    ::meshtastic::MqttClientProxyMessage* temp = _impl_.payload_variant_.mqttclientproxymessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.mqttclientproxymessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::MqttClientProxyMessage& FromRadio::_internal_mqttclientproxymessage() const {
  return _internal_has_mqttclientproxymessage()
      ? *_impl_.payload_variant_.mqttclientproxymessage_
      : reinterpret_cast< ::meshtastic::MqttClientProxyMessage&>(::meshtastic::_MqttClientProxyMessage_default_instance_);
}
inline const ::meshtastic::MqttClientProxyMessage& FromRadio::mqttclientproxymessage() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.mqttClientProxyMessage)
  return _internal_mqttclientproxymessage();
}
inline ::meshtastic::MqttClientProxyMessage* FromRadio::unsafe_arena_release_mqttclientproxymessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.mqttClientProxyMessage)
  if (_internal_has_mqttclientproxymessage()) {
    clear_has_payload_variant();
    ::meshtastic::MqttClientProxyMessage* temp = _impl_.payload_variant_.mqttclientproxymessage_;
    _impl_.payload_variant_.mqttclientproxymessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* mqttclientproxymessage) {
  clear_payload_variant();
  if (mqttclientproxymessage) {
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ = mqttclientproxymessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.mqttClientProxyMessage)
}
inline ::meshtastic::MqttClientProxyMessage* FromRadio::_internal_mutable_mqttclientproxymessage() {
  if (!_internal_has_mqttclientproxymessage()) {
    clear_payload_variant();
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ = CreateMaybeMessage< ::meshtastic::MqttClientProxyMessage >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.mqttclientproxymessage_;
}
inline ::meshtastic::MqttClientProxyMessage* FromRadio::mutable_mqttclientproxymessage() {
  ::meshtastic::MqttClientProxyMessage* _msg = _internal_mutable_mqttclientproxymessage();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.mqttClientProxyMessage)
  return _msg;
}

// .meshtastic.FileInfo fileInfo = 15;
inline bool FromRadio::_internal_has_fileinfo() const {
  return payload_variant_case() == kFileInfo;
}
inline bool FromRadio::has_fileinfo() const {
  return _internal_has_fileinfo();
}
inline void FromRadio::set_has_fileinfo() {
  _impl_._oneof_case_[0] = kFileInfo;
}
inline void FromRadio::clear_fileinfo() {
  if (_internal_has_fileinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.fileinfo_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::FileInfo* FromRadio::release_fileinfo() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.fileInfo)
  if (_internal_has_fileinfo()) {
    clear_has_payload_variant();
    ::meshtastic::FileInfo* temp = _impl_.payload_variant_.fileinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.fileinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::FileInfo& FromRadio::_internal_fileinfo() const {
  return _internal_has_fileinfo()
      ? *_impl_.payload_variant_.fileinfo_
      : reinterpret_cast< ::meshtastic::FileInfo&>(::meshtastic::_FileInfo_default_instance_);
}
inline const ::meshtastic::FileInfo& FromRadio::fileinfo() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.fileInfo)
  return _internal_fileinfo();
}
inline ::meshtastic::FileInfo* FromRadio::unsafe_arena_release_fileinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.fileInfo)
  if (_internal_has_fileinfo()) {
    clear_has_payload_variant();
    ::meshtastic::FileInfo* temp = _impl_.payload_variant_.fileinfo_;
    _impl_.payload_variant_.fileinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_fileinfo(::meshtastic::FileInfo* fileinfo) {
  clear_payload_variant();
  if (fileinfo) {
    set_has_fileinfo();
    _impl_.payload_variant_.fileinfo_ = fileinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.fileInfo)
}
inline ::meshtastic::FileInfo* FromRadio::_internal_mutable_fileinfo() {
  if (!_internal_has_fileinfo()) {
    clear_payload_variant();
    set_has_fileinfo();
    _impl_.payload_variant_.fileinfo_ = CreateMaybeMessage< ::meshtastic::FileInfo >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.fileinfo_;
}
inline ::meshtastic::FileInfo* FromRadio::mutable_fileinfo() {
  ::meshtastic::FileInfo* _msg = _internal_mutable_fileinfo();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.fileInfo)
  return _msg;
}

// .meshtastic.ClientNotification clientNotification = 16;
inline bool FromRadio::_internal_has_clientnotification() const {
  return payload_variant_case() == kClientNotification;
}
inline bool FromRadio::has_clientnotification() const {
  return _internal_has_clientnotification();
}
inline void FromRadio::set_has_clientnotification() {
  _impl_._oneof_case_[0] = kClientNotification;
}
inline void FromRadio::clear_clientnotification() {
  if (_internal_has_clientnotification()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.clientnotification_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ClientNotification* FromRadio::release_clientnotification() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.clientNotification)
  if (_internal_has_clientnotification()) {
    clear_has_payload_variant();
    ::meshtastic::ClientNotification* temp = _impl_.payload_variant_.clientnotification_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.clientnotification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ClientNotification& FromRadio::_internal_clientnotification() const {
  return _internal_has_clientnotification()
      ? *_impl_.payload_variant_.clientnotification_
      : reinterpret_cast< ::meshtastic::ClientNotification&>(::meshtastic::_ClientNotification_default_instance_);
}
inline const ::meshtastic::ClientNotification& FromRadio::clientnotification() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.clientNotification)
  return _internal_clientnotification();
}
inline ::meshtastic::ClientNotification* FromRadio::unsafe_arena_release_clientnotification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.clientNotification)
  if (_internal_has_clientnotification()) {
    clear_has_payload_variant();
    ::meshtastic::ClientNotification* temp = _impl_.payload_variant_.clientnotification_;
    _impl_.payload_variant_.clientnotification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_clientnotification(::meshtastic::ClientNotification* clientnotification) {
  clear_payload_variant();
  if (clientnotification) {
    set_has_clientnotification();
    _impl_.payload_variant_.clientnotification_ = clientnotification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.clientNotification)
}
inline ::meshtastic::ClientNotification* FromRadio::_internal_mutable_clientnotification() {
  if (!_internal_has_clientnotification()) {
    clear_payload_variant();
    set_has_clientnotification();
    _impl_.payload_variant_.clientnotification_ = CreateMaybeMessage< ::meshtastic::ClientNotification >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.clientnotification_;
}
inline ::meshtastic::ClientNotification* FromRadio::mutable_clientnotification() {
  ::meshtastic::ClientNotification* _msg = _internal_mutable_clientnotification();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.clientNotification)
  return _msg;
}

// .meshtastic.DeviceUIConfig deviceuiConfig = 17;
inline bool FromRadio::_internal_has_deviceuiconfig() const {
  return payload_variant_case() == kDeviceuiConfig;
}
inline bool FromRadio::has_deviceuiconfig() const {
  return _internal_has_deviceuiconfig();
}
inline void FromRadio::set_has_deviceuiconfig() {
  _impl_._oneof_case_[0] = kDeviceuiConfig;
}
inline ::meshtastic::DeviceUIConfig* FromRadio::release_deviceuiconfig() {
  // @@protoc_insertion_point(field_release:meshtastic.FromRadio.deviceuiConfig)
  if (_internal_has_deviceuiconfig()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceUIConfig* temp = _impl_.payload_variant_.deviceuiconfig_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.deviceuiconfig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceUIConfig& FromRadio::_internal_deviceuiconfig() const {
  return _internal_has_deviceuiconfig()
      ? *_impl_.payload_variant_.deviceuiconfig_
      : reinterpret_cast< ::meshtastic::DeviceUIConfig&>(::meshtastic::_DeviceUIConfig_default_instance_);
}
inline const ::meshtastic::DeviceUIConfig& FromRadio::deviceuiconfig() const {
  // @@protoc_insertion_point(field_get:meshtastic.FromRadio.deviceuiConfig)
  return _internal_deviceuiconfig();
}
inline ::meshtastic::DeviceUIConfig* FromRadio::unsafe_arena_release_deviceuiconfig() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.FromRadio.deviceuiConfig)
  if (_internal_has_deviceuiconfig()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceUIConfig* temp = _impl_.payload_variant_.deviceuiconfig_;
    _impl_.payload_variant_.deviceuiconfig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FromRadio::unsafe_arena_set_allocated_deviceuiconfig(::meshtastic::DeviceUIConfig* deviceuiconfig) {
  clear_payload_variant();
  if (deviceuiconfig) {
    set_has_deviceuiconfig();
    _impl_.payload_variant_.deviceuiconfig_ = deviceuiconfig;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.FromRadio.deviceuiConfig)
}
inline ::meshtastic::DeviceUIConfig* FromRadio::_internal_mutable_deviceuiconfig() {
  if (!_internal_has_deviceuiconfig()) {
    clear_payload_variant();
    set_has_deviceuiconfig();
    _impl_.payload_variant_.deviceuiconfig_ = CreateMaybeMessage< ::meshtastic::DeviceUIConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.deviceuiconfig_;
}
inline ::meshtastic::DeviceUIConfig* FromRadio::mutable_deviceuiconfig() {
  ::meshtastic::DeviceUIConfig* _msg = _internal_mutable_deviceuiconfig();
  // @@protoc_insertion_point(field_mutable:meshtastic.FromRadio.deviceuiConfig)
  return _msg;
}

inline bool FromRadio::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void FromRadio::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline FromRadio::PayloadVariantCase FromRadio::payload_variant_case() const {
  return FromRadio::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientNotification

// optional uint32 reply_id = 1;
inline bool ClientNotification::_internal_has_reply_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientNotification::has_reply_id() const {
  return _internal_has_reply_id();
}
inline void ClientNotification::clear_reply_id() {
  _impl_.reply_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ClientNotification::_internal_reply_id() const {
  return _impl_.reply_id_;
}
inline uint32_t ClientNotification::reply_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.reply_id)
  return _internal_reply_id();
}
inline void ClientNotification::_internal_set_reply_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reply_id_ = value;
}
inline void ClientNotification::set_reply_id(uint32_t value) {
  _internal_set_reply_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.ClientNotification.reply_id)
}

// fixed32 time = 2;
inline void ClientNotification::clear_time() {
  _impl_.time_ = 0u;
}
inline uint32_t ClientNotification::_internal_time() const {
  return _impl_.time_;
}
inline uint32_t ClientNotification::time() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.time)
  return _internal_time();
}
inline void ClientNotification::_internal_set_time(uint32_t value) {
  
  _impl_.time_ = value;
}
inline void ClientNotification::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.ClientNotification.time)
}

// .meshtastic.LogRecord.Level level = 3;
inline void ClientNotification::clear_level() {
  _impl_.level_ = 0;
}
inline ::meshtastic::LogRecord_Level ClientNotification::_internal_level() const {
  return static_cast< ::meshtastic::LogRecord_Level >(_impl_.level_);
}
inline ::meshtastic::LogRecord_Level ClientNotification::level() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.level)
  return _internal_level();
}
inline void ClientNotification::_internal_set_level(::meshtastic::LogRecord_Level value) {
  
  _impl_.level_ = value;
}
inline void ClientNotification::set_level(::meshtastic::LogRecord_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:meshtastic.ClientNotification.level)
}

// string message = 4;
inline void ClientNotification::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ClientNotification::message() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientNotification::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.ClientNotification.message)
}
inline std::string* ClientNotification::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.message)
  return _s;
}
inline const std::string& ClientNotification::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ClientNotification::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientNotification::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientNotification::release_message() {
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.message)
  return _impl_.message_.Release();
}
inline void ClientNotification::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.message)
}

// .meshtastic.KeyVerificationNumberInform key_verification_number_inform = 11;
inline bool ClientNotification::_internal_has_key_verification_number_inform() const {
  return payload_variant_case() == kKeyVerificationNumberInform;
}
inline bool ClientNotification::has_key_verification_number_inform() const {
  return _internal_has_key_verification_number_inform();
}
inline void ClientNotification::set_has_key_verification_number_inform() {
  _impl_._oneof_case_[0] = kKeyVerificationNumberInform;
}
inline void ClientNotification::clear_key_verification_number_inform() {
  if (_internal_has_key_verification_number_inform()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.key_verification_number_inform_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::KeyVerificationNumberInform* ClientNotification::release_key_verification_number_inform() {
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.key_verification_number_inform)
  if (_internal_has_key_verification_number_inform()) {
    clear_has_payload_variant();
    ::meshtastic::KeyVerificationNumberInform* temp = _impl_.payload_variant_.key_verification_number_inform_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.key_verification_number_inform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::KeyVerificationNumberInform& ClientNotification::_internal_key_verification_number_inform() const {
  return _internal_has_key_verification_number_inform()
      ? *_impl_.payload_variant_.key_verification_number_inform_
      : reinterpret_cast< ::meshtastic::KeyVerificationNumberInform&>(::meshtastic::_KeyVerificationNumberInform_default_instance_);
}
inline const ::meshtastic::KeyVerificationNumberInform& ClientNotification::key_verification_number_inform() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.key_verification_number_inform)
  return _internal_key_verification_number_inform();
}
inline ::meshtastic::KeyVerificationNumberInform* ClientNotification::unsafe_arena_release_key_verification_number_inform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ClientNotification.key_verification_number_inform)
  if (_internal_has_key_verification_number_inform()) {
    clear_has_payload_variant();
    ::meshtastic::KeyVerificationNumberInform* temp = _impl_.payload_variant_.key_verification_number_inform_;
    _impl_.payload_variant_.key_verification_number_inform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientNotification::unsafe_arena_set_allocated_key_verification_number_inform(::meshtastic::KeyVerificationNumberInform* key_verification_number_inform) {
  clear_payload_variant();
  if (key_verification_number_inform) {
    set_has_key_verification_number_inform();
    _impl_.payload_variant_.key_verification_number_inform_ = key_verification_number_inform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ClientNotification.key_verification_number_inform)
}
inline ::meshtastic::KeyVerificationNumberInform* ClientNotification::_internal_mutable_key_verification_number_inform() {
  if (!_internal_has_key_verification_number_inform()) {
    clear_payload_variant();
    set_has_key_verification_number_inform();
    _impl_.payload_variant_.key_verification_number_inform_ = CreateMaybeMessage< ::meshtastic::KeyVerificationNumberInform >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.key_verification_number_inform_;
}
inline ::meshtastic::KeyVerificationNumberInform* ClientNotification::mutable_key_verification_number_inform() {
  ::meshtastic::KeyVerificationNumberInform* _msg = _internal_mutable_key_verification_number_inform();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.key_verification_number_inform)
  return _msg;
}

// .meshtastic.KeyVerificationNumberRequest key_verification_number_request = 12;
inline bool ClientNotification::_internal_has_key_verification_number_request() const {
  return payload_variant_case() == kKeyVerificationNumberRequest;
}
inline bool ClientNotification::has_key_verification_number_request() const {
  return _internal_has_key_verification_number_request();
}
inline void ClientNotification::set_has_key_verification_number_request() {
  _impl_._oneof_case_[0] = kKeyVerificationNumberRequest;
}
inline void ClientNotification::clear_key_verification_number_request() {
  if (_internal_has_key_verification_number_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.key_verification_number_request_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::KeyVerificationNumberRequest* ClientNotification::release_key_verification_number_request() {
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.key_verification_number_request)
  if (_internal_has_key_verification_number_request()) {
    clear_has_payload_variant();
    ::meshtastic::KeyVerificationNumberRequest* temp = _impl_.payload_variant_.key_verification_number_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.key_verification_number_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::KeyVerificationNumberRequest& ClientNotification::_internal_key_verification_number_request() const {
  return _internal_has_key_verification_number_request()
      ? *_impl_.payload_variant_.key_verification_number_request_
      : reinterpret_cast< ::meshtastic::KeyVerificationNumberRequest&>(::meshtastic::_KeyVerificationNumberRequest_default_instance_);
}
inline const ::meshtastic::KeyVerificationNumberRequest& ClientNotification::key_verification_number_request() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.key_verification_number_request)
  return _internal_key_verification_number_request();
}
inline ::meshtastic::KeyVerificationNumberRequest* ClientNotification::unsafe_arena_release_key_verification_number_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ClientNotification.key_verification_number_request)
  if (_internal_has_key_verification_number_request()) {
    clear_has_payload_variant();
    ::meshtastic::KeyVerificationNumberRequest* temp = _impl_.payload_variant_.key_verification_number_request_;
    _impl_.payload_variant_.key_verification_number_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientNotification::unsafe_arena_set_allocated_key_verification_number_request(::meshtastic::KeyVerificationNumberRequest* key_verification_number_request) {
  clear_payload_variant();
  if (key_verification_number_request) {
    set_has_key_verification_number_request();
    _impl_.payload_variant_.key_verification_number_request_ = key_verification_number_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ClientNotification.key_verification_number_request)
}
inline ::meshtastic::KeyVerificationNumberRequest* ClientNotification::_internal_mutable_key_verification_number_request() {
  if (!_internal_has_key_verification_number_request()) {
    clear_payload_variant();
    set_has_key_verification_number_request();
    _impl_.payload_variant_.key_verification_number_request_ = CreateMaybeMessage< ::meshtastic::KeyVerificationNumberRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.key_verification_number_request_;
}
inline ::meshtastic::KeyVerificationNumberRequest* ClientNotification::mutable_key_verification_number_request() {
  ::meshtastic::KeyVerificationNumberRequest* _msg = _internal_mutable_key_verification_number_request();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.key_verification_number_request)
  return _msg;
}

// .meshtastic.KeyVerificationFinal key_verification_final = 13;
inline bool ClientNotification::_internal_has_key_verification_final() const {
  return payload_variant_case() == kKeyVerificationFinal;
}
inline bool ClientNotification::has_key_verification_final() const {
  return _internal_has_key_verification_final();
}
inline void ClientNotification::set_has_key_verification_final() {
  _impl_._oneof_case_[0] = kKeyVerificationFinal;
}
inline void ClientNotification::clear_key_verification_final() {
  if (_internal_has_key_verification_final()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.key_verification_final_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::KeyVerificationFinal* ClientNotification::release_key_verification_final() {
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.key_verification_final)
  if (_internal_has_key_verification_final()) {
    clear_has_payload_variant();
    ::meshtastic::KeyVerificationFinal* temp = _impl_.payload_variant_.key_verification_final_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.key_verification_final_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::KeyVerificationFinal& ClientNotification::_internal_key_verification_final() const {
  return _internal_has_key_verification_final()
      ? *_impl_.payload_variant_.key_verification_final_
      : reinterpret_cast< ::meshtastic::KeyVerificationFinal&>(::meshtastic::_KeyVerificationFinal_default_instance_);
}
inline const ::meshtastic::KeyVerificationFinal& ClientNotification::key_verification_final() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.key_verification_final)
  return _internal_key_verification_final();
}
inline ::meshtastic::KeyVerificationFinal* ClientNotification::unsafe_arena_release_key_verification_final() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ClientNotification.key_verification_final)
  if (_internal_has_key_verification_final()) {
    clear_has_payload_variant();
    ::meshtastic::KeyVerificationFinal* temp = _impl_.payload_variant_.key_verification_final_;
    _impl_.payload_variant_.key_verification_final_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientNotification::unsafe_arena_set_allocated_key_verification_final(::meshtastic::KeyVerificationFinal* key_verification_final) {
  clear_payload_variant();
  if (key_verification_final) {
    set_has_key_verification_final();
    _impl_.payload_variant_.key_verification_final_ = key_verification_final;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ClientNotification.key_verification_final)
}
inline ::meshtastic::KeyVerificationFinal* ClientNotification::_internal_mutable_key_verification_final() {
  if (!_internal_has_key_verification_final()) {
    clear_payload_variant();
    set_has_key_verification_final();
    _impl_.payload_variant_.key_verification_final_ = CreateMaybeMessage< ::meshtastic::KeyVerificationFinal >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.key_verification_final_;
}
inline ::meshtastic::KeyVerificationFinal* ClientNotification::mutable_key_verification_final() {
  ::meshtastic::KeyVerificationFinal* _msg = _internal_mutable_key_verification_final();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.key_verification_final)
  return _msg;
}

// .meshtastic.DuplicatedPublicKey duplicated_public_key = 14;
inline bool ClientNotification::_internal_has_duplicated_public_key() const {
  return payload_variant_case() == kDuplicatedPublicKey;
}
inline bool ClientNotification::has_duplicated_public_key() const {
  return _internal_has_duplicated_public_key();
}
inline void ClientNotification::set_has_duplicated_public_key() {
  _impl_._oneof_case_[0] = kDuplicatedPublicKey;
}
inline void ClientNotification::clear_duplicated_public_key() {
  if (_internal_has_duplicated_public_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.duplicated_public_key_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::DuplicatedPublicKey* ClientNotification::release_duplicated_public_key() {
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.duplicated_public_key)
  if (_internal_has_duplicated_public_key()) {
    clear_has_payload_variant();
    ::meshtastic::DuplicatedPublicKey* temp = _impl_.payload_variant_.duplicated_public_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.duplicated_public_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DuplicatedPublicKey& ClientNotification::_internal_duplicated_public_key() const {
  return _internal_has_duplicated_public_key()
      ? *_impl_.payload_variant_.duplicated_public_key_
      : reinterpret_cast< ::meshtastic::DuplicatedPublicKey&>(::meshtastic::_DuplicatedPublicKey_default_instance_);
}
inline const ::meshtastic::DuplicatedPublicKey& ClientNotification::duplicated_public_key() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.duplicated_public_key)
  return _internal_duplicated_public_key();
}
inline ::meshtastic::DuplicatedPublicKey* ClientNotification::unsafe_arena_release_duplicated_public_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ClientNotification.duplicated_public_key)
  if (_internal_has_duplicated_public_key()) {
    clear_has_payload_variant();
    ::meshtastic::DuplicatedPublicKey* temp = _impl_.payload_variant_.duplicated_public_key_;
    _impl_.payload_variant_.duplicated_public_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientNotification::unsafe_arena_set_allocated_duplicated_public_key(::meshtastic::DuplicatedPublicKey* duplicated_public_key) {
  clear_payload_variant();
  if (duplicated_public_key) {
    set_has_duplicated_public_key();
    _impl_.payload_variant_.duplicated_public_key_ = duplicated_public_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ClientNotification.duplicated_public_key)
}
inline ::meshtastic::DuplicatedPublicKey* ClientNotification::_internal_mutable_duplicated_public_key() {
  if (!_internal_has_duplicated_public_key()) {
    clear_payload_variant();
    set_has_duplicated_public_key();
    _impl_.payload_variant_.duplicated_public_key_ = CreateMaybeMessage< ::meshtastic::DuplicatedPublicKey >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.duplicated_public_key_;
}
inline ::meshtastic::DuplicatedPublicKey* ClientNotification::mutable_duplicated_public_key() {
  ::meshtastic::DuplicatedPublicKey* _msg = _internal_mutable_duplicated_public_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.duplicated_public_key)
  return _msg;
}

// .meshtastic.LowEntropyKey low_entropy_key = 15;
inline bool ClientNotification::_internal_has_low_entropy_key() const {
  return payload_variant_case() == kLowEntropyKey;
}
inline bool ClientNotification::has_low_entropy_key() const {
  return _internal_has_low_entropy_key();
}
inline void ClientNotification::set_has_low_entropy_key() {
  _impl_._oneof_case_[0] = kLowEntropyKey;
}
inline void ClientNotification::clear_low_entropy_key() {
  if (_internal_has_low_entropy_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.low_entropy_key_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::LowEntropyKey* ClientNotification::release_low_entropy_key() {
  // @@protoc_insertion_point(field_release:meshtastic.ClientNotification.low_entropy_key)
  if (_internal_has_low_entropy_key()) {
    clear_has_payload_variant();
    ::meshtastic::LowEntropyKey* temp = _impl_.payload_variant_.low_entropy_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.low_entropy_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::LowEntropyKey& ClientNotification::_internal_low_entropy_key() const {
  return _internal_has_low_entropy_key()
      ? *_impl_.payload_variant_.low_entropy_key_
      : reinterpret_cast< ::meshtastic::LowEntropyKey&>(::meshtastic::_LowEntropyKey_default_instance_);
}
inline const ::meshtastic::LowEntropyKey& ClientNotification::low_entropy_key() const {
  // @@protoc_insertion_point(field_get:meshtastic.ClientNotification.low_entropy_key)
  return _internal_low_entropy_key();
}
inline ::meshtastic::LowEntropyKey* ClientNotification::unsafe_arena_release_low_entropy_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ClientNotification.low_entropy_key)
  if (_internal_has_low_entropy_key()) {
    clear_has_payload_variant();
    ::meshtastic::LowEntropyKey* temp = _impl_.payload_variant_.low_entropy_key_;
    _impl_.payload_variant_.low_entropy_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientNotification::unsafe_arena_set_allocated_low_entropy_key(::meshtastic::LowEntropyKey* low_entropy_key) {
  clear_payload_variant();
  if (low_entropy_key) {
    set_has_low_entropy_key();
    _impl_.payload_variant_.low_entropy_key_ = low_entropy_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ClientNotification.low_entropy_key)
}
inline ::meshtastic::LowEntropyKey* ClientNotification::_internal_mutable_low_entropy_key() {
  if (!_internal_has_low_entropy_key()) {
    clear_payload_variant();
    set_has_low_entropy_key();
    _impl_.payload_variant_.low_entropy_key_ = CreateMaybeMessage< ::meshtastic::LowEntropyKey >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.low_entropy_key_;
}
inline ::meshtastic::LowEntropyKey* ClientNotification::mutable_low_entropy_key() {
  ::meshtastic::LowEntropyKey* _msg = _internal_mutable_low_entropy_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.ClientNotification.low_entropy_key)
  return _msg;
}

inline bool ClientNotification::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void ClientNotification::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline ClientNotification::PayloadVariantCase ClientNotification::payload_variant_case() const {
  return ClientNotification::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// KeyVerificationNumberInform

// uint64 nonce = 1;
inline void KeyVerificationNumberInform::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t KeyVerificationNumberInform::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t KeyVerificationNumberInform::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationNumberInform.nonce)
  return _internal_nonce();
}
inline void KeyVerificationNumberInform::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void KeyVerificationNumberInform::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationNumberInform.nonce)
}

// string remote_longname = 2;
inline void KeyVerificationNumberInform::clear_remote_longname() {
  _impl_.remote_longname_.ClearToEmpty();
}
inline const std::string& KeyVerificationNumberInform::remote_longname() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationNumberInform.remote_longname)
  return _internal_remote_longname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyVerificationNumberInform::set_remote_longname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remote_longname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationNumberInform.remote_longname)
}
inline std::string* KeyVerificationNumberInform::mutable_remote_longname() {
  std::string* _s = _internal_mutable_remote_longname();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerificationNumberInform.remote_longname)
  return _s;
}
inline const std::string& KeyVerificationNumberInform::_internal_remote_longname() const {
  return _impl_.remote_longname_.Get();
}
inline void KeyVerificationNumberInform::_internal_set_remote_longname(const std::string& value) {
  
  _impl_.remote_longname_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyVerificationNumberInform::_internal_mutable_remote_longname() {
  
  return _impl_.remote_longname_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyVerificationNumberInform::release_remote_longname() {
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerificationNumberInform.remote_longname)
  return _impl_.remote_longname_.Release();
}
inline void KeyVerificationNumberInform::set_allocated_remote_longname(std::string* remote_longname) {
  if (remote_longname != nullptr) {
    
  } else {
    
  }
  _impl_.remote_longname_.SetAllocated(remote_longname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_longname_.IsDefault()) {
    _impl_.remote_longname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerificationNumberInform.remote_longname)
}

// uint32 security_number = 3;
inline void KeyVerificationNumberInform::clear_security_number() {
  _impl_.security_number_ = 0u;
}
inline uint32_t KeyVerificationNumberInform::_internal_security_number() const {
  return _impl_.security_number_;
}
inline uint32_t KeyVerificationNumberInform::security_number() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationNumberInform.security_number)
  return _internal_security_number();
}
inline void KeyVerificationNumberInform::_internal_set_security_number(uint32_t value) {
  
  _impl_.security_number_ = value;
}
inline void KeyVerificationNumberInform::set_security_number(uint32_t value) {
  _internal_set_security_number(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationNumberInform.security_number)
}

// -------------------------------------------------------------------

// KeyVerificationNumberRequest

// uint64 nonce = 1;
inline void KeyVerificationNumberRequest::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t KeyVerificationNumberRequest::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t KeyVerificationNumberRequest::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationNumberRequest.nonce)
  return _internal_nonce();
}
inline void KeyVerificationNumberRequest::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void KeyVerificationNumberRequest::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationNumberRequest.nonce)
}

// string remote_longname = 2;
inline void KeyVerificationNumberRequest::clear_remote_longname() {
  _impl_.remote_longname_.ClearToEmpty();
}
inline const std::string& KeyVerificationNumberRequest::remote_longname() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationNumberRequest.remote_longname)
  return _internal_remote_longname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyVerificationNumberRequest::set_remote_longname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remote_longname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationNumberRequest.remote_longname)
}
inline std::string* KeyVerificationNumberRequest::mutable_remote_longname() {
  std::string* _s = _internal_mutable_remote_longname();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerificationNumberRequest.remote_longname)
  return _s;
}
inline const std::string& KeyVerificationNumberRequest::_internal_remote_longname() const {
  return _impl_.remote_longname_.Get();
}
inline void KeyVerificationNumberRequest::_internal_set_remote_longname(const std::string& value) {
  
  _impl_.remote_longname_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyVerificationNumberRequest::_internal_mutable_remote_longname() {
  
  return _impl_.remote_longname_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyVerificationNumberRequest::release_remote_longname() {
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerificationNumberRequest.remote_longname)
  return _impl_.remote_longname_.Release();
}
inline void KeyVerificationNumberRequest::set_allocated_remote_longname(std::string* remote_longname) {
  if (remote_longname != nullptr) {
    
  } else {
    
  }
  _impl_.remote_longname_.SetAllocated(remote_longname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_longname_.IsDefault()) {
    _impl_.remote_longname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerificationNumberRequest.remote_longname)
}

// -------------------------------------------------------------------

// KeyVerificationFinal

// uint64 nonce = 1;
inline void KeyVerificationFinal::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t KeyVerificationFinal::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t KeyVerificationFinal::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationFinal.nonce)
  return _internal_nonce();
}
inline void KeyVerificationFinal::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void KeyVerificationFinal::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationFinal.nonce)
}

// string remote_longname = 2;
inline void KeyVerificationFinal::clear_remote_longname() {
  _impl_.remote_longname_.ClearToEmpty();
}
inline const std::string& KeyVerificationFinal::remote_longname() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationFinal.remote_longname)
  return _internal_remote_longname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyVerificationFinal::set_remote_longname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remote_longname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationFinal.remote_longname)
}
inline std::string* KeyVerificationFinal::mutable_remote_longname() {
  std::string* _s = _internal_mutable_remote_longname();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerificationFinal.remote_longname)
  return _s;
}
inline const std::string& KeyVerificationFinal::_internal_remote_longname() const {
  return _impl_.remote_longname_.Get();
}
inline void KeyVerificationFinal::_internal_set_remote_longname(const std::string& value) {
  
  _impl_.remote_longname_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyVerificationFinal::_internal_mutable_remote_longname() {
  
  return _impl_.remote_longname_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyVerificationFinal::release_remote_longname() {
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerificationFinal.remote_longname)
  return _impl_.remote_longname_.Release();
}
inline void KeyVerificationFinal::set_allocated_remote_longname(std::string* remote_longname) {
  if (remote_longname != nullptr) {
    
  } else {
    
  }
  _impl_.remote_longname_.SetAllocated(remote_longname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_longname_.IsDefault()) {
    _impl_.remote_longname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerificationFinal.remote_longname)
}

// bool isSender = 3;
inline void KeyVerificationFinal::clear_issender() {
  _impl_.issender_ = false;
}
inline bool KeyVerificationFinal::_internal_issender() const {
  return _impl_.issender_;
}
inline bool KeyVerificationFinal::issender() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationFinal.isSender)
  return _internal_issender();
}
inline void KeyVerificationFinal::_internal_set_issender(bool value) {
  
  _impl_.issender_ = value;
}
inline void KeyVerificationFinal::set_issender(bool value) {
  _internal_set_issender(value);
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationFinal.isSender)
}

// string verification_characters = 4;
inline void KeyVerificationFinal::clear_verification_characters() {
  _impl_.verification_characters_.ClearToEmpty();
}
inline const std::string& KeyVerificationFinal::verification_characters() const {
  // @@protoc_insertion_point(field_get:meshtastic.KeyVerificationFinal.verification_characters)
  return _internal_verification_characters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyVerificationFinal::set_verification_characters(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verification_characters_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.KeyVerificationFinal.verification_characters)
}
inline std::string* KeyVerificationFinal::mutable_verification_characters() {
  std::string* _s = _internal_mutable_verification_characters();
  // @@protoc_insertion_point(field_mutable:meshtastic.KeyVerificationFinal.verification_characters)
  return _s;
}
inline const std::string& KeyVerificationFinal::_internal_verification_characters() const {
  return _impl_.verification_characters_.Get();
}
inline void KeyVerificationFinal::_internal_set_verification_characters(const std::string& value) {
  
  _impl_.verification_characters_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyVerificationFinal::_internal_mutable_verification_characters() {
  
  return _impl_.verification_characters_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyVerificationFinal::release_verification_characters() {
  // @@protoc_insertion_point(field_release:meshtastic.KeyVerificationFinal.verification_characters)
  return _impl_.verification_characters_.Release();
}
inline void KeyVerificationFinal::set_allocated_verification_characters(std::string* verification_characters) {
  if (verification_characters != nullptr) {
    
  } else {
    
  }
  _impl_.verification_characters_.SetAllocated(verification_characters, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verification_characters_.IsDefault()) {
    _impl_.verification_characters_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.KeyVerificationFinal.verification_characters)
}

// -------------------------------------------------------------------

// DuplicatedPublicKey

// -------------------------------------------------------------------

// LowEntropyKey

// -------------------------------------------------------------------

// FileInfo

// string file_name = 1;
inline void FileInfo::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& FileInfo::file_name() const {
  // @@protoc_insertion_point(field_get:meshtastic.FileInfo.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.FileInfo.file_name)
}
inline std::string* FileInfo::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.FileInfo.file_name)
  return _s;
}
inline const std::string& FileInfo::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void FileInfo::_internal_set_file_name(const std::string& value) {
  
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_file_name() {
  
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FileInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:meshtastic.FileInfo.file_name)
  return _impl_.file_name_.Release();
}
inline void FileInfo::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FileInfo.file_name)
}

// uint32 size_bytes = 2;
inline void FileInfo::clear_size_bytes() {
  _impl_.size_bytes_ = 0u;
}
inline uint32_t FileInfo::_internal_size_bytes() const {
  return _impl_.size_bytes_;
}
inline uint32_t FileInfo::size_bytes() const {
  // @@protoc_insertion_point(field_get:meshtastic.FileInfo.size_bytes)
  return _internal_size_bytes();
}
inline void FileInfo::_internal_set_size_bytes(uint32_t value) {
  
  _impl_.size_bytes_ = value;
}
inline void FileInfo::set_size_bytes(uint32_t value) {
  _internal_set_size_bytes(value);
  // @@protoc_insertion_point(field_set:meshtastic.FileInfo.size_bytes)
}

// -------------------------------------------------------------------

// ToRadio

// .meshtastic.MeshPacket packet = 1;
inline bool ToRadio::_internal_has_packet() const {
  return payload_variant_case() == kPacket;
}
inline bool ToRadio::has_packet() const {
  return _internal_has_packet();
}
inline void ToRadio::set_has_packet() {
  _impl_._oneof_case_[0] = kPacket;
}
inline void ToRadio::clear_packet() {
  if (_internal_has_packet()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.packet_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::MeshPacket* ToRadio::release_packet() {
  // @@protoc_insertion_point(field_release:meshtastic.ToRadio.packet)
  if (_internal_has_packet()) {
    clear_has_payload_variant();
    ::meshtastic::MeshPacket* temp = _impl_.payload_variant_.packet_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::MeshPacket& ToRadio::_internal_packet() const {
  return _internal_has_packet()
      ? *_impl_.payload_variant_.packet_
      : reinterpret_cast< ::meshtastic::MeshPacket&>(::meshtastic::_MeshPacket_default_instance_);
}
inline const ::meshtastic::MeshPacket& ToRadio::packet() const {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.packet)
  return _internal_packet();
}
inline ::meshtastic::MeshPacket* ToRadio::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ToRadio.packet)
  if (_internal_has_packet()) {
    clear_has_payload_variant();
    ::meshtastic::MeshPacket* temp = _impl_.payload_variant_.packet_;
    _impl_.payload_variant_.packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToRadio::unsafe_arena_set_allocated_packet(::meshtastic::MeshPacket* packet) {
  clear_payload_variant();
  if (packet) {
    set_has_packet();
    _impl_.payload_variant_.packet_ = packet;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ToRadio.packet)
}
inline ::meshtastic::MeshPacket* ToRadio::_internal_mutable_packet() {
  if (!_internal_has_packet()) {
    clear_payload_variant();
    set_has_packet();
    _impl_.payload_variant_.packet_ = CreateMaybeMessage< ::meshtastic::MeshPacket >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.packet_;
}
inline ::meshtastic::MeshPacket* ToRadio::mutable_packet() {
  ::meshtastic::MeshPacket* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:meshtastic.ToRadio.packet)
  return _msg;
}

// uint32 want_config_id = 3;
inline bool ToRadio::_internal_has_want_config_id() const {
  return payload_variant_case() == kWantConfigId;
}
inline bool ToRadio::has_want_config_id() const {
  return _internal_has_want_config_id();
}
inline void ToRadio::set_has_want_config_id() {
  _impl_._oneof_case_[0] = kWantConfigId;
}
inline void ToRadio::clear_want_config_id() {
  if (_internal_has_want_config_id()) {
    _impl_.payload_variant_.want_config_id_ = 0u;
    clear_has_payload_variant();
  }
}
inline uint32_t ToRadio::_internal_want_config_id() const {
  if (_internal_has_want_config_id()) {
    return _impl_.payload_variant_.want_config_id_;
  }
  return 0u;
}
inline void ToRadio::_internal_set_want_config_id(uint32_t value) {
  if (!_internal_has_want_config_id()) {
    clear_payload_variant();
    set_has_want_config_id();
  }
  _impl_.payload_variant_.want_config_id_ = value;
}
inline uint32_t ToRadio::want_config_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.want_config_id)
  return _internal_want_config_id();
}
inline void ToRadio::set_want_config_id(uint32_t value) {
  _internal_set_want_config_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.ToRadio.want_config_id)
}

// bool disconnect = 4;
inline bool ToRadio::_internal_has_disconnect() const {
  return payload_variant_case() == kDisconnect;
}
inline bool ToRadio::has_disconnect() const {
  return _internal_has_disconnect();
}
inline void ToRadio::set_has_disconnect() {
  _impl_._oneof_case_[0] = kDisconnect;
}
inline void ToRadio::clear_disconnect() {
  if (_internal_has_disconnect()) {
    _impl_.payload_variant_.disconnect_ = false;
    clear_has_payload_variant();
  }
}
inline bool ToRadio::_internal_disconnect() const {
  if (_internal_has_disconnect()) {
    return _impl_.payload_variant_.disconnect_;
  }
  return false;
}
inline void ToRadio::_internal_set_disconnect(bool value) {
  if (!_internal_has_disconnect()) {
    clear_payload_variant();
    set_has_disconnect();
  }
  _impl_.payload_variant_.disconnect_ = value;
}
inline bool ToRadio::disconnect() const {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.disconnect)
  return _internal_disconnect();
}
inline void ToRadio::set_disconnect(bool value) {
  _internal_set_disconnect(value);
  // @@protoc_insertion_point(field_set:meshtastic.ToRadio.disconnect)
}

// .meshtastic.XModem xmodemPacket = 5;
inline bool ToRadio::_internal_has_xmodempacket() const {
  return payload_variant_case() == kXmodemPacket;
}
inline bool ToRadio::has_xmodempacket() const {
  return _internal_has_xmodempacket();
}
inline void ToRadio::set_has_xmodempacket() {
  _impl_._oneof_case_[0] = kXmodemPacket;
}
inline ::meshtastic::XModem* ToRadio::release_xmodempacket() {
  // @@protoc_insertion_point(field_release:meshtastic.ToRadio.xmodemPacket)
  if (_internal_has_xmodempacket()) {
    clear_has_payload_variant();
    ::meshtastic::XModem* temp = _impl_.payload_variant_.xmodempacket_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.xmodempacket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::XModem& ToRadio::_internal_xmodempacket() const {
  return _internal_has_xmodempacket()
      ? *_impl_.payload_variant_.xmodempacket_
      : reinterpret_cast< ::meshtastic::XModem&>(::meshtastic::_XModem_default_instance_);
}
inline const ::meshtastic::XModem& ToRadio::xmodempacket() const {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.xmodemPacket)
  return _internal_xmodempacket();
}
inline ::meshtastic::XModem* ToRadio::unsafe_arena_release_xmodempacket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ToRadio.xmodemPacket)
  if (_internal_has_xmodempacket()) {
    clear_has_payload_variant();
    ::meshtastic::XModem* temp = _impl_.payload_variant_.xmodempacket_;
    _impl_.payload_variant_.xmodempacket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToRadio::unsafe_arena_set_allocated_xmodempacket(::meshtastic::XModem* xmodempacket) {
  clear_payload_variant();
  if (xmodempacket) {
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ = xmodempacket;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ToRadio.xmodemPacket)
}
inline ::meshtastic::XModem* ToRadio::_internal_mutable_xmodempacket() {
  if (!_internal_has_xmodempacket()) {
    clear_payload_variant();
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ = CreateMaybeMessage< ::meshtastic::XModem >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.xmodempacket_;
}
inline ::meshtastic::XModem* ToRadio::mutable_xmodempacket() {
  ::meshtastic::XModem* _msg = _internal_mutable_xmodempacket();
  // @@protoc_insertion_point(field_mutable:meshtastic.ToRadio.xmodemPacket)
  return _msg;
}

// .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 6;
inline bool ToRadio::_internal_has_mqttclientproxymessage() const {
  return payload_variant_case() == kMqttClientProxyMessage;
}
inline bool ToRadio::has_mqttclientproxymessage() const {
  return _internal_has_mqttclientproxymessage();
}
inline void ToRadio::set_has_mqttclientproxymessage() {
  _impl_._oneof_case_[0] = kMqttClientProxyMessage;
}
inline void ToRadio::clear_mqttclientproxymessage() {
  if (_internal_has_mqttclientproxymessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.mqttclientproxymessage_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::MqttClientProxyMessage* ToRadio::release_mqttclientproxymessage() {
  // @@protoc_insertion_point(field_release:meshtastic.ToRadio.mqttClientProxyMessage)
  if (_internal_has_mqttclientproxymessage()) {
    clear_has_payload_variant();
    ::meshtastic::MqttClientProxyMessage* temp = _impl_.payload_variant_.mqttclientproxymessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.mqttclientproxymessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::MqttClientProxyMessage& ToRadio::_internal_mqttclientproxymessage() const {
  return _internal_has_mqttclientproxymessage()
      ? *_impl_.payload_variant_.mqttclientproxymessage_
      : reinterpret_cast< ::meshtastic::MqttClientProxyMessage&>(::meshtastic::_MqttClientProxyMessage_default_instance_);
}
inline const ::meshtastic::MqttClientProxyMessage& ToRadio::mqttclientproxymessage() const {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.mqttClientProxyMessage)
  return _internal_mqttclientproxymessage();
}
inline ::meshtastic::MqttClientProxyMessage* ToRadio::unsafe_arena_release_mqttclientproxymessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ToRadio.mqttClientProxyMessage)
  if (_internal_has_mqttclientproxymessage()) {
    clear_has_payload_variant();
    ::meshtastic::MqttClientProxyMessage* temp = _impl_.payload_variant_.mqttclientproxymessage_;
    _impl_.payload_variant_.mqttclientproxymessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToRadio::unsafe_arena_set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* mqttclientproxymessage) {
  clear_payload_variant();
  if (mqttclientproxymessage) {
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ = mqttclientproxymessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ToRadio.mqttClientProxyMessage)
}
inline ::meshtastic::MqttClientProxyMessage* ToRadio::_internal_mutable_mqttclientproxymessage() {
  if (!_internal_has_mqttclientproxymessage()) {
    clear_payload_variant();
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ = CreateMaybeMessage< ::meshtastic::MqttClientProxyMessage >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.mqttclientproxymessage_;
}
inline ::meshtastic::MqttClientProxyMessage* ToRadio::mutable_mqttclientproxymessage() {
  ::meshtastic::MqttClientProxyMessage* _msg = _internal_mutable_mqttclientproxymessage();
  // @@protoc_insertion_point(field_mutable:meshtastic.ToRadio.mqttClientProxyMessage)
  return _msg;
}

// .meshtastic.Heartbeat heartbeat = 7;
inline bool ToRadio::_internal_has_heartbeat() const {
  return payload_variant_case() == kHeartbeat;
}
inline bool ToRadio::has_heartbeat() const {
  return _internal_has_heartbeat();
}
inline void ToRadio::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void ToRadio::clear_heartbeat() {
  if (_internal_has_heartbeat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.heartbeat_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Heartbeat* ToRadio::release_heartbeat() {
  // @@protoc_insertion_point(field_release:meshtastic.ToRadio.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_payload_variant();
    ::meshtastic::Heartbeat* temp = _impl_.payload_variant_.heartbeat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Heartbeat& ToRadio::_internal_heartbeat() const {
  return _internal_has_heartbeat()
      ? *_impl_.payload_variant_.heartbeat_
      : reinterpret_cast< ::meshtastic::Heartbeat&>(::meshtastic::_Heartbeat_default_instance_);
}
inline const ::meshtastic::Heartbeat& ToRadio::heartbeat() const {
  // @@protoc_insertion_point(field_get:meshtastic.ToRadio.heartbeat)
  return _internal_heartbeat();
}
inline ::meshtastic::Heartbeat* ToRadio::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ToRadio.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_payload_variant();
    ::meshtastic::Heartbeat* temp = _impl_.payload_variant_.heartbeat_;
    _impl_.payload_variant_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToRadio::unsafe_arena_set_allocated_heartbeat(::meshtastic::Heartbeat* heartbeat) {
  clear_payload_variant();
  if (heartbeat) {
    set_has_heartbeat();
    _impl_.payload_variant_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ToRadio.heartbeat)
}
inline ::meshtastic::Heartbeat* ToRadio::_internal_mutable_heartbeat() {
  if (!_internal_has_heartbeat()) {
    clear_payload_variant();
    set_has_heartbeat();
    _impl_.payload_variant_.heartbeat_ = CreateMaybeMessage< ::meshtastic::Heartbeat >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.heartbeat_;
}
inline ::meshtastic::Heartbeat* ToRadio::mutable_heartbeat() {
  ::meshtastic::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:meshtastic.ToRadio.heartbeat)
  return _msg;
}

inline bool ToRadio::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void ToRadio::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline ToRadio::PayloadVariantCase ToRadio::payload_variant_case() const {
  return ToRadio::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Compressed

// .meshtastic.PortNum portnum = 1;
inline void Compressed::clear_portnum() {
  _impl_.portnum_ = 0;
}
inline ::meshtastic::PortNum Compressed::_internal_portnum() const {
  return static_cast< ::meshtastic::PortNum >(_impl_.portnum_);
}
inline ::meshtastic::PortNum Compressed::portnum() const {
  // @@protoc_insertion_point(field_get:meshtastic.Compressed.portnum)
  return _internal_portnum();
}
inline void Compressed::_internal_set_portnum(::meshtastic::PortNum value) {
  
  _impl_.portnum_ = value;
}
inline void Compressed::set_portnum(::meshtastic::PortNum value) {
  _internal_set_portnum(value);
  // @@protoc_insertion_point(field_set:meshtastic.Compressed.portnum)
}

// bytes data = 2;
inline void Compressed::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Compressed::data() const {
  // @@protoc_insertion_point(field_get:meshtastic.Compressed.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Compressed::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.Compressed.data)
}
inline std::string* Compressed::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:meshtastic.Compressed.data)
  return _s;
}
inline const std::string& Compressed::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Compressed::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Compressed::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Compressed::release_data() {
  // @@protoc_insertion_point(field_release:meshtastic.Compressed.data)
  return _impl_.data_.Release();
}
inline void Compressed::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Compressed.data)
}

// -------------------------------------------------------------------

// NeighborInfo

// uint32 node_id = 1;
inline void NeighborInfo::clear_node_id() {
  _impl_.node_id_ = 0u;
}
inline uint32_t NeighborInfo::_internal_node_id() const {
  return _impl_.node_id_;
}
inline uint32_t NeighborInfo::node_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.NeighborInfo.node_id)
  return _internal_node_id();
}
inline void NeighborInfo::_internal_set_node_id(uint32_t value) {
  
  _impl_.node_id_ = value;
}
inline void NeighborInfo::set_node_id(uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.NeighborInfo.node_id)
}

// uint32 last_sent_by_id = 2;
inline void NeighborInfo::clear_last_sent_by_id() {
  _impl_.last_sent_by_id_ = 0u;
}
inline uint32_t NeighborInfo::_internal_last_sent_by_id() const {
  return _impl_.last_sent_by_id_;
}
inline uint32_t NeighborInfo::last_sent_by_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.NeighborInfo.last_sent_by_id)
  return _internal_last_sent_by_id();
}
inline void NeighborInfo::_internal_set_last_sent_by_id(uint32_t value) {
  
  _impl_.last_sent_by_id_ = value;
}
inline void NeighborInfo::set_last_sent_by_id(uint32_t value) {
  _internal_set_last_sent_by_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.NeighborInfo.last_sent_by_id)
}

// uint32 node_broadcast_interval_secs = 3;
inline void NeighborInfo::clear_node_broadcast_interval_secs() {
  _impl_.node_broadcast_interval_secs_ = 0u;
}
inline uint32_t NeighborInfo::_internal_node_broadcast_interval_secs() const {
  return _impl_.node_broadcast_interval_secs_;
}
inline uint32_t NeighborInfo::node_broadcast_interval_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.NeighborInfo.node_broadcast_interval_secs)
  return _internal_node_broadcast_interval_secs();
}
inline void NeighborInfo::_internal_set_node_broadcast_interval_secs(uint32_t value) {
  
  _impl_.node_broadcast_interval_secs_ = value;
}
inline void NeighborInfo::set_node_broadcast_interval_secs(uint32_t value) {
  _internal_set_node_broadcast_interval_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.NeighborInfo.node_broadcast_interval_secs)
}

// repeated .meshtastic.Neighbor neighbors = 4;
inline int NeighborInfo::_internal_neighbors_size() const {
  return _impl_.neighbors_.size();
}
inline int NeighborInfo::neighbors_size() const {
  return _internal_neighbors_size();
}
inline void NeighborInfo::clear_neighbors() {
  _impl_.neighbors_.Clear();
}
inline ::meshtastic::Neighbor* NeighborInfo::mutable_neighbors(int index) {
  // @@protoc_insertion_point(field_mutable:meshtastic.NeighborInfo.neighbors)
  return _impl_.neighbors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::Neighbor >*
NeighborInfo::mutable_neighbors() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.NeighborInfo.neighbors)
  return &_impl_.neighbors_;
}
inline const ::meshtastic::Neighbor& NeighborInfo::_internal_neighbors(int index) const {
  return _impl_.neighbors_.Get(index);
}
inline const ::meshtastic::Neighbor& NeighborInfo::neighbors(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.NeighborInfo.neighbors)
  return _internal_neighbors(index);
}
inline ::meshtastic::Neighbor* NeighborInfo::_internal_add_neighbors() {
  return _impl_.neighbors_.Add();
}
inline ::meshtastic::Neighbor* NeighborInfo::add_neighbors() {
  ::meshtastic::Neighbor* _add = _internal_add_neighbors();
  // @@protoc_insertion_point(field_add:meshtastic.NeighborInfo.neighbors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::Neighbor >&
NeighborInfo::neighbors() const {
  // @@protoc_insertion_point(field_list:meshtastic.NeighborInfo.neighbors)
  return _impl_.neighbors_;
}

// -------------------------------------------------------------------

// Neighbor

// uint32 node_id = 1;
inline void Neighbor::clear_node_id() {
  _impl_.node_id_ = 0u;
}
inline uint32_t Neighbor::_internal_node_id() const {
  return _impl_.node_id_;
}
inline uint32_t Neighbor::node_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.Neighbor.node_id)
  return _internal_node_id();
}
inline void Neighbor::_internal_set_node_id(uint32_t value) {
  
  _impl_.node_id_ = value;
}
inline void Neighbor::set_node_id(uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.Neighbor.node_id)
}

// float snr = 2;
inline void Neighbor::clear_snr() {
  _impl_.snr_ = 0;
}
inline float Neighbor::_internal_snr() const {
  return _impl_.snr_;
}
inline float Neighbor::snr() const {
  // @@protoc_insertion_point(field_get:meshtastic.Neighbor.snr)
  return _internal_snr();
}
inline void Neighbor::_internal_set_snr(float value) {
  
  _impl_.snr_ = value;
}
inline void Neighbor::set_snr(float value) {
  _internal_set_snr(value);
  // @@protoc_insertion_point(field_set:meshtastic.Neighbor.snr)
}

// fixed32 last_rx_time = 3;
inline void Neighbor::clear_last_rx_time() {
  _impl_.last_rx_time_ = 0u;
}
inline uint32_t Neighbor::_internal_last_rx_time() const {
  return _impl_.last_rx_time_;
}
inline uint32_t Neighbor::last_rx_time() const {
  // @@protoc_insertion_point(field_get:meshtastic.Neighbor.last_rx_time)
  return _internal_last_rx_time();
}
inline void Neighbor::_internal_set_last_rx_time(uint32_t value) {
  
  _impl_.last_rx_time_ = value;
}
inline void Neighbor::set_last_rx_time(uint32_t value) {
  _internal_set_last_rx_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.Neighbor.last_rx_time)
}

// uint32 node_broadcast_interval_secs = 4;
inline void Neighbor::clear_node_broadcast_interval_secs() {
  _impl_.node_broadcast_interval_secs_ = 0u;
}
inline uint32_t Neighbor::_internal_node_broadcast_interval_secs() const {
  return _impl_.node_broadcast_interval_secs_;
}
inline uint32_t Neighbor::node_broadcast_interval_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Neighbor.node_broadcast_interval_secs)
  return _internal_node_broadcast_interval_secs();
}
inline void Neighbor::_internal_set_node_broadcast_interval_secs(uint32_t value) {
  
  _impl_.node_broadcast_interval_secs_ = value;
}
inline void Neighbor::set_node_broadcast_interval_secs(uint32_t value) {
  _internal_set_node_broadcast_interval_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Neighbor.node_broadcast_interval_secs)
}

// -------------------------------------------------------------------

// DeviceMetadata

// string firmware_version = 1;
inline void DeviceMetadata::clear_firmware_version() {
  _impl_.firmware_version_.ClearToEmpty();
}
inline const std::string& DeviceMetadata::firmware_version() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.firmware_version)
  return _internal_firmware_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMetadata::set_firmware_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.firmware_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.firmware_version)
}
inline std::string* DeviceMetadata::mutable_firmware_version() {
  std::string* _s = _internal_mutable_firmware_version();
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceMetadata.firmware_version)
  return _s;
}
inline const std::string& DeviceMetadata::_internal_firmware_version() const {
  return _impl_.firmware_version_.Get();
}
inline void DeviceMetadata::_internal_set_firmware_version(const std::string& value) {
  
  _impl_.firmware_version_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMetadata::_internal_mutable_firmware_version() {
  
  return _impl_.firmware_version_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMetadata::release_firmware_version() {
  // @@protoc_insertion_point(field_release:meshtastic.DeviceMetadata.firmware_version)
  return _impl_.firmware_version_.Release();
}
inline void DeviceMetadata::set_allocated_firmware_version(std::string* firmware_version) {
  if (firmware_version != nullptr) {
    
  } else {
    
  }
  _impl_.firmware_version_.SetAllocated(firmware_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firmware_version_.IsDefault()) {
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.DeviceMetadata.firmware_version)
}

// uint32 device_state_version = 2;
inline void DeviceMetadata::clear_device_state_version() {
  _impl_.device_state_version_ = 0u;
}
inline uint32_t DeviceMetadata::_internal_device_state_version() const {
  return _impl_.device_state_version_;
}
inline uint32_t DeviceMetadata::device_state_version() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.device_state_version)
  return _internal_device_state_version();
}
inline void DeviceMetadata::_internal_set_device_state_version(uint32_t value) {
  
  _impl_.device_state_version_ = value;
}
inline void DeviceMetadata::set_device_state_version(uint32_t value) {
  _internal_set_device_state_version(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.device_state_version)
}

// bool canShutdown = 3;
inline void DeviceMetadata::clear_canshutdown() {
  _impl_.canshutdown_ = false;
}
inline bool DeviceMetadata::_internal_canshutdown() const {
  return _impl_.canshutdown_;
}
inline bool DeviceMetadata::canshutdown() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.canShutdown)
  return _internal_canshutdown();
}
inline void DeviceMetadata::_internal_set_canshutdown(bool value) {
  
  _impl_.canshutdown_ = value;
}
inline void DeviceMetadata::set_canshutdown(bool value) {
  _internal_set_canshutdown(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.canShutdown)
}

// bool hasWifi = 4;
inline void DeviceMetadata::clear_haswifi() {
  _impl_.haswifi_ = false;
}
inline bool DeviceMetadata::_internal_haswifi() const {
  return _impl_.haswifi_;
}
inline bool DeviceMetadata::haswifi() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hasWifi)
  return _internal_haswifi();
}
inline void DeviceMetadata::_internal_set_haswifi(bool value) {
  
  _impl_.haswifi_ = value;
}
inline void DeviceMetadata::set_haswifi(bool value) {
  _internal_set_haswifi(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hasWifi)
}

// bool hasBluetooth = 5;
inline void DeviceMetadata::clear_hasbluetooth() {
  _impl_.hasbluetooth_ = false;
}
inline bool DeviceMetadata::_internal_hasbluetooth() const {
  return _impl_.hasbluetooth_;
}
inline bool DeviceMetadata::hasbluetooth() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hasBluetooth)
  return _internal_hasbluetooth();
}
inline void DeviceMetadata::_internal_set_hasbluetooth(bool value) {
  
  _impl_.hasbluetooth_ = value;
}
inline void DeviceMetadata::set_hasbluetooth(bool value) {
  _internal_set_hasbluetooth(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hasBluetooth)
}

// bool hasEthernet = 6;
inline void DeviceMetadata::clear_hasethernet() {
  _impl_.hasethernet_ = false;
}
inline bool DeviceMetadata::_internal_hasethernet() const {
  return _impl_.hasethernet_;
}
inline bool DeviceMetadata::hasethernet() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hasEthernet)
  return _internal_hasethernet();
}
inline void DeviceMetadata::_internal_set_hasethernet(bool value) {
  
  _impl_.hasethernet_ = value;
}
inline void DeviceMetadata::set_hasethernet(bool value) {
  _internal_set_hasethernet(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hasEthernet)
}

// .meshtastic.Config.DeviceConfig.Role role = 7;
inline void DeviceMetadata::clear_role() {
  _impl_.role_ = 0;
}
inline ::meshtastic::Config_DeviceConfig_Role DeviceMetadata::_internal_role() const {
  return static_cast< ::meshtastic::Config_DeviceConfig_Role >(_impl_.role_);
}
inline ::meshtastic::Config_DeviceConfig_Role DeviceMetadata::role() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.role)
  return _internal_role();
}
inline void DeviceMetadata::_internal_set_role(::meshtastic::Config_DeviceConfig_Role value) {
  
  _impl_.role_ = value;
}
inline void DeviceMetadata::set_role(::meshtastic::Config_DeviceConfig_Role value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.role)
}

// uint32 position_flags = 8;
inline void DeviceMetadata::clear_position_flags() {
  _impl_.position_flags_ = 0u;
}
inline uint32_t DeviceMetadata::_internal_position_flags() const {
  return _impl_.position_flags_;
}
inline uint32_t DeviceMetadata::position_flags() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.position_flags)
  return _internal_position_flags();
}
inline void DeviceMetadata::_internal_set_position_flags(uint32_t value) {
  
  _impl_.position_flags_ = value;
}
inline void DeviceMetadata::set_position_flags(uint32_t value) {
  _internal_set_position_flags(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.position_flags)
}

// .meshtastic.HardwareModel hw_model = 9;
inline void DeviceMetadata::clear_hw_model() {
  _impl_.hw_model_ = 0;
}
inline ::meshtastic::HardwareModel DeviceMetadata::_internal_hw_model() const {
  return static_cast< ::meshtastic::HardwareModel >(_impl_.hw_model_);
}
inline ::meshtastic::HardwareModel DeviceMetadata::hw_model() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hw_model)
  return _internal_hw_model();
}
inline void DeviceMetadata::_internal_set_hw_model(::meshtastic::HardwareModel value) {
  
  _impl_.hw_model_ = value;
}
inline void DeviceMetadata::set_hw_model(::meshtastic::HardwareModel value) {
  _internal_set_hw_model(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hw_model)
}

// bool hasRemoteHardware = 10;
inline void DeviceMetadata::clear_hasremotehardware() {
  _impl_.hasremotehardware_ = false;
}
inline bool DeviceMetadata::_internal_hasremotehardware() const {
  return _impl_.hasremotehardware_;
}
inline bool DeviceMetadata::hasremotehardware() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hasRemoteHardware)
  return _internal_hasremotehardware();
}
inline void DeviceMetadata::_internal_set_hasremotehardware(bool value) {
  
  _impl_.hasremotehardware_ = value;
}
inline void DeviceMetadata::set_hasremotehardware(bool value) {
  _internal_set_hasremotehardware(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hasRemoteHardware)
}

// bool hasPKC = 11;
inline void DeviceMetadata::clear_haspkc() {
  _impl_.haspkc_ = false;
}
inline bool DeviceMetadata::_internal_haspkc() const {
  return _impl_.haspkc_;
}
inline bool DeviceMetadata::haspkc() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.hasPKC)
  return _internal_haspkc();
}
inline void DeviceMetadata::_internal_set_haspkc(bool value) {
  
  _impl_.haspkc_ = value;
}
inline void DeviceMetadata::set_haspkc(bool value) {
  _internal_set_haspkc(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.hasPKC)
}

// uint32 excluded_modules = 12;
inline void DeviceMetadata::clear_excluded_modules() {
  _impl_.excluded_modules_ = 0u;
}
inline uint32_t DeviceMetadata::_internal_excluded_modules() const {
  return _impl_.excluded_modules_;
}
inline uint32_t DeviceMetadata::excluded_modules() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceMetadata.excluded_modules)
  return _internal_excluded_modules();
}
inline void DeviceMetadata::_internal_set_excluded_modules(uint32_t value) {
  
  _impl_.excluded_modules_ = value;
}
inline void DeviceMetadata::set_excluded_modules(uint32_t value) {
  _internal_set_excluded_modules(value);
  // @@protoc_insertion_point(field_set:meshtastic.DeviceMetadata.excluded_modules)
}

// -------------------------------------------------------------------

// Heartbeat

// uint32 nonce = 1;
inline void Heartbeat::clear_nonce() {
  _impl_.nonce_ = 0u;
}
inline uint32_t Heartbeat::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint32_t Heartbeat::nonce() const {
  // @@protoc_insertion_point(field_get:meshtastic.Heartbeat.nonce)
  return _internal_nonce();
}
inline void Heartbeat::_internal_set_nonce(uint32_t value) {
  
  _impl_.nonce_ = value;
}
inline void Heartbeat::set_nonce(uint32_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:meshtastic.Heartbeat.nonce)
}

// -------------------------------------------------------------------

// NodeRemoteHardwarePin

// uint32 node_num = 1;
inline void NodeRemoteHardwarePin::clear_node_num() {
  _impl_.node_num_ = 0u;
}
inline uint32_t NodeRemoteHardwarePin::_internal_node_num() const {
  return _impl_.node_num_;
}
inline uint32_t NodeRemoteHardwarePin::node_num() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeRemoteHardwarePin.node_num)
  return _internal_node_num();
}
inline void NodeRemoteHardwarePin::_internal_set_node_num(uint32_t value) {
  
  _impl_.node_num_ = value;
}
inline void NodeRemoteHardwarePin::set_node_num(uint32_t value) {
  _internal_set_node_num(value);
  // @@protoc_insertion_point(field_set:meshtastic.NodeRemoteHardwarePin.node_num)
}

// .meshtastic.RemoteHardwarePin pin = 2;
inline bool NodeRemoteHardwarePin::_internal_has_pin() const {
  return this != internal_default_instance() && _impl_.pin_ != nullptr;
}
inline bool NodeRemoteHardwarePin::has_pin() const {
  return _internal_has_pin();
}
inline const ::meshtastic::RemoteHardwarePin& NodeRemoteHardwarePin::_internal_pin() const {
  const ::meshtastic::RemoteHardwarePin* p = _impl_.pin_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::RemoteHardwarePin&>(
      ::meshtastic::_RemoteHardwarePin_default_instance_);
}
inline const ::meshtastic::RemoteHardwarePin& NodeRemoteHardwarePin::pin() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeRemoteHardwarePin.pin)
  return _internal_pin();
}
inline void NodeRemoteHardwarePin::unsafe_arena_set_allocated_pin(
    ::meshtastic::RemoteHardwarePin* pin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pin_);
  }
  _impl_.pin_ = pin;
  if (pin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeRemoteHardwarePin.pin)
}
inline ::meshtastic::RemoteHardwarePin* NodeRemoteHardwarePin::release_pin() {
  
  ::meshtastic::RemoteHardwarePin* temp = _impl_.pin_;
  _impl_.pin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::RemoteHardwarePin* NodeRemoteHardwarePin::unsafe_arena_release_pin() {
  // @@protoc_insertion_point(field_release:meshtastic.NodeRemoteHardwarePin.pin)
  
  ::meshtastic::RemoteHardwarePin* temp = _impl_.pin_;
  _impl_.pin_ = nullptr;
  return temp;
}
inline ::meshtastic::RemoteHardwarePin* NodeRemoteHardwarePin::_internal_mutable_pin() {
  
  if (_impl_.pin_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::RemoteHardwarePin>(GetArenaForAllocation());
    _impl_.pin_ = p;
  }
  return _impl_.pin_;
}
inline ::meshtastic::RemoteHardwarePin* NodeRemoteHardwarePin::mutable_pin() {
  ::meshtastic::RemoteHardwarePin* _msg = _internal_mutable_pin();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeRemoteHardwarePin.pin)
  return _msg;
}
inline void NodeRemoteHardwarePin::set_allocated_pin(::meshtastic::RemoteHardwarePin* pin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pin_);
  }
  if (pin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pin));
    if (message_arena != submessage_arena) {
      pin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pin_ = pin;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeRemoteHardwarePin.pin)
}

// -------------------------------------------------------------------

// ChunkedPayload

// uint32 payload_id = 1;
inline void ChunkedPayload::clear_payload_id() {
  _impl_.payload_id_ = 0u;
}
inline uint32_t ChunkedPayload::_internal_payload_id() const {
  return _impl_.payload_id_;
}
inline uint32_t ChunkedPayload::payload_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayload.payload_id)
  return _internal_payload_id();
}
inline void ChunkedPayload::_internal_set_payload_id(uint32_t value) {
  
  _impl_.payload_id_ = value;
}
inline void ChunkedPayload::set_payload_id(uint32_t value) {
  _internal_set_payload_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayload.payload_id)
}

// uint32 chunk_count = 2;
inline void ChunkedPayload::clear_chunk_count() {
  _impl_.chunk_count_ = 0u;
}
inline uint32_t ChunkedPayload::_internal_chunk_count() const {
  return _impl_.chunk_count_;
}
inline uint32_t ChunkedPayload::chunk_count() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayload.chunk_count)
  return _internal_chunk_count();
}
inline void ChunkedPayload::_internal_set_chunk_count(uint32_t value) {
  
  _impl_.chunk_count_ = value;
}
inline void ChunkedPayload::set_chunk_count(uint32_t value) {
  _internal_set_chunk_count(value);
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayload.chunk_count)
}

// uint32 chunk_index = 3;
inline void ChunkedPayload::clear_chunk_index() {
  _impl_.chunk_index_ = 0u;
}
inline uint32_t ChunkedPayload::_internal_chunk_index() const {
  return _impl_.chunk_index_;
}
inline uint32_t ChunkedPayload::chunk_index() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayload.chunk_index)
  return _internal_chunk_index();
}
inline void ChunkedPayload::_internal_set_chunk_index(uint32_t value) {
  
  _impl_.chunk_index_ = value;
}
inline void ChunkedPayload::set_chunk_index(uint32_t value) {
  _internal_set_chunk_index(value);
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayload.chunk_index)
}

// bytes payload_chunk = 4;
inline void ChunkedPayload::clear_payload_chunk() {
  _impl_.payload_chunk_.ClearToEmpty();
}
inline const std::string& ChunkedPayload::payload_chunk() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayload.payload_chunk)
  return _internal_payload_chunk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChunkedPayload::set_payload_chunk(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_chunk_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayload.payload_chunk)
}
inline std::string* ChunkedPayload::mutable_payload_chunk() {
  std::string* _s = _internal_mutable_payload_chunk();
  // @@protoc_insertion_point(field_mutable:meshtastic.ChunkedPayload.payload_chunk)
  return _s;
}
inline const std::string& ChunkedPayload::_internal_payload_chunk() const {
  return _impl_.payload_chunk_.Get();
}
inline void ChunkedPayload::_internal_set_payload_chunk(const std::string& value) {
  
  _impl_.payload_chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* ChunkedPayload::_internal_mutable_payload_chunk() {
  
  return _impl_.payload_chunk_.Mutable(GetArenaForAllocation());
}
inline std::string* ChunkedPayload::release_payload_chunk() {
  // @@protoc_insertion_point(field_release:meshtastic.ChunkedPayload.payload_chunk)
  return _impl_.payload_chunk_.Release();
}
inline void ChunkedPayload::set_allocated_payload_chunk(std::string* payload_chunk) {
  if (payload_chunk != nullptr) {
    
  } else {
    
  }
  _impl_.payload_chunk_.SetAllocated(payload_chunk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_chunk_.IsDefault()) {
    _impl_.payload_chunk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ChunkedPayload.payload_chunk)
}

// -------------------------------------------------------------------

// resend_chunks

// repeated uint32 chunks = 1;
inline int resend_chunks::_internal_chunks_size() const {
  return _impl_.chunks_.size();
}
inline int resend_chunks::chunks_size() const {
  return _internal_chunks_size();
}
inline void resend_chunks::clear_chunks() {
  _impl_.chunks_.Clear();
}
inline uint32_t resend_chunks::_internal_chunks(int index) const {
  return _impl_.chunks_.Get(index);
}
inline uint32_t resend_chunks::chunks(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.resend_chunks.chunks)
  return _internal_chunks(index);
}
inline void resend_chunks::set_chunks(int index, uint32_t value) {
  _impl_.chunks_.Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.resend_chunks.chunks)
}
inline void resend_chunks::_internal_add_chunks(uint32_t value) {
  _impl_.chunks_.Add(value);
}
inline void resend_chunks::add_chunks(uint32_t value) {
  _internal_add_chunks(value);
  // @@protoc_insertion_point(field_add:meshtastic.resend_chunks.chunks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
resend_chunks::_internal_chunks() const {
  return _impl_.chunks_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
resend_chunks::chunks() const {
  // @@protoc_insertion_point(field_list:meshtastic.resend_chunks.chunks)
  return _internal_chunks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
resend_chunks::_internal_mutable_chunks() {
  return &_impl_.chunks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
resend_chunks::mutable_chunks() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.resend_chunks.chunks)
  return _internal_mutable_chunks();
}

// -------------------------------------------------------------------

// ChunkedPayloadResponse

// uint32 payload_id = 1;
inline void ChunkedPayloadResponse::clear_payload_id() {
  _impl_.payload_id_ = 0u;
}
inline uint32_t ChunkedPayloadResponse::_internal_payload_id() const {
  return _impl_.payload_id_;
}
inline uint32_t ChunkedPayloadResponse::payload_id() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayloadResponse.payload_id)
  return _internal_payload_id();
}
inline void ChunkedPayloadResponse::_internal_set_payload_id(uint32_t value) {
  
  _impl_.payload_id_ = value;
}
inline void ChunkedPayloadResponse::set_payload_id(uint32_t value) {
  _internal_set_payload_id(value);
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayloadResponse.payload_id)
}

// bool request_transfer = 2;
inline bool ChunkedPayloadResponse::_internal_has_request_transfer() const {
  return payload_variant_case() == kRequestTransfer;
}
inline bool ChunkedPayloadResponse::has_request_transfer() const {
  return _internal_has_request_transfer();
}
inline void ChunkedPayloadResponse::set_has_request_transfer() {
  _impl_._oneof_case_[0] = kRequestTransfer;
}
inline void ChunkedPayloadResponse::clear_request_transfer() {
  if (_internal_has_request_transfer()) {
    _impl_.payload_variant_.request_transfer_ = false;
    clear_has_payload_variant();
  }
}
inline bool ChunkedPayloadResponse::_internal_request_transfer() const {
  if (_internal_has_request_transfer()) {
    return _impl_.payload_variant_.request_transfer_;
  }
  return false;
}
inline void ChunkedPayloadResponse::_internal_set_request_transfer(bool value) {
  if (!_internal_has_request_transfer()) {
    clear_payload_variant();
    set_has_request_transfer();
  }
  _impl_.payload_variant_.request_transfer_ = value;
}
inline bool ChunkedPayloadResponse::request_transfer() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayloadResponse.request_transfer)
  return _internal_request_transfer();
}
inline void ChunkedPayloadResponse::set_request_transfer(bool value) {
  _internal_set_request_transfer(value);
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayloadResponse.request_transfer)
}

// bool accept_transfer = 3;
inline bool ChunkedPayloadResponse::_internal_has_accept_transfer() const {
  return payload_variant_case() == kAcceptTransfer;
}
inline bool ChunkedPayloadResponse::has_accept_transfer() const {
  return _internal_has_accept_transfer();
}
inline void ChunkedPayloadResponse::set_has_accept_transfer() {
  _impl_._oneof_case_[0] = kAcceptTransfer;
}
inline void ChunkedPayloadResponse::clear_accept_transfer() {
  if (_internal_has_accept_transfer()) {
    _impl_.payload_variant_.accept_transfer_ = false;
    clear_has_payload_variant();
  }
}
inline bool ChunkedPayloadResponse::_internal_accept_transfer() const {
  if (_internal_has_accept_transfer()) {
    return _impl_.payload_variant_.accept_transfer_;
  }
  return false;
}
inline void ChunkedPayloadResponse::_internal_set_accept_transfer(bool value) {
  if (!_internal_has_accept_transfer()) {
    clear_payload_variant();
    set_has_accept_transfer();
  }
  _impl_.payload_variant_.accept_transfer_ = value;
}
inline bool ChunkedPayloadResponse::accept_transfer() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayloadResponse.accept_transfer)
  return _internal_accept_transfer();
}
inline void ChunkedPayloadResponse::set_accept_transfer(bool value) {
  _internal_set_accept_transfer(value);
  // @@protoc_insertion_point(field_set:meshtastic.ChunkedPayloadResponse.accept_transfer)
}

// .meshtastic.resend_chunks resend_chunks = 4;
inline bool ChunkedPayloadResponse::_internal_has_resend_chunks() const {
  return payload_variant_case() == kResendChunks;
}
inline bool ChunkedPayloadResponse::has_resend_chunks() const {
  return _internal_has_resend_chunks();
}
inline void ChunkedPayloadResponse::set_has_resend_chunks() {
  _impl_._oneof_case_[0] = kResendChunks;
}
inline void ChunkedPayloadResponse::clear_resend_chunks() {
  if (_internal_has_resend_chunks()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.resend_chunks_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::resend_chunks* ChunkedPayloadResponse::release_resend_chunks() {
  // @@protoc_insertion_point(field_release:meshtastic.ChunkedPayloadResponse.resend_chunks)
  if (_internal_has_resend_chunks()) {
    clear_has_payload_variant();
    ::meshtastic::resend_chunks* temp = _impl_.payload_variant_.resend_chunks_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.resend_chunks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::resend_chunks& ChunkedPayloadResponse::_internal_resend_chunks() const {
  return _internal_has_resend_chunks()
      ? *_impl_.payload_variant_.resend_chunks_
      : reinterpret_cast< ::meshtastic::resend_chunks&>(::meshtastic::_resend_chunks_default_instance_);
}
inline const ::meshtastic::resend_chunks& ChunkedPayloadResponse::resend_chunks() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChunkedPayloadResponse.resend_chunks)
  return _internal_resend_chunks();
}
inline ::meshtastic::resend_chunks* ChunkedPayloadResponse::unsafe_arena_release_resend_chunks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ChunkedPayloadResponse.resend_chunks)
  if (_internal_has_resend_chunks()) {
    clear_has_payload_variant();
    ::meshtastic::resend_chunks* temp = _impl_.payload_variant_.resend_chunks_;
    _impl_.payload_variant_.resend_chunks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChunkedPayloadResponse::unsafe_arena_set_allocated_resend_chunks(::meshtastic::resend_chunks* resend_chunks) {
  clear_payload_variant();
  if (resend_chunks) {
    set_has_resend_chunks();
    _impl_.payload_variant_.resend_chunks_ = resend_chunks;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ChunkedPayloadResponse.resend_chunks)
}
inline ::meshtastic::resend_chunks* ChunkedPayloadResponse::_internal_mutable_resend_chunks() {
  if (!_internal_has_resend_chunks()) {
    clear_payload_variant();
    set_has_resend_chunks();
    _impl_.payload_variant_.resend_chunks_ = CreateMaybeMessage< ::meshtastic::resend_chunks >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.resend_chunks_;
}
inline ::meshtastic::resend_chunks* ChunkedPayloadResponse::mutable_resend_chunks() {
  ::meshtastic::resend_chunks* _msg = _internal_mutable_resend_chunks();
  // @@protoc_insertion_point(field_mutable:meshtastic.ChunkedPayloadResponse.resend_chunks)
  return _msg;
}

inline bool ChunkedPayloadResponse::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void ChunkedPayloadResponse::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline ChunkedPayloadResponse::PayloadVariantCase ChunkedPayloadResponse::payload_variant_case() const {
  return ChunkedPayloadResponse::PayloadVariantCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meshtastic

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::meshtastic::Position_LocSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Position_LocSource>() {
  return ::meshtastic::Position_LocSource_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Position_AltSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Position_AltSource>() {
  return ::meshtastic::Position_AltSource_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Routing_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Routing_Error>() {
  return ::meshtastic::Routing_Error_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::MeshPacket_Priority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::MeshPacket_Priority>() {
  return ::meshtastic::MeshPacket_Priority_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::MeshPacket_Delayed> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::MeshPacket_Delayed>() {
  return ::meshtastic::MeshPacket_Delayed_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::MeshPacket_TransportMechanism> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::MeshPacket_TransportMechanism>() {
  return ::meshtastic::MeshPacket_TransportMechanism_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::LogRecord_Level> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::LogRecord_Level>() {
  return ::meshtastic::LogRecord_Level_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::HardwareModel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::HardwareModel>() {
  return ::meshtastic::HardwareModel_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Constants> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Constants>() {
  return ::meshtastic::Constants_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::CriticalErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::CriticalErrorCode>() {
  return ::meshtastic::CriticalErrorCode_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::FirmwareEdition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::FirmwareEdition>() {
  return ::meshtastic::FirmwareEdition_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::ExcludedModules> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::ExcludedModules>() {
  return ::meshtastic::ExcludedModules_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fmesh_2eproto
