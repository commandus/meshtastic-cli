// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meshtastic/config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "meshtastic/device_ui.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_meshtastic_2fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_meshtastic_2fconfig_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_meshtastic_2fconfig_2eproto;
namespace meshtastic {
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Config_BluetoothConfig;
struct Config_BluetoothConfigDefaultTypeInternal;
extern Config_BluetoothConfigDefaultTypeInternal _Config_BluetoothConfig_default_instance_;
class Config_DeviceConfig;
struct Config_DeviceConfigDefaultTypeInternal;
extern Config_DeviceConfigDefaultTypeInternal _Config_DeviceConfig_default_instance_;
class Config_DisplayConfig;
struct Config_DisplayConfigDefaultTypeInternal;
extern Config_DisplayConfigDefaultTypeInternal _Config_DisplayConfig_default_instance_;
class Config_LoRaConfig;
struct Config_LoRaConfigDefaultTypeInternal;
extern Config_LoRaConfigDefaultTypeInternal _Config_LoRaConfig_default_instance_;
class Config_NetworkConfig;
struct Config_NetworkConfigDefaultTypeInternal;
extern Config_NetworkConfigDefaultTypeInternal _Config_NetworkConfig_default_instance_;
class Config_NetworkConfig_IpV4Config;
struct Config_NetworkConfig_IpV4ConfigDefaultTypeInternal;
extern Config_NetworkConfig_IpV4ConfigDefaultTypeInternal _Config_NetworkConfig_IpV4Config_default_instance_;
class Config_PositionConfig;
struct Config_PositionConfigDefaultTypeInternal;
extern Config_PositionConfigDefaultTypeInternal _Config_PositionConfig_default_instance_;
class Config_PowerConfig;
struct Config_PowerConfigDefaultTypeInternal;
extern Config_PowerConfigDefaultTypeInternal _Config_PowerConfig_default_instance_;
class Config_SecurityConfig;
struct Config_SecurityConfigDefaultTypeInternal;
extern Config_SecurityConfigDefaultTypeInternal _Config_SecurityConfig_default_instance_;
class Config_SessionkeyConfig;
struct Config_SessionkeyConfigDefaultTypeInternal;
extern Config_SessionkeyConfigDefaultTypeInternal _Config_SessionkeyConfig_default_instance_;
}  // namespace meshtastic
PROTOBUF_NAMESPACE_OPEN
template<> ::meshtastic::Config* Arena::CreateMaybeMessage<::meshtastic::Config>(Arena*);
template<> ::meshtastic::Config_BluetoothConfig* Arena::CreateMaybeMessage<::meshtastic::Config_BluetoothConfig>(Arena*);
template<> ::meshtastic::Config_DeviceConfig* Arena::CreateMaybeMessage<::meshtastic::Config_DeviceConfig>(Arena*);
template<> ::meshtastic::Config_DisplayConfig* Arena::CreateMaybeMessage<::meshtastic::Config_DisplayConfig>(Arena*);
template<> ::meshtastic::Config_LoRaConfig* Arena::CreateMaybeMessage<::meshtastic::Config_LoRaConfig>(Arena*);
template<> ::meshtastic::Config_NetworkConfig* Arena::CreateMaybeMessage<::meshtastic::Config_NetworkConfig>(Arena*);
template<> ::meshtastic::Config_NetworkConfig_IpV4Config* Arena::CreateMaybeMessage<::meshtastic::Config_NetworkConfig_IpV4Config>(Arena*);
template<> ::meshtastic::Config_PositionConfig* Arena::CreateMaybeMessage<::meshtastic::Config_PositionConfig>(Arena*);
template<> ::meshtastic::Config_PowerConfig* Arena::CreateMaybeMessage<::meshtastic::Config_PowerConfig>(Arena*);
template<> ::meshtastic::Config_SecurityConfig* Arena::CreateMaybeMessage<::meshtastic::Config_SecurityConfig>(Arena*);
template<> ::meshtastic::Config_SessionkeyConfig* Arena::CreateMaybeMessage<::meshtastic::Config_SessionkeyConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace meshtastic {

enum Config_DeviceConfig_Role : int {
  Config_DeviceConfig_Role_CLIENT = 0,
  Config_DeviceConfig_Role_CLIENT_MUTE = 1,
  Config_DeviceConfig_Role_ROUTER = 2,
  Config_DeviceConfig_Role_ROUTER_CLIENT PROTOBUF_DEPRECATED_ENUM = 3,
  Config_DeviceConfig_Role_REPEATER = 4,
  Config_DeviceConfig_Role_TRACKER = 5,
  Config_DeviceConfig_Role_SENSOR = 6,
  Config_DeviceConfig_Role_TAK = 7,
  Config_DeviceConfig_Role_CLIENT_HIDDEN = 8,
  Config_DeviceConfig_Role_LOST_AND_FOUND = 9,
  Config_DeviceConfig_Role_TAK_TRACKER = 10,
  Config_DeviceConfig_Role_ROUTER_LATE = 11,
  Config_DeviceConfig_Role_CLIENT_BASE = 12,
  Config_DeviceConfig_Role_Config_DeviceConfig_Role_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_DeviceConfig_Role_Config_DeviceConfig_Role_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_DeviceConfig_Role_IsValid(int value);
constexpr Config_DeviceConfig_Role Config_DeviceConfig_Role_Role_MIN = Config_DeviceConfig_Role_CLIENT;
constexpr Config_DeviceConfig_Role Config_DeviceConfig_Role_Role_MAX = Config_DeviceConfig_Role_CLIENT_BASE;
constexpr int Config_DeviceConfig_Role_Role_ARRAYSIZE = Config_DeviceConfig_Role_Role_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_DeviceConfig_Role_descriptor();
template<typename T>
inline const std::string& Config_DeviceConfig_Role_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_DeviceConfig_Role>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_DeviceConfig_Role_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_DeviceConfig_Role_descriptor(), enum_t_value);
}
inline bool Config_DeviceConfig_Role_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_DeviceConfig_Role* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_DeviceConfig_Role>(
    Config_DeviceConfig_Role_descriptor(), name, value);
}
enum Config_DeviceConfig_RebroadcastMode : int {
  Config_DeviceConfig_RebroadcastMode_ALL = 0,
  Config_DeviceConfig_RebroadcastMode_ALL_SKIP_DECODING = 1,
  Config_DeviceConfig_RebroadcastMode_LOCAL_ONLY = 2,
  Config_DeviceConfig_RebroadcastMode_KNOWN_ONLY = 3,
  Config_DeviceConfig_RebroadcastMode_NONE = 4,
  Config_DeviceConfig_RebroadcastMode_CORE_PORTNUMS_ONLY = 5,
  Config_DeviceConfig_RebroadcastMode_Config_DeviceConfig_RebroadcastMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_DeviceConfig_RebroadcastMode_Config_DeviceConfig_RebroadcastMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_DeviceConfig_RebroadcastMode_IsValid(int value);
constexpr Config_DeviceConfig_RebroadcastMode Config_DeviceConfig_RebroadcastMode_RebroadcastMode_MIN = Config_DeviceConfig_RebroadcastMode_ALL;
constexpr Config_DeviceConfig_RebroadcastMode Config_DeviceConfig_RebroadcastMode_RebroadcastMode_MAX = Config_DeviceConfig_RebroadcastMode_CORE_PORTNUMS_ONLY;
constexpr int Config_DeviceConfig_RebroadcastMode_RebroadcastMode_ARRAYSIZE = Config_DeviceConfig_RebroadcastMode_RebroadcastMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_DeviceConfig_RebroadcastMode_descriptor();
template<typename T>
inline const std::string& Config_DeviceConfig_RebroadcastMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_DeviceConfig_RebroadcastMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_DeviceConfig_RebroadcastMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_DeviceConfig_RebroadcastMode_descriptor(), enum_t_value);
}
inline bool Config_DeviceConfig_RebroadcastMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_DeviceConfig_RebroadcastMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_DeviceConfig_RebroadcastMode>(
    Config_DeviceConfig_RebroadcastMode_descriptor(), name, value);
}
enum Config_DeviceConfig_BuzzerMode : int {
  Config_DeviceConfig_BuzzerMode_ALL_ENABLED = 0,
  Config_DeviceConfig_BuzzerMode_DISABLED = 1,
  Config_DeviceConfig_BuzzerMode_NOTIFICATIONS_ONLY = 2,
  Config_DeviceConfig_BuzzerMode_SYSTEM_ONLY = 3,
  Config_DeviceConfig_BuzzerMode_DIRECT_MSG_ONLY = 4,
  Config_DeviceConfig_BuzzerMode_Config_DeviceConfig_BuzzerMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_DeviceConfig_BuzzerMode_Config_DeviceConfig_BuzzerMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_DeviceConfig_BuzzerMode_IsValid(int value);
constexpr Config_DeviceConfig_BuzzerMode Config_DeviceConfig_BuzzerMode_BuzzerMode_MIN = Config_DeviceConfig_BuzzerMode_ALL_ENABLED;
constexpr Config_DeviceConfig_BuzzerMode Config_DeviceConfig_BuzzerMode_BuzzerMode_MAX = Config_DeviceConfig_BuzzerMode_DIRECT_MSG_ONLY;
constexpr int Config_DeviceConfig_BuzzerMode_BuzzerMode_ARRAYSIZE = Config_DeviceConfig_BuzzerMode_BuzzerMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_DeviceConfig_BuzzerMode_descriptor();
template<typename T>
inline const std::string& Config_DeviceConfig_BuzzerMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_DeviceConfig_BuzzerMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_DeviceConfig_BuzzerMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_DeviceConfig_BuzzerMode_descriptor(), enum_t_value);
}
inline bool Config_DeviceConfig_BuzzerMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_DeviceConfig_BuzzerMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_DeviceConfig_BuzzerMode>(
    Config_DeviceConfig_BuzzerMode_descriptor(), name, value);
}
enum Config_PositionConfig_PositionFlags : int {
  Config_PositionConfig_PositionFlags_UNSET = 0,
  Config_PositionConfig_PositionFlags_ALTITUDE = 1,
  Config_PositionConfig_PositionFlags_ALTITUDE_MSL = 2,
  Config_PositionConfig_PositionFlags_GEOIDAL_SEPARATION = 4,
  Config_PositionConfig_PositionFlags_DOP = 8,
  Config_PositionConfig_PositionFlags_HVDOP = 16,
  Config_PositionConfig_PositionFlags_SATINVIEW = 32,
  Config_PositionConfig_PositionFlags_SEQ_NO = 64,
  Config_PositionConfig_PositionFlags_TIMESTAMP = 128,
  Config_PositionConfig_PositionFlags_HEADING = 256,
  Config_PositionConfig_PositionFlags_SPEED = 512,
  Config_PositionConfig_PositionFlags_Config_PositionConfig_PositionFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_PositionConfig_PositionFlags_Config_PositionConfig_PositionFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_PositionConfig_PositionFlags_IsValid(int value);
constexpr Config_PositionConfig_PositionFlags Config_PositionConfig_PositionFlags_PositionFlags_MIN = Config_PositionConfig_PositionFlags_UNSET;
constexpr Config_PositionConfig_PositionFlags Config_PositionConfig_PositionFlags_PositionFlags_MAX = Config_PositionConfig_PositionFlags_SPEED;
constexpr int Config_PositionConfig_PositionFlags_PositionFlags_ARRAYSIZE = Config_PositionConfig_PositionFlags_PositionFlags_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_PositionConfig_PositionFlags_descriptor();
template<typename T>
inline const std::string& Config_PositionConfig_PositionFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_PositionConfig_PositionFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_PositionConfig_PositionFlags_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_PositionConfig_PositionFlags_descriptor(), enum_t_value);
}
inline bool Config_PositionConfig_PositionFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_PositionConfig_PositionFlags* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_PositionConfig_PositionFlags>(
    Config_PositionConfig_PositionFlags_descriptor(), name, value);
}
enum Config_PositionConfig_GpsMode : int {
  Config_PositionConfig_GpsMode_DISABLED = 0,
  Config_PositionConfig_GpsMode_ENABLED = 1,
  Config_PositionConfig_GpsMode_NOT_PRESENT = 2,
  Config_PositionConfig_GpsMode_Config_PositionConfig_GpsMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_PositionConfig_GpsMode_Config_PositionConfig_GpsMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_PositionConfig_GpsMode_IsValid(int value);
constexpr Config_PositionConfig_GpsMode Config_PositionConfig_GpsMode_GpsMode_MIN = Config_PositionConfig_GpsMode_DISABLED;
constexpr Config_PositionConfig_GpsMode Config_PositionConfig_GpsMode_GpsMode_MAX = Config_PositionConfig_GpsMode_NOT_PRESENT;
constexpr int Config_PositionConfig_GpsMode_GpsMode_ARRAYSIZE = Config_PositionConfig_GpsMode_GpsMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_PositionConfig_GpsMode_descriptor();
template<typename T>
inline const std::string& Config_PositionConfig_GpsMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_PositionConfig_GpsMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_PositionConfig_GpsMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_PositionConfig_GpsMode_descriptor(), enum_t_value);
}
inline bool Config_PositionConfig_GpsMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_PositionConfig_GpsMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_PositionConfig_GpsMode>(
    Config_PositionConfig_GpsMode_descriptor(), name, value);
}
enum Config_NetworkConfig_AddressMode : int {
  Config_NetworkConfig_AddressMode_DHCP = 0,
  Config_NetworkConfig_AddressMode_STATIC = 1,
  Config_NetworkConfig_AddressMode_Config_NetworkConfig_AddressMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_NetworkConfig_AddressMode_Config_NetworkConfig_AddressMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_NetworkConfig_AddressMode_IsValid(int value);
constexpr Config_NetworkConfig_AddressMode Config_NetworkConfig_AddressMode_AddressMode_MIN = Config_NetworkConfig_AddressMode_DHCP;
constexpr Config_NetworkConfig_AddressMode Config_NetworkConfig_AddressMode_AddressMode_MAX = Config_NetworkConfig_AddressMode_STATIC;
constexpr int Config_NetworkConfig_AddressMode_AddressMode_ARRAYSIZE = Config_NetworkConfig_AddressMode_AddressMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_NetworkConfig_AddressMode_descriptor();
template<typename T>
inline const std::string& Config_NetworkConfig_AddressMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_NetworkConfig_AddressMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_NetworkConfig_AddressMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_NetworkConfig_AddressMode_descriptor(), enum_t_value);
}
inline bool Config_NetworkConfig_AddressMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_NetworkConfig_AddressMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_NetworkConfig_AddressMode>(
    Config_NetworkConfig_AddressMode_descriptor(), name, value);
}
enum Config_NetworkConfig_ProtocolFlags : int {
  Config_NetworkConfig_ProtocolFlags_NO_BROADCAST = 0,
  Config_NetworkConfig_ProtocolFlags_UDP_BROADCAST = 1,
  Config_NetworkConfig_ProtocolFlags_Config_NetworkConfig_ProtocolFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_NetworkConfig_ProtocolFlags_Config_NetworkConfig_ProtocolFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_NetworkConfig_ProtocolFlags_IsValid(int value);
constexpr Config_NetworkConfig_ProtocolFlags Config_NetworkConfig_ProtocolFlags_ProtocolFlags_MIN = Config_NetworkConfig_ProtocolFlags_NO_BROADCAST;
constexpr Config_NetworkConfig_ProtocolFlags Config_NetworkConfig_ProtocolFlags_ProtocolFlags_MAX = Config_NetworkConfig_ProtocolFlags_UDP_BROADCAST;
constexpr int Config_NetworkConfig_ProtocolFlags_ProtocolFlags_ARRAYSIZE = Config_NetworkConfig_ProtocolFlags_ProtocolFlags_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_NetworkConfig_ProtocolFlags_descriptor();
template<typename T>
inline const std::string& Config_NetworkConfig_ProtocolFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_NetworkConfig_ProtocolFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_NetworkConfig_ProtocolFlags_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_NetworkConfig_ProtocolFlags_descriptor(), enum_t_value);
}
inline bool Config_NetworkConfig_ProtocolFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_NetworkConfig_ProtocolFlags* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_NetworkConfig_ProtocolFlags>(
    Config_NetworkConfig_ProtocolFlags_descriptor(), name, value);
}
enum Config_DisplayConfig_GpsCoordinateFormat : int {
  Config_DisplayConfig_GpsCoordinateFormat_DEC = 0,
  Config_DisplayConfig_GpsCoordinateFormat_DMS = 1,
  Config_DisplayConfig_GpsCoordinateFormat_UTM = 2,
  Config_DisplayConfig_GpsCoordinateFormat_MGRS = 3,
  Config_DisplayConfig_GpsCoordinateFormat_OLC = 4,
  Config_DisplayConfig_GpsCoordinateFormat_OSGR = 5,
  Config_DisplayConfig_GpsCoordinateFormat_Config_DisplayConfig_GpsCoordinateFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_DisplayConfig_GpsCoordinateFormat_Config_DisplayConfig_GpsCoordinateFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_DisplayConfig_GpsCoordinateFormat_IsValid(int value);
constexpr Config_DisplayConfig_GpsCoordinateFormat Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_MIN = Config_DisplayConfig_GpsCoordinateFormat_DEC;
constexpr Config_DisplayConfig_GpsCoordinateFormat Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_MAX = Config_DisplayConfig_GpsCoordinateFormat_OSGR;
constexpr int Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_ARRAYSIZE = Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_DisplayConfig_GpsCoordinateFormat_descriptor();
template<typename T>
inline const std::string& Config_DisplayConfig_GpsCoordinateFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_DisplayConfig_GpsCoordinateFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_DisplayConfig_GpsCoordinateFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_DisplayConfig_GpsCoordinateFormat_descriptor(), enum_t_value);
}
inline bool Config_DisplayConfig_GpsCoordinateFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_DisplayConfig_GpsCoordinateFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_DisplayConfig_GpsCoordinateFormat>(
    Config_DisplayConfig_GpsCoordinateFormat_descriptor(), name, value);
}
enum Config_DisplayConfig_DisplayUnits : int {
  Config_DisplayConfig_DisplayUnits_METRIC = 0,
  Config_DisplayConfig_DisplayUnits_IMPERIAL = 1,
  Config_DisplayConfig_DisplayUnits_Config_DisplayConfig_DisplayUnits_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_DisplayConfig_DisplayUnits_Config_DisplayConfig_DisplayUnits_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_DisplayConfig_DisplayUnits_IsValid(int value);
constexpr Config_DisplayConfig_DisplayUnits Config_DisplayConfig_DisplayUnits_DisplayUnits_MIN = Config_DisplayConfig_DisplayUnits_METRIC;
constexpr Config_DisplayConfig_DisplayUnits Config_DisplayConfig_DisplayUnits_DisplayUnits_MAX = Config_DisplayConfig_DisplayUnits_IMPERIAL;
constexpr int Config_DisplayConfig_DisplayUnits_DisplayUnits_ARRAYSIZE = Config_DisplayConfig_DisplayUnits_DisplayUnits_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_DisplayConfig_DisplayUnits_descriptor();
template<typename T>
inline const std::string& Config_DisplayConfig_DisplayUnits_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_DisplayConfig_DisplayUnits>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_DisplayConfig_DisplayUnits_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_DisplayConfig_DisplayUnits_descriptor(), enum_t_value);
}
inline bool Config_DisplayConfig_DisplayUnits_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_DisplayConfig_DisplayUnits* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_DisplayConfig_DisplayUnits>(
    Config_DisplayConfig_DisplayUnits_descriptor(), name, value);
}
enum Config_DisplayConfig_OledType : int {
  Config_DisplayConfig_OledType_OLED_AUTO = 0,
  Config_DisplayConfig_OledType_OLED_SSD1306 = 1,
  Config_DisplayConfig_OledType_OLED_SH1106 = 2,
  Config_DisplayConfig_OledType_OLED_SH1107 = 3,
  Config_DisplayConfig_OledType_OLED_SH1107_128_128 = 4,
  Config_DisplayConfig_OledType_Config_DisplayConfig_OledType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_DisplayConfig_OledType_Config_DisplayConfig_OledType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_DisplayConfig_OledType_IsValid(int value);
constexpr Config_DisplayConfig_OledType Config_DisplayConfig_OledType_OledType_MIN = Config_DisplayConfig_OledType_OLED_AUTO;
constexpr Config_DisplayConfig_OledType Config_DisplayConfig_OledType_OledType_MAX = Config_DisplayConfig_OledType_OLED_SH1107_128_128;
constexpr int Config_DisplayConfig_OledType_OledType_ARRAYSIZE = Config_DisplayConfig_OledType_OledType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_DisplayConfig_OledType_descriptor();
template<typename T>
inline const std::string& Config_DisplayConfig_OledType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_DisplayConfig_OledType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_DisplayConfig_OledType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_DisplayConfig_OledType_descriptor(), enum_t_value);
}
inline bool Config_DisplayConfig_OledType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_DisplayConfig_OledType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_DisplayConfig_OledType>(
    Config_DisplayConfig_OledType_descriptor(), name, value);
}
enum Config_DisplayConfig_DisplayMode : int {
  Config_DisplayConfig_DisplayMode_DEFAULT = 0,
  Config_DisplayConfig_DisplayMode_TWOCOLOR = 1,
  Config_DisplayConfig_DisplayMode_INVERTED = 2,
  Config_DisplayConfig_DisplayMode_COLOR = 3,
  Config_DisplayConfig_DisplayMode_Config_DisplayConfig_DisplayMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_DisplayConfig_DisplayMode_Config_DisplayConfig_DisplayMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_DisplayConfig_DisplayMode_IsValid(int value);
constexpr Config_DisplayConfig_DisplayMode Config_DisplayConfig_DisplayMode_DisplayMode_MIN = Config_DisplayConfig_DisplayMode_DEFAULT;
constexpr Config_DisplayConfig_DisplayMode Config_DisplayConfig_DisplayMode_DisplayMode_MAX = Config_DisplayConfig_DisplayMode_COLOR;
constexpr int Config_DisplayConfig_DisplayMode_DisplayMode_ARRAYSIZE = Config_DisplayConfig_DisplayMode_DisplayMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_DisplayConfig_DisplayMode_descriptor();
template<typename T>
inline const std::string& Config_DisplayConfig_DisplayMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_DisplayConfig_DisplayMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_DisplayConfig_DisplayMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_DisplayConfig_DisplayMode_descriptor(), enum_t_value);
}
inline bool Config_DisplayConfig_DisplayMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_DisplayConfig_DisplayMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_DisplayConfig_DisplayMode>(
    Config_DisplayConfig_DisplayMode_descriptor(), name, value);
}
enum Config_DisplayConfig_CompassOrientation : int {
  Config_DisplayConfig_CompassOrientation_DEGREES_0 = 0,
  Config_DisplayConfig_CompassOrientation_DEGREES_90 = 1,
  Config_DisplayConfig_CompassOrientation_DEGREES_180 = 2,
  Config_DisplayConfig_CompassOrientation_DEGREES_270 = 3,
  Config_DisplayConfig_CompassOrientation_DEGREES_0_INVERTED = 4,
  Config_DisplayConfig_CompassOrientation_DEGREES_90_INVERTED = 5,
  Config_DisplayConfig_CompassOrientation_DEGREES_180_INVERTED = 6,
  Config_DisplayConfig_CompassOrientation_DEGREES_270_INVERTED = 7,
  Config_DisplayConfig_CompassOrientation_Config_DisplayConfig_CompassOrientation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_DisplayConfig_CompassOrientation_Config_DisplayConfig_CompassOrientation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_DisplayConfig_CompassOrientation_IsValid(int value);
constexpr Config_DisplayConfig_CompassOrientation Config_DisplayConfig_CompassOrientation_CompassOrientation_MIN = Config_DisplayConfig_CompassOrientation_DEGREES_0;
constexpr Config_DisplayConfig_CompassOrientation Config_DisplayConfig_CompassOrientation_CompassOrientation_MAX = Config_DisplayConfig_CompassOrientation_DEGREES_270_INVERTED;
constexpr int Config_DisplayConfig_CompassOrientation_CompassOrientation_ARRAYSIZE = Config_DisplayConfig_CompassOrientation_CompassOrientation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_DisplayConfig_CompassOrientation_descriptor();
template<typename T>
inline const std::string& Config_DisplayConfig_CompassOrientation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_DisplayConfig_CompassOrientation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_DisplayConfig_CompassOrientation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_DisplayConfig_CompassOrientation_descriptor(), enum_t_value);
}
inline bool Config_DisplayConfig_CompassOrientation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_DisplayConfig_CompassOrientation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_DisplayConfig_CompassOrientation>(
    Config_DisplayConfig_CompassOrientation_descriptor(), name, value);
}
enum Config_LoRaConfig_RegionCode : int {
  Config_LoRaConfig_RegionCode_UNSET = 0,
  Config_LoRaConfig_RegionCode_US = 1,
  Config_LoRaConfig_RegionCode_EU_433 = 2,
  Config_LoRaConfig_RegionCode_EU_868 = 3,
  Config_LoRaConfig_RegionCode_CN = 4,
  Config_LoRaConfig_RegionCode_JP = 5,
  Config_LoRaConfig_RegionCode_ANZ = 6,
  Config_LoRaConfig_RegionCode_KR = 7,
  Config_LoRaConfig_RegionCode_TW = 8,
  Config_LoRaConfig_RegionCode_RU = 9,
  Config_LoRaConfig_RegionCode_IN = 10,
  Config_LoRaConfig_RegionCode_NZ_865 = 11,
  Config_LoRaConfig_RegionCode_TH = 12,
  Config_LoRaConfig_RegionCode_LORA_24 = 13,
  Config_LoRaConfig_RegionCode_UA_433 = 14,
  Config_LoRaConfig_RegionCode_UA_868 = 15,
  Config_LoRaConfig_RegionCode_MY_433 = 16,
  Config_LoRaConfig_RegionCode_MY_919 = 17,
  Config_LoRaConfig_RegionCode_SG_923 = 18,
  Config_LoRaConfig_RegionCode_PH_433 = 19,
  Config_LoRaConfig_RegionCode_PH_868 = 20,
  Config_LoRaConfig_RegionCode_PH_915 = 21,
  Config_LoRaConfig_RegionCode_ANZ_433 = 22,
  Config_LoRaConfig_RegionCode_KZ_433 = 23,
  Config_LoRaConfig_RegionCode_KZ_863 = 24,
  Config_LoRaConfig_RegionCode_NP_865 = 25,
  Config_LoRaConfig_RegionCode_BR_902 = 26,
  Config_LoRaConfig_RegionCode_Config_LoRaConfig_RegionCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_LoRaConfig_RegionCode_Config_LoRaConfig_RegionCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_LoRaConfig_RegionCode_IsValid(int value);
constexpr Config_LoRaConfig_RegionCode Config_LoRaConfig_RegionCode_RegionCode_MIN = Config_LoRaConfig_RegionCode_UNSET;
constexpr Config_LoRaConfig_RegionCode Config_LoRaConfig_RegionCode_RegionCode_MAX = Config_LoRaConfig_RegionCode_BR_902;
constexpr int Config_LoRaConfig_RegionCode_RegionCode_ARRAYSIZE = Config_LoRaConfig_RegionCode_RegionCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_LoRaConfig_RegionCode_descriptor();
template<typename T>
inline const std::string& Config_LoRaConfig_RegionCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_LoRaConfig_RegionCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_LoRaConfig_RegionCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_LoRaConfig_RegionCode_descriptor(), enum_t_value);
}
inline bool Config_LoRaConfig_RegionCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_LoRaConfig_RegionCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_LoRaConfig_RegionCode>(
    Config_LoRaConfig_RegionCode_descriptor(), name, value);
}
enum Config_LoRaConfig_ModemPreset : int {
  Config_LoRaConfig_ModemPreset_LONG_FAST = 0,
  Config_LoRaConfig_ModemPreset_LONG_SLOW = 1,
  Config_LoRaConfig_ModemPreset_VERY_LONG_SLOW PROTOBUF_DEPRECATED_ENUM = 2,
  Config_LoRaConfig_ModemPreset_MEDIUM_SLOW = 3,
  Config_LoRaConfig_ModemPreset_MEDIUM_FAST = 4,
  Config_LoRaConfig_ModemPreset_SHORT_SLOW = 5,
  Config_LoRaConfig_ModemPreset_SHORT_FAST = 6,
  Config_LoRaConfig_ModemPreset_LONG_MODERATE = 7,
  Config_LoRaConfig_ModemPreset_SHORT_TURBO = 8,
  Config_LoRaConfig_ModemPreset_Config_LoRaConfig_ModemPreset_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_LoRaConfig_ModemPreset_Config_LoRaConfig_ModemPreset_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_LoRaConfig_ModemPreset_IsValid(int value);
constexpr Config_LoRaConfig_ModemPreset Config_LoRaConfig_ModemPreset_ModemPreset_MIN = Config_LoRaConfig_ModemPreset_LONG_FAST;
constexpr Config_LoRaConfig_ModemPreset Config_LoRaConfig_ModemPreset_ModemPreset_MAX = Config_LoRaConfig_ModemPreset_SHORT_TURBO;
constexpr int Config_LoRaConfig_ModemPreset_ModemPreset_ARRAYSIZE = Config_LoRaConfig_ModemPreset_ModemPreset_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_LoRaConfig_ModemPreset_descriptor();
template<typename T>
inline const std::string& Config_LoRaConfig_ModemPreset_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_LoRaConfig_ModemPreset>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_LoRaConfig_ModemPreset_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_LoRaConfig_ModemPreset_descriptor(), enum_t_value);
}
inline bool Config_LoRaConfig_ModemPreset_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_LoRaConfig_ModemPreset* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_LoRaConfig_ModemPreset>(
    Config_LoRaConfig_ModemPreset_descriptor(), name, value);
}
enum Config_BluetoothConfig_PairingMode : int {
  Config_BluetoothConfig_PairingMode_RANDOM_PIN = 0,
  Config_BluetoothConfig_PairingMode_FIXED_PIN = 1,
  Config_BluetoothConfig_PairingMode_NO_PIN = 2,
  Config_BluetoothConfig_PairingMode_Config_BluetoothConfig_PairingMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Config_BluetoothConfig_PairingMode_Config_BluetoothConfig_PairingMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Config_BluetoothConfig_PairingMode_IsValid(int value);
constexpr Config_BluetoothConfig_PairingMode Config_BluetoothConfig_PairingMode_PairingMode_MIN = Config_BluetoothConfig_PairingMode_RANDOM_PIN;
constexpr Config_BluetoothConfig_PairingMode Config_BluetoothConfig_PairingMode_PairingMode_MAX = Config_BluetoothConfig_PairingMode_NO_PIN;
constexpr int Config_BluetoothConfig_PairingMode_PairingMode_ARRAYSIZE = Config_BluetoothConfig_PairingMode_PairingMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_BluetoothConfig_PairingMode_descriptor();
template<typename T>
inline const std::string& Config_BluetoothConfig_PairingMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_BluetoothConfig_PairingMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_BluetoothConfig_PairingMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_BluetoothConfig_PairingMode_descriptor(), enum_t_value);
}
inline bool Config_BluetoothConfig_PairingMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_BluetoothConfig_PairingMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_BluetoothConfig_PairingMode>(
    Config_BluetoothConfig_PairingMode_descriptor(), name, value);
}
// ===================================================================

class Config_DeviceConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Config.DeviceConfig) */ {
 public:
  inline Config_DeviceConfig() : Config_DeviceConfig(nullptr) {}
  ~Config_DeviceConfig() override;
  explicit PROTOBUF_CONSTEXPR Config_DeviceConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config_DeviceConfig(const Config_DeviceConfig& from);
  Config_DeviceConfig(Config_DeviceConfig&& from) noexcept
    : Config_DeviceConfig() {
    *this = ::std::move(from);
  }

  inline Config_DeviceConfig& operator=(const Config_DeviceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_DeviceConfig& operator=(Config_DeviceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_DeviceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config_DeviceConfig* internal_default_instance() {
    return reinterpret_cast<const Config_DeviceConfig*>(
               &_Config_DeviceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Config_DeviceConfig& a, Config_DeviceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_DeviceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_DeviceConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_DeviceConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config_DeviceConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config_DeviceConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config_DeviceConfig& from) {
    Config_DeviceConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_DeviceConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Config.DeviceConfig";
  }
  protected:
  explicit Config_DeviceConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Config_DeviceConfig_Role Role;
  static constexpr Role CLIENT =
    Config_DeviceConfig_Role_CLIENT;
  static constexpr Role CLIENT_MUTE =
    Config_DeviceConfig_Role_CLIENT_MUTE;
  static constexpr Role ROUTER =
    Config_DeviceConfig_Role_ROUTER;
  PROTOBUF_DEPRECATED_ENUM static constexpr Role ROUTER_CLIENT =
    Config_DeviceConfig_Role_ROUTER_CLIENT;
  static constexpr Role REPEATER =
    Config_DeviceConfig_Role_REPEATER;
  static constexpr Role TRACKER =
    Config_DeviceConfig_Role_TRACKER;
  static constexpr Role SENSOR =
    Config_DeviceConfig_Role_SENSOR;
  static constexpr Role TAK =
    Config_DeviceConfig_Role_TAK;
  static constexpr Role CLIENT_HIDDEN =
    Config_DeviceConfig_Role_CLIENT_HIDDEN;
  static constexpr Role LOST_AND_FOUND =
    Config_DeviceConfig_Role_LOST_AND_FOUND;
  static constexpr Role TAK_TRACKER =
    Config_DeviceConfig_Role_TAK_TRACKER;
  static constexpr Role ROUTER_LATE =
    Config_DeviceConfig_Role_ROUTER_LATE;
  static constexpr Role CLIENT_BASE =
    Config_DeviceConfig_Role_CLIENT_BASE;
  static inline bool Role_IsValid(int value) {
    return Config_DeviceConfig_Role_IsValid(value);
  }
  static constexpr Role Role_MIN =
    Config_DeviceConfig_Role_Role_MIN;
  static constexpr Role Role_MAX =
    Config_DeviceConfig_Role_Role_MAX;
  static constexpr int Role_ARRAYSIZE =
    Config_DeviceConfig_Role_Role_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Role_descriptor() {
    return Config_DeviceConfig_Role_descriptor();
  }
  template<typename T>
  static inline const std::string& Role_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Role>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Role_Name.");
    return Config_DeviceConfig_Role_Name(enum_t_value);
  }
  static inline bool Role_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Role* value) {
    return Config_DeviceConfig_Role_Parse(name, value);
  }

  typedef Config_DeviceConfig_RebroadcastMode RebroadcastMode;
  static constexpr RebroadcastMode ALL =
    Config_DeviceConfig_RebroadcastMode_ALL;
  static constexpr RebroadcastMode ALL_SKIP_DECODING =
    Config_DeviceConfig_RebroadcastMode_ALL_SKIP_DECODING;
  static constexpr RebroadcastMode LOCAL_ONLY =
    Config_DeviceConfig_RebroadcastMode_LOCAL_ONLY;
  static constexpr RebroadcastMode KNOWN_ONLY =
    Config_DeviceConfig_RebroadcastMode_KNOWN_ONLY;
  static constexpr RebroadcastMode NONE =
    Config_DeviceConfig_RebroadcastMode_NONE;
  static constexpr RebroadcastMode CORE_PORTNUMS_ONLY =
    Config_DeviceConfig_RebroadcastMode_CORE_PORTNUMS_ONLY;
  static inline bool RebroadcastMode_IsValid(int value) {
    return Config_DeviceConfig_RebroadcastMode_IsValid(value);
  }
  static constexpr RebroadcastMode RebroadcastMode_MIN =
    Config_DeviceConfig_RebroadcastMode_RebroadcastMode_MIN;
  static constexpr RebroadcastMode RebroadcastMode_MAX =
    Config_DeviceConfig_RebroadcastMode_RebroadcastMode_MAX;
  static constexpr int RebroadcastMode_ARRAYSIZE =
    Config_DeviceConfig_RebroadcastMode_RebroadcastMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RebroadcastMode_descriptor() {
    return Config_DeviceConfig_RebroadcastMode_descriptor();
  }
  template<typename T>
  static inline const std::string& RebroadcastMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RebroadcastMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RebroadcastMode_Name.");
    return Config_DeviceConfig_RebroadcastMode_Name(enum_t_value);
  }
  static inline bool RebroadcastMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RebroadcastMode* value) {
    return Config_DeviceConfig_RebroadcastMode_Parse(name, value);
  }

  typedef Config_DeviceConfig_BuzzerMode BuzzerMode;
  static constexpr BuzzerMode ALL_ENABLED =
    Config_DeviceConfig_BuzzerMode_ALL_ENABLED;
  static constexpr BuzzerMode DISABLED =
    Config_DeviceConfig_BuzzerMode_DISABLED;
  static constexpr BuzzerMode NOTIFICATIONS_ONLY =
    Config_DeviceConfig_BuzzerMode_NOTIFICATIONS_ONLY;
  static constexpr BuzzerMode SYSTEM_ONLY =
    Config_DeviceConfig_BuzzerMode_SYSTEM_ONLY;
  static constexpr BuzzerMode DIRECT_MSG_ONLY =
    Config_DeviceConfig_BuzzerMode_DIRECT_MSG_ONLY;
  static inline bool BuzzerMode_IsValid(int value) {
    return Config_DeviceConfig_BuzzerMode_IsValid(value);
  }
  static constexpr BuzzerMode BuzzerMode_MIN =
    Config_DeviceConfig_BuzzerMode_BuzzerMode_MIN;
  static constexpr BuzzerMode BuzzerMode_MAX =
    Config_DeviceConfig_BuzzerMode_BuzzerMode_MAX;
  static constexpr int BuzzerMode_ARRAYSIZE =
    Config_DeviceConfig_BuzzerMode_BuzzerMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BuzzerMode_descriptor() {
    return Config_DeviceConfig_BuzzerMode_descriptor();
  }
  template<typename T>
  static inline const std::string& BuzzerMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BuzzerMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BuzzerMode_Name.");
    return Config_DeviceConfig_BuzzerMode_Name(enum_t_value);
  }
  static inline bool BuzzerMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BuzzerMode* value) {
    return Config_DeviceConfig_BuzzerMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTzdefFieldNumber = 11,
    kRoleFieldNumber = 1,
    kButtonGpioFieldNumber = 4,
    kBuzzerGpioFieldNumber = 5,
    kRebroadcastModeFieldNumber = 6,
    kNodeInfoBroadcastSecsFieldNumber = 7,
    kSerialEnabledFieldNumber = 2,
    kDoubleTapAsButtonPressFieldNumber = 8,
    kIsManagedFieldNumber = 9,
    kDisableTripleClickFieldNumber = 10,
    kLedHeartbeatDisabledFieldNumber = 12,
    kBuzzerModeFieldNumber = 13,
  };
  // string tzdef = 11;
  void clear_tzdef();
  const std::string& tzdef() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tzdef(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tzdef();
  PROTOBUF_NODISCARD std::string* release_tzdef();
  void set_allocated_tzdef(std::string* tzdef);
  private:
  const std::string& _internal_tzdef() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tzdef(const std::string& value);
  std::string* _internal_mutable_tzdef();
  public:

  // .meshtastic.Config.DeviceConfig.Role role = 1;
  void clear_role();
  ::meshtastic::Config_DeviceConfig_Role role() const;
  void set_role(::meshtastic::Config_DeviceConfig_Role value);
  private:
  ::meshtastic::Config_DeviceConfig_Role _internal_role() const;
  void _internal_set_role(::meshtastic::Config_DeviceConfig_Role value);
  public:

  // uint32 button_gpio = 4;
  void clear_button_gpio();
  uint32_t button_gpio() const;
  void set_button_gpio(uint32_t value);
  private:
  uint32_t _internal_button_gpio() const;
  void _internal_set_button_gpio(uint32_t value);
  public:

  // uint32 buzzer_gpio = 5;
  void clear_buzzer_gpio();
  uint32_t buzzer_gpio() const;
  void set_buzzer_gpio(uint32_t value);
  private:
  uint32_t _internal_buzzer_gpio() const;
  void _internal_set_buzzer_gpio(uint32_t value);
  public:

  // .meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;
  void clear_rebroadcast_mode();
  ::meshtastic::Config_DeviceConfig_RebroadcastMode rebroadcast_mode() const;
  void set_rebroadcast_mode(::meshtastic::Config_DeviceConfig_RebroadcastMode value);
  private:
  ::meshtastic::Config_DeviceConfig_RebroadcastMode _internal_rebroadcast_mode() const;
  void _internal_set_rebroadcast_mode(::meshtastic::Config_DeviceConfig_RebroadcastMode value);
  public:

  // uint32 node_info_broadcast_secs = 7;
  void clear_node_info_broadcast_secs();
  uint32_t node_info_broadcast_secs() const;
  void set_node_info_broadcast_secs(uint32_t value);
  private:
  uint32_t _internal_node_info_broadcast_secs() const;
  void _internal_set_node_info_broadcast_secs(uint32_t value);
  public:

  // bool serial_enabled = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_serial_enabled();
  PROTOBUF_DEPRECATED bool serial_enabled() const;
  PROTOBUF_DEPRECATED void set_serial_enabled(bool value);
  private:
  bool _internal_serial_enabled() const;
  void _internal_set_serial_enabled(bool value);
  public:

  // bool double_tap_as_button_press = 8;
  void clear_double_tap_as_button_press();
  bool double_tap_as_button_press() const;
  void set_double_tap_as_button_press(bool value);
  private:
  bool _internal_double_tap_as_button_press() const;
  void _internal_set_double_tap_as_button_press(bool value);
  public:

  // bool is_managed = 9 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_is_managed();
  PROTOBUF_DEPRECATED bool is_managed() const;
  PROTOBUF_DEPRECATED void set_is_managed(bool value);
  private:
  bool _internal_is_managed() const;
  void _internal_set_is_managed(bool value);
  public:

  // bool disable_triple_click = 10;
  void clear_disable_triple_click();
  bool disable_triple_click() const;
  void set_disable_triple_click(bool value);
  private:
  bool _internal_disable_triple_click() const;
  void _internal_set_disable_triple_click(bool value);
  public:

  // bool led_heartbeat_disabled = 12;
  void clear_led_heartbeat_disabled();
  bool led_heartbeat_disabled() const;
  void set_led_heartbeat_disabled(bool value);
  private:
  bool _internal_led_heartbeat_disabled() const;
  void _internal_set_led_heartbeat_disabled(bool value);
  public:

  // .meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;
  void clear_buzzer_mode();
  ::meshtastic::Config_DeviceConfig_BuzzerMode buzzer_mode() const;
  void set_buzzer_mode(::meshtastic::Config_DeviceConfig_BuzzerMode value);
  private:
  ::meshtastic::Config_DeviceConfig_BuzzerMode _internal_buzzer_mode() const;
  void _internal_set_buzzer_mode(::meshtastic::Config_DeviceConfig_BuzzerMode value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Config.DeviceConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tzdef_;
    int role_;
    uint32_t button_gpio_;
    uint32_t buzzer_gpio_;
    int rebroadcast_mode_;
    uint32_t node_info_broadcast_secs_;
    bool serial_enabled_;
    bool double_tap_as_button_press_;
    bool is_managed_;
    bool disable_triple_click_;
    bool led_heartbeat_disabled_;
    int buzzer_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config_PositionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Config.PositionConfig) */ {
 public:
  inline Config_PositionConfig() : Config_PositionConfig(nullptr) {}
  ~Config_PositionConfig() override;
  explicit PROTOBUF_CONSTEXPR Config_PositionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config_PositionConfig(const Config_PositionConfig& from);
  Config_PositionConfig(Config_PositionConfig&& from) noexcept
    : Config_PositionConfig() {
    *this = ::std::move(from);
  }

  inline Config_PositionConfig& operator=(const Config_PositionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_PositionConfig& operator=(Config_PositionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_PositionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config_PositionConfig* internal_default_instance() {
    return reinterpret_cast<const Config_PositionConfig*>(
               &_Config_PositionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Config_PositionConfig& a, Config_PositionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_PositionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_PositionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_PositionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config_PositionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config_PositionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config_PositionConfig& from) {
    Config_PositionConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_PositionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Config.PositionConfig";
  }
  protected:
  explicit Config_PositionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Config_PositionConfig_PositionFlags PositionFlags;
  static constexpr PositionFlags UNSET =
    Config_PositionConfig_PositionFlags_UNSET;
  static constexpr PositionFlags ALTITUDE =
    Config_PositionConfig_PositionFlags_ALTITUDE;
  static constexpr PositionFlags ALTITUDE_MSL =
    Config_PositionConfig_PositionFlags_ALTITUDE_MSL;
  static constexpr PositionFlags GEOIDAL_SEPARATION =
    Config_PositionConfig_PositionFlags_GEOIDAL_SEPARATION;
  static constexpr PositionFlags DOP =
    Config_PositionConfig_PositionFlags_DOP;
  static constexpr PositionFlags HVDOP =
    Config_PositionConfig_PositionFlags_HVDOP;
  static constexpr PositionFlags SATINVIEW =
    Config_PositionConfig_PositionFlags_SATINVIEW;
  static constexpr PositionFlags SEQ_NO =
    Config_PositionConfig_PositionFlags_SEQ_NO;
  static constexpr PositionFlags TIMESTAMP =
    Config_PositionConfig_PositionFlags_TIMESTAMP;
  static constexpr PositionFlags HEADING =
    Config_PositionConfig_PositionFlags_HEADING;
  static constexpr PositionFlags SPEED =
    Config_PositionConfig_PositionFlags_SPEED;
  static inline bool PositionFlags_IsValid(int value) {
    return Config_PositionConfig_PositionFlags_IsValid(value);
  }
  static constexpr PositionFlags PositionFlags_MIN =
    Config_PositionConfig_PositionFlags_PositionFlags_MIN;
  static constexpr PositionFlags PositionFlags_MAX =
    Config_PositionConfig_PositionFlags_PositionFlags_MAX;
  static constexpr int PositionFlags_ARRAYSIZE =
    Config_PositionConfig_PositionFlags_PositionFlags_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PositionFlags_descriptor() {
    return Config_PositionConfig_PositionFlags_descriptor();
  }
  template<typename T>
  static inline const std::string& PositionFlags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PositionFlags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PositionFlags_Name.");
    return Config_PositionConfig_PositionFlags_Name(enum_t_value);
  }
  static inline bool PositionFlags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PositionFlags* value) {
    return Config_PositionConfig_PositionFlags_Parse(name, value);
  }

  typedef Config_PositionConfig_GpsMode GpsMode;
  static constexpr GpsMode DISABLED =
    Config_PositionConfig_GpsMode_DISABLED;
  static constexpr GpsMode ENABLED =
    Config_PositionConfig_GpsMode_ENABLED;
  static constexpr GpsMode NOT_PRESENT =
    Config_PositionConfig_GpsMode_NOT_PRESENT;
  static inline bool GpsMode_IsValid(int value) {
    return Config_PositionConfig_GpsMode_IsValid(value);
  }
  static constexpr GpsMode GpsMode_MIN =
    Config_PositionConfig_GpsMode_GpsMode_MIN;
  static constexpr GpsMode GpsMode_MAX =
    Config_PositionConfig_GpsMode_GpsMode_MAX;
  static constexpr int GpsMode_ARRAYSIZE =
    Config_PositionConfig_GpsMode_GpsMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GpsMode_descriptor() {
    return Config_PositionConfig_GpsMode_descriptor();
  }
  template<typename T>
  static inline const std::string& GpsMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GpsMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GpsMode_Name.");
    return Config_PositionConfig_GpsMode_Name(enum_t_value);
  }
  static inline bool GpsMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GpsMode* value) {
    return Config_PositionConfig_GpsMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPositionBroadcastSecsFieldNumber = 1,
    kPositionBroadcastSmartEnabledFieldNumber = 2,
    kFixedPositionFieldNumber = 3,
    kGpsEnabledFieldNumber = 4,
    kGpsUpdateIntervalFieldNumber = 5,
    kGpsAttemptTimeFieldNumber = 6,
    kPositionFlagsFieldNumber = 7,
    kRxGpioFieldNumber = 8,
    kTxGpioFieldNumber = 9,
    kBroadcastSmartMinimumDistanceFieldNumber = 10,
    kBroadcastSmartMinimumIntervalSecsFieldNumber = 11,
    kGpsEnGpioFieldNumber = 12,
    kGpsModeFieldNumber = 13,
  };
  // uint32 position_broadcast_secs = 1;
  void clear_position_broadcast_secs();
  uint32_t position_broadcast_secs() const;
  void set_position_broadcast_secs(uint32_t value);
  private:
  uint32_t _internal_position_broadcast_secs() const;
  void _internal_set_position_broadcast_secs(uint32_t value);
  public:

  // bool position_broadcast_smart_enabled = 2;
  void clear_position_broadcast_smart_enabled();
  bool position_broadcast_smart_enabled() const;
  void set_position_broadcast_smart_enabled(bool value);
  private:
  bool _internal_position_broadcast_smart_enabled() const;
  void _internal_set_position_broadcast_smart_enabled(bool value);
  public:

  // bool fixed_position = 3;
  void clear_fixed_position();
  bool fixed_position() const;
  void set_fixed_position(bool value);
  private:
  bool _internal_fixed_position() const;
  void _internal_set_fixed_position(bool value);
  public:

  // bool gps_enabled = 4 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_gps_enabled();
  PROTOBUF_DEPRECATED bool gps_enabled() const;
  PROTOBUF_DEPRECATED void set_gps_enabled(bool value);
  private:
  bool _internal_gps_enabled() const;
  void _internal_set_gps_enabled(bool value);
  public:

  // uint32 gps_update_interval = 5;
  void clear_gps_update_interval();
  uint32_t gps_update_interval() const;
  void set_gps_update_interval(uint32_t value);
  private:
  uint32_t _internal_gps_update_interval() const;
  void _internal_set_gps_update_interval(uint32_t value);
  public:

  // uint32 gps_attempt_time = 6 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_gps_attempt_time();
  PROTOBUF_DEPRECATED uint32_t gps_attempt_time() const;
  PROTOBUF_DEPRECATED void set_gps_attempt_time(uint32_t value);
  private:
  uint32_t _internal_gps_attempt_time() const;
  void _internal_set_gps_attempt_time(uint32_t value);
  public:

  // uint32 position_flags = 7;
  void clear_position_flags();
  uint32_t position_flags() const;
  void set_position_flags(uint32_t value);
  private:
  uint32_t _internal_position_flags() const;
  void _internal_set_position_flags(uint32_t value);
  public:

  // uint32 rx_gpio = 8;
  void clear_rx_gpio();
  uint32_t rx_gpio() const;
  void set_rx_gpio(uint32_t value);
  private:
  uint32_t _internal_rx_gpio() const;
  void _internal_set_rx_gpio(uint32_t value);
  public:

  // uint32 tx_gpio = 9;
  void clear_tx_gpio();
  uint32_t tx_gpio() const;
  void set_tx_gpio(uint32_t value);
  private:
  uint32_t _internal_tx_gpio() const;
  void _internal_set_tx_gpio(uint32_t value);
  public:

  // uint32 broadcast_smart_minimum_distance = 10;
  void clear_broadcast_smart_minimum_distance();
  uint32_t broadcast_smart_minimum_distance() const;
  void set_broadcast_smart_minimum_distance(uint32_t value);
  private:
  uint32_t _internal_broadcast_smart_minimum_distance() const;
  void _internal_set_broadcast_smart_minimum_distance(uint32_t value);
  public:

  // uint32 broadcast_smart_minimum_interval_secs = 11;
  void clear_broadcast_smart_minimum_interval_secs();
  uint32_t broadcast_smart_minimum_interval_secs() const;
  void set_broadcast_smart_minimum_interval_secs(uint32_t value);
  private:
  uint32_t _internal_broadcast_smart_minimum_interval_secs() const;
  void _internal_set_broadcast_smart_minimum_interval_secs(uint32_t value);
  public:

  // uint32 gps_en_gpio = 12;
  void clear_gps_en_gpio();
  uint32_t gps_en_gpio() const;
  void set_gps_en_gpio(uint32_t value);
  private:
  uint32_t _internal_gps_en_gpio() const;
  void _internal_set_gps_en_gpio(uint32_t value);
  public:

  // .meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;
  void clear_gps_mode();
  ::meshtastic::Config_PositionConfig_GpsMode gps_mode() const;
  void set_gps_mode(::meshtastic::Config_PositionConfig_GpsMode value);
  private:
  ::meshtastic::Config_PositionConfig_GpsMode _internal_gps_mode() const;
  void _internal_set_gps_mode(::meshtastic::Config_PositionConfig_GpsMode value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Config.PositionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t position_broadcast_secs_;
    bool position_broadcast_smart_enabled_;
    bool fixed_position_;
    bool gps_enabled_;
    uint32_t gps_update_interval_;
    uint32_t gps_attempt_time_;
    uint32_t position_flags_;
    uint32_t rx_gpio_;
    uint32_t tx_gpio_;
    uint32_t broadcast_smart_minimum_distance_;
    uint32_t broadcast_smart_minimum_interval_secs_;
    uint32_t gps_en_gpio_;
    int gps_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config_PowerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Config.PowerConfig) */ {
 public:
  inline Config_PowerConfig() : Config_PowerConfig(nullptr) {}
  ~Config_PowerConfig() override;
  explicit PROTOBUF_CONSTEXPR Config_PowerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config_PowerConfig(const Config_PowerConfig& from);
  Config_PowerConfig(Config_PowerConfig&& from) noexcept
    : Config_PowerConfig() {
    *this = ::std::move(from);
  }

  inline Config_PowerConfig& operator=(const Config_PowerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_PowerConfig& operator=(Config_PowerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_PowerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config_PowerConfig* internal_default_instance() {
    return reinterpret_cast<const Config_PowerConfig*>(
               &_Config_PowerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Config_PowerConfig& a, Config_PowerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_PowerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_PowerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_PowerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config_PowerConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config_PowerConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config_PowerConfig& from) {
    Config_PowerConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_PowerConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Config.PowerConfig";
  }
  protected:
  explicit Config_PowerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsPowerSavingFieldNumber = 1,
    kOnBatteryShutdownAfterSecsFieldNumber = 2,
    kAdcMultiplierOverrideFieldNumber = 3,
    kWaitBluetoothSecsFieldNumber = 4,
    kSdsSecsFieldNumber = 6,
    kLsSecsFieldNumber = 7,
    kMinWakeSecsFieldNumber = 8,
    kDeviceBatteryInaAddressFieldNumber = 9,
    kPowermonEnablesFieldNumber = 32,
  };
  // bool is_power_saving = 1;
  void clear_is_power_saving();
  bool is_power_saving() const;
  void set_is_power_saving(bool value);
  private:
  bool _internal_is_power_saving() const;
  void _internal_set_is_power_saving(bool value);
  public:

  // uint32 on_battery_shutdown_after_secs = 2;
  void clear_on_battery_shutdown_after_secs();
  uint32_t on_battery_shutdown_after_secs() const;
  void set_on_battery_shutdown_after_secs(uint32_t value);
  private:
  uint32_t _internal_on_battery_shutdown_after_secs() const;
  void _internal_set_on_battery_shutdown_after_secs(uint32_t value);
  public:

  // float adc_multiplier_override = 3;
  void clear_adc_multiplier_override();
  float adc_multiplier_override() const;
  void set_adc_multiplier_override(float value);
  private:
  float _internal_adc_multiplier_override() const;
  void _internal_set_adc_multiplier_override(float value);
  public:

  // uint32 wait_bluetooth_secs = 4;
  void clear_wait_bluetooth_secs();
  uint32_t wait_bluetooth_secs() const;
  void set_wait_bluetooth_secs(uint32_t value);
  private:
  uint32_t _internal_wait_bluetooth_secs() const;
  void _internal_set_wait_bluetooth_secs(uint32_t value);
  public:

  // uint32 sds_secs = 6;
  void clear_sds_secs();
  uint32_t sds_secs() const;
  void set_sds_secs(uint32_t value);
  private:
  uint32_t _internal_sds_secs() const;
  void _internal_set_sds_secs(uint32_t value);
  public:

  // uint32 ls_secs = 7;
  void clear_ls_secs();
  uint32_t ls_secs() const;
  void set_ls_secs(uint32_t value);
  private:
  uint32_t _internal_ls_secs() const;
  void _internal_set_ls_secs(uint32_t value);
  public:

  // uint32 min_wake_secs = 8;
  void clear_min_wake_secs();
  uint32_t min_wake_secs() const;
  void set_min_wake_secs(uint32_t value);
  private:
  uint32_t _internal_min_wake_secs() const;
  void _internal_set_min_wake_secs(uint32_t value);
  public:

  // uint32 device_battery_ina_address = 9;
  void clear_device_battery_ina_address();
  uint32_t device_battery_ina_address() const;
  void set_device_battery_ina_address(uint32_t value);
  private:
  uint32_t _internal_device_battery_ina_address() const;
  void _internal_set_device_battery_ina_address(uint32_t value);
  public:

  // uint64 powermon_enables = 32;
  void clear_powermon_enables();
  uint64_t powermon_enables() const;
  void set_powermon_enables(uint64_t value);
  private:
  uint64_t _internal_powermon_enables() const;
  void _internal_set_powermon_enables(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Config.PowerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_power_saving_;
    uint32_t on_battery_shutdown_after_secs_;
    float adc_multiplier_override_;
    uint32_t wait_bluetooth_secs_;
    uint32_t sds_secs_;
    uint32_t ls_secs_;
    uint32_t min_wake_secs_;
    uint32_t device_battery_ina_address_;
    uint64_t powermon_enables_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config_NetworkConfig_IpV4Config final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Config.NetworkConfig.IpV4Config) */ {
 public:
  inline Config_NetworkConfig_IpV4Config() : Config_NetworkConfig_IpV4Config(nullptr) {}
  ~Config_NetworkConfig_IpV4Config() override;
  explicit PROTOBUF_CONSTEXPR Config_NetworkConfig_IpV4Config(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config_NetworkConfig_IpV4Config(const Config_NetworkConfig_IpV4Config& from);
  Config_NetworkConfig_IpV4Config(Config_NetworkConfig_IpV4Config&& from) noexcept
    : Config_NetworkConfig_IpV4Config() {
    *this = ::std::move(from);
  }

  inline Config_NetworkConfig_IpV4Config& operator=(const Config_NetworkConfig_IpV4Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_NetworkConfig_IpV4Config& operator=(Config_NetworkConfig_IpV4Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_NetworkConfig_IpV4Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config_NetworkConfig_IpV4Config* internal_default_instance() {
    return reinterpret_cast<const Config_NetworkConfig_IpV4Config*>(
               &_Config_NetworkConfig_IpV4Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Config_NetworkConfig_IpV4Config& a, Config_NetworkConfig_IpV4Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_NetworkConfig_IpV4Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_NetworkConfig_IpV4Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_NetworkConfig_IpV4Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config_NetworkConfig_IpV4Config>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config_NetworkConfig_IpV4Config& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config_NetworkConfig_IpV4Config& from) {
    Config_NetworkConfig_IpV4Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_NetworkConfig_IpV4Config* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Config.NetworkConfig.IpV4Config";
  }
  protected:
  explicit Config_NetworkConfig_IpV4Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kGatewayFieldNumber = 2,
    kSubnetFieldNumber = 3,
    kDnsFieldNumber = 4,
  };
  // fixed32 ip = 1;
  void clear_ip();
  uint32_t ip() const;
  void set_ip(uint32_t value);
  private:
  uint32_t _internal_ip() const;
  void _internal_set_ip(uint32_t value);
  public:

  // fixed32 gateway = 2;
  void clear_gateway();
  uint32_t gateway() const;
  void set_gateway(uint32_t value);
  private:
  uint32_t _internal_gateway() const;
  void _internal_set_gateway(uint32_t value);
  public:

  // fixed32 subnet = 3;
  void clear_subnet();
  uint32_t subnet() const;
  void set_subnet(uint32_t value);
  private:
  uint32_t _internal_subnet() const;
  void _internal_set_subnet(uint32_t value);
  public:

  // fixed32 dns = 4;
  void clear_dns();
  uint32_t dns() const;
  void set_dns(uint32_t value);
  private:
  uint32_t _internal_dns() const;
  void _internal_set_dns(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Config.NetworkConfig.IpV4Config)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t ip_;
    uint32_t gateway_;
    uint32_t subnet_;
    uint32_t dns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config_NetworkConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Config.NetworkConfig) */ {
 public:
  inline Config_NetworkConfig() : Config_NetworkConfig(nullptr) {}
  ~Config_NetworkConfig() override;
  explicit PROTOBUF_CONSTEXPR Config_NetworkConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config_NetworkConfig(const Config_NetworkConfig& from);
  Config_NetworkConfig(Config_NetworkConfig&& from) noexcept
    : Config_NetworkConfig() {
    *this = ::std::move(from);
  }

  inline Config_NetworkConfig& operator=(const Config_NetworkConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_NetworkConfig& operator=(Config_NetworkConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_NetworkConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config_NetworkConfig* internal_default_instance() {
    return reinterpret_cast<const Config_NetworkConfig*>(
               &_Config_NetworkConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Config_NetworkConfig& a, Config_NetworkConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_NetworkConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_NetworkConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_NetworkConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config_NetworkConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config_NetworkConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config_NetworkConfig& from) {
    Config_NetworkConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_NetworkConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Config.NetworkConfig";
  }
  protected:
  explicit Config_NetworkConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Config_NetworkConfig_IpV4Config IpV4Config;

  typedef Config_NetworkConfig_AddressMode AddressMode;
  static constexpr AddressMode DHCP =
    Config_NetworkConfig_AddressMode_DHCP;
  static constexpr AddressMode STATIC =
    Config_NetworkConfig_AddressMode_STATIC;
  static inline bool AddressMode_IsValid(int value) {
    return Config_NetworkConfig_AddressMode_IsValid(value);
  }
  static constexpr AddressMode AddressMode_MIN =
    Config_NetworkConfig_AddressMode_AddressMode_MIN;
  static constexpr AddressMode AddressMode_MAX =
    Config_NetworkConfig_AddressMode_AddressMode_MAX;
  static constexpr int AddressMode_ARRAYSIZE =
    Config_NetworkConfig_AddressMode_AddressMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AddressMode_descriptor() {
    return Config_NetworkConfig_AddressMode_descriptor();
  }
  template<typename T>
  static inline const std::string& AddressMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AddressMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AddressMode_Name.");
    return Config_NetworkConfig_AddressMode_Name(enum_t_value);
  }
  static inline bool AddressMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AddressMode* value) {
    return Config_NetworkConfig_AddressMode_Parse(name, value);
  }

  typedef Config_NetworkConfig_ProtocolFlags ProtocolFlags;
  static constexpr ProtocolFlags NO_BROADCAST =
    Config_NetworkConfig_ProtocolFlags_NO_BROADCAST;
  static constexpr ProtocolFlags UDP_BROADCAST =
    Config_NetworkConfig_ProtocolFlags_UDP_BROADCAST;
  static inline bool ProtocolFlags_IsValid(int value) {
    return Config_NetworkConfig_ProtocolFlags_IsValid(value);
  }
  static constexpr ProtocolFlags ProtocolFlags_MIN =
    Config_NetworkConfig_ProtocolFlags_ProtocolFlags_MIN;
  static constexpr ProtocolFlags ProtocolFlags_MAX =
    Config_NetworkConfig_ProtocolFlags_ProtocolFlags_MAX;
  static constexpr int ProtocolFlags_ARRAYSIZE =
    Config_NetworkConfig_ProtocolFlags_ProtocolFlags_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ProtocolFlags_descriptor() {
    return Config_NetworkConfig_ProtocolFlags_descriptor();
  }
  template<typename T>
  static inline const std::string& ProtocolFlags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ProtocolFlags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ProtocolFlags_Name.");
    return Config_NetworkConfig_ProtocolFlags_Name(enum_t_value);
  }
  static inline bool ProtocolFlags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ProtocolFlags* value) {
    return Config_NetworkConfig_ProtocolFlags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWifiSsidFieldNumber = 3,
    kWifiPskFieldNumber = 4,
    kNtpServerFieldNumber = 5,
    kRsyslogServerFieldNumber = 9,
    kIpv4ConfigFieldNumber = 8,
    kWifiEnabledFieldNumber = 1,
    kEthEnabledFieldNumber = 6,
    kIpv6EnabledFieldNumber = 11,
    kAddressModeFieldNumber = 7,
    kEnabledProtocolsFieldNumber = 10,
  };
  // string wifi_ssid = 3;
  void clear_wifi_ssid();
  const std::string& wifi_ssid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wifi_ssid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wifi_ssid();
  PROTOBUF_NODISCARD std::string* release_wifi_ssid();
  void set_allocated_wifi_ssid(std::string* wifi_ssid);
  private:
  const std::string& _internal_wifi_ssid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wifi_ssid(const std::string& value);
  std::string* _internal_mutable_wifi_ssid();
  public:

  // string wifi_psk = 4;
  void clear_wifi_psk();
  const std::string& wifi_psk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wifi_psk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wifi_psk();
  PROTOBUF_NODISCARD std::string* release_wifi_psk();
  void set_allocated_wifi_psk(std::string* wifi_psk);
  private:
  const std::string& _internal_wifi_psk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wifi_psk(const std::string& value);
  std::string* _internal_mutable_wifi_psk();
  public:

  // string ntp_server = 5;
  void clear_ntp_server();
  const std::string& ntp_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ntp_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ntp_server();
  PROTOBUF_NODISCARD std::string* release_ntp_server();
  void set_allocated_ntp_server(std::string* ntp_server);
  private:
  const std::string& _internal_ntp_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ntp_server(const std::string& value);
  std::string* _internal_mutable_ntp_server();
  public:

  // string rsyslog_server = 9;
  void clear_rsyslog_server();
  const std::string& rsyslog_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rsyslog_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rsyslog_server();
  PROTOBUF_NODISCARD std::string* release_rsyslog_server();
  void set_allocated_rsyslog_server(std::string* rsyslog_server);
  private:
  const std::string& _internal_rsyslog_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rsyslog_server(const std::string& value);
  std::string* _internal_mutable_rsyslog_server();
  public:

  // .meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;
  bool has_ipv4_config() const;
  private:
  bool _internal_has_ipv4_config() const;
  public:
  void clear_ipv4_config();
  const ::meshtastic::Config_NetworkConfig_IpV4Config& ipv4_config() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_NetworkConfig_IpV4Config* release_ipv4_config();
  ::meshtastic::Config_NetworkConfig_IpV4Config* mutable_ipv4_config();
  void set_allocated_ipv4_config(::meshtastic::Config_NetworkConfig_IpV4Config* ipv4_config);
  private:
  const ::meshtastic::Config_NetworkConfig_IpV4Config& _internal_ipv4_config() const;
  ::meshtastic::Config_NetworkConfig_IpV4Config* _internal_mutable_ipv4_config();
  public:
  void unsafe_arena_set_allocated_ipv4_config(
      ::meshtastic::Config_NetworkConfig_IpV4Config* ipv4_config);
  ::meshtastic::Config_NetworkConfig_IpV4Config* unsafe_arena_release_ipv4_config();

  // bool wifi_enabled = 1;
  void clear_wifi_enabled();
  bool wifi_enabled() const;
  void set_wifi_enabled(bool value);
  private:
  bool _internal_wifi_enabled() const;
  void _internal_set_wifi_enabled(bool value);
  public:

  // bool eth_enabled = 6;
  void clear_eth_enabled();
  bool eth_enabled() const;
  void set_eth_enabled(bool value);
  private:
  bool _internal_eth_enabled() const;
  void _internal_set_eth_enabled(bool value);
  public:

  // bool ipv6_enabled = 11;
  void clear_ipv6_enabled();
  bool ipv6_enabled() const;
  void set_ipv6_enabled(bool value);
  private:
  bool _internal_ipv6_enabled() const;
  void _internal_set_ipv6_enabled(bool value);
  public:

  // .meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;
  void clear_address_mode();
  ::meshtastic::Config_NetworkConfig_AddressMode address_mode() const;
  void set_address_mode(::meshtastic::Config_NetworkConfig_AddressMode value);
  private:
  ::meshtastic::Config_NetworkConfig_AddressMode _internal_address_mode() const;
  void _internal_set_address_mode(::meshtastic::Config_NetworkConfig_AddressMode value);
  public:

  // uint32 enabled_protocols = 10;
  void clear_enabled_protocols();
  uint32_t enabled_protocols() const;
  void set_enabled_protocols(uint32_t value);
  private:
  uint32_t _internal_enabled_protocols() const;
  void _internal_set_enabled_protocols(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Config.NetworkConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wifi_ssid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wifi_psk_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ntp_server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rsyslog_server_;
    ::meshtastic::Config_NetworkConfig_IpV4Config* ipv4_config_;
    bool wifi_enabled_;
    bool eth_enabled_;
    bool ipv6_enabled_;
    int address_mode_;
    uint32_t enabled_protocols_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config_DisplayConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Config.DisplayConfig) */ {
 public:
  inline Config_DisplayConfig() : Config_DisplayConfig(nullptr) {}
  ~Config_DisplayConfig() override;
  explicit PROTOBUF_CONSTEXPR Config_DisplayConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config_DisplayConfig(const Config_DisplayConfig& from);
  Config_DisplayConfig(Config_DisplayConfig&& from) noexcept
    : Config_DisplayConfig() {
    *this = ::std::move(from);
  }

  inline Config_DisplayConfig& operator=(const Config_DisplayConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_DisplayConfig& operator=(Config_DisplayConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_DisplayConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config_DisplayConfig* internal_default_instance() {
    return reinterpret_cast<const Config_DisplayConfig*>(
               &_Config_DisplayConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Config_DisplayConfig& a, Config_DisplayConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_DisplayConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_DisplayConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_DisplayConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config_DisplayConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config_DisplayConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config_DisplayConfig& from) {
    Config_DisplayConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_DisplayConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Config.DisplayConfig";
  }
  protected:
  explicit Config_DisplayConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Config_DisplayConfig_GpsCoordinateFormat GpsCoordinateFormat;
  static constexpr GpsCoordinateFormat DEC =
    Config_DisplayConfig_GpsCoordinateFormat_DEC;
  static constexpr GpsCoordinateFormat DMS =
    Config_DisplayConfig_GpsCoordinateFormat_DMS;
  static constexpr GpsCoordinateFormat UTM =
    Config_DisplayConfig_GpsCoordinateFormat_UTM;
  static constexpr GpsCoordinateFormat MGRS =
    Config_DisplayConfig_GpsCoordinateFormat_MGRS;
  static constexpr GpsCoordinateFormat OLC =
    Config_DisplayConfig_GpsCoordinateFormat_OLC;
  static constexpr GpsCoordinateFormat OSGR =
    Config_DisplayConfig_GpsCoordinateFormat_OSGR;
  static inline bool GpsCoordinateFormat_IsValid(int value) {
    return Config_DisplayConfig_GpsCoordinateFormat_IsValid(value);
  }
  static constexpr GpsCoordinateFormat GpsCoordinateFormat_MIN =
    Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_MIN;
  static constexpr GpsCoordinateFormat GpsCoordinateFormat_MAX =
    Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_MAX;
  static constexpr int GpsCoordinateFormat_ARRAYSIZE =
    Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GpsCoordinateFormat_descriptor() {
    return Config_DisplayConfig_GpsCoordinateFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& GpsCoordinateFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GpsCoordinateFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GpsCoordinateFormat_Name.");
    return Config_DisplayConfig_GpsCoordinateFormat_Name(enum_t_value);
  }
  static inline bool GpsCoordinateFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GpsCoordinateFormat* value) {
    return Config_DisplayConfig_GpsCoordinateFormat_Parse(name, value);
  }

  typedef Config_DisplayConfig_DisplayUnits DisplayUnits;
  static constexpr DisplayUnits METRIC =
    Config_DisplayConfig_DisplayUnits_METRIC;
  static constexpr DisplayUnits IMPERIAL =
    Config_DisplayConfig_DisplayUnits_IMPERIAL;
  static inline bool DisplayUnits_IsValid(int value) {
    return Config_DisplayConfig_DisplayUnits_IsValid(value);
  }
  static constexpr DisplayUnits DisplayUnits_MIN =
    Config_DisplayConfig_DisplayUnits_DisplayUnits_MIN;
  static constexpr DisplayUnits DisplayUnits_MAX =
    Config_DisplayConfig_DisplayUnits_DisplayUnits_MAX;
  static constexpr int DisplayUnits_ARRAYSIZE =
    Config_DisplayConfig_DisplayUnits_DisplayUnits_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DisplayUnits_descriptor() {
    return Config_DisplayConfig_DisplayUnits_descriptor();
  }
  template<typename T>
  static inline const std::string& DisplayUnits_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DisplayUnits>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DisplayUnits_Name.");
    return Config_DisplayConfig_DisplayUnits_Name(enum_t_value);
  }
  static inline bool DisplayUnits_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DisplayUnits* value) {
    return Config_DisplayConfig_DisplayUnits_Parse(name, value);
  }

  typedef Config_DisplayConfig_OledType OledType;
  static constexpr OledType OLED_AUTO =
    Config_DisplayConfig_OledType_OLED_AUTO;
  static constexpr OledType OLED_SSD1306 =
    Config_DisplayConfig_OledType_OLED_SSD1306;
  static constexpr OledType OLED_SH1106 =
    Config_DisplayConfig_OledType_OLED_SH1106;
  static constexpr OledType OLED_SH1107 =
    Config_DisplayConfig_OledType_OLED_SH1107;
  static constexpr OledType OLED_SH1107_128_128 =
    Config_DisplayConfig_OledType_OLED_SH1107_128_128;
  static inline bool OledType_IsValid(int value) {
    return Config_DisplayConfig_OledType_IsValid(value);
  }
  static constexpr OledType OledType_MIN =
    Config_DisplayConfig_OledType_OledType_MIN;
  static constexpr OledType OledType_MAX =
    Config_DisplayConfig_OledType_OledType_MAX;
  static constexpr int OledType_ARRAYSIZE =
    Config_DisplayConfig_OledType_OledType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OledType_descriptor() {
    return Config_DisplayConfig_OledType_descriptor();
  }
  template<typename T>
  static inline const std::string& OledType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OledType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OledType_Name.");
    return Config_DisplayConfig_OledType_Name(enum_t_value);
  }
  static inline bool OledType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OledType* value) {
    return Config_DisplayConfig_OledType_Parse(name, value);
  }

  typedef Config_DisplayConfig_DisplayMode DisplayMode;
  static constexpr DisplayMode DEFAULT =
    Config_DisplayConfig_DisplayMode_DEFAULT;
  static constexpr DisplayMode TWOCOLOR =
    Config_DisplayConfig_DisplayMode_TWOCOLOR;
  static constexpr DisplayMode INVERTED =
    Config_DisplayConfig_DisplayMode_INVERTED;
  static constexpr DisplayMode COLOR =
    Config_DisplayConfig_DisplayMode_COLOR;
  static inline bool DisplayMode_IsValid(int value) {
    return Config_DisplayConfig_DisplayMode_IsValid(value);
  }
  static constexpr DisplayMode DisplayMode_MIN =
    Config_DisplayConfig_DisplayMode_DisplayMode_MIN;
  static constexpr DisplayMode DisplayMode_MAX =
    Config_DisplayConfig_DisplayMode_DisplayMode_MAX;
  static constexpr int DisplayMode_ARRAYSIZE =
    Config_DisplayConfig_DisplayMode_DisplayMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DisplayMode_descriptor() {
    return Config_DisplayConfig_DisplayMode_descriptor();
  }
  template<typename T>
  static inline const std::string& DisplayMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DisplayMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DisplayMode_Name.");
    return Config_DisplayConfig_DisplayMode_Name(enum_t_value);
  }
  static inline bool DisplayMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DisplayMode* value) {
    return Config_DisplayConfig_DisplayMode_Parse(name, value);
  }

  typedef Config_DisplayConfig_CompassOrientation CompassOrientation;
  static constexpr CompassOrientation DEGREES_0 =
    Config_DisplayConfig_CompassOrientation_DEGREES_0;
  static constexpr CompassOrientation DEGREES_90 =
    Config_DisplayConfig_CompassOrientation_DEGREES_90;
  static constexpr CompassOrientation DEGREES_180 =
    Config_DisplayConfig_CompassOrientation_DEGREES_180;
  static constexpr CompassOrientation DEGREES_270 =
    Config_DisplayConfig_CompassOrientation_DEGREES_270;
  static constexpr CompassOrientation DEGREES_0_INVERTED =
    Config_DisplayConfig_CompassOrientation_DEGREES_0_INVERTED;
  static constexpr CompassOrientation DEGREES_90_INVERTED =
    Config_DisplayConfig_CompassOrientation_DEGREES_90_INVERTED;
  static constexpr CompassOrientation DEGREES_180_INVERTED =
    Config_DisplayConfig_CompassOrientation_DEGREES_180_INVERTED;
  static constexpr CompassOrientation DEGREES_270_INVERTED =
    Config_DisplayConfig_CompassOrientation_DEGREES_270_INVERTED;
  static inline bool CompassOrientation_IsValid(int value) {
    return Config_DisplayConfig_CompassOrientation_IsValid(value);
  }
  static constexpr CompassOrientation CompassOrientation_MIN =
    Config_DisplayConfig_CompassOrientation_CompassOrientation_MIN;
  static constexpr CompassOrientation CompassOrientation_MAX =
    Config_DisplayConfig_CompassOrientation_CompassOrientation_MAX;
  static constexpr int CompassOrientation_ARRAYSIZE =
    Config_DisplayConfig_CompassOrientation_CompassOrientation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CompassOrientation_descriptor() {
    return Config_DisplayConfig_CompassOrientation_descriptor();
  }
  template<typename T>
  static inline const std::string& CompassOrientation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CompassOrientation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CompassOrientation_Name.");
    return Config_DisplayConfig_CompassOrientation_Name(enum_t_value);
  }
  static inline bool CompassOrientation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CompassOrientation* value) {
    return Config_DisplayConfig_CompassOrientation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kScreenOnSecsFieldNumber = 1,
    kGpsFormatFieldNumber = 2,
    kAutoScreenCarouselSecsFieldNumber = 3,
    kUnitsFieldNumber = 6,
    kOledFieldNumber = 7,
    kCompassNorthTopFieldNumber = 4,
    kFlipScreenFieldNumber = 5,
    kHeadingBoldFieldNumber = 9,
    kWakeOnTapOrMotionFieldNumber = 10,
    kDisplaymodeFieldNumber = 8,
    kCompassOrientationFieldNumber = 11,
    kUse12HClockFieldNumber = 12,
  };
  // uint32 screen_on_secs = 1;
  void clear_screen_on_secs();
  uint32_t screen_on_secs() const;
  void set_screen_on_secs(uint32_t value);
  private:
  uint32_t _internal_screen_on_secs() const;
  void _internal_set_screen_on_secs(uint32_t value);
  public:

  // .meshtastic.Config.DisplayConfig.GpsCoordinateFormat gps_format = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_gps_format();
  PROTOBUF_DEPRECATED ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat gps_format() const;
  PROTOBUF_DEPRECATED void set_gps_format(::meshtastic::Config_DisplayConfig_GpsCoordinateFormat value);
  private:
  ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat _internal_gps_format() const;
  void _internal_set_gps_format(::meshtastic::Config_DisplayConfig_GpsCoordinateFormat value);
  public:

  // uint32 auto_screen_carousel_secs = 3;
  void clear_auto_screen_carousel_secs();
  uint32_t auto_screen_carousel_secs() const;
  void set_auto_screen_carousel_secs(uint32_t value);
  private:
  uint32_t _internal_auto_screen_carousel_secs() const;
  void _internal_set_auto_screen_carousel_secs(uint32_t value);
  public:

  // .meshtastic.Config.DisplayConfig.DisplayUnits units = 6;
  void clear_units();
  ::meshtastic::Config_DisplayConfig_DisplayUnits units() const;
  void set_units(::meshtastic::Config_DisplayConfig_DisplayUnits value);
  private:
  ::meshtastic::Config_DisplayConfig_DisplayUnits _internal_units() const;
  void _internal_set_units(::meshtastic::Config_DisplayConfig_DisplayUnits value);
  public:

  // .meshtastic.Config.DisplayConfig.OledType oled = 7;
  void clear_oled();
  ::meshtastic::Config_DisplayConfig_OledType oled() const;
  void set_oled(::meshtastic::Config_DisplayConfig_OledType value);
  private:
  ::meshtastic::Config_DisplayConfig_OledType _internal_oled() const;
  void _internal_set_oled(::meshtastic::Config_DisplayConfig_OledType value);
  public:

  // bool compass_north_top = 4 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_compass_north_top();
  PROTOBUF_DEPRECATED bool compass_north_top() const;
  PROTOBUF_DEPRECATED void set_compass_north_top(bool value);
  private:
  bool _internal_compass_north_top() const;
  void _internal_set_compass_north_top(bool value);
  public:

  // bool flip_screen = 5;
  void clear_flip_screen();
  bool flip_screen() const;
  void set_flip_screen(bool value);
  private:
  bool _internal_flip_screen() const;
  void _internal_set_flip_screen(bool value);
  public:

  // bool heading_bold = 9;
  void clear_heading_bold();
  bool heading_bold() const;
  void set_heading_bold(bool value);
  private:
  bool _internal_heading_bold() const;
  void _internal_set_heading_bold(bool value);
  public:

  // bool wake_on_tap_or_motion = 10;
  void clear_wake_on_tap_or_motion();
  bool wake_on_tap_or_motion() const;
  void set_wake_on_tap_or_motion(bool value);
  private:
  bool _internal_wake_on_tap_or_motion() const;
  void _internal_set_wake_on_tap_or_motion(bool value);
  public:

  // .meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;
  void clear_displaymode();
  ::meshtastic::Config_DisplayConfig_DisplayMode displaymode() const;
  void set_displaymode(::meshtastic::Config_DisplayConfig_DisplayMode value);
  private:
  ::meshtastic::Config_DisplayConfig_DisplayMode _internal_displaymode() const;
  void _internal_set_displaymode(::meshtastic::Config_DisplayConfig_DisplayMode value);
  public:

  // .meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;
  void clear_compass_orientation();
  ::meshtastic::Config_DisplayConfig_CompassOrientation compass_orientation() const;
  void set_compass_orientation(::meshtastic::Config_DisplayConfig_CompassOrientation value);
  private:
  ::meshtastic::Config_DisplayConfig_CompassOrientation _internal_compass_orientation() const;
  void _internal_set_compass_orientation(::meshtastic::Config_DisplayConfig_CompassOrientation value);
  public:

  // bool use_12h_clock = 12;
  void clear_use_12h_clock();
  bool use_12h_clock() const;
  void set_use_12h_clock(bool value);
  private:
  bool _internal_use_12h_clock() const;
  void _internal_set_use_12h_clock(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Config.DisplayConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t screen_on_secs_;
    int gps_format_;
    uint32_t auto_screen_carousel_secs_;
    int units_;
    int oled_;
    bool compass_north_top_;
    bool flip_screen_;
    bool heading_bold_;
    bool wake_on_tap_or_motion_;
    int displaymode_;
    int compass_orientation_;
    bool use_12h_clock_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config_LoRaConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Config.LoRaConfig) */ {
 public:
  inline Config_LoRaConfig() : Config_LoRaConfig(nullptr) {}
  ~Config_LoRaConfig() override;
  explicit PROTOBUF_CONSTEXPR Config_LoRaConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config_LoRaConfig(const Config_LoRaConfig& from);
  Config_LoRaConfig(Config_LoRaConfig&& from) noexcept
    : Config_LoRaConfig() {
    *this = ::std::move(from);
  }

  inline Config_LoRaConfig& operator=(const Config_LoRaConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_LoRaConfig& operator=(Config_LoRaConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_LoRaConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config_LoRaConfig* internal_default_instance() {
    return reinterpret_cast<const Config_LoRaConfig*>(
               &_Config_LoRaConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Config_LoRaConfig& a, Config_LoRaConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_LoRaConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_LoRaConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_LoRaConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config_LoRaConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config_LoRaConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config_LoRaConfig& from) {
    Config_LoRaConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_LoRaConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Config.LoRaConfig";
  }
  protected:
  explicit Config_LoRaConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Config_LoRaConfig_RegionCode RegionCode;
  static constexpr RegionCode UNSET =
    Config_LoRaConfig_RegionCode_UNSET;
  static constexpr RegionCode US =
    Config_LoRaConfig_RegionCode_US;
  static constexpr RegionCode EU_433 =
    Config_LoRaConfig_RegionCode_EU_433;
  static constexpr RegionCode EU_868 =
    Config_LoRaConfig_RegionCode_EU_868;
  static constexpr RegionCode CN =
    Config_LoRaConfig_RegionCode_CN;
  static constexpr RegionCode JP =
    Config_LoRaConfig_RegionCode_JP;
  static constexpr RegionCode ANZ =
    Config_LoRaConfig_RegionCode_ANZ;
  static constexpr RegionCode KR =
    Config_LoRaConfig_RegionCode_KR;
  static constexpr RegionCode TW =
    Config_LoRaConfig_RegionCode_TW;
  static constexpr RegionCode RU =
    Config_LoRaConfig_RegionCode_RU;
  static constexpr RegionCode IN =
    Config_LoRaConfig_RegionCode_IN;
  static constexpr RegionCode NZ_865 =
    Config_LoRaConfig_RegionCode_NZ_865;
  static constexpr RegionCode TH =
    Config_LoRaConfig_RegionCode_TH;
  static constexpr RegionCode LORA_24 =
    Config_LoRaConfig_RegionCode_LORA_24;
  static constexpr RegionCode UA_433 =
    Config_LoRaConfig_RegionCode_UA_433;
  static constexpr RegionCode UA_868 =
    Config_LoRaConfig_RegionCode_UA_868;
  static constexpr RegionCode MY_433 =
    Config_LoRaConfig_RegionCode_MY_433;
  static constexpr RegionCode MY_919 =
    Config_LoRaConfig_RegionCode_MY_919;
  static constexpr RegionCode SG_923 =
    Config_LoRaConfig_RegionCode_SG_923;
  static constexpr RegionCode PH_433 =
    Config_LoRaConfig_RegionCode_PH_433;
  static constexpr RegionCode PH_868 =
    Config_LoRaConfig_RegionCode_PH_868;
  static constexpr RegionCode PH_915 =
    Config_LoRaConfig_RegionCode_PH_915;
  static constexpr RegionCode ANZ_433 =
    Config_LoRaConfig_RegionCode_ANZ_433;
  static constexpr RegionCode KZ_433 =
    Config_LoRaConfig_RegionCode_KZ_433;
  static constexpr RegionCode KZ_863 =
    Config_LoRaConfig_RegionCode_KZ_863;
  static constexpr RegionCode NP_865 =
    Config_LoRaConfig_RegionCode_NP_865;
  static constexpr RegionCode BR_902 =
    Config_LoRaConfig_RegionCode_BR_902;
  static inline bool RegionCode_IsValid(int value) {
    return Config_LoRaConfig_RegionCode_IsValid(value);
  }
  static constexpr RegionCode RegionCode_MIN =
    Config_LoRaConfig_RegionCode_RegionCode_MIN;
  static constexpr RegionCode RegionCode_MAX =
    Config_LoRaConfig_RegionCode_RegionCode_MAX;
  static constexpr int RegionCode_ARRAYSIZE =
    Config_LoRaConfig_RegionCode_RegionCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RegionCode_descriptor() {
    return Config_LoRaConfig_RegionCode_descriptor();
  }
  template<typename T>
  static inline const std::string& RegionCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RegionCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RegionCode_Name.");
    return Config_LoRaConfig_RegionCode_Name(enum_t_value);
  }
  static inline bool RegionCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RegionCode* value) {
    return Config_LoRaConfig_RegionCode_Parse(name, value);
  }

  typedef Config_LoRaConfig_ModemPreset ModemPreset;
  static constexpr ModemPreset LONG_FAST =
    Config_LoRaConfig_ModemPreset_LONG_FAST;
  static constexpr ModemPreset LONG_SLOW =
    Config_LoRaConfig_ModemPreset_LONG_SLOW;
  PROTOBUF_DEPRECATED_ENUM static constexpr ModemPreset VERY_LONG_SLOW =
    Config_LoRaConfig_ModemPreset_VERY_LONG_SLOW;
  static constexpr ModemPreset MEDIUM_SLOW =
    Config_LoRaConfig_ModemPreset_MEDIUM_SLOW;
  static constexpr ModemPreset MEDIUM_FAST =
    Config_LoRaConfig_ModemPreset_MEDIUM_FAST;
  static constexpr ModemPreset SHORT_SLOW =
    Config_LoRaConfig_ModemPreset_SHORT_SLOW;
  static constexpr ModemPreset SHORT_FAST =
    Config_LoRaConfig_ModemPreset_SHORT_FAST;
  static constexpr ModemPreset LONG_MODERATE =
    Config_LoRaConfig_ModemPreset_LONG_MODERATE;
  static constexpr ModemPreset SHORT_TURBO =
    Config_LoRaConfig_ModemPreset_SHORT_TURBO;
  static inline bool ModemPreset_IsValid(int value) {
    return Config_LoRaConfig_ModemPreset_IsValid(value);
  }
  static constexpr ModemPreset ModemPreset_MIN =
    Config_LoRaConfig_ModemPreset_ModemPreset_MIN;
  static constexpr ModemPreset ModemPreset_MAX =
    Config_LoRaConfig_ModemPreset_ModemPreset_MAX;
  static constexpr int ModemPreset_ARRAYSIZE =
    Config_LoRaConfig_ModemPreset_ModemPreset_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ModemPreset_descriptor() {
    return Config_LoRaConfig_ModemPreset_descriptor();
  }
  template<typename T>
  static inline const std::string& ModemPreset_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ModemPreset>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ModemPreset_Name.");
    return Config_LoRaConfig_ModemPreset_Name(enum_t_value);
  }
  static inline bool ModemPreset_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ModemPreset* value) {
    return Config_LoRaConfig_ModemPreset_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIgnoreIncomingFieldNumber = 103,
    kModemPresetFieldNumber = 2,
    kBandwidthFieldNumber = 3,
    kSpreadFactorFieldNumber = 4,
    kCodingRateFieldNumber = 5,
    kFrequencyOffsetFieldNumber = 6,
    kRegionFieldNumber = 7,
    kHopLimitFieldNumber = 8,
    kUsePresetFieldNumber = 1,
    kTxEnabledFieldNumber = 9,
    kOverrideDutyCycleFieldNumber = 12,
    kSx126XRxBoostedGainFieldNumber = 13,
    kTxPowerFieldNumber = 10,
    kChannelNumFieldNumber = 11,
    kOverrideFrequencyFieldNumber = 14,
    kPaFanDisabledFieldNumber = 15,
    kIgnoreMqttFieldNumber = 104,
    kConfigOkToMqttFieldNumber = 105,
  };
  // repeated uint32 ignore_incoming = 103;
  int ignore_incoming_size() const;
  private:
  int _internal_ignore_incoming_size() const;
  public:
  void clear_ignore_incoming();
  private:
  uint32_t _internal_ignore_incoming(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_ignore_incoming() const;
  void _internal_add_ignore_incoming(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_ignore_incoming();
  public:
  uint32_t ignore_incoming(int index) const;
  void set_ignore_incoming(int index, uint32_t value);
  void add_ignore_incoming(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      ignore_incoming() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_ignore_incoming();

  // .meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;
  void clear_modem_preset();
  ::meshtastic::Config_LoRaConfig_ModemPreset modem_preset() const;
  void set_modem_preset(::meshtastic::Config_LoRaConfig_ModemPreset value);
  private:
  ::meshtastic::Config_LoRaConfig_ModemPreset _internal_modem_preset() const;
  void _internal_set_modem_preset(::meshtastic::Config_LoRaConfig_ModemPreset value);
  public:

  // uint32 bandwidth = 3;
  void clear_bandwidth();
  uint32_t bandwidth() const;
  void set_bandwidth(uint32_t value);
  private:
  uint32_t _internal_bandwidth() const;
  void _internal_set_bandwidth(uint32_t value);
  public:

  // uint32 spread_factor = 4;
  void clear_spread_factor();
  uint32_t spread_factor() const;
  void set_spread_factor(uint32_t value);
  private:
  uint32_t _internal_spread_factor() const;
  void _internal_set_spread_factor(uint32_t value);
  public:

  // uint32 coding_rate = 5;
  void clear_coding_rate();
  uint32_t coding_rate() const;
  void set_coding_rate(uint32_t value);
  private:
  uint32_t _internal_coding_rate() const;
  void _internal_set_coding_rate(uint32_t value);
  public:

  // float frequency_offset = 6;
  void clear_frequency_offset();
  float frequency_offset() const;
  void set_frequency_offset(float value);
  private:
  float _internal_frequency_offset() const;
  void _internal_set_frequency_offset(float value);
  public:

  // .meshtastic.Config.LoRaConfig.RegionCode region = 7;
  void clear_region();
  ::meshtastic::Config_LoRaConfig_RegionCode region() const;
  void set_region(::meshtastic::Config_LoRaConfig_RegionCode value);
  private:
  ::meshtastic::Config_LoRaConfig_RegionCode _internal_region() const;
  void _internal_set_region(::meshtastic::Config_LoRaConfig_RegionCode value);
  public:

  // uint32 hop_limit = 8;
  void clear_hop_limit();
  uint32_t hop_limit() const;
  void set_hop_limit(uint32_t value);
  private:
  uint32_t _internal_hop_limit() const;
  void _internal_set_hop_limit(uint32_t value);
  public:

  // bool use_preset = 1;
  void clear_use_preset();
  bool use_preset() const;
  void set_use_preset(bool value);
  private:
  bool _internal_use_preset() const;
  void _internal_set_use_preset(bool value);
  public:

  // bool tx_enabled = 9;
  void clear_tx_enabled();
  bool tx_enabled() const;
  void set_tx_enabled(bool value);
  private:
  bool _internal_tx_enabled() const;
  void _internal_set_tx_enabled(bool value);
  public:

  // bool override_duty_cycle = 12;
  void clear_override_duty_cycle();
  bool override_duty_cycle() const;
  void set_override_duty_cycle(bool value);
  private:
  bool _internal_override_duty_cycle() const;
  void _internal_set_override_duty_cycle(bool value);
  public:

  // bool sx126x_rx_boosted_gain = 13;
  void clear_sx126x_rx_boosted_gain();
  bool sx126x_rx_boosted_gain() const;
  void set_sx126x_rx_boosted_gain(bool value);
  private:
  bool _internal_sx126x_rx_boosted_gain() const;
  void _internal_set_sx126x_rx_boosted_gain(bool value);
  public:

  // int32 tx_power = 10;
  void clear_tx_power();
  int32_t tx_power() const;
  void set_tx_power(int32_t value);
  private:
  int32_t _internal_tx_power() const;
  void _internal_set_tx_power(int32_t value);
  public:

  // uint32 channel_num = 11;
  void clear_channel_num();
  uint32_t channel_num() const;
  void set_channel_num(uint32_t value);
  private:
  uint32_t _internal_channel_num() const;
  void _internal_set_channel_num(uint32_t value);
  public:

  // float override_frequency = 14;
  void clear_override_frequency();
  float override_frequency() const;
  void set_override_frequency(float value);
  private:
  float _internal_override_frequency() const;
  void _internal_set_override_frequency(float value);
  public:

  // bool pa_fan_disabled = 15;
  void clear_pa_fan_disabled();
  bool pa_fan_disabled() const;
  void set_pa_fan_disabled(bool value);
  private:
  bool _internal_pa_fan_disabled() const;
  void _internal_set_pa_fan_disabled(bool value);
  public:

  // bool ignore_mqtt = 104;
  void clear_ignore_mqtt();
  bool ignore_mqtt() const;
  void set_ignore_mqtt(bool value);
  private:
  bool _internal_ignore_mqtt() const;
  void _internal_set_ignore_mqtt(bool value);
  public:

  // bool config_ok_to_mqtt = 105;
  void clear_config_ok_to_mqtt();
  bool config_ok_to_mqtt() const;
  void set_config_ok_to_mqtt(bool value);
  private:
  bool _internal_config_ok_to_mqtt() const;
  void _internal_set_config_ok_to_mqtt(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Config.LoRaConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > ignore_incoming_;
    mutable std::atomic<int> _ignore_incoming_cached_byte_size_;
    int modem_preset_;
    uint32_t bandwidth_;
    uint32_t spread_factor_;
    uint32_t coding_rate_;
    float frequency_offset_;
    int region_;
    uint32_t hop_limit_;
    bool use_preset_;
    bool tx_enabled_;
    bool override_duty_cycle_;
    bool sx126x_rx_boosted_gain_;
    int32_t tx_power_;
    uint32_t channel_num_;
    float override_frequency_;
    bool pa_fan_disabled_;
    bool ignore_mqtt_;
    bool config_ok_to_mqtt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config_BluetoothConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Config.BluetoothConfig) */ {
 public:
  inline Config_BluetoothConfig() : Config_BluetoothConfig(nullptr) {}
  ~Config_BluetoothConfig() override;
  explicit PROTOBUF_CONSTEXPR Config_BluetoothConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config_BluetoothConfig(const Config_BluetoothConfig& from);
  Config_BluetoothConfig(Config_BluetoothConfig&& from) noexcept
    : Config_BluetoothConfig() {
    *this = ::std::move(from);
  }

  inline Config_BluetoothConfig& operator=(const Config_BluetoothConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_BluetoothConfig& operator=(Config_BluetoothConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_BluetoothConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config_BluetoothConfig* internal_default_instance() {
    return reinterpret_cast<const Config_BluetoothConfig*>(
               &_Config_BluetoothConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Config_BluetoothConfig& a, Config_BluetoothConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_BluetoothConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_BluetoothConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_BluetoothConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config_BluetoothConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config_BluetoothConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config_BluetoothConfig& from) {
    Config_BluetoothConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_BluetoothConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Config.BluetoothConfig";
  }
  protected:
  explicit Config_BluetoothConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Config_BluetoothConfig_PairingMode PairingMode;
  static constexpr PairingMode RANDOM_PIN =
    Config_BluetoothConfig_PairingMode_RANDOM_PIN;
  static constexpr PairingMode FIXED_PIN =
    Config_BluetoothConfig_PairingMode_FIXED_PIN;
  static constexpr PairingMode NO_PIN =
    Config_BluetoothConfig_PairingMode_NO_PIN;
  static inline bool PairingMode_IsValid(int value) {
    return Config_BluetoothConfig_PairingMode_IsValid(value);
  }
  static constexpr PairingMode PairingMode_MIN =
    Config_BluetoothConfig_PairingMode_PairingMode_MIN;
  static constexpr PairingMode PairingMode_MAX =
    Config_BluetoothConfig_PairingMode_PairingMode_MAX;
  static constexpr int PairingMode_ARRAYSIZE =
    Config_BluetoothConfig_PairingMode_PairingMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PairingMode_descriptor() {
    return Config_BluetoothConfig_PairingMode_descriptor();
  }
  template<typename T>
  static inline const std::string& PairingMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PairingMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PairingMode_Name.");
    return Config_BluetoothConfig_PairingMode_Name(enum_t_value);
  }
  static inline bool PairingMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PairingMode* value) {
    return Config_BluetoothConfig_PairingMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kModeFieldNumber = 2,
    kFixedPinFieldNumber = 3,
  };
  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // .meshtastic.Config.BluetoothConfig.PairingMode mode = 2;
  void clear_mode();
  ::meshtastic::Config_BluetoothConfig_PairingMode mode() const;
  void set_mode(::meshtastic::Config_BluetoothConfig_PairingMode value);
  private:
  ::meshtastic::Config_BluetoothConfig_PairingMode _internal_mode() const;
  void _internal_set_mode(::meshtastic::Config_BluetoothConfig_PairingMode value);
  public:

  // uint32 fixed_pin = 3;
  void clear_fixed_pin();
  uint32_t fixed_pin() const;
  void set_fixed_pin(uint32_t value);
  private:
  uint32_t _internal_fixed_pin() const;
  void _internal_set_fixed_pin(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Config.BluetoothConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enabled_;
    int mode_;
    uint32_t fixed_pin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config_SecurityConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Config.SecurityConfig) */ {
 public:
  inline Config_SecurityConfig() : Config_SecurityConfig(nullptr) {}
  ~Config_SecurityConfig() override;
  explicit PROTOBUF_CONSTEXPR Config_SecurityConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config_SecurityConfig(const Config_SecurityConfig& from);
  Config_SecurityConfig(Config_SecurityConfig&& from) noexcept
    : Config_SecurityConfig() {
    *this = ::std::move(from);
  }

  inline Config_SecurityConfig& operator=(const Config_SecurityConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_SecurityConfig& operator=(Config_SecurityConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_SecurityConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config_SecurityConfig* internal_default_instance() {
    return reinterpret_cast<const Config_SecurityConfig*>(
               &_Config_SecurityConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Config_SecurityConfig& a, Config_SecurityConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_SecurityConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_SecurityConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_SecurityConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config_SecurityConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config_SecurityConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config_SecurityConfig& from) {
    Config_SecurityConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config_SecurityConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Config.SecurityConfig";
  }
  protected:
  explicit Config_SecurityConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdminKeyFieldNumber = 3,
    kPublicKeyFieldNumber = 1,
    kPrivateKeyFieldNumber = 2,
    kIsManagedFieldNumber = 4,
    kSerialEnabledFieldNumber = 5,
    kDebugLogApiEnabledFieldNumber = 6,
    kAdminChannelEnabledFieldNumber = 8,
  };
  // repeated bytes admin_key = 3;
  int admin_key_size() const;
  private:
  int _internal_admin_key_size() const;
  public:
  void clear_admin_key();
  const std::string& admin_key(int index) const;
  std::string* mutable_admin_key(int index);
  void set_admin_key(int index, const std::string& value);
  void set_admin_key(int index, std::string&& value);
  void set_admin_key(int index, const char* value);
  void set_admin_key(int index, const void* value, size_t size);
  std::string* add_admin_key();
  void add_admin_key(const std::string& value);
  void add_admin_key(std::string&& value);
  void add_admin_key(const char* value);
  void add_admin_key(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& admin_key() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_admin_key();
  private:
  const std::string& _internal_admin_key(int index) const;
  std::string* _internal_add_admin_key();
  public:

  // bytes public_key = 1;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // bytes private_key = 2;
  void clear_private_key();
  const std::string& private_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_key();
  PROTOBUF_NODISCARD std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // bool is_managed = 4;
  void clear_is_managed();
  bool is_managed() const;
  void set_is_managed(bool value);
  private:
  bool _internal_is_managed() const;
  void _internal_set_is_managed(bool value);
  public:

  // bool serial_enabled = 5;
  void clear_serial_enabled();
  bool serial_enabled() const;
  void set_serial_enabled(bool value);
  private:
  bool _internal_serial_enabled() const;
  void _internal_set_serial_enabled(bool value);
  public:

  // bool debug_log_api_enabled = 6;
  void clear_debug_log_api_enabled();
  bool debug_log_api_enabled() const;
  void set_debug_log_api_enabled(bool value);
  private:
  bool _internal_debug_log_api_enabled() const;
  void _internal_set_debug_log_api_enabled(bool value);
  public:

  // bool admin_channel_enabled = 8;
  void clear_admin_channel_enabled();
  bool admin_channel_enabled() const;
  void set_admin_channel_enabled(bool value);
  private:
  bool _internal_admin_channel_enabled() const;
  void _internal_set_admin_channel_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.Config.SecurityConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> admin_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
    bool is_managed_;
    bool serial_enabled_;
    bool debug_log_api_enabled_;
    bool admin_channel_enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config_SessionkeyConfig final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:meshtastic.Config.SessionkeyConfig) */ {
 public:
  inline Config_SessionkeyConfig() : Config_SessionkeyConfig(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Config_SessionkeyConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config_SessionkeyConfig(const Config_SessionkeyConfig& from);
  Config_SessionkeyConfig(Config_SessionkeyConfig&& from) noexcept
    : Config_SessionkeyConfig() {
    *this = ::std::move(from);
  }

  inline Config_SessionkeyConfig& operator=(const Config_SessionkeyConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_SessionkeyConfig& operator=(Config_SessionkeyConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_SessionkeyConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config_SessionkeyConfig* internal_default_instance() {
    return reinterpret_cast<const Config_SessionkeyConfig*>(
               &_Config_SessionkeyConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Config_SessionkeyConfig& a, Config_SessionkeyConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_SessionkeyConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_SessionkeyConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_SessionkeyConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config_SessionkeyConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Config_SessionkeyConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Config_SessionkeyConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Config.SessionkeyConfig";
  }
  protected:
  explicit Config_SessionkeyConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:meshtastic.Config.SessionkeyConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  explicit PROTOBUF_CONSTEXPR Config(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config(const Config& from);
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kDevice = 1,
    kPosition = 2,
    kPower = 3,
    kNetwork = 4,
    kDisplay = 5,
    kLora = 6,
    kBluetooth = 7,
    kSecurity = 8,
    kSessionkey = 9,
    kDeviceUi = 10,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };

  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config& from) {
    Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.Config";
  }
  protected:
  explicit Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Config_DeviceConfig DeviceConfig;
  typedef Config_PositionConfig PositionConfig;
  typedef Config_PowerConfig PowerConfig;
  typedef Config_NetworkConfig NetworkConfig;
  typedef Config_DisplayConfig DisplayConfig;
  typedef Config_LoRaConfig LoRaConfig;
  typedef Config_BluetoothConfig BluetoothConfig;
  typedef Config_SecurityConfig SecurityConfig;
  typedef Config_SessionkeyConfig SessionkeyConfig;

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kPositionFieldNumber = 2,
    kPowerFieldNumber = 3,
    kNetworkFieldNumber = 4,
    kDisplayFieldNumber = 5,
    kLoraFieldNumber = 6,
    kBluetoothFieldNumber = 7,
    kSecurityFieldNumber = 8,
    kSessionkeyFieldNumber = 9,
    kDeviceUiFieldNumber = 10,
  };
  // .meshtastic.Config.DeviceConfig device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::meshtastic::Config_DeviceConfig& device() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_DeviceConfig* release_device();
  ::meshtastic::Config_DeviceConfig* mutable_device();
  void set_allocated_device(::meshtastic::Config_DeviceConfig* device);
  private:
  const ::meshtastic::Config_DeviceConfig& _internal_device() const;
  ::meshtastic::Config_DeviceConfig* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::meshtastic::Config_DeviceConfig* device);
  ::meshtastic::Config_DeviceConfig* unsafe_arena_release_device();

  // .meshtastic.Config.PositionConfig position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::meshtastic::Config_PositionConfig& position() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_PositionConfig* release_position();
  ::meshtastic::Config_PositionConfig* mutable_position();
  void set_allocated_position(::meshtastic::Config_PositionConfig* position);
  private:
  const ::meshtastic::Config_PositionConfig& _internal_position() const;
  ::meshtastic::Config_PositionConfig* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::meshtastic::Config_PositionConfig* position);
  ::meshtastic::Config_PositionConfig* unsafe_arena_release_position();

  // .meshtastic.Config.PowerConfig power = 3;
  bool has_power() const;
  private:
  bool _internal_has_power() const;
  public:
  void clear_power();
  const ::meshtastic::Config_PowerConfig& power() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_PowerConfig* release_power();
  ::meshtastic::Config_PowerConfig* mutable_power();
  void set_allocated_power(::meshtastic::Config_PowerConfig* power);
  private:
  const ::meshtastic::Config_PowerConfig& _internal_power() const;
  ::meshtastic::Config_PowerConfig* _internal_mutable_power();
  public:
  void unsafe_arena_set_allocated_power(
      ::meshtastic::Config_PowerConfig* power);
  ::meshtastic::Config_PowerConfig* unsafe_arena_release_power();

  // .meshtastic.Config.NetworkConfig network = 4;
  bool has_network() const;
  private:
  bool _internal_has_network() const;
  public:
  void clear_network();
  const ::meshtastic::Config_NetworkConfig& network() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_NetworkConfig* release_network();
  ::meshtastic::Config_NetworkConfig* mutable_network();
  void set_allocated_network(::meshtastic::Config_NetworkConfig* network);
  private:
  const ::meshtastic::Config_NetworkConfig& _internal_network() const;
  ::meshtastic::Config_NetworkConfig* _internal_mutable_network();
  public:
  void unsafe_arena_set_allocated_network(
      ::meshtastic::Config_NetworkConfig* network);
  ::meshtastic::Config_NetworkConfig* unsafe_arena_release_network();

  // .meshtastic.Config.DisplayConfig display = 5;
  bool has_display() const;
  private:
  bool _internal_has_display() const;
  public:
  void clear_display();
  const ::meshtastic::Config_DisplayConfig& display() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_DisplayConfig* release_display();
  ::meshtastic::Config_DisplayConfig* mutable_display();
  void set_allocated_display(::meshtastic::Config_DisplayConfig* display);
  private:
  const ::meshtastic::Config_DisplayConfig& _internal_display() const;
  ::meshtastic::Config_DisplayConfig* _internal_mutable_display();
  public:
  void unsafe_arena_set_allocated_display(
      ::meshtastic::Config_DisplayConfig* display);
  ::meshtastic::Config_DisplayConfig* unsafe_arena_release_display();

  // .meshtastic.Config.LoRaConfig lora = 6;
  bool has_lora() const;
  private:
  bool _internal_has_lora() const;
  public:
  void clear_lora();
  const ::meshtastic::Config_LoRaConfig& lora() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_LoRaConfig* release_lora();
  ::meshtastic::Config_LoRaConfig* mutable_lora();
  void set_allocated_lora(::meshtastic::Config_LoRaConfig* lora);
  private:
  const ::meshtastic::Config_LoRaConfig& _internal_lora() const;
  ::meshtastic::Config_LoRaConfig* _internal_mutable_lora();
  public:
  void unsafe_arena_set_allocated_lora(
      ::meshtastic::Config_LoRaConfig* lora);
  ::meshtastic::Config_LoRaConfig* unsafe_arena_release_lora();

  // .meshtastic.Config.BluetoothConfig bluetooth = 7;
  bool has_bluetooth() const;
  private:
  bool _internal_has_bluetooth() const;
  public:
  void clear_bluetooth();
  const ::meshtastic::Config_BluetoothConfig& bluetooth() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_BluetoothConfig* release_bluetooth();
  ::meshtastic::Config_BluetoothConfig* mutable_bluetooth();
  void set_allocated_bluetooth(::meshtastic::Config_BluetoothConfig* bluetooth);
  private:
  const ::meshtastic::Config_BluetoothConfig& _internal_bluetooth() const;
  ::meshtastic::Config_BluetoothConfig* _internal_mutable_bluetooth();
  public:
  void unsafe_arena_set_allocated_bluetooth(
      ::meshtastic::Config_BluetoothConfig* bluetooth);
  ::meshtastic::Config_BluetoothConfig* unsafe_arena_release_bluetooth();

  // .meshtastic.Config.SecurityConfig security = 8;
  bool has_security() const;
  private:
  bool _internal_has_security() const;
  public:
  void clear_security();
  const ::meshtastic::Config_SecurityConfig& security() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_SecurityConfig* release_security();
  ::meshtastic::Config_SecurityConfig* mutable_security();
  void set_allocated_security(::meshtastic::Config_SecurityConfig* security);
  private:
  const ::meshtastic::Config_SecurityConfig& _internal_security() const;
  ::meshtastic::Config_SecurityConfig* _internal_mutable_security();
  public:
  void unsafe_arena_set_allocated_security(
      ::meshtastic::Config_SecurityConfig* security);
  ::meshtastic::Config_SecurityConfig* unsafe_arena_release_security();

  // .meshtastic.Config.SessionkeyConfig sessionkey = 9;
  bool has_sessionkey() const;
  private:
  bool _internal_has_sessionkey() const;
  public:
  void clear_sessionkey();
  const ::meshtastic::Config_SessionkeyConfig& sessionkey() const;
  PROTOBUF_NODISCARD ::meshtastic::Config_SessionkeyConfig* release_sessionkey();
  ::meshtastic::Config_SessionkeyConfig* mutable_sessionkey();
  void set_allocated_sessionkey(::meshtastic::Config_SessionkeyConfig* sessionkey);
  private:
  const ::meshtastic::Config_SessionkeyConfig& _internal_sessionkey() const;
  ::meshtastic::Config_SessionkeyConfig* _internal_mutable_sessionkey();
  public:
  void unsafe_arena_set_allocated_sessionkey(
      ::meshtastic::Config_SessionkeyConfig* sessionkey);
  ::meshtastic::Config_SessionkeyConfig* unsafe_arena_release_sessionkey();

  // .meshtastic.DeviceUIConfig device_ui = 10;
  bool has_device_ui() const;
  private:
  bool _internal_has_device_ui() const;
  public:
  void clear_device_ui();
  const ::meshtastic::DeviceUIConfig& device_ui() const;
  PROTOBUF_NODISCARD ::meshtastic::DeviceUIConfig* release_device_ui();
  ::meshtastic::DeviceUIConfig* mutable_device_ui();
  void set_allocated_device_ui(::meshtastic::DeviceUIConfig* device_ui);
  private:
  const ::meshtastic::DeviceUIConfig& _internal_device_ui() const;
  ::meshtastic::DeviceUIConfig* _internal_mutable_device_ui();
  public:
  void unsafe_arena_set_allocated_device_ui(
      ::meshtastic::DeviceUIConfig* device_ui);
  ::meshtastic::DeviceUIConfig* unsafe_arena_release_device_ui();

  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.Config)
 private:
  class _Internal;
  void set_has_device();
  void set_has_position();
  void set_has_power();
  void set_has_network();
  void set_has_display();
  void set_has_lora();
  void set_has_bluetooth();
  void set_has_security();
  void set_has_sessionkey();
  void set_has_device_ui();

  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::meshtastic::Config_DeviceConfig* device_;
      ::meshtastic::Config_PositionConfig* position_;
      ::meshtastic::Config_PowerConfig* power_;
      ::meshtastic::Config_NetworkConfig* network_;
      ::meshtastic::Config_DisplayConfig* display_;
      ::meshtastic::Config_LoRaConfig* lora_;
      ::meshtastic::Config_BluetoothConfig* bluetooth_;
      ::meshtastic::Config_SecurityConfig* security_;
      ::meshtastic::Config_SessionkeyConfig* sessionkey_;
      ::meshtastic::DeviceUIConfig* device_ui_;
    } payload_variant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Config_DeviceConfig

// .meshtastic.Config.DeviceConfig.Role role = 1;
inline void Config_DeviceConfig::clear_role() {
  _impl_.role_ = 0;
}
inline ::meshtastic::Config_DeviceConfig_Role Config_DeviceConfig::_internal_role() const {
  return static_cast< ::meshtastic::Config_DeviceConfig_Role >(_impl_.role_);
}
inline ::meshtastic::Config_DeviceConfig_Role Config_DeviceConfig::role() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.role)
  return _internal_role();
}
inline void Config_DeviceConfig::_internal_set_role(::meshtastic::Config_DeviceConfig_Role value) {
  
  _impl_.role_ = value;
}
inline void Config_DeviceConfig::set_role(::meshtastic::Config_DeviceConfig_Role value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.role)
}

// bool serial_enabled = 2 [deprecated = true];
inline void Config_DeviceConfig::clear_serial_enabled() {
  _impl_.serial_enabled_ = false;
}
inline bool Config_DeviceConfig::_internal_serial_enabled() const {
  return _impl_.serial_enabled_;
}
inline bool Config_DeviceConfig::serial_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.serial_enabled)
  return _internal_serial_enabled();
}
inline void Config_DeviceConfig::_internal_set_serial_enabled(bool value) {
  
  _impl_.serial_enabled_ = value;
}
inline void Config_DeviceConfig::set_serial_enabled(bool value) {
  _internal_set_serial_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.serial_enabled)
}

// uint32 button_gpio = 4;
inline void Config_DeviceConfig::clear_button_gpio() {
  _impl_.button_gpio_ = 0u;
}
inline uint32_t Config_DeviceConfig::_internal_button_gpio() const {
  return _impl_.button_gpio_;
}
inline uint32_t Config_DeviceConfig::button_gpio() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.button_gpio)
  return _internal_button_gpio();
}
inline void Config_DeviceConfig::_internal_set_button_gpio(uint32_t value) {
  
  _impl_.button_gpio_ = value;
}
inline void Config_DeviceConfig::set_button_gpio(uint32_t value) {
  _internal_set_button_gpio(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.button_gpio)
}

// uint32 buzzer_gpio = 5;
inline void Config_DeviceConfig::clear_buzzer_gpio() {
  _impl_.buzzer_gpio_ = 0u;
}
inline uint32_t Config_DeviceConfig::_internal_buzzer_gpio() const {
  return _impl_.buzzer_gpio_;
}
inline uint32_t Config_DeviceConfig::buzzer_gpio() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.buzzer_gpio)
  return _internal_buzzer_gpio();
}
inline void Config_DeviceConfig::_internal_set_buzzer_gpio(uint32_t value) {
  
  _impl_.buzzer_gpio_ = value;
}
inline void Config_DeviceConfig::set_buzzer_gpio(uint32_t value) {
  _internal_set_buzzer_gpio(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.buzzer_gpio)
}

// .meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;
inline void Config_DeviceConfig::clear_rebroadcast_mode() {
  _impl_.rebroadcast_mode_ = 0;
}
inline ::meshtastic::Config_DeviceConfig_RebroadcastMode Config_DeviceConfig::_internal_rebroadcast_mode() const {
  return static_cast< ::meshtastic::Config_DeviceConfig_RebroadcastMode >(_impl_.rebroadcast_mode_);
}
inline ::meshtastic::Config_DeviceConfig_RebroadcastMode Config_DeviceConfig::rebroadcast_mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.rebroadcast_mode)
  return _internal_rebroadcast_mode();
}
inline void Config_DeviceConfig::_internal_set_rebroadcast_mode(::meshtastic::Config_DeviceConfig_RebroadcastMode value) {
  
  _impl_.rebroadcast_mode_ = value;
}
inline void Config_DeviceConfig::set_rebroadcast_mode(::meshtastic::Config_DeviceConfig_RebroadcastMode value) {
  _internal_set_rebroadcast_mode(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.rebroadcast_mode)
}

// uint32 node_info_broadcast_secs = 7;
inline void Config_DeviceConfig::clear_node_info_broadcast_secs() {
  _impl_.node_info_broadcast_secs_ = 0u;
}
inline uint32_t Config_DeviceConfig::_internal_node_info_broadcast_secs() const {
  return _impl_.node_info_broadcast_secs_;
}
inline uint32_t Config_DeviceConfig::node_info_broadcast_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.node_info_broadcast_secs)
  return _internal_node_info_broadcast_secs();
}
inline void Config_DeviceConfig::_internal_set_node_info_broadcast_secs(uint32_t value) {
  
  _impl_.node_info_broadcast_secs_ = value;
}
inline void Config_DeviceConfig::set_node_info_broadcast_secs(uint32_t value) {
  _internal_set_node_info_broadcast_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.node_info_broadcast_secs)
}

// bool double_tap_as_button_press = 8;
inline void Config_DeviceConfig::clear_double_tap_as_button_press() {
  _impl_.double_tap_as_button_press_ = false;
}
inline bool Config_DeviceConfig::_internal_double_tap_as_button_press() const {
  return _impl_.double_tap_as_button_press_;
}
inline bool Config_DeviceConfig::double_tap_as_button_press() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.double_tap_as_button_press)
  return _internal_double_tap_as_button_press();
}
inline void Config_DeviceConfig::_internal_set_double_tap_as_button_press(bool value) {
  
  _impl_.double_tap_as_button_press_ = value;
}
inline void Config_DeviceConfig::set_double_tap_as_button_press(bool value) {
  _internal_set_double_tap_as_button_press(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.double_tap_as_button_press)
}

// bool is_managed = 9 [deprecated = true];
inline void Config_DeviceConfig::clear_is_managed() {
  _impl_.is_managed_ = false;
}
inline bool Config_DeviceConfig::_internal_is_managed() const {
  return _impl_.is_managed_;
}
inline bool Config_DeviceConfig::is_managed() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.is_managed)
  return _internal_is_managed();
}
inline void Config_DeviceConfig::_internal_set_is_managed(bool value) {
  
  _impl_.is_managed_ = value;
}
inline void Config_DeviceConfig::set_is_managed(bool value) {
  _internal_set_is_managed(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.is_managed)
}

// bool disable_triple_click = 10;
inline void Config_DeviceConfig::clear_disable_triple_click() {
  _impl_.disable_triple_click_ = false;
}
inline bool Config_DeviceConfig::_internal_disable_triple_click() const {
  return _impl_.disable_triple_click_;
}
inline bool Config_DeviceConfig::disable_triple_click() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.disable_triple_click)
  return _internal_disable_triple_click();
}
inline void Config_DeviceConfig::_internal_set_disable_triple_click(bool value) {
  
  _impl_.disable_triple_click_ = value;
}
inline void Config_DeviceConfig::set_disable_triple_click(bool value) {
  _internal_set_disable_triple_click(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.disable_triple_click)
}

// string tzdef = 11;
inline void Config_DeviceConfig::clear_tzdef() {
  _impl_.tzdef_.ClearToEmpty();
}
inline const std::string& Config_DeviceConfig::tzdef() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.tzdef)
  return _internal_tzdef();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config_DeviceConfig::set_tzdef(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tzdef_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.tzdef)
}
inline std::string* Config_DeviceConfig::mutable_tzdef() {
  std::string* _s = _internal_mutable_tzdef();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.DeviceConfig.tzdef)
  return _s;
}
inline const std::string& Config_DeviceConfig::_internal_tzdef() const {
  return _impl_.tzdef_.Get();
}
inline void Config_DeviceConfig::_internal_set_tzdef(const std::string& value) {
  
  _impl_.tzdef_.Set(value, GetArenaForAllocation());
}
inline std::string* Config_DeviceConfig::_internal_mutable_tzdef() {
  
  return _impl_.tzdef_.Mutable(GetArenaForAllocation());
}
inline std::string* Config_DeviceConfig::release_tzdef() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.DeviceConfig.tzdef)
  return _impl_.tzdef_.Release();
}
inline void Config_DeviceConfig::set_allocated_tzdef(std::string* tzdef) {
  if (tzdef != nullptr) {
    
  } else {
    
  }
  _impl_.tzdef_.SetAllocated(tzdef, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tzdef_.IsDefault()) {
    _impl_.tzdef_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.DeviceConfig.tzdef)
}

// bool led_heartbeat_disabled = 12;
inline void Config_DeviceConfig::clear_led_heartbeat_disabled() {
  _impl_.led_heartbeat_disabled_ = false;
}
inline bool Config_DeviceConfig::_internal_led_heartbeat_disabled() const {
  return _impl_.led_heartbeat_disabled_;
}
inline bool Config_DeviceConfig::led_heartbeat_disabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.led_heartbeat_disabled)
  return _internal_led_heartbeat_disabled();
}
inline void Config_DeviceConfig::_internal_set_led_heartbeat_disabled(bool value) {
  
  _impl_.led_heartbeat_disabled_ = value;
}
inline void Config_DeviceConfig::set_led_heartbeat_disabled(bool value) {
  _internal_set_led_heartbeat_disabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.led_heartbeat_disabled)
}

// .meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;
inline void Config_DeviceConfig::clear_buzzer_mode() {
  _impl_.buzzer_mode_ = 0;
}
inline ::meshtastic::Config_DeviceConfig_BuzzerMode Config_DeviceConfig::_internal_buzzer_mode() const {
  return static_cast< ::meshtastic::Config_DeviceConfig_BuzzerMode >(_impl_.buzzer_mode_);
}
inline ::meshtastic::Config_DeviceConfig_BuzzerMode Config_DeviceConfig::buzzer_mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.buzzer_mode)
  return _internal_buzzer_mode();
}
inline void Config_DeviceConfig::_internal_set_buzzer_mode(::meshtastic::Config_DeviceConfig_BuzzerMode value) {
  
  _impl_.buzzer_mode_ = value;
}
inline void Config_DeviceConfig::set_buzzer_mode(::meshtastic::Config_DeviceConfig_BuzzerMode value) {
  _internal_set_buzzer_mode(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.buzzer_mode)
}

// -------------------------------------------------------------------

// Config_PositionConfig

// uint32 position_broadcast_secs = 1;
inline void Config_PositionConfig::clear_position_broadcast_secs() {
  _impl_.position_broadcast_secs_ = 0u;
}
inline uint32_t Config_PositionConfig::_internal_position_broadcast_secs() const {
  return _impl_.position_broadcast_secs_;
}
inline uint32_t Config_PositionConfig::position_broadcast_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.position_broadcast_secs)
  return _internal_position_broadcast_secs();
}
inline void Config_PositionConfig::_internal_set_position_broadcast_secs(uint32_t value) {
  
  _impl_.position_broadcast_secs_ = value;
}
inline void Config_PositionConfig::set_position_broadcast_secs(uint32_t value) {
  _internal_set_position_broadcast_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.position_broadcast_secs)
}

// bool position_broadcast_smart_enabled = 2;
inline void Config_PositionConfig::clear_position_broadcast_smart_enabled() {
  _impl_.position_broadcast_smart_enabled_ = false;
}
inline bool Config_PositionConfig::_internal_position_broadcast_smart_enabled() const {
  return _impl_.position_broadcast_smart_enabled_;
}
inline bool Config_PositionConfig::position_broadcast_smart_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.position_broadcast_smart_enabled)
  return _internal_position_broadcast_smart_enabled();
}
inline void Config_PositionConfig::_internal_set_position_broadcast_smart_enabled(bool value) {
  
  _impl_.position_broadcast_smart_enabled_ = value;
}
inline void Config_PositionConfig::set_position_broadcast_smart_enabled(bool value) {
  _internal_set_position_broadcast_smart_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.position_broadcast_smart_enabled)
}

// bool fixed_position = 3;
inline void Config_PositionConfig::clear_fixed_position() {
  _impl_.fixed_position_ = false;
}
inline bool Config_PositionConfig::_internal_fixed_position() const {
  return _impl_.fixed_position_;
}
inline bool Config_PositionConfig::fixed_position() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.fixed_position)
  return _internal_fixed_position();
}
inline void Config_PositionConfig::_internal_set_fixed_position(bool value) {
  
  _impl_.fixed_position_ = value;
}
inline void Config_PositionConfig::set_fixed_position(bool value) {
  _internal_set_fixed_position(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.fixed_position)
}

// bool gps_enabled = 4 [deprecated = true];
inline void Config_PositionConfig::clear_gps_enabled() {
  _impl_.gps_enabled_ = false;
}
inline bool Config_PositionConfig::_internal_gps_enabled() const {
  return _impl_.gps_enabled_;
}
inline bool Config_PositionConfig::gps_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.gps_enabled)
  return _internal_gps_enabled();
}
inline void Config_PositionConfig::_internal_set_gps_enabled(bool value) {
  
  _impl_.gps_enabled_ = value;
}
inline void Config_PositionConfig::set_gps_enabled(bool value) {
  _internal_set_gps_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.gps_enabled)
}

// uint32 gps_update_interval = 5;
inline void Config_PositionConfig::clear_gps_update_interval() {
  _impl_.gps_update_interval_ = 0u;
}
inline uint32_t Config_PositionConfig::_internal_gps_update_interval() const {
  return _impl_.gps_update_interval_;
}
inline uint32_t Config_PositionConfig::gps_update_interval() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.gps_update_interval)
  return _internal_gps_update_interval();
}
inline void Config_PositionConfig::_internal_set_gps_update_interval(uint32_t value) {
  
  _impl_.gps_update_interval_ = value;
}
inline void Config_PositionConfig::set_gps_update_interval(uint32_t value) {
  _internal_set_gps_update_interval(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.gps_update_interval)
}

// uint32 gps_attempt_time = 6 [deprecated = true];
inline void Config_PositionConfig::clear_gps_attempt_time() {
  _impl_.gps_attempt_time_ = 0u;
}
inline uint32_t Config_PositionConfig::_internal_gps_attempt_time() const {
  return _impl_.gps_attempt_time_;
}
inline uint32_t Config_PositionConfig::gps_attempt_time() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.gps_attempt_time)
  return _internal_gps_attempt_time();
}
inline void Config_PositionConfig::_internal_set_gps_attempt_time(uint32_t value) {
  
  _impl_.gps_attempt_time_ = value;
}
inline void Config_PositionConfig::set_gps_attempt_time(uint32_t value) {
  _internal_set_gps_attempt_time(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.gps_attempt_time)
}

// uint32 position_flags = 7;
inline void Config_PositionConfig::clear_position_flags() {
  _impl_.position_flags_ = 0u;
}
inline uint32_t Config_PositionConfig::_internal_position_flags() const {
  return _impl_.position_flags_;
}
inline uint32_t Config_PositionConfig::position_flags() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.position_flags)
  return _internal_position_flags();
}
inline void Config_PositionConfig::_internal_set_position_flags(uint32_t value) {
  
  _impl_.position_flags_ = value;
}
inline void Config_PositionConfig::set_position_flags(uint32_t value) {
  _internal_set_position_flags(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.position_flags)
}

// uint32 rx_gpio = 8;
inline void Config_PositionConfig::clear_rx_gpio() {
  _impl_.rx_gpio_ = 0u;
}
inline uint32_t Config_PositionConfig::_internal_rx_gpio() const {
  return _impl_.rx_gpio_;
}
inline uint32_t Config_PositionConfig::rx_gpio() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.rx_gpio)
  return _internal_rx_gpio();
}
inline void Config_PositionConfig::_internal_set_rx_gpio(uint32_t value) {
  
  _impl_.rx_gpio_ = value;
}
inline void Config_PositionConfig::set_rx_gpio(uint32_t value) {
  _internal_set_rx_gpio(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.rx_gpio)
}

// uint32 tx_gpio = 9;
inline void Config_PositionConfig::clear_tx_gpio() {
  _impl_.tx_gpio_ = 0u;
}
inline uint32_t Config_PositionConfig::_internal_tx_gpio() const {
  return _impl_.tx_gpio_;
}
inline uint32_t Config_PositionConfig::tx_gpio() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.tx_gpio)
  return _internal_tx_gpio();
}
inline void Config_PositionConfig::_internal_set_tx_gpio(uint32_t value) {
  
  _impl_.tx_gpio_ = value;
}
inline void Config_PositionConfig::set_tx_gpio(uint32_t value) {
  _internal_set_tx_gpio(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.tx_gpio)
}

// uint32 broadcast_smart_minimum_distance = 10;
inline void Config_PositionConfig::clear_broadcast_smart_minimum_distance() {
  _impl_.broadcast_smart_minimum_distance_ = 0u;
}
inline uint32_t Config_PositionConfig::_internal_broadcast_smart_minimum_distance() const {
  return _impl_.broadcast_smart_minimum_distance_;
}
inline uint32_t Config_PositionConfig::broadcast_smart_minimum_distance() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.broadcast_smart_minimum_distance)
  return _internal_broadcast_smart_minimum_distance();
}
inline void Config_PositionConfig::_internal_set_broadcast_smart_minimum_distance(uint32_t value) {
  
  _impl_.broadcast_smart_minimum_distance_ = value;
}
inline void Config_PositionConfig::set_broadcast_smart_minimum_distance(uint32_t value) {
  _internal_set_broadcast_smart_minimum_distance(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.broadcast_smart_minimum_distance)
}

// uint32 broadcast_smart_minimum_interval_secs = 11;
inline void Config_PositionConfig::clear_broadcast_smart_minimum_interval_secs() {
  _impl_.broadcast_smart_minimum_interval_secs_ = 0u;
}
inline uint32_t Config_PositionConfig::_internal_broadcast_smart_minimum_interval_secs() const {
  return _impl_.broadcast_smart_minimum_interval_secs_;
}
inline uint32_t Config_PositionConfig::broadcast_smart_minimum_interval_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.broadcast_smart_minimum_interval_secs)
  return _internal_broadcast_smart_minimum_interval_secs();
}
inline void Config_PositionConfig::_internal_set_broadcast_smart_minimum_interval_secs(uint32_t value) {
  
  _impl_.broadcast_smart_minimum_interval_secs_ = value;
}
inline void Config_PositionConfig::set_broadcast_smart_minimum_interval_secs(uint32_t value) {
  _internal_set_broadcast_smart_minimum_interval_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.broadcast_smart_minimum_interval_secs)
}

// uint32 gps_en_gpio = 12;
inline void Config_PositionConfig::clear_gps_en_gpio() {
  _impl_.gps_en_gpio_ = 0u;
}
inline uint32_t Config_PositionConfig::_internal_gps_en_gpio() const {
  return _impl_.gps_en_gpio_;
}
inline uint32_t Config_PositionConfig::gps_en_gpio() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.gps_en_gpio)
  return _internal_gps_en_gpio();
}
inline void Config_PositionConfig::_internal_set_gps_en_gpio(uint32_t value) {
  
  _impl_.gps_en_gpio_ = value;
}
inline void Config_PositionConfig::set_gps_en_gpio(uint32_t value) {
  _internal_set_gps_en_gpio(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.gps_en_gpio)
}

// .meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;
inline void Config_PositionConfig::clear_gps_mode() {
  _impl_.gps_mode_ = 0;
}
inline ::meshtastic::Config_PositionConfig_GpsMode Config_PositionConfig::_internal_gps_mode() const {
  return static_cast< ::meshtastic::Config_PositionConfig_GpsMode >(_impl_.gps_mode_);
}
inline ::meshtastic::Config_PositionConfig_GpsMode Config_PositionConfig::gps_mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.gps_mode)
  return _internal_gps_mode();
}
inline void Config_PositionConfig::_internal_set_gps_mode(::meshtastic::Config_PositionConfig_GpsMode value) {
  
  _impl_.gps_mode_ = value;
}
inline void Config_PositionConfig::set_gps_mode(::meshtastic::Config_PositionConfig_GpsMode value) {
  _internal_set_gps_mode(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.gps_mode)
}

// -------------------------------------------------------------------

// Config_PowerConfig

// bool is_power_saving = 1;
inline void Config_PowerConfig::clear_is_power_saving() {
  _impl_.is_power_saving_ = false;
}
inline bool Config_PowerConfig::_internal_is_power_saving() const {
  return _impl_.is_power_saving_;
}
inline bool Config_PowerConfig::is_power_saving() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.is_power_saving)
  return _internal_is_power_saving();
}
inline void Config_PowerConfig::_internal_set_is_power_saving(bool value) {
  
  _impl_.is_power_saving_ = value;
}
inline void Config_PowerConfig::set_is_power_saving(bool value) {
  _internal_set_is_power_saving(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.is_power_saving)
}

// uint32 on_battery_shutdown_after_secs = 2;
inline void Config_PowerConfig::clear_on_battery_shutdown_after_secs() {
  _impl_.on_battery_shutdown_after_secs_ = 0u;
}
inline uint32_t Config_PowerConfig::_internal_on_battery_shutdown_after_secs() const {
  return _impl_.on_battery_shutdown_after_secs_;
}
inline uint32_t Config_PowerConfig::on_battery_shutdown_after_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.on_battery_shutdown_after_secs)
  return _internal_on_battery_shutdown_after_secs();
}
inline void Config_PowerConfig::_internal_set_on_battery_shutdown_after_secs(uint32_t value) {
  
  _impl_.on_battery_shutdown_after_secs_ = value;
}
inline void Config_PowerConfig::set_on_battery_shutdown_after_secs(uint32_t value) {
  _internal_set_on_battery_shutdown_after_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.on_battery_shutdown_after_secs)
}

// float adc_multiplier_override = 3;
inline void Config_PowerConfig::clear_adc_multiplier_override() {
  _impl_.adc_multiplier_override_ = 0;
}
inline float Config_PowerConfig::_internal_adc_multiplier_override() const {
  return _impl_.adc_multiplier_override_;
}
inline float Config_PowerConfig::adc_multiplier_override() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.adc_multiplier_override)
  return _internal_adc_multiplier_override();
}
inline void Config_PowerConfig::_internal_set_adc_multiplier_override(float value) {
  
  _impl_.adc_multiplier_override_ = value;
}
inline void Config_PowerConfig::set_adc_multiplier_override(float value) {
  _internal_set_adc_multiplier_override(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.adc_multiplier_override)
}

// uint32 wait_bluetooth_secs = 4;
inline void Config_PowerConfig::clear_wait_bluetooth_secs() {
  _impl_.wait_bluetooth_secs_ = 0u;
}
inline uint32_t Config_PowerConfig::_internal_wait_bluetooth_secs() const {
  return _impl_.wait_bluetooth_secs_;
}
inline uint32_t Config_PowerConfig::wait_bluetooth_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.wait_bluetooth_secs)
  return _internal_wait_bluetooth_secs();
}
inline void Config_PowerConfig::_internal_set_wait_bluetooth_secs(uint32_t value) {
  
  _impl_.wait_bluetooth_secs_ = value;
}
inline void Config_PowerConfig::set_wait_bluetooth_secs(uint32_t value) {
  _internal_set_wait_bluetooth_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.wait_bluetooth_secs)
}

// uint32 sds_secs = 6;
inline void Config_PowerConfig::clear_sds_secs() {
  _impl_.sds_secs_ = 0u;
}
inline uint32_t Config_PowerConfig::_internal_sds_secs() const {
  return _impl_.sds_secs_;
}
inline uint32_t Config_PowerConfig::sds_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.sds_secs)
  return _internal_sds_secs();
}
inline void Config_PowerConfig::_internal_set_sds_secs(uint32_t value) {
  
  _impl_.sds_secs_ = value;
}
inline void Config_PowerConfig::set_sds_secs(uint32_t value) {
  _internal_set_sds_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.sds_secs)
}

// uint32 ls_secs = 7;
inline void Config_PowerConfig::clear_ls_secs() {
  _impl_.ls_secs_ = 0u;
}
inline uint32_t Config_PowerConfig::_internal_ls_secs() const {
  return _impl_.ls_secs_;
}
inline uint32_t Config_PowerConfig::ls_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.ls_secs)
  return _internal_ls_secs();
}
inline void Config_PowerConfig::_internal_set_ls_secs(uint32_t value) {
  
  _impl_.ls_secs_ = value;
}
inline void Config_PowerConfig::set_ls_secs(uint32_t value) {
  _internal_set_ls_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.ls_secs)
}

// uint32 min_wake_secs = 8;
inline void Config_PowerConfig::clear_min_wake_secs() {
  _impl_.min_wake_secs_ = 0u;
}
inline uint32_t Config_PowerConfig::_internal_min_wake_secs() const {
  return _impl_.min_wake_secs_;
}
inline uint32_t Config_PowerConfig::min_wake_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.min_wake_secs)
  return _internal_min_wake_secs();
}
inline void Config_PowerConfig::_internal_set_min_wake_secs(uint32_t value) {
  
  _impl_.min_wake_secs_ = value;
}
inline void Config_PowerConfig::set_min_wake_secs(uint32_t value) {
  _internal_set_min_wake_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.min_wake_secs)
}

// uint32 device_battery_ina_address = 9;
inline void Config_PowerConfig::clear_device_battery_ina_address() {
  _impl_.device_battery_ina_address_ = 0u;
}
inline uint32_t Config_PowerConfig::_internal_device_battery_ina_address() const {
  return _impl_.device_battery_ina_address_;
}
inline uint32_t Config_PowerConfig::device_battery_ina_address() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.device_battery_ina_address)
  return _internal_device_battery_ina_address();
}
inline void Config_PowerConfig::_internal_set_device_battery_ina_address(uint32_t value) {
  
  _impl_.device_battery_ina_address_ = value;
}
inline void Config_PowerConfig::set_device_battery_ina_address(uint32_t value) {
  _internal_set_device_battery_ina_address(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.device_battery_ina_address)
}

// uint64 powermon_enables = 32;
inline void Config_PowerConfig::clear_powermon_enables() {
  _impl_.powermon_enables_ = uint64_t{0u};
}
inline uint64_t Config_PowerConfig::_internal_powermon_enables() const {
  return _impl_.powermon_enables_;
}
inline uint64_t Config_PowerConfig::powermon_enables() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.powermon_enables)
  return _internal_powermon_enables();
}
inline void Config_PowerConfig::_internal_set_powermon_enables(uint64_t value) {
  
  _impl_.powermon_enables_ = value;
}
inline void Config_PowerConfig::set_powermon_enables(uint64_t value) {
  _internal_set_powermon_enables(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.powermon_enables)
}

// -------------------------------------------------------------------

// Config_NetworkConfig_IpV4Config

// fixed32 ip = 1;
inline void Config_NetworkConfig_IpV4Config::clear_ip() {
  _impl_.ip_ = 0u;
}
inline uint32_t Config_NetworkConfig_IpV4Config::_internal_ip() const {
  return _impl_.ip_;
}
inline uint32_t Config_NetworkConfig_IpV4Config::ip() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.IpV4Config.ip)
  return _internal_ip();
}
inline void Config_NetworkConfig_IpV4Config::_internal_set_ip(uint32_t value) {
  
  _impl_.ip_ = value;
}
inline void Config_NetworkConfig_IpV4Config::set_ip(uint32_t value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.IpV4Config.ip)
}

// fixed32 gateway = 2;
inline void Config_NetworkConfig_IpV4Config::clear_gateway() {
  _impl_.gateway_ = 0u;
}
inline uint32_t Config_NetworkConfig_IpV4Config::_internal_gateway() const {
  return _impl_.gateway_;
}
inline uint32_t Config_NetworkConfig_IpV4Config::gateway() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.IpV4Config.gateway)
  return _internal_gateway();
}
inline void Config_NetworkConfig_IpV4Config::_internal_set_gateway(uint32_t value) {
  
  _impl_.gateway_ = value;
}
inline void Config_NetworkConfig_IpV4Config::set_gateway(uint32_t value) {
  _internal_set_gateway(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.IpV4Config.gateway)
}

// fixed32 subnet = 3;
inline void Config_NetworkConfig_IpV4Config::clear_subnet() {
  _impl_.subnet_ = 0u;
}
inline uint32_t Config_NetworkConfig_IpV4Config::_internal_subnet() const {
  return _impl_.subnet_;
}
inline uint32_t Config_NetworkConfig_IpV4Config::subnet() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.IpV4Config.subnet)
  return _internal_subnet();
}
inline void Config_NetworkConfig_IpV4Config::_internal_set_subnet(uint32_t value) {
  
  _impl_.subnet_ = value;
}
inline void Config_NetworkConfig_IpV4Config::set_subnet(uint32_t value) {
  _internal_set_subnet(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.IpV4Config.subnet)
}

// fixed32 dns = 4;
inline void Config_NetworkConfig_IpV4Config::clear_dns() {
  _impl_.dns_ = 0u;
}
inline uint32_t Config_NetworkConfig_IpV4Config::_internal_dns() const {
  return _impl_.dns_;
}
inline uint32_t Config_NetworkConfig_IpV4Config::dns() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.IpV4Config.dns)
  return _internal_dns();
}
inline void Config_NetworkConfig_IpV4Config::_internal_set_dns(uint32_t value) {
  
  _impl_.dns_ = value;
}
inline void Config_NetworkConfig_IpV4Config::set_dns(uint32_t value) {
  _internal_set_dns(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.IpV4Config.dns)
}

// -------------------------------------------------------------------

// Config_NetworkConfig

// bool wifi_enabled = 1;
inline void Config_NetworkConfig::clear_wifi_enabled() {
  _impl_.wifi_enabled_ = false;
}
inline bool Config_NetworkConfig::_internal_wifi_enabled() const {
  return _impl_.wifi_enabled_;
}
inline bool Config_NetworkConfig::wifi_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.wifi_enabled)
  return _internal_wifi_enabled();
}
inline void Config_NetworkConfig::_internal_set_wifi_enabled(bool value) {
  
  _impl_.wifi_enabled_ = value;
}
inline void Config_NetworkConfig::set_wifi_enabled(bool value) {
  _internal_set_wifi_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.wifi_enabled)
}

// string wifi_ssid = 3;
inline void Config_NetworkConfig::clear_wifi_ssid() {
  _impl_.wifi_ssid_.ClearToEmpty();
}
inline const std::string& Config_NetworkConfig::wifi_ssid() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.wifi_ssid)
  return _internal_wifi_ssid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config_NetworkConfig::set_wifi_ssid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wifi_ssid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.wifi_ssid)
}
inline std::string* Config_NetworkConfig::mutable_wifi_ssid() {
  std::string* _s = _internal_mutable_wifi_ssid();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.NetworkConfig.wifi_ssid)
  return _s;
}
inline const std::string& Config_NetworkConfig::_internal_wifi_ssid() const {
  return _impl_.wifi_ssid_.Get();
}
inline void Config_NetworkConfig::_internal_set_wifi_ssid(const std::string& value) {
  
  _impl_.wifi_ssid_.Set(value, GetArenaForAllocation());
}
inline std::string* Config_NetworkConfig::_internal_mutable_wifi_ssid() {
  
  return _impl_.wifi_ssid_.Mutable(GetArenaForAllocation());
}
inline std::string* Config_NetworkConfig::release_wifi_ssid() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.NetworkConfig.wifi_ssid)
  return _impl_.wifi_ssid_.Release();
}
inline void Config_NetworkConfig::set_allocated_wifi_ssid(std::string* wifi_ssid) {
  if (wifi_ssid != nullptr) {
    
  } else {
    
  }
  _impl_.wifi_ssid_.SetAllocated(wifi_ssid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wifi_ssid_.IsDefault()) {
    _impl_.wifi_ssid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.NetworkConfig.wifi_ssid)
}

// string wifi_psk = 4;
inline void Config_NetworkConfig::clear_wifi_psk() {
  _impl_.wifi_psk_.ClearToEmpty();
}
inline const std::string& Config_NetworkConfig::wifi_psk() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.wifi_psk)
  return _internal_wifi_psk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config_NetworkConfig::set_wifi_psk(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wifi_psk_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.wifi_psk)
}
inline std::string* Config_NetworkConfig::mutable_wifi_psk() {
  std::string* _s = _internal_mutable_wifi_psk();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.NetworkConfig.wifi_psk)
  return _s;
}
inline const std::string& Config_NetworkConfig::_internal_wifi_psk() const {
  return _impl_.wifi_psk_.Get();
}
inline void Config_NetworkConfig::_internal_set_wifi_psk(const std::string& value) {
  
  _impl_.wifi_psk_.Set(value, GetArenaForAllocation());
}
inline std::string* Config_NetworkConfig::_internal_mutable_wifi_psk() {
  
  return _impl_.wifi_psk_.Mutable(GetArenaForAllocation());
}
inline std::string* Config_NetworkConfig::release_wifi_psk() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.NetworkConfig.wifi_psk)
  return _impl_.wifi_psk_.Release();
}
inline void Config_NetworkConfig::set_allocated_wifi_psk(std::string* wifi_psk) {
  if (wifi_psk != nullptr) {
    
  } else {
    
  }
  _impl_.wifi_psk_.SetAllocated(wifi_psk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wifi_psk_.IsDefault()) {
    _impl_.wifi_psk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.NetworkConfig.wifi_psk)
}

// string ntp_server = 5;
inline void Config_NetworkConfig::clear_ntp_server() {
  _impl_.ntp_server_.ClearToEmpty();
}
inline const std::string& Config_NetworkConfig::ntp_server() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.ntp_server)
  return _internal_ntp_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config_NetworkConfig::set_ntp_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ntp_server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.ntp_server)
}
inline std::string* Config_NetworkConfig::mutable_ntp_server() {
  std::string* _s = _internal_mutable_ntp_server();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.NetworkConfig.ntp_server)
  return _s;
}
inline const std::string& Config_NetworkConfig::_internal_ntp_server() const {
  return _impl_.ntp_server_.Get();
}
inline void Config_NetworkConfig::_internal_set_ntp_server(const std::string& value) {
  
  _impl_.ntp_server_.Set(value, GetArenaForAllocation());
}
inline std::string* Config_NetworkConfig::_internal_mutable_ntp_server() {
  
  return _impl_.ntp_server_.Mutable(GetArenaForAllocation());
}
inline std::string* Config_NetworkConfig::release_ntp_server() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.NetworkConfig.ntp_server)
  return _impl_.ntp_server_.Release();
}
inline void Config_NetworkConfig::set_allocated_ntp_server(std::string* ntp_server) {
  if (ntp_server != nullptr) {
    
  } else {
    
  }
  _impl_.ntp_server_.SetAllocated(ntp_server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ntp_server_.IsDefault()) {
    _impl_.ntp_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.NetworkConfig.ntp_server)
}

// bool eth_enabled = 6;
inline void Config_NetworkConfig::clear_eth_enabled() {
  _impl_.eth_enabled_ = false;
}
inline bool Config_NetworkConfig::_internal_eth_enabled() const {
  return _impl_.eth_enabled_;
}
inline bool Config_NetworkConfig::eth_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.eth_enabled)
  return _internal_eth_enabled();
}
inline void Config_NetworkConfig::_internal_set_eth_enabled(bool value) {
  
  _impl_.eth_enabled_ = value;
}
inline void Config_NetworkConfig::set_eth_enabled(bool value) {
  _internal_set_eth_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.eth_enabled)
}

// .meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;
inline void Config_NetworkConfig::clear_address_mode() {
  _impl_.address_mode_ = 0;
}
inline ::meshtastic::Config_NetworkConfig_AddressMode Config_NetworkConfig::_internal_address_mode() const {
  return static_cast< ::meshtastic::Config_NetworkConfig_AddressMode >(_impl_.address_mode_);
}
inline ::meshtastic::Config_NetworkConfig_AddressMode Config_NetworkConfig::address_mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.address_mode)
  return _internal_address_mode();
}
inline void Config_NetworkConfig::_internal_set_address_mode(::meshtastic::Config_NetworkConfig_AddressMode value) {
  
  _impl_.address_mode_ = value;
}
inline void Config_NetworkConfig::set_address_mode(::meshtastic::Config_NetworkConfig_AddressMode value) {
  _internal_set_address_mode(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.address_mode)
}

// .meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;
inline bool Config_NetworkConfig::_internal_has_ipv4_config() const {
  return this != internal_default_instance() && _impl_.ipv4_config_ != nullptr;
}
inline bool Config_NetworkConfig::has_ipv4_config() const {
  return _internal_has_ipv4_config();
}
inline void Config_NetworkConfig::clear_ipv4_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.ipv4_config_ != nullptr) {
    delete _impl_.ipv4_config_;
  }
  _impl_.ipv4_config_ = nullptr;
}
inline const ::meshtastic::Config_NetworkConfig_IpV4Config& Config_NetworkConfig::_internal_ipv4_config() const {
  const ::meshtastic::Config_NetworkConfig_IpV4Config* p = _impl_.ipv4_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Config_NetworkConfig_IpV4Config&>(
      ::meshtastic::_Config_NetworkConfig_IpV4Config_default_instance_);
}
inline const ::meshtastic::Config_NetworkConfig_IpV4Config& Config_NetworkConfig::ipv4_config() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.ipv4_config)
  return _internal_ipv4_config();
}
inline void Config_NetworkConfig::unsafe_arena_set_allocated_ipv4_config(
    ::meshtastic::Config_NetworkConfig_IpV4Config* ipv4_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ipv4_config_);
  }
  _impl_.ipv4_config_ = ipv4_config;
  if (ipv4_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.NetworkConfig.ipv4_config)
}
inline ::meshtastic::Config_NetworkConfig_IpV4Config* Config_NetworkConfig::release_ipv4_config() {
  
  ::meshtastic::Config_NetworkConfig_IpV4Config* temp = _impl_.ipv4_config_;
  _impl_.ipv4_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::Config_NetworkConfig_IpV4Config* Config_NetworkConfig::unsafe_arena_release_ipv4_config() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.NetworkConfig.ipv4_config)
  
  ::meshtastic::Config_NetworkConfig_IpV4Config* temp = _impl_.ipv4_config_;
  _impl_.ipv4_config_ = nullptr;
  return temp;
}
inline ::meshtastic::Config_NetworkConfig_IpV4Config* Config_NetworkConfig::_internal_mutable_ipv4_config() {
  
  if (_impl_.ipv4_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::Config_NetworkConfig_IpV4Config>(GetArenaForAllocation());
    _impl_.ipv4_config_ = p;
  }
  return _impl_.ipv4_config_;
}
inline ::meshtastic::Config_NetworkConfig_IpV4Config* Config_NetworkConfig::mutable_ipv4_config() {
  ::meshtastic::Config_NetworkConfig_IpV4Config* _msg = _internal_mutable_ipv4_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.NetworkConfig.ipv4_config)
  return _msg;
}
inline void Config_NetworkConfig::set_allocated_ipv4_config(::meshtastic::Config_NetworkConfig_IpV4Config* ipv4_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ipv4_config_;
  }
  if (ipv4_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ipv4_config);
    if (message_arena != submessage_arena) {
      ipv4_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ipv4_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ipv4_config_ = ipv4_config;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.NetworkConfig.ipv4_config)
}

// string rsyslog_server = 9;
inline void Config_NetworkConfig::clear_rsyslog_server() {
  _impl_.rsyslog_server_.ClearToEmpty();
}
inline const std::string& Config_NetworkConfig::rsyslog_server() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.rsyslog_server)
  return _internal_rsyslog_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config_NetworkConfig::set_rsyslog_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rsyslog_server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.rsyslog_server)
}
inline std::string* Config_NetworkConfig::mutable_rsyslog_server() {
  std::string* _s = _internal_mutable_rsyslog_server();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.NetworkConfig.rsyslog_server)
  return _s;
}
inline const std::string& Config_NetworkConfig::_internal_rsyslog_server() const {
  return _impl_.rsyslog_server_.Get();
}
inline void Config_NetworkConfig::_internal_set_rsyslog_server(const std::string& value) {
  
  _impl_.rsyslog_server_.Set(value, GetArenaForAllocation());
}
inline std::string* Config_NetworkConfig::_internal_mutable_rsyslog_server() {
  
  return _impl_.rsyslog_server_.Mutable(GetArenaForAllocation());
}
inline std::string* Config_NetworkConfig::release_rsyslog_server() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.NetworkConfig.rsyslog_server)
  return _impl_.rsyslog_server_.Release();
}
inline void Config_NetworkConfig::set_allocated_rsyslog_server(std::string* rsyslog_server) {
  if (rsyslog_server != nullptr) {
    
  } else {
    
  }
  _impl_.rsyslog_server_.SetAllocated(rsyslog_server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rsyslog_server_.IsDefault()) {
    _impl_.rsyslog_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.NetworkConfig.rsyslog_server)
}

// uint32 enabled_protocols = 10;
inline void Config_NetworkConfig::clear_enabled_protocols() {
  _impl_.enabled_protocols_ = 0u;
}
inline uint32_t Config_NetworkConfig::_internal_enabled_protocols() const {
  return _impl_.enabled_protocols_;
}
inline uint32_t Config_NetworkConfig::enabled_protocols() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.enabled_protocols)
  return _internal_enabled_protocols();
}
inline void Config_NetworkConfig::_internal_set_enabled_protocols(uint32_t value) {
  
  _impl_.enabled_protocols_ = value;
}
inline void Config_NetworkConfig::set_enabled_protocols(uint32_t value) {
  _internal_set_enabled_protocols(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.enabled_protocols)
}

// bool ipv6_enabled = 11;
inline void Config_NetworkConfig::clear_ipv6_enabled() {
  _impl_.ipv6_enabled_ = false;
}
inline bool Config_NetworkConfig::_internal_ipv6_enabled() const {
  return _impl_.ipv6_enabled_;
}
inline bool Config_NetworkConfig::ipv6_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.ipv6_enabled)
  return _internal_ipv6_enabled();
}
inline void Config_NetworkConfig::_internal_set_ipv6_enabled(bool value) {
  
  _impl_.ipv6_enabled_ = value;
}
inline void Config_NetworkConfig::set_ipv6_enabled(bool value) {
  _internal_set_ipv6_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.ipv6_enabled)
}

// -------------------------------------------------------------------

// Config_DisplayConfig

// uint32 screen_on_secs = 1;
inline void Config_DisplayConfig::clear_screen_on_secs() {
  _impl_.screen_on_secs_ = 0u;
}
inline uint32_t Config_DisplayConfig::_internal_screen_on_secs() const {
  return _impl_.screen_on_secs_;
}
inline uint32_t Config_DisplayConfig::screen_on_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.screen_on_secs)
  return _internal_screen_on_secs();
}
inline void Config_DisplayConfig::_internal_set_screen_on_secs(uint32_t value) {
  
  _impl_.screen_on_secs_ = value;
}
inline void Config_DisplayConfig::set_screen_on_secs(uint32_t value) {
  _internal_set_screen_on_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.screen_on_secs)
}

// .meshtastic.Config.DisplayConfig.GpsCoordinateFormat gps_format = 2 [deprecated = true];
inline void Config_DisplayConfig::clear_gps_format() {
  _impl_.gps_format_ = 0;
}
inline ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat Config_DisplayConfig::_internal_gps_format() const {
  return static_cast< ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat >(_impl_.gps_format_);
}
inline ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat Config_DisplayConfig::gps_format() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.gps_format)
  return _internal_gps_format();
}
inline void Config_DisplayConfig::_internal_set_gps_format(::meshtastic::Config_DisplayConfig_GpsCoordinateFormat value) {
  
  _impl_.gps_format_ = value;
}
inline void Config_DisplayConfig::set_gps_format(::meshtastic::Config_DisplayConfig_GpsCoordinateFormat value) {
  _internal_set_gps_format(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.gps_format)
}

// uint32 auto_screen_carousel_secs = 3;
inline void Config_DisplayConfig::clear_auto_screen_carousel_secs() {
  _impl_.auto_screen_carousel_secs_ = 0u;
}
inline uint32_t Config_DisplayConfig::_internal_auto_screen_carousel_secs() const {
  return _impl_.auto_screen_carousel_secs_;
}
inline uint32_t Config_DisplayConfig::auto_screen_carousel_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.auto_screen_carousel_secs)
  return _internal_auto_screen_carousel_secs();
}
inline void Config_DisplayConfig::_internal_set_auto_screen_carousel_secs(uint32_t value) {
  
  _impl_.auto_screen_carousel_secs_ = value;
}
inline void Config_DisplayConfig::set_auto_screen_carousel_secs(uint32_t value) {
  _internal_set_auto_screen_carousel_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.auto_screen_carousel_secs)
}

// bool compass_north_top = 4 [deprecated = true];
inline void Config_DisplayConfig::clear_compass_north_top() {
  _impl_.compass_north_top_ = false;
}
inline bool Config_DisplayConfig::_internal_compass_north_top() const {
  return _impl_.compass_north_top_;
}
inline bool Config_DisplayConfig::compass_north_top() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.compass_north_top)
  return _internal_compass_north_top();
}
inline void Config_DisplayConfig::_internal_set_compass_north_top(bool value) {
  
  _impl_.compass_north_top_ = value;
}
inline void Config_DisplayConfig::set_compass_north_top(bool value) {
  _internal_set_compass_north_top(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.compass_north_top)
}

// bool flip_screen = 5;
inline void Config_DisplayConfig::clear_flip_screen() {
  _impl_.flip_screen_ = false;
}
inline bool Config_DisplayConfig::_internal_flip_screen() const {
  return _impl_.flip_screen_;
}
inline bool Config_DisplayConfig::flip_screen() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.flip_screen)
  return _internal_flip_screen();
}
inline void Config_DisplayConfig::_internal_set_flip_screen(bool value) {
  
  _impl_.flip_screen_ = value;
}
inline void Config_DisplayConfig::set_flip_screen(bool value) {
  _internal_set_flip_screen(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.flip_screen)
}

// .meshtastic.Config.DisplayConfig.DisplayUnits units = 6;
inline void Config_DisplayConfig::clear_units() {
  _impl_.units_ = 0;
}
inline ::meshtastic::Config_DisplayConfig_DisplayUnits Config_DisplayConfig::_internal_units() const {
  return static_cast< ::meshtastic::Config_DisplayConfig_DisplayUnits >(_impl_.units_);
}
inline ::meshtastic::Config_DisplayConfig_DisplayUnits Config_DisplayConfig::units() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.units)
  return _internal_units();
}
inline void Config_DisplayConfig::_internal_set_units(::meshtastic::Config_DisplayConfig_DisplayUnits value) {
  
  _impl_.units_ = value;
}
inline void Config_DisplayConfig::set_units(::meshtastic::Config_DisplayConfig_DisplayUnits value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.units)
}

// .meshtastic.Config.DisplayConfig.OledType oled = 7;
inline void Config_DisplayConfig::clear_oled() {
  _impl_.oled_ = 0;
}
inline ::meshtastic::Config_DisplayConfig_OledType Config_DisplayConfig::_internal_oled() const {
  return static_cast< ::meshtastic::Config_DisplayConfig_OledType >(_impl_.oled_);
}
inline ::meshtastic::Config_DisplayConfig_OledType Config_DisplayConfig::oled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.oled)
  return _internal_oled();
}
inline void Config_DisplayConfig::_internal_set_oled(::meshtastic::Config_DisplayConfig_OledType value) {
  
  _impl_.oled_ = value;
}
inline void Config_DisplayConfig::set_oled(::meshtastic::Config_DisplayConfig_OledType value) {
  _internal_set_oled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.oled)
}

// .meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;
inline void Config_DisplayConfig::clear_displaymode() {
  _impl_.displaymode_ = 0;
}
inline ::meshtastic::Config_DisplayConfig_DisplayMode Config_DisplayConfig::_internal_displaymode() const {
  return static_cast< ::meshtastic::Config_DisplayConfig_DisplayMode >(_impl_.displaymode_);
}
inline ::meshtastic::Config_DisplayConfig_DisplayMode Config_DisplayConfig::displaymode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.displaymode)
  return _internal_displaymode();
}
inline void Config_DisplayConfig::_internal_set_displaymode(::meshtastic::Config_DisplayConfig_DisplayMode value) {
  
  _impl_.displaymode_ = value;
}
inline void Config_DisplayConfig::set_displaymode(::meshtastic::Config_DisplayConfig_DisplayMode value) {
  _internal_set_displaymode(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.displaymode)
}

// bool heading_bold = 9;
inline void Config_DisplayConfig::clear_heading_bold() {
  _impl_.heading_bold_ = false;
}
inline bool Config_DisplayConfig::_internal_heading_bold() const {
  return _impl_.heading_bold_;
}
inline bool Config_DisplayConfig::heading_bold() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.heading_bold)
  return _internal_heading_bold();
}
inline void Config_DisplayConfig::_internal_set_heading_bold(bool value) {
  
  _impl_.heading_bold_ = value;
}
inline void Config_DisplayConfig::set_heading_bold(bool value) {
  _internal_set_heading_bold(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.heading_bold)
}

// bool wake_on_tap_or_motion = 10;
inline void Config_DisplayConfig::clear_wake_on_tap_or_motion() {
  _impl_.wake_on_tap_or_motion_ = false;
}
inline bool Config_DisplayConfig::_internal_wake_on_tap_or_motion() const {
  return _impl_.wake_on_tap_or_motion_;
}
inline bool Config_DisplayConfig::wake_on_tap_or_motion() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.wake_on_tap_or_motion)
  return _internal_wake_on_tap_or_motion();
}
inline void Config_DisplayConfig::_internal_set_wake_on_tap_or_motion(bool value) {
  
  _impl_.wake_on_tap_or_motion_ = value;
}
inline void Config_DisplayConfig::set_wake_on_tap_or_motion(bool value) {
  _internal_set_wake_on_tap_or_motion(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.wake_on_tap_or_motion)
}

// .meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;
inline void Config_DisplayConfig::clear_compass_orientation() {
  _impl_.compass_orientation_ = 0;
}
inline ::meshtastic::Config_DisplayConfig_CompassOrientation Config_DisplayConfig::_internal_compass_orientation() const {
  return static_cast< ::meshtastic::Config_DisplayConfig_CompassOrientation >(_impl_.compass_orientation_);
}
inline ::meshtastic::Config_DisplayConfig_CompassOrientation Config_DisplayConfig::compass_orientation() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.compass_orientation)
  return _internal_compass_orientation();
}
inline void Config_DisplayConfig::_internal_set_compass_orientation(::meshtastic::Config_DisplayConfig_CompassOrientation value) {
  
  _impl_.compass_orientation_ = value;
}
inline void Config_DisplayConfig::set_compass_orientation(::meshtastic::Config_DisplayConfig_CompassOrientation value) {
  _internal_set_compass_orientation(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.compass_orientation)
}

// bool use_12h_clock = 12;
inline void Config_DisplayConfig::clear_use_12h_clock() {
  _impl_.use_12h_clock_ = false;
}
inline bool Config_DisplayConfig::_internal_use_12h_clock() const {
  return _impl_.use_12h_clock_;
}
inline bool Config_DisplayConfig::use_12h_clock() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.use_12h_clock)
  return _internal_use_12h_clock();
}
inline void Config_DisplayConfig::_internal_set_use_12h_clock(bool value) {
  
  _impl_.use_12h_clock_ = value;
}
inline void Config_DisplayConfig::set_use_12h_clock(bool value) {
  _internal_set_use_12h_clock(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.use_12h_clock)
}

// -------------------------------------------------------------------

// Config_LoRaConfig

// bool use_preset = 1;
inline void Config_LoRaConfig::clear_use_preset() {
  _impl_.use_preset_ = false;
}
inline bool Config_LoRaConfig::_internal_use_preset() const {
  return _impl_.use_preset_;
}
inline bool Config_LoRaConfig::use_preset() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.use_preset)
  return _internal_use_preset();
}
inline void Config_LoRaConfig::_internal_set_use_preset(bool value) {
  
  _impl_.use_preset_ = value;
}
inline void Config_LoRaConfig::set_use_preset(bool value) {
  _internal_set_use_preset(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.use_preset)
}

// .meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;
inline void Config_LoRaConfig::clear_modem_preset() {
  _impl_.modem_preset_ = 0;
}
inline ::meshtastic::Config_LoRaConfig_ModemPreset Config_LoRaConfig::_internal_modem_preset() const {
  return static_cast< ::meshtastic::Config_LoRaConfig_ModemPreset >(_impl_.modem_preset_);
}
inline ::meshtastic::Config_LoRaConfig_ModemPreset Config_LoRaConfig::modem_preset() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.modem_preset)
  return _internal_modem_preset();
}
inline void Config_LoRaConfig::_internal_set_modem_preset(::meshtastic::Config_LoRaConfig_ModemPreset value) {
  
  _impl_.modem_preset_ = value;
}
inline void Config_LoRaConfig::set_modem_preset(::meshtastic::Config_LoRaConfig_ModemPreset value) {
  _internal_set_modem_preset(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.modem_preset)
}

// uint32 bandwidth = 3;
inline void Config_LoRaConfig::clear_bandwidth() {
  _impl_.bandwidth_ = 0u;
}
inline uint32_t Config_LoRaConfig::_internal_bandwidth() const {
  return _impl_.bandwidth_;
}
inline uint32_t Config_LoRaConfig::bandwidth() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.bandwidth)
  return _internal_bandwidth();
}
inline void Config_LoRaConfig::_internal_set_bandwidth(uint32_t value) {
  
  _impl_.bandwidth_ = value;
}
inline void Config_LoRaConfig::set_bandwidth(uint32_t value) {
  _internal_set_bandwidth(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.bandwidth)
}

// uint32 spread_factor = 4;
inline void Config_LoRaConfig::clear_spread_factor() {
  _impl_.spread_factor_ = 0u;
}
inline uint32_t Config_LoRaConfig::_internal_spread_factor() const {
  return _impl_.spread_factor_;
}
inline uint32_t Config_LoRaConfig::spread_factor() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.spread_factor)
  return _internal_spread_factor();
}
inline void Config_LoRaConfig::_internal_set_spread_factor(uint32_t value) {
  
  _impl_.spread_factor_ = value;
}
inline void Config_LoRaConfig::set_spread_factor(uint32_t value) {
  _internal_set_spread_factor(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.spread_factor)
}

// uint32 coding_rate = 5;
inline void Config_LoRaConfig::clear_coding_rate() {
  _impl_.coding_rate_ = 0u;
}
inline uint32_t Config_LoRaConfig::_internal_coding_rate() const {
  return _impl_.coding_rate_;
}
inline uint32_t Config_LoRaConfig::coding_rate() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.coding_rate)
  return _internal_coding_rate();
}
inline void Config_LoRaConfig::_internal_set_coding_rate(uint32_t value) {
  
  _impl_.coding_rate_ = value;
}
inline void Config_LoRaConfig::set_coding_rate(uint32_t value) {
  _internal_set_coding_rate(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.coding_rate)
}

// float frequency_offset = 6;
inline void Config_LoRaConfig::clear_frequency_offset() {
  _impl_.frequency_offset_ = 0;
}
inline float Config_LoRaConfig::_internal_frequency_offset() const {
  return _impl_.frequency_offset_;
}
inline float Config_LoRaConfig::frequency_offset() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.frequency_offset)
  return _internal_frequency_offset();
}
inline void Config_LoRaConfig::_internal_set_frequency_offset(float value) {
  
  _impl_.frequency_offset_ = value;
}
inline void Config_LoRaConfig::set_frequency_offset(float value) {
  _internal_set_frequency_offset(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.frequency_offset)
}

// .meshtastic.Config.LoRaConfig.RegionCode region = 7;
inline void Config_LoRaConfig::clear_region() {
  _impl_.region_ = 0;
}
inline ::meshtastic::Config_LoRaConfig_RegionCode Config_LoRaConfig::_internal_region() const {
  return static_cast< ::meshtastic::Config_LoRaConfig_RegionCode >(_impl_.region_);
}
inline ::meshtastic::Config_LoRaConfig_RegionCode Config_LoRaConfig::region() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.region)
  return _internal_region();
}
inline void Config_LoRaConfig::_internal_set_region(::meshtastic::Config_LoRaConfig_RegionCode value) {
  
  _impl_.region_ = value;
}
inline void Config_LoRaConfig::set_region(::meshtastic::Config_LoRaConfig_RegionCode value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.region)
}

// uint32 hop_limit = 8;
inline void Config_LoRaConfig::clear_hop_limit() {
  _impl_.hop_limit_ = 0u;
}
inline uint32_t Config_LoRaConfig::_internal_hop_limit() const {
  return _impl_.hop_limit_;
}
inline uint32_t Config_LoRaConfig::hop_limit() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.hop_limit)
  return _internal_hop_limit();
}
inline void Config_LoRaConfig::_internal_set_hop_limit(uint32_t value) {
  
  _impl_.hop_limit_ = value;
}
inline void Config_LoRaConfig::set_hop_limit(uint32_t value) {
  _internal_set_hop_limit(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.hop_limit)
}

// bool tx_enabled = 9;
inline void Config_LoRaConfig::clear_tx_enabled() {
  _impl_.tx_enabled_ = false;
}
inline bool Config_LoRaConfig::_internal_tx_enabled() const {
  return _impl_.tx_enabled_;
}
inline bool Config_LoRaConfig::tx_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.tx_enabled)
  return _internal_tx_enabled();
}
inline void Config_LoRaConfig::_internal_set_tx_enabled(bool value) {
  
  _impl_.tx_enabled_ = value;
}
inline void Config_LoRaConfig::set_tx_enabled(bool value) {
  _internal_set_tx_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.tx_enabled)
}

// int32 tx_power = 10;
inline void Config_LoRaConfig::clear_tx_power() {
  _impl_.tx_power_ = 0;
}
inline int32_t Config_LoRaConfig::_internal_tx_power() const {
  return _impl_.tx_power_;
}
inline int32_t Config_LoRaConfig::tx_power() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.tx_power)
  return _internal_tx_power();
}
inline void Config_LoRaConfig::_internal_set_tx_power(int32_t value) {
  
  _impl_.tx_power_ = value;
}
inline void Config_LoRaConfig::set_tx_power(int32_t value) {
  _internal_set_tx_power(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.tx_power)
}

// uint32 channel_num = 11;
inline void Config_LoRaConfig::clear_channel_num() {
  _impl_.channel_num_ = 0u;
}
inline uint32_t Config_LoRaConfig::_internal_channel_num() const {
  return _impl_.channel_num_;
}
inline uint32_t Config_LoRaConfig::channel_num() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.channel_num)
  return _internal_channel_num();
}
inline void Config_LoRaConfig::_internal_set_channel_num(uint32_t value) {
  
  _impl_.channel_num_ = value;
}
inline void Config_LoRaConfig::set_channel_num(uint32_t value) {
  _internal_set_channel_num(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.channel_num)
}

// bool override_duty_cycle = 12;
inline void Config_LoRaConfig::clear_override_duty_cycle() {
  _impl_.override_duty_cycle_ = false;
}
inline bool Config_LoRaConfig::_internal_override_duty_cycle() const {
  return _impl_.override_duty_cycle_;
}
inline bool Config_LoRaConfig::override_duty_cycle() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.override_duty_cycle)
  return _internal_override_duty_cycle();
}
inline void Config_LoRaConfig::_internal_set_override_duty_cycle(bool value) {
  
  _impl_.override_duty_cycle_ = value;
}
inline void Config_LoRaConfig::set_override_duty_cycle(bool value) {
  _internal_set_override_duty_cycle(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.override_duty_cycle)
}

// bool sx126x_rx_boosted_gain = 13;
inline void Config_LoRaConfig::clear_sx126x_rx_boosted_gain() {
  _impl_.sx126x_rx_boosted_gain_ = false;
}
inline bool Config_LoRaConfig::_internal_sx126x_rx_boosted_gain() const {
  return _impl_.sx126x_rx_boosted_gain_;
}
inline bool Config_LoRaConfig::sx126x_rx_boosted_gain() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.sx126x_rx_boosted_gain)
  return _internal_sx126x_rx_boosted_gain();
}
inline void Config_LoRaConfig::_internal_set_sx126x_rx_boosted_gain(bool value) {
  
  _impl_.sx126x_rx_boosted_gain_ = value;
}
inline void Config_LoRaConfig::set_sx126x_rx_boosted_gain(bool value) {
  _internal_set_sx126x_rx_boosted_gain(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.sx126x_rx_boosted_gain)
}

// float override_frequency = 14;
inline void Config_LoRaConfig::clear_override_frequency() {
  _impl_.override_frequency_ = 0;
}
inline float Config_LoRaConfig::_internal_override_frequency() const {
  return _impl_.override_frequency_;
}
inline float Config_LoRaConfig::override_frequency() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.override_frequency)
  return _internal_override_frequency();
}
inline void Config_LoRaConfig::_internal_set_override_frequency(float value) {
  
  _impl_.override_frequency_ = value;
}
inline void Config_LoRaConfig::set_override_frequency(float value) {
  _internal_set_override_frequency(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.override_frequency)
}

// bool pa_fan_disabled = 15;
inline void Config_LoRaConfig::clear_pa_fan_disabled() {
  _impl_.pa_fan_disabled_ = false;
}
inline bool Config_LoRaConfig::_internal_pa_fan_disabled() const {
  return _impl_.pa_fan_disabled_;
}
inline bool Config_LoRaConfig::pa_fan_disabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.pa_fan_disabled)
  return _internal_pa_fan_disabled();
}
inline void Config_LoRaConfig::_internal_set_pa_fan_disabled(bool value) {
  
  _impl_.pa_fan_disabled_ = value;
}
inline void Config_LoRaConfig::set_pa_fan_disabled(bool value) {
  _internal_set_pa_fan_disabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.pa_fan_disabled)
}

// repeated uint32 ignore_incoming = 103;
inline int Config_LoRaConfig::_internal_ignore_incoming_size() const {
  return _impl_.ignore_incoming_.size();
}
inline int Config_LoRaConfig::ignore_incoming_size() const {
  return _internal_ignore_incoming_size();
}
inline void Config_LoRaConfig::clear_ignore_incoming() {
  _impl_.ignore_incoming_.Clear();
}
inline uint32_t Config_LoRaConfig::_internal_ignore_incoming(int index) const {
  return _impl_.ignore_incoming_.Get(index);
}
inline uint32_t Config_LoRaConfig::ignore_incoming(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.ignore_incoming)
  return _internal_ignore_incoming(index);
}
inline void Config_LoRaConfig::set_ignore_incoming(int index, uint32_t value) {
  _impl_.ignore_incoming_.Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.ignore_incoming)
}
inline void Config_LoRaConfig::_internal_add_ignore_incoming(uint32_t value) {
  _impl_.ignore_incoming_.Add(value);
}
inline void Config_LoRaConfig::add_ignore_incoming(uint32_t value) {
  _internal_add_ignore_incoming(value);
  // @@protoc_insertion_point(field_add:meshtastic.Config.LoRaConfig.ignore_incoming)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Config_LoRaConfig::_internal_ignore_incoming() const {
  return _impl_.ignore_incoming_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Config_LoRaConfig::ignore_incoming() const {
  // @@protoc_insertion_point(field_list:meshtastic.Config.LoRaConfig.ignore_incoming)
  return _internal_ignore_incoming();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Config_LoRaConfig::_internal_mutable_ignore_incoming() {
  return &_impl_.ignore_incoming_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Config_LoRaConfig::mutable_ignore_incoming() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.Config.LoRaConfig.ignore_incoming)
  return _internal_mutable_ignore_incoming();
}

// bool ignore_mqtt = 104;
inline void Config_LoRaConfig::clear_ignore_mqtt() {
  _impl_.ignore_mqtt_ = false;
}
inline bool Config_LoRaConfig::_internal_ignore_mqtt() const {
  return _impl_.ignore_mqtt_;
}
inline bool Config_LoRaConfig::ignore_mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.ignore_mqtt)
  return _internal_ignore_mqtt();
}
inline void Config_LoRaConfig::_internal_set_ignore_mqtt(bool value) {
  
  _impl_.ignore_mqtt_ = value;
}
inline void Config_LoRaConfig::set_ignore_mqtt(bool value) {
  _internal_set_ignore_mqtt(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.ignore_mqtt)
}

// bool config_ok_to_mqtt = 105;
inline void Config_LoRaConfig::clear_config_ok_to_mqtt() {
  _impl_.config_ok_to_mqtt_ = false;
}
inline bool Config_LoRaConfig::_internal_config_ok_to_mqtt() const {
  return _impl_.config_ok_to_mqtt_;
}
inline bool Config_LoRaConfig::config_ok_to_mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.config_ok_to_mqtt)
  return _internal_config_ok_to_mqtt();
}
inline void Config_LoRaConfig::_internal_set_config_ok_to_mqtt(bool value) {
  
  _impl_.config_ok_to_mqtt_ = value;
}
inline void Config_LoRaConfig::set_config_ok_to_mqtt(bool value) {
  _internal_set_config_ok_to_mqtt(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.config_ok_to_mqtt)
}

// -------------------------------------------------------------------

// Config_BluetoothConfig

// bool enabled = 1;
inline void Config_BluetoothConfig::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool Config_BluetoothConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool Config_BluetoothConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.BluetoothConfig.enabled)
  return _internal_enabled();
}
inline void Config_BluetoothConfig::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void Config_BluetoothConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.BluetoothConfig.enabled)
}

// .meshtastic.Config.BluetoothConfig.PairingMode mode = 2;
inline void Config_BluetoothConfig::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::meshtastic::Config_BluetoothConfig_PairingMode Config_BluetoothConfig::_internal_mode() const {
  return static_cast< ::meshtastic::Config_BluetoothConfig_PairingMode >(_impl_.mode_);
}
inline ::meshtastic::Config_BluetoothConfig_PairingMode Config_BluetoothConfig::mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.BluetoothConfig.mode)
  return _internal_mode();
}
inline void Config_BluetoothConfig::_internal_set_mode(::meshtastic::Config_BluetoothConfig_PairingMode value) {
  
  _impl_.mode_ = value;
}
inline void Config_BluetoothConfig::set_mode(::meshtastic::Config_BluetoothConfig_PairingMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.BluetoothConfig.mode)
}

// uint32 fixed_pin = 3;
inline void Config_BluetoothConfig::clear_fixed_pin() {
  _impl_.fixed_pin_ = 0u;
}
inline uint32_t Config_BluetoothConfig::_internal_fixed_pin() const {
  return _impl_.fixed_pin_;
}
inline uint32_t Config_BluetoothConfig::fixed_pin() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.BluetoothConfig.fixed_pin)
  return _internal_fixed_pin();
}
inline void Config_BluetoothConfig::_internal_set_fixed_pin(uint32_t value) {
  
  _impl_.fixed_pin_ = value;
}
inline void Config_BluetoothConfig::set_fixed_pin(uint32_t value) {
  _internal_set_fixed_pin(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.BluetoothConfig.fixed_pin)
}

// -------------------------------------------------------------------

// Config_SecurityConfig

// bytes public_key = 1;
inline void Config_SecurityConfig::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& Config_SecurityConfig::public_key() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config_SecurityConfig::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.public_key)
}
inline std::string* Config_SecurityConfig::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.SecurityConfig.public_key)
  return _s;
}
inline const std::string& Config_SecurityConfig::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void Config_SecurityConfig::_internal_set_public_key(const std::string& value) {
  
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Config_SecurityConfig::_internal_mutable_public_key() {
  
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Config_SecurityConfig::release_public_key() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.SecurityConfig.public_key)
  return _impl_.public_key_.Release();
}
inline void Config_SecurityConfig::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.SecurityConfig.public_key)
}

// bytes private_key = 2;
inline void Config_SecurityConfig::clear_private_key() {
  _impl_.private_key_.ClearToEmpty();
}
inline const std::string& Config_SecurityConfig::private_key() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.private_key)
  return _internal_private_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config_SecurityConfig::set_private_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.private_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.private_key)
}
inline std::string* Config_SecurityConfig::mutable_private_key() {
  std::string* _s = _internal_mutable_private_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.SecurityConfig.private_key)
  return _s;
}
inline const std::string& Config_SecurityConfig::_internal_private_key() const {
  return _impl_.private_key_.Get();
}
inline void Config_SecurityConfig::_internal_set_private_key(const std::string& value) {
  
  _impl_.private_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Config_SecurityConfig::_internal_mutable_private_key() {
  
  return _impl_.private_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Config_SecurityConfig::release_private_key() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.SecurityConfig.private_key)
  return _impl_.private_key_.Release();
}
inline void Config_SecurityConfig::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    
  } else {
    
  }
  _impl_.private_key_.SetAllocated(private_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.private_key_.IsDefault()) {
    _impl_.private_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.SecurityConfig.private_key)
}

// repeated bytes admin_key = 3;
inline int Config_SecurityConfig::_internal_admin_key_size() const {
  return _impl_.admin_key_.size();
}
inline int Config_SecurityConfig::admin_key_size() const {
  return _internal_admin_key_size();
}
inline void Config_SecurityConfig::clear_admin_key() {
  _impl_.admin_key_.Clear();
}
inline std::string* Config_SecurityConfig::add_admin_key() {
  std::string* _s = _internal_add_admin_key();
  // @@protoc_insertion_point(field_add_mutable:meshtastic.Config.SecurityConfig.admin_key)
  return _s;
}
inline const std::string& Config_SecurityConfig::_internal_admin_key(int index) const {
  return _impl_.admin_key_.Get(index);
}
inline const std::string& Config_SecurityConfig::admin_key(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.admin_key)
  return _internal_admin_key(index);
}
inline std::string* Config_SecurityConfig::mutable_admin_key(int index) {
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.SecurityConfig.admin_key)
  return _impl_.admin_key_.Mutable(index);
}
inline void Config_SecurityConfig::set_admin_key(int index, const std::string& value) {
  _impl_.admin_key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.admin_key)
}
inline void Config_SecurityConfig::set_admin_key(int index, std::string&& value) {
  _impl_.admin_key_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.admin_key)
}
inline void Config_SecurityConfig::set_admin_key(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.admin_key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:meshtastic.Config.SecurityConfig.admin_key)
}
inline void Config_SecurityConfig::set_admin_key(int index, const void* value, size_t size) {
  _impl_.admin_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:meshtastic.Config.SecurityConfig.admin_key)
}
inline std::string* Config_SecurityConfig::_internal_add_admin_key() {
  return _impl_.admin_key_.Add();
}
inline void Config_SecurityConfig::add_admin_key(const std::string& value) {
  _impl_.admin_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:meshtastic.Config.SecurityConfig.admin_key)
}
inline void Config_SecurityConfig::add_admin_key(std::string&& value) {
  _impl_.admin_key_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:meshtastic.Config.SecurityConfig.admin_key)
}
inline void Config_SecurityConfig::add_admin_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.admin_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:meshtastic.Config.SecurityConfig.admin_key)
}
inline void Config_SecurityConfig::add_admin_key(const void* value, size_t size) {
  _impl_.admin_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:meshtastic.Config.SecurityConfig.admin_key)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Config_SecurityConfig::admin_key() const {
  // @@protoc_insertion_point(field_list:meshtastic.Config.SecurityConfig.admin_key)
  return _impl_.admin_key_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Config_SecurityConfig::mutable_admin_key() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.Config.SecurityConfig.admin_key)
  return &_impl_.admin_key_;
}

// bool is_managed = 4;
inline void Config_SecurityConfig::clear_is_managed() {
  _impl_.is_managed_ = false;
}
inline bool Config_SecurityConfig::_internal_is_managed() const {
  return _impl_.is_managed_;
}
inline bool Config_SecurityConfig::is_managed() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.is_managed)
  return _internal_is_managed();
}
inline void Config_SecurityConfig::_internal_set_is_managed(bool value) {
  
  _impl_.is_managed_ = value;
}
inline void Config_SecurityConfig::set_is_managed(bool value) {
  _internal_set_is_managed(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.is_managed)
}

// bool serial_enabled = 5;
inline void Config_SecurityConfig::clear_serial_enabled() {
  _impl_.serial_enabled_ = false;
}
inline bool Config_SecurityConfig::_internal_serial_enabled() const {
  return _impl_.serial_enabled_;
}
inline bool Config_SecurityConfig::serial_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.serial_enabled)
  return _internal_serial_enabled();
}
inline void Config_SecurityConfig::_internal_set_serial_enabled(bool value) {
  
  _impl_.serial_enabled_ = value;
}
inline void Config_SecurityConfig::set_serial_enabled(bool value) {
  _internal_set_serial_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.serial_enabled)
}

// bool debug_log_api_enabled = 6;
inline void Config_SecurityConfig::clear_debug_log_api_enabled() {
  _impl_.debug_log_api_enabled_ = false;
}
inline bool Config_SecurityConfig::_internal_debug_log_api_enabled() const {
  return _impl_.debug_log_api_enabled_;
}
inline bool Config_SecurityConfig::debug_log_api_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.debug_log_api_enabled)
  return _internal_debug_log_api_enabled();
}
inline void Config_SecurityConfig::_internal_set_debug_log_api_enabled(bool value) {
  
  _impl_.debug_log_api_enabled_ = value;
}
inline void Config_SecurityConfig::set_debug_log_api_enabled(bool value) {
  _internal_set_debug_log_api_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.debug_log_api_enabled)
}

// bool admin_channel_enabled = 8;
inline void Config_SecurityConfig::clear_admin_channel_enabled() {
  _impl_.admin_channel_enabled_ = false;
}
inline bool Config_SecurityConfig::_internal_admin_channel_enabled() const {
  return _impl_.admin_channel_enabled_;
}
inline bool Config_SecurityConfig::admin_channel_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.admin_channel_enabled)
  return _internal_admin_channel_enabled();
}
inline void Config_SecurityConfig::_internal_set_admin_channel_enabled(bool value) {
  
  _impl_.admin_channel_enabled_ = value;
}
inline void Config_SecurityConfig::set_admin_channel_enabled(bool value) {
  _internal_set_admin_channel_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.admin_channel_enabled)
}

// -------------------------------------------------------------------

// Config_SessionkeyConfig

// -------------------------------------------------------------------

// Config

// .meshtastic.Config.DeviceConfig device = 1;
inline bool Config::_internal_has_device() const {
  return payload_variant_case() == kDevice;
}
inline bool Config::has_device() const {
  return _internal_has_device();
}
inline void Config::set_has_device() {
  _impl_._oneof_case_[0] = kDevice;
}
inline void Config::clear_device() {
  if (_internal_has_device()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.device_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_DeviceConfig* Config::release_device() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.device)
  if (_internal_has_device()) {
    clear_has_payload_variant();
    ::meshtastic::Config_DeviceConfig* temp = _impl_.payload_variant_.device_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_DeviceConfig& Config::_internal_device() const {
  return _internal_has_device()
      ? *_impl_.payload_variant_.device_
      : reinterpret_cast< ::meshtastic::Config_DeviceConfig&>(::meshtastic::_Config_DeviceConfig_default_instance_);
}
inline const ::meshtastic::Config_DeviceConfig& Config::device() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.device)
  return _internal_device();
}
inline ::meshtastic::Config_DeviceConfig* Config::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.device)
  if (_internal_has_device()) {
    clear_has_payload_variant();
    ::meshtastic::Config_DeviceConfig* temp = _impl_.payload_variant_.device_;
    _impl_.payload_variant_.device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_device(::meshtastic::Config_DeviceConfig* device) {
  clear_payload_variant();
  if (device) {
    set_has_device();
    _impl_.payload_variant_.device_ = device;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.device)
}
inline ::meshtastic::Config_DeviceConfig* Config::_internal_mutable_device() {
  if (!_internal_has_device()) {
    clear_payload_variant();
    set_has_device();
    _impl_.payload_variant_.device_ = CreateMaybeMessage< ::meshtastic::Config_DeviceConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.device_;
}
inline ::meshtastic::Config_DeviceConfig* Config::mutable_device() {
  ::meshtastic::Config_DeviceConfig* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.device)
  return _msg;
}

// .meshtastic.Config.PositionConfig position = 2;
inline bool Config::_internal_has_position() const {
  return payload_variant_case() == kPosition;
}
inline bool Config::has_position() const {
  return _internal_has_position();
}
inline void Config::set_has_position() {
  _impl_._oneof_case_[0] = kPosition;
}
inline void Config::clear_position() {
  if (_internal_has_position()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.position_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_PositionConfig* Config::release_position() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.position)
  if (_internal_has_position()) {
    clear_has_payload_variant();
    ::meshtastic::Config_PositionConfig* temp = _impl_.payload_variant_.position_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_PositionConfig& Config::_internal_position() const {
  return _internal_has_position()
      ? *_impl_.payload_variant_.position_
      : reinterpret_cast< ::meshtastic::Config_PositionConfig&>(::meshtastic::_Config_PositionConfig_default_instance_);
}
inline const ::meshtastic::Config_PositionConfig& Config::position() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.position)
  return _internal_position();
}
inline ::meshtastic::Config_PositionConfig* Config::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.position)
  if (_internal_has_position()) {
    clear_has_payload_variant();
    ::meshtastic::Config_PositionConfig* temp = _impl_.payload_variant_.position_;
    _impl_.payload_variant_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_position(::meshtastic::Config_PositionConfig* position) {
  clear_payload_variant();
  if (position) {
    set_has_position();
    _impl_.payload_variant_.position_ = position;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.position)
}
inline ::meshtastic::Config_PositionConfig* Config::_internal_mutable_position() {
  if (!_internal_has_position()) {
    clear_payload_variant();
    set_has_position();
    _impl_.payload_variant_.position_ = CreateMaybeMessage< ::meshtastic::Config_PositionConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.position_;
}
inline ::meshtastic::Config_PositionConfig* Config::mutable_position() {
  ::meshtastic::Config_PositionConfig* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.position)
  return _msg;
}

// .meshtastic.Config.PowerConfig power = 3;
inline bool Config::_internal_has_power() const {
  return payload_variant_case() == kPower;
}
inline bool Config::has_power() const {
  return _internal_has_power();
}
inline void Config::set_has_power() {
  _impl_._oneof_case_[0] = kPower;
}
inline void Config::clear_power() {
  if (_internal_has_power()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.power_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_PowerConfig* Config::release_power() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.power)
  if (_internal_has_power()) {
    clear_has_payload_variant();
    ::meshtastic::Config_PowerConfig* temp = _impl_.payload_variant_.power_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.power_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_PowerConfig& Config::_internal_power() const {
  return _internal_has_power()
      ? *_impl_.payload_variant_.power_
      : reinterpret_cast< ::meshtastic::Config_PowerConfig&>(::meshtastic::_Config_PowerConfig_default_instance_);
}
inline const ::meshtastic::Config_PowerConfig& Config::power() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.power)
  return _internal_power();
}
inline ::meshtastic::Config_PowerConfig* Config::unsafe_arena_release_power() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.power)
  if (_internal_has_power()) {
    clear_has_payload_variant();
    ::meshtastic::Config_PowerConfig* temp = _impl_.payload_variant_.power_;
    _impl_.payload_variant_.power_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_power(::meshtastic::Config_PowerConfig* power) {
  clear_payload_variant();
  if (power) {
    set_has_power();
    _impl_.payload_variant_.power_ = power;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.power)
}
inline ::meshtastic::Config_PowerConfig* Config::_internal_mutable_power() {
  if (!_internal_has_power()) {
    clear_payload_variant();
    set_has_power();
    _impl_.payload_variant_.power_ = CreateMaybeMessage< ::meshtastic::Config_PowerConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.power_;
}
inline ::meshtastic::Config_PowerConfig* Config::mutable_power() {
  ::meshtastic::Config_PowerConfig* _msg = _internal_mutable_power();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.power)
  return _msg;
}

// .meshtastic.Config.NetworkConfig network = 4;
inline bool Config::_internal_has_network() const {
  return payload_variant_case() == kNetwork;
}
inline bool Config::has_network() const {
  return _internal_has_network();
}
inline void Config::set_has_network() {
  _impl_._oneof_case_[0] = kNetwork;
}
inline void Config::clear_network() {
  if (_internal_has_network()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.network_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_NetworkConfig* Config::release_network() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.network)
  if (_internal_has_network()) {
    clear_has_payload_variant();
    ::meshtastic::Config_NetworkConfig* temp = _impl_.payload_variant_.network_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.network_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_NetworkConfig& Config::_internal_network() const {
  return _internal_has_network()
      ? *_impl_.payload_variant_.network_
      : reinterpret_cast< ::meshtastic::Config_NetworkConfig&>(::meshtastic::_Config_NetworkConfig_default_instance_);
}
inline const ::meshtastic::Config_NetworkConfig& Config::network() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.network)
  return _internal_network();
}
inline ::meshtastic::Config_NetworkConfig* Config::unsafe_arena_release_network() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.network)
  if (_internal_has_network()) {
    clear_has_payload_variant();
    ::meshtastic::Config_NetworkConfig* temp = _impl_.payload_variant_.network_;
    _impl_.payload_variant_.network_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_network(::meshtastic::Config_NetworkConfig* network) {
  clear_payload_variant();
  if (network) {
    set_has_network();
    _impl_.payload_variant_.network_ = network;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.network)
}
inline ::meshtastic::Config_NetworkConfig* Config::_internal_mutable_network() {
  if (!_internal_has_network()) {
    clear_payload_variant();
    set_has_network();
    _impl_.payload_variant_.network_ = CreateMaybeMessage< ::meshtastic::Config_NetworkConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.network_;
}
inline ::meshtastic::Config_NetworkConfig* Config::mutable_network() {
  ::meshtastic::Config_NetworkConfig* _msg = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.network)
  return _msg;
}

// .meshtastic.Config.DisplayConfig display = 5;
inline bool Config::_internal_has_display() const {
  return payload_variant_case() == kDisplay;
}
inline bool Config::has_display() const {
  return _internal_has_display();
}
inline void Config::set_has_display() {
  _impl_._oneof_case_[0] = kDisplay;
}
inline void Config::clear_display() {
  if (_internal_has_display()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.display_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_DisplayConfig* Config::release_display() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.display)
  if (_internal_has_display()) {
    clear_has_payload_variant();
    ::meshtastic::Config_DisplayConfig* temp = _impl_.payload_variant_.display_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.display_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_DisplayConfig& Config::_internal_display() const {
  return _internal_has_display()
      ? *_impl_.payload_variant_.display_
      : reinterpret_cast< ::meshtastic::Config_DisplayConfig&>(::meshtastic::_Config_DisplayConfig_default_instance_);
}
inline const ::meshtastic::Config_DisplayConfig& Config::display() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.display)
  return _internal_display();
}
inline ::meshtastic::Config_DisplayConfig* Config::unsafe_arena_release_display() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.display)
  if (_internal_has_display()) {
    clear_has_payload_variant();
    ::meshtastic::Config_DisplayConfig* temp = _impl_.payload_variant_.display_;
    _impl_.payload_variant_.display_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_display(::meshtastic::Config_DisplayConfig* display) {
  clear_payload_variant();
  if (display) {
    set_has_display();
    _impl_.payload_variant_.display_ = display;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.display)
}
inline ::meshtastic::Config_DisplayConfig* Config::_internal_mutable_display() {
  if (!_internal_has_display()) {
    clear_payload_variant();
    set_has_display();
    _impl_.payload_variant_.display_ = CreateMaybeMessage< ::meshtastic::Config_DisplayConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.display_;
}
inline ::meshtastic::Config_DisplayConfig* Config::mutable_display() {
  ::meshtastic::Config_DisplayConfig* _msg = _internal_mutable_display();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.display)
  return _msg;
}

// .meshtastic.Config.LoRaConfig lora = 6;
inline bool Config::_internal_has_lora() const {
  return payload_variant_case() == kLora;
}
inline bool Config::has_lora() const {
  return _internal_has_lora();
}
inline void Config::set_has_lora() {
  _impl_._oneof_case_[0] = kLora;
}
inline void Config::clear_lora() {
  if (_internal_has_lora()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.lora_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_LoRaConfig* Config::release_lora() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.lora)
  if (_internal_has_lora()) {
    clear_has_payload_variant();
    ::meshtastic::Config_LoRaConfig* temp = _impl_.payload_variant_.lora_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.lora_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_LoRaConfig& Config::_internal_lora() const {
  return _internal_has_lora()
      ? *_impl_.payload_variant_.lora_
      : reinterpret_cast< ::meshtastic::Config_LoRaConfig&>(::meshtastic::_Config_LoRaConfig_default_instance_);
}
inline const ::meshtastic::Config_LoRaConfig& Config::lora() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.lora)
  return _internal_lora();
}
inline ::meshtastic::Config_LoRaConfig* Config::unsafe_arena_release_lora() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.lora)
  if (_internal_has_lora()) {
    clear_has_payload_variant();
    ::meshtastic::Config_LoRaConfig* temp = _impl_.payload_variant_.lora_;
    _impl_.payload_variant_.lora_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_lora(::meshtastic::Config_LoRaConfig* lora) {
  clear_payload_variant();
  if (lora) {
    set_has_lora();
    _impl_.payload_variant_.lora_ = lora;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.lora)
}
inline ::meshtastic::Config_LoRaConfig* Config::_internal_mutable_lora() {
  if (!_internal_has_lora()) {
    clear_payload_variant();
    set_has_lora();
    _impl_.payload_variant_.lora_ = CreateMaybeMessage< ::meshtastic::Config_LoRaConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.lora_;
}
inline ::meshtastic::Config_LoRaConfig* Config::mutable_lora() {
  ::meshtastic::Config_LoRaConfig* _msg = _internal_mutable_lora();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.lora)
  return _msg;
}

// .meshtastic.Config.BluetoothConfig bluetooth = 7;
inline bool Config::_internal_has_bluetooth() const {
  return payload_variant_case() == kBluetooth;
}
inline bool Config::has_bluetooth() const {
  return _internal_has_bluetooth();
}
inline void Config::set_has_bluetooth() {
  _impl_._oneof_case_[0] = kBluetooth;
}
inline void Config::clear_bluetooth() {
  if (_internal_has_bluetooth()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.bluetooth_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_BluetoothConfig* Config::release_bluetooth() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.bluetooth)
  if (_internal_has_bluetooth()) {
    clear_has_payload_variant();
    ::meshtastic::Config_BluetoothConfig* temp = _impl_.payload_variant_.bluetooth_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.bluetooth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_BluetoothConfig& Config::_internal_bluetooth() const {
  return _internal_has_bluetooth()
      ? *_impl_.payload_variant_.bluetooth_
      : reinterpret_cast< ::meshtastic::Config_BluetoothConfig&>(::meshtastic::_Config_BluetoothConfig_default_instance_);
}
inline const ::meshtastic::Config_BluetoothConfig& Config::bluetooth() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.bluetooth)
  return _internal_bluetooth();
}
inline ::meshtastic::Config_BluetoothConfig* Config::unsafe_arena_release_bluetooth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.bluetooth)
  if (_internal_has_bluetooth()) {
    clear_has_payload_variant();
    ::meshtastic::Config_BluetoothConfig* temp = _impl_.payload_variant_.bluetooth_;
    _impl_.payload_variant_.bluetooth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_bluetooth(::meshtastic::Config_BluetoothConfig* bluetooth) {
  clear_payload_variant();
  if (bluetooth) {
    set_has_bluetooth();
    _impl_.payload_variant_.bluetooth_ = bluetooth;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.bluetooth)
}
inline ::meshtastic::Config_BluetoothConfig* Config::_internal_mutable_bluetooth() {
  if (!_internal_has_bluetooth()) {
    clear_payload_variant();
    set_has_bluetooth();
    _impl_.payload_variant_.bluetooth_ = CreateMaybeMessage< ::meshtastic::Config_BluetoothConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.bluetooth_;
}
inline ::meshtastic::Config_BluetoothConfig* Config::mutable_bluetooth() {
  ::meshtastic::Config_BluetoothConfig* _msg = _internal_mutable_bluetooth();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.bluetooth)
  return _msg;
}

// .meshtastic.Config.SecurityConfig security = 8;
inline bool Config::_internal_has_security() const {
  return payload_variant_case() == kSecurity;
}
inline bool Config::has_security() const {
  return _internal_has_security();
}
inline void Config::set_has_security() {
  _impl_._oneof_case_[0] = kSecurity;
}
inline void Config::clear_security() {
  if (_internal_has_security()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.security_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_SecurityConfig* Config::release_security() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.security)
  if (_internal_has_security()) {
    clear_has_payload_variant();
    ::meshtastic::Config_SecurityConfig* temp = _impl_.payload_variant_.security_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.security_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_SecurityConfig& Config::_internal_security() const {
  return _internal_has_security()
      ? *_impl_.payload_variant_.security_
      : reinterpret_cast< ::meshtastic::Config_SecurityConfig&>(::meshtastic::_Config_SecurityConfig_default_instance_);
}
inline const ::meshtastic::Config_SecurityConfig& Config::security() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.security)
  return _internal_security();
}
inline ::meshtastic::Config_SecurityConfig* Config::unsafe_arena_release_security() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.security)
  if (_internal_has_security()) {
    clear_has_payload_variant();
    ::meshtastic::Config_SecurityConfig* temp = _impl_.payload_variant_.security_;
    _impl_.payload_variant_.security_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_security(::meshtastic::Config_SecurityConfig* security) {
  clear_payload_variant();
  if (security) {
    set_has_security();
    _impl_.payload_variant_.security_ = security;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.security)
}
inline ::meshtastic::Config_SecurityConfig* Config::_internal_mutable_security() {
  if (!_internal_has_security()) {
    clear_payload_variant();
    set_has_security();
    _impl_.payload_variant_.security_ = CreateMaybeMessage< ::meshtastic::Config_SecurityConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.security_;
}
inline ::meshtastic::Config_SecurityConfig* Config::mutable_security() {
  ::meshtastic::Config_SecurityConfig* _msg = _internal_mutable_security();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.security)
  return _msg;
}

// .meshtastic.Config.SessionkeyConfig sessionkey = 9;
inline bool Config::_internal_has_sessionkey() const {
  return payload_variant_case() == kSessionkey;
}
inline bool Config::has_sessionkey() const {
  return _internal_has_sessionkey();
}
inline void Config::set_has_sessionkey() {
  _impl_._oneof_case_[0] = kSessionkey;
}
inline void Config::clear_sessionkey() {
  if (_internal_has_sessionkey()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.sessionkey_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_SessionkeyConfig* Config::release_sessionkey() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.sessionkey)
  if (_internal_has_sessionkey()) {
    clear_has_payload_variant();
    ::meshtastic::Config_SessionkeyConfig* temp = _impl_.payload_variant_.sessionkey_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.sessionkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_SessionkeyConfig& Config::_internal_sessionkey() const {
  return _internal_has_sessionkey()
      ? *_impl_.payload_variant_.sessionkey_
      : reinterpret_cast< ::meshtastic::Config_SessionkeyConfig&>(::meshtastic::_Config_SessionkeyConfig_default_instance_);
}
inline const ::meshtastic::Config_SessionkeyConfig& Config::sessionkey() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.sessionkey)
  return _internal_sessionkey();
}
inline ::meshtastic::Config_SessionkeyConfig* Config::unsafe_arena_release_sessionkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.sessionkey)
  if (_internal_has_sessionkey()) {
    clear_has_payload_variant();
    ::meshtastic::Config_SessionkeyConfig* temp = _impl_.payload_variant_.sessionkey_;
    _impl_.payload_variant_.sessionkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_sessionkey(::meshtastic::Config_SessionkeyConfig* sessionkey) {
  clear_payload_variant();
  if (sessionkey) {
    set_has_sessionkey();
    _impl_.payload_variant_.sessionkey_ = sessionkey;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.sessionkey)
}
inline ::meshtastic::Config_SessionkeyConfig* Config::_internal_mutable_sessionkey() {
  if (!_internal_has_sessionkey()) {
    clear_payload_variant();
    set_has_sessionkey();
    _impl_.payload_variant_.sessionkey_ = CreateMaybeMessage< ::meshtastic::Config_SessionkeyConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.sessionkey_;
}
inline ::meshtastic::Config_SessionkeyConfig* Config::mutable_sessionkey() {
  ::meshtastic::Config_SessionkeyConfig* _msg = _internal_mutable_sessionkey();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.sessionkey)
  return _msg;
}

// .meshtastic.DeviceUIConfig device_ui = 10;
inline bool Config::_internal_has_device_ui() const {
  return payload_variant_case() == kDeviceUi;
}
inline bool Config::has_device_ui() const {
  return _internal_has_device_ui();
}
inline void Config::set_has_device_ui() {
  _impl_._oneof_case_[0] = kDeviceUi;
}
inline ::meshtastic::DeviceUIConfig* Config::release_device_ui() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.device_ui)
  if (_internal_has_device_ui()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceUIConfig* temp = _impl_.payload_variant_.device_ui_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.device_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceUIConfig& Config::_internal_device_ui() const {
  return _internal_has_device_ui()
      ? *_impl_.payload_variant_.device_ui_
      : reinterpret_cast< ::meshtastic::DeviceUIConfig&>(::meshtastic::_DeviceUIConfig_default_instance_);
}
inline const ::meshtastic::DeviceUIConfig& Config::device_ui() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.device_ui)
  return _internal_device_ui();
}
inline ::meshtastic::DeviceUIConfig* Config::unsafe_arena_release_device_ui() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.device_ui)
  if (_internal_has_device_ui()) {
    clear_has_payload_variant();
    ::meshtastic::DeviceUIConfig* temp = _impl_.payload_variant_.device_ui_;
    _impl_.payload_variant_.device_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_device_ui(::meshtastic::DeviceUIConfig* device_ui) {
  clear_payload_variant();
  if (device_ui) {
    set_has_device_ui();
    _impl_.payload_variant_.device_ui_ = device_ui;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.device_ui)
}
inline ::meshtastic::DeviceUIConfig* Config::_internal_mutable_device_ui() {
  if (!_internal_has_device_ui()) {
    clear_payload_variant();
    set_has_device_ui();
    _impl_.payload_variant_.device_ui_ = CreateMaybeMessage< ::meshtastic::DeviceUIConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.device_ui_;
}
inline ::meshtastic::DeviceUIConfig* Config::mutable_device_ui() {
  ::meshtastic::DeviceUIConfig* _msg = _internal_mutable_device_ui();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.device_ui)
  return _msg;
}

inline bool Config::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void Config::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline Config::PayloadVariantCase Config::payload_variant_case() const {
  return Config::PayloadVariantCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meshtastic

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::meshtastic::Config_DeviceConfig_Role> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_DeviceConfig_Role>() {
  return ::meshtastic::Config_DeviceConfig_Role_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_DeviceConfig_RebroadcastMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_DeviceConfig_RebroadcastMode>() {
  return ::meshtastic::Config_DeviceConfig_RebroadcastMode_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_DeviceConfig_BuzzerMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_DeviceConfig_BuzzerMode>() {
  return ::meshtastic::Config_DeviceConfig_BuzzerMode_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_PositionConfig_PositionFlags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_PositionConfig_PositionFlags>() {
  return ::meshtastic::Config_PositionConfig_PositionFlags_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_PositionConfig_GpsMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_PositionConfig_GpsMode>() {
  return ::meshtastic::Config_PositionConfig_GpsMode_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_NetworkConfig_AddressMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_NetworkConfig_AddressMode>() {
  return ::meshtastic::Config_NetworkConfig_AddressMode_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_NetworkConfig_ProtocolFlags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_NetworkConfig_ProtocolFlags>() {
  return ::meshtastic::Config_NetworkConfig_ProtocolFlags_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat>() {
  return ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_DisplayConfig_DisplayUnits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_DisplayConfig_DisplayUnits>() {
  return ::meshtastic::Config_DisplayConfig_DisplayUnits_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_DisplayConfig_OledType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_DisplayConfig_OledType>() {
  return ::meshtastic::Config_DisplayConfig_OledType_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_DisplayConfig_DisplayMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_DisplayConfig_DisplayMode>() {
  return ::meshtastic::Config_DisplayConfig_DisplayMode_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_DisplayConfig_CompassOrientation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_DisplayConfig_CompassOrientation>() {
  return ::meshtastic::Config_DisplayConfig_CompassOrientation_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_LoRaConfig_RegionCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_LoRaConfig_RegionCode>() {
  return ::meshtastic::Config_LoRaConfig_RegionCode_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_LoRaConfig_ModemPreset> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_LoRaConfig_ModemPreset>() {
  return ::meshtastic::Config_LoRaConfig_ModemPreset_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::Config_BluetoothConfig_PairingMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::Config_BluetoothConfig_PairingMode>() {
  return ::meshtastic::Config_BluetoothConfig_PairingMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fconfig_2eproto
