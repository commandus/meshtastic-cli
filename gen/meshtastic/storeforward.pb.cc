// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meshtastic/storeforward.proto

#include "meshtastic/storeforward.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace meshtastic {
PROTOBUF_CONSTEXPR StoreAndForward_Statistics::StoreAndForward_Statistics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messages_total_)*/0u
  , /*decltype(_impl_.messages_saved_)*/0u
  , /*decltype(_impl_.messages_max_)*/0u
  , /*decltype(_impl_.up_time_)*/0u
  , /*decltype(_impl_.requests_)*/0u
  , /*decltype(_impl_.requests_history_)*/0u
  , /*decltype(_impl_.heartbeat_)*/false
  , /*decltype(_impl_.return_max_)*/0u
  , /*decltype(_impl_.return_window_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StoreAndForward_StatisticsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StoreAndForward_StatisticsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StoreAndForward_StatisticsDefaultTypeInternal() {}
  union {
    StoreAndForward_Statistics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StoreAndForward_StatisticsDefaultTypeInternal _StoreAndForward_Statistics_default_instance_;
PROTOBUF_CONSTEXPR StoreAndForward_History::StoreAndForward_History(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.history_messages_)*/0u
  , /*decltype(_impl_.window_)*/0u
  , /*decltype(_impl_.last_request_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StoreAndForward_HistoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StoreAndForward_HistoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StoreAndForward_HistoryDefaultTypeInternal() {}
  union {
    StoreAndForward_History _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StoreAndForward_HistoryDefaultTypeInternal _StoreAndForward_History_default_instance_;
PROTOBUF_CONSTEXPR StoreAndForward_Heartbeat::StoreAndForward_Heartbeat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.period_)*/0u
  , /*decltype(_impl_.secondary_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StoreAndForward_HeartbeatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StoreAndForward_HeartbeatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StoreAndForward_HeartbeatDefaultTypeInternal() {}
  union {
    StoreAndForward_Heartbeat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StoreAndForward_HeartbeatDefaultTypeInternal _StoreAndForward_Heartbeat_default_instance_;
PROTOBUF_CONSTEXPR StoreAndForward::StoreAndForward(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rr_)*/0
  , /*decltype(_impl_.variant_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct StoreAndForwardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StoreAndForwardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StoreAndForwardDefaultTypeInternal() {}
  union {
    StoreAndForward _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StoreAndForwardDefaultTypeInternal _StoreAndForward_default_instance_;
}  // namespace meshtastic
static ::_pb::Metadata file_level_metadata_meshtastic_2fstoreforward_2eproto[4];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_meshtastic_2fstoreforward_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_meshtastic_2fstoreforward_2eproto = nullptr;

const uint32_t TableStruct_meshtastic_2fstoreforward_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Statistics, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Statistics, _impl_.messages_total_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Statistics, _impl_.messages_saved_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Statistics, _impl_.messages_max_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Statistics, _impl_.up_time_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Statistics, _impl_.requests_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Statistics, _impl_.requests_history_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Statistics, _impl_.heartbeat_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Statistics, _impl_.return_max_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Statistics, _impl_.return_window_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_History, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_History, _impl_.history_messages_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_History, _impl_.window_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_History, _impl_.last_request_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Heartbeat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Heartbeat, _impl_.period_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward_Heartbeat, _impl_.secondary_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward, _impl_.rr_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::meshtastic::StoreAndForward, _impl_.variant_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::meshtastic::StoreAndForward_Statistics)},
  { 15, -1, -1, sizeof(::meshtastic::StoreAndForward_History)},
  { 24, -1, -1, sizeof(::meshtastic::StoreAndForward_Heartbeat)},
  { 32, -1, -1, sizeof(::meshtastic::StoreAndForward)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::meshtastic::_StoreAndForward_Statistics_default_instance_._instance,
  &::meshtastic::_StoreAndForward_History_default_instance_._instance,
  &::meshtastic::_StoreAndForward_Heartbeat_default_instance_._instance,
  &::meshtastic::_StoreAndForward_default_instance_._instance,
};

const char descriptor_table_protodef_meshtastic_2fstoreforward_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035meshtastic/storeforward.proto\022\nmeshtas"
  "tic\"\234\007\n\017StoreAndForward\0227\n\002rr\030\001 \001(\0162+.me"
  "shtastic.StoreAndForward.RequestResponse"
  "\0227\n\005stats\030\002 \001(\0132&.meshtastic.StoreAndFor"
  "ward.StatisticsH\000\0226\n\007history\030\003 \001(\0132#.mes"
  "htastic.StoreAndForward.HistoryH\000\022:\n\thea"
  "rtbeat\030\004 \001(\0132%.meshtastic.StoreAndForwar"
  "d.HeartbeatH\000\022\016\n\004text\030\005 \001(\014H\000\032\315\001\n\nStatis"
  "tics\022\026\n\016messages_total\030\001 \001(\r\022\026\n\016messages"
  "_saved\030\002 \001(\r\022\024\n\014messages_max\030\003 \001(\r\022\017\n\007up"
  "_time\030\004 \001(\r\022\020\n\010requests\030\005 \001(\r\022\030\n\020request"
  "s_history\030\006 \001(\r\022\021\n\theartbeat\030\007 \001(\010\022\022\n\nre"
  "turn_max\030\010 \001(\r\022\025\n\rreturn_window\030\t \001(\r\032I\n"
  "\007History\022\030\n\020history_messages\030\001 \001(\r\022\016\n\006wi"
  "ndow\030\002 \001(\r\022\024\n\014last_request\030\003 \001(\r\032.\n\tHear"
  "tbeat\022\016\n\006period\030\001 \001(\r\022\021\n\tsecondary\030\002 \001(\r"
  "\"\274\002\n\017RequestResponse\022\t\n\005UNSET\020\000\022\020\n\014ROUTE"
  "R_ERROR\020\001\022\024\n\020ROUTER_HEARTBEAT\020\002\022\017\n\013ROUTE"
  "R_PING\020\003\022\017\n\013ROUTER_PONG\020\004\022\017\n\013ROUTER_BUSY"
  "\020\005\022\022\n\016ROUTER_HISTORY\020\006\022\020\n\014ROUTER_STATS\020\007"
  "\022\026\n\022ROUTER_TEXT_DIRECT\020\010\022\031\n\025ROUTER_TEXT_"
  "BROADCAST\020\t\022\020\n\014CLIENT_ERROR\020@\022\022\n\016CLIENT_"
  "HISTORY\020A\022\020\n\014CLIENT_STATS\020B\022\017\n\013CLIENT_PI"
  "NG\020C\022\017\n\013CLIENT_PONG\020D\022\020\n\014CLIENT_ABORT\020jB"
  "\t\n\007variantBj\n\023com.geeksville.meshB\025Store"
  "AndForwardProtosZ\"github.com/meshtastic/"
  "go/generated\252\002\024Meshtastic.Protobufs\272\002\000b\006"
  "proto3"
  ;
static ::_pbi::once_flag descriptor_table_meshtastic_2fstoreforward_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_meshtastic_2fstoreforward_2eproto = {
    false, false, 1086, descriptor_table_protodef_meshtastic_2fstoreforward_2eproto,
    "meshtastic/storeforward.proto",
    &descriptor_table_meshtastic_2fstoreforward_2eproto_once, nullptr, 0, 4,
    schemas, file_default_instances, TableStruct_meshtastic_2fstoreforward_2eproto::offsets,
    file_level_metadata_meshtastic_2fstoreforward_2eproto, file_level_enum_descriptors_meshtastic_2fstoreforward_2eproto,
    file_level_service_descriptors_meshtastic_2fstoreforward_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_meshtastic_2fstoreforward_2eproto_getter() {
  return &descriptor_table_meshtastic_2fstoreforward_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_meshtastic_2fstoreforward_2eproto(&descriptor_table_meshtastic_2fstoreforward_2eproto);
namespace meshtastic {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StoreAndForward_RequestResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fstoreforward_2eproto);
  return file_level_enum_descriptors_meshtastic_2fstoreforward_2eproto[0];
}
bool StoreAndForward_RequestResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 106:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr StoreAndForward_RequestResponse StoreAndForward::UNSET;
constexpr StoreAndForward_RequestResponse StoreAndForward::ROUTER_ERROR;
constexpr StoreAndForward_RequestResponse StoreAndForward::ROUTER_HEARTBEAT;
constexpr StoreAndForward_RequestResponse StoreAndForward::ROUTER_PING;
constexpr StoreAndForward_RequestResponse StoreAndForward::ROUTER_PONG;
constexpr StoreAndForward_RequestResponse StoreAndForward::ROUTER_BUSY;
constexpr StoreAndForward_RequestResponse StoreAndForward::ROUTER_HISTORY;
constexpr StoreAndForward_RequestResponse StoreAndForward::ROUTER_STATS;
constexpr StoreAndForward_RequestResponse StoreAndForward::ROUTER_TEXT_DIRECT;
constexpr StoreAndForward_RequestResponse StoreAndForward::ROUTER_TEXT_BROADCAST;
constexpr StoreAndForward_RequestResponse StoreAndForward::CLIENT_ERROR;
constexpr StoreAndForward_RequestResponse StoreAndForward::CLIENT_HISTORY;
constexpr StoreAndForward_RequestResponse StoreAndForward::CLIENT_STATS;
constexpr StoreAndForward_RequestResponse StoreAndForward::CLIENT_PING;
constexpr StoreAndForward_RequestResponse StoreAndForward::CLIENT_PONG;
constexpr StoreAndForward_RequestResponse StoreAndForward::CLIENT_ABORT;
constexpr StoreAndForward_RequestResponse StoreAndForward::RequestResponse_MIN;
constexpr StoreAndForward_RequestResponse StoreAndForward::RequestResponse_MAX;
constexpr int StoreAndForward::RequestResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class StoreAndForward_Statistics::_Internal {
 public:
};

StoreAndForward_Statistics::StoreAndForward_Statistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.StoreAndForward.Statistics)
}
StoreAndForward_Statistics::StoreAndForward_Statistics(const StoreAndForward_Statistics& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StoreAndForward_Statistics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_total_){}
    , decltype(_impl_.messages_saved_){}
    , decltype(_impl_.messages_max_){}
    , decltype(_impl_.up_time_){}
    , decltype(_impl_.requests_){}
    , decltype(_impl_.requests_history_){}
    , decltype(_impl_.heartbeat_){}
    , decltype(_impl_.return_max_){}
    , decltype(_impl_.return_window_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.messages_total_, &from._impl_.messages_total_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.return_window_) -
    reinterpret_cast<char*>(&_impl_.messages_total_)) + sizeof(_impl_.return_window_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.StoreAndForward.Statistics)
}

inline void StoreAndForward_Statistics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_total_){0u}
    , decltype(_impl_.messages_saved_){0u}
    , decltype(_impl_.messages_max_){0u}
    , decltype(_impl_.up_time_){0u}
    , decltype(_impl_.requests_){0u}
    , decltype(_impl_.requests_history_){0u}
    , decltype(_impl_.heartbeat_){false}
    , decltype(_impl_.return_max_){0u}
    , decltype(_impl_.return_window_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StoreAndForward_Statistics::~StoreAndForward_Statistics() {
  // @@protoc_insertion_point(destructor:meshtastic.StoreAndForward.Statistics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StoreAndForward_Statistics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreAndForward_Statistics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StoreAndForward_Statistics::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.StoreAndForward.Statistics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.messages_total_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.return_window_) -
      reinterpret_cast<char*>(&_impl_.messages_total_)) + sizeof(_impl_.return_window_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreAndForward_Statistics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 messages_total = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.messages_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 messages_saved = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.messages_saved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 messages_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.messages_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 up_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.up_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 requests = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.requests_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 requests_history = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.requests_history_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool heartbeat = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.heartbeat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 return_max = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.return_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 return_window = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.return_window_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreAndForward_Statistics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.StoreAndForward.Statistics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 messages_total = 1;
  if (this->_internal_messages_total() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_messages_total(), target);
  }

  // uint32 messages_saved = 2;
  if (this->_internal_messages_saved() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_messages_saved(), target);
  }

  // uint32 messages_max = 3;
  if (this->_internal_messages_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_messages_max(), target);
  }

  // uint32 up_time = 4;
  if (this->_internal_up_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_up_time(), target);
  }

  // uint32 requests = 5;
  if (this->_internal_requests() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_requests(), target);
  }

  // uint32 requests_history = 6;
  if (this->_internal_requests_history() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_requests_history(), target);
  }

  // bool heartbeat = 7;
  if (this->_internal_heartbeat() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_heartbeat(), target);
  }

  // uint32 return_max = 8;
  if (this->_internal_return_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_return_max(), target);
  }

  // uint32 return_window = 9;
  if (this->_internal_return_window() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_return_window(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.StoreAndForward.Statistics)
  return target;
}

size_t StoreAndForward_Statistics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.StoreAndForward.Statistics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 messages_total = 1;
  if (this->_internal_messages_total() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_messages_total());
  }

  // uint32 messages_saved = 2;
  if (this->_internal_messages_saved() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_messages_saved());
  }

  // uint32 messages_max = 3;
  if (this->_internal_messages_max() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_messages_max());
  }

  // uint32 up_time = 4;
  if (this->_internal_up_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_up_time());
  }

  // uint32 requests = 5;
  if (this->_internal_requests() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_requests());
  }

  // uint32 requests_history = 6;
  if (this->_internal_requests_history() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_requests_history());
  }

  // bool heartbeat = 7;
  if (this->_internal_heartbeat() != 0) {
    total_size += 1 + 1;
  }

  // uint32 return_max = 8;
  if (this->_internal_return_max() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_return_max());
  }

  // uint32 return_window = 9;
  if (this->_internal_return_window() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_return_window());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreAndForward_Statistics::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StoreAndForward_Statistics::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreAndForward_Statistics::GetClassData() const { return &_class_data_; }


void StoreAndForward_Statistics::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StoreAndForward_Statistics*>(&to_msg);
  auto& from = static_cast<const StoreAndForward_Statistics&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.StoreAndForward.Statistics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_messages_total() != 0) {
    _this->_internal_set_messages_total(from._internal_messages_total());
  }
  if (from._internal_messages_saved() != 0) {
    _this->_internal_set_messages_saved(from._internal_messages_saved());
  }
  if (from._internal_messages_max() != 0) {
    _this->_internal_set_messages_max(from._internal_messages_max());
  }
  if (from._internal_up_time() != 0) {
    _this->_internal_set_up_time(from._internal_up_time());
  }
  if (from._internal_requests() != 0) {
    _this->_internal_set_requests(from._internal_requests());
  }
  if (from._internal_requests_history() != 0) {
    _this->_internal_set_requests_history(from._internal_requests_history());
  }
  if (from._internal_heartbeat() != 0) {
    _this->_internal_set_heartbeat(from._internal_heartbeat());
  }
  if (from._internal_return_max() != 0) {
    _this->_internal_set_return_max(from._internal_return_max());
  }
  if (from._internal_return_window() != 0) {
    _this->_internal_set_return_window(from._internal_return_window());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreAndForward_Statistics::CopyFrom(const StoreAndForward_Statistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.StoreAndForward.Statistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreAndForward_Statistics::IsInitialized() const {
  return true;
}

void StoreAndForward_Statistics::InternalSwap(StoreAndForward_Statistics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreAndForward_Statistics, _impl_.return_window_)
      + sizeof(StoreAndForward_Statistics::_impl_.return_window_)
      - PROTOBUF_FIELD_OFFSET(StoreAndForward_Statistics, _impl_.messages_total_)>(
          reinterpret_cast<char*>(&_impl_.messages_total_),
          reinterpret_cast<char*>(&other->_impl_.messages_total_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreAndForward_Statistics::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fstoreforward_2eproto_getter, &descriptor_table_meshtastic_2fstoreforward_2eproto_once,
      file_level_metadata_meshtastic_2fstoreforward_2eproto[0]);
}

// ===================================================================

class StoreAndForward_History::_Internal {
 public:
};

StoreAndForward_History::StoreAndForward_History(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.StoreAndForward.History)
}
StoreAndForward_History::StoreAndForward_History(const StoreAndForward_History& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StoreAndForward_History* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.history_messages_){}
    , decltype(_impl_.window_){}
    , decltype(_impl_.last_request_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.history_messages_, &from._impl_.history_messages_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_request_) -
    reinterpret_cast<char*>(&_impl_.history_messages_)) + sizeof(_impl_.last_request_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.StoreAndForward.History)
}

inline void StoreAndForward_History::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.history_messages_){0u}
    , decltype(_impl_.window_){0u}
    , decltype(_impl_.last_request_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StoreAndForward_History::~StoreAndForward_History() {
  // @@protoc_insertion_point(destructor:meshtastic.StoreAndForward.History)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StoreAndForward_History::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreAndForward_History::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StoreAndForward_History::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.StoreAndForward.History)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.history_messages_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.last_request_) -
      reinterpret_cast<char*>(&_impl_.history_messages_)) + sizeof(_impl_.last_request_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreAndForward_History::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 history_messages = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.history_messages_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 window = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.window_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 last_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.last_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreAndForward_History::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.StoreAndForward.History)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 history_messages = 1;
  if (this->_internal_history_messages() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_history_messages(), target);
  }

  // uint32 window = 2;
  if (this->_internal_window() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_window(), target);
  }

  // uint32 last_request = 3;
  if (this->_internal_last_request() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_last_request(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.StoreAndForward.History)
  return target;
}

size_t StoreAndForward_History::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.StoreAndForward.History)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 history_messages = 1;
  if (this->_internal_history_messages() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_history_messages());
  }

  // uint32 window = 2;
  if (this->_internal_window() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_window());
  }

  // uint32 last_request = 3;
  if (this->_internal_last_request() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_request());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreAndForward_History::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StoreAndForward_History::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreAndForward_History::GetClassData() const { return &_class_data_; }


void StoreAndForward_History::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StoreAndForward_History*>(&to_msg);
  auto& from = static_cast<const StoreAndForward_History&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.StoreAndForward.History)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_history_messages() != 0) {
    _this->_internal_set_history_messages(from._internal_history_messages());
  }
  if (from._internal_window() != 0) {
    _this->_internal_set_window(from._internal_window());
  }
  if (from._internal_last_request() != 0) {
    _this->_internal_set_last_request(from._internal_last_request());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreAndForward_History::CopyFrom(const StoreAndForward_History& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.StoreAndForward.History)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreAndForward_History::IsInitialized() const {
  return true;
}

void StoreAndForward_History::InternalSwap(StoreAndForward_History* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreAndForward_History, _impl_.last_request_)
      + sizeof(StoreAndForward_History::_impl_.last_request_)
      - PROTOBUF_FIELD_OFFSET(StoreAndForward_History, _impl_.history_messages_)>(
          reinterpret_cast<char*>(&_impl_.history_messages_),
          reinterpret_cast<char*>(&other->_impl_.history_messages_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreAndForward_History::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fstoreforward_2eproto_getter, &descriptor_table_meshtastic_2fstoreforward_2eproto_once,
      file_level_metadata_meshtastic_2fstoreforward_2eproto[1]);
}

// ===================================================================

class StoreAndForward_Heartbeat::_Internal {
 public:
};

StoreAndForward_Heartbeat::StoreAndForward_Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.StoreAndForward.Heartbeat)
}
StoreAndForward_Heartbeat::StoreAndForward_Heartbeat(const StoreAndForward_Heartbeat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StoreAndForward_Heartbeat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.period_){}
    , decltype(_impl_.secondary_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.period_, &from._impl_.period_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.secondary_) -
    reinterpret_cast<char*>(&_impl_.period_)) + sizeof(_impl_.secondary_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.StoreAndForward.Heartbeat)
}

inline void StoreAndForward_Heartbeat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.period_){0u}
    , decltype(_impl_.secondary_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StoreAndForward_Heartbeat::~StoreAndForward_Heartbeat() {
  // @@protoc_insertion_point(destructor:meshtastic.StoreAndForward.Heartbeat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StoreAndForward_Heartbeat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StoreAndForward_Heartbeat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StoreAndForward_Heartbeat::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.StoreAndForward.Heartbeat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.period_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.secondary_) -
      reinterpret_cast<char*>(&_impl_.period_)) + sizeof(_impl_.secondary_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreAndForward_Heartbeat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 period = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 secondary = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.secondary_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreAndForward_Heartbeat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.StoreAndForward.Heartbeat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 period = 1;
  if (this->_internal_period() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_period(), target);
  }

  // uint32 secondary = 2;
  if (this->_internal_secondary() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_secondary(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.StoreAndForward.Heartbeat)
  return target;
}

size_t StoreAndForward_Heartbeat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.StoreAndForward.Heartbeat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 period = 1;
  if (this->_internal_period() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_period());
  }

  // uint32 secondary = 2;
  if (this->_internal_secondary() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_secondary());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreAndForward_Heartbeat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StoreAndForward_Heartbeat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreAndForward_Heartbeat::GetClassData() const { return &_class_data_; }


void StoreAndForward_Heartbeat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StoreAndForward_Heartbeat*>(&to_msg);
  auto& from = static_cast<const StoreAndForward_Heartbeat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.StoreAndForward.Heartbeat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_period() != 0) {
    _this->_internal_set_period(from._internal_period());
  }
  if (from._internal_secondary() != 0) {
    _this->_internal_set_secondary(from._internal_secondary());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreAndForward_Heartbeat::CopyFrom(const StoreAndForward_Heartbeat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.StoreAndForward.Heartbeat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreAndForward_Heartbeat::IsInitialized() const {
  return true;
}

void StoreAndForward_Heartbeat::InternalSwap(StoreAndForward_Heartbeat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreAndForward_Heartbeat, _impl_.secondary_)
      + sizeof(StoreAndForward_Heartbeat::_impl_.secondary_)
      - PROTOBUF_FIELD_OFFSET(StoreAndForward_Heartbeat, _impl_.period_)>(
          reinterpret_cast<char*>(&_impl_.period_),
          reinterpret_cast<char*>(&other->_impl_.period_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreAndForward_Heartbeat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fstoreforward_2eproto_getter, &descriptor_table_meshtastic_2fstoreforward_2eproto_once,
      file_level_metadata_meshtastic_2fstoreforward_2eproto[2]);
}

// ===================================================================

class StoreAndForward::_Internal {
 public:
  static const ::meshtastic::StoreAndForward_Statistics& stats(const StoreAndForward* msg);
  static const ::meshtastic::StoreAndForward_History& history(const StoreAndForward* msg);
  static const ::meshtastic::StoreAndForward_Heartbeat& heartbeat(const StoreAndForward* msg);
};

const ::meshtastic::StoreAndForward_Statistics&
StoreAndForward::_Internal::stats(const StoreAndForward* msg) {
  return *msg->_impl_.variant_.stats_;
}
const ::meshtastic::StoreAndForward_History&
StoreAndForward::_Internal::history(const StoreAndForward* msg) {
  return *msg->_impl_.variant_.history_;
}
const ::meshtastic::StoreAndForward_Heartbeat&
StoreAndForward::_Internal::heartbeat(const StoreAndForward* msg) {
  return *msg->_impl_.variant_.heartbeat_;
}
void StoreAndForward::set_allocated_stats(::meshtastic::StoreAndForward_Statistics* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_variant();
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stats);
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    set_has_stats();
    _impl_.variant_.stats_ = stats;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.StoreAndForward.stats)
}
void StoreAndForward::set_allocated_history(::meshtastic::StoreAndForward_History* history) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_variant();
  if (history) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(history);
    if (message_arena != submessage_arena) {
      history = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, history, submessage_arena);
    }
    set_has_history();
    _impl_.variant_.history_ = history;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.StoreAndForward.history)
}
void StoreAndForward::set_allocated_heartbeat(::meshtastic::StoreAndForward_Heartbeat* heartbeat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_variant();
  if (heartbeat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heartbeat);
    if (message_arena != submessage_arena) {
      heartbeat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heartbeat, submessage_arena);
    }
    set_has_heartbeat();
    _impl_.variant_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.StoreAndForward.heartbeat)
}
StoreAndForward::StoreAndForward(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.StoreAndForward)
}
StoreAndForward::StoreAndForward(const StoreAndForward& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StoreAndForward* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rr_){}
    , decltype(_impl_.variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.rr_ = from._impl_.rr_;
  clear_has_variant();
  switch (from.variant_case()) {
    case kStats: {
      _this->_internal_mutable_stats()->::meshtastic::StoreAndForward_Statistics::MergeFrom(
          from._internal_stats());
      break;
    }
    case kHistory: {
      _this->_internal_mutable_history()->::meshtastic::StoreAndForward_History::MergeFrom(
          from._internal_history());
      break;
    }
    case kHeartbeat: {
      _this->_internal_mutable_heartbeat()->::meshtastic::StoreAndForward_Heartbeat::MergeFrom(
          from._internal_heartbeat());
      break;
    }
    case kText: {
      _this->_internal_set_text(from._internal_text());
      break;
    }
    case VARIANT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:meshtastic.StoreAndForward)
}

inline void StoreAndForward::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.rr_){0}
    , decltype(_impl_.variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_variant();
}

StoreAndForward::~StoreAndForward() {
  // @@protoc_insertion_point(destructor:meshtastic.StoreAndForward)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StoreAndForward::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_variant()) {
    clear_variant();
  }
}

void StoreAndForward::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StoreAndForward::clear_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.StoreAndForward)
  switch (variant_case()) {
    case kStats: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.variant_.stats_;
      }
      break;
    }
    case kHistory: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.variant_.history_;
      }
      break;
    }
    case kHeartbeat: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.variant_.heartbeat_;
      }
      break;
    }
    case kText: {
      _impl_.variant_.text_.Destroy();
      break;
    }
    case VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}


void StoreAndForward::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.StoreAndForward)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rr_ = 0;
  clear_variant();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreAndForward::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .meshtastic.StoreAndForward.RequestResponse rr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_rr(static_cast<::meshtastic::StoreAndForward_RequestResponse>(val));
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.StoreAndForward.Statistics stats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.StoreAndForward.History history = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_history(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.StoreAndForward.Heartbeat heartbeat = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_heartbeat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes text = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StoreAndForward::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.StoreAndForward)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .meshtastic.StoreAndForward.RequestResponse rr = 1;
  if (this->_internal_rr() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_rr(), target);
  }

  // .meshtastic.StoreAndForward.Statistics stats = 2;
  if (_internal_has_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.StoreAndForward.History history = 3;
  if (_internal_has_history()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::history(this),
        _Internal::history(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.StoreAndForward.Heartbeat heartbeat = 4;
  if (_internal_has_heartbeat()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::heartbeat(this),
        _Internal::heartbeat(this).GetCachedSize(), target, stream);
  }

  // bytes text = 5;
  if (_internal_has_text()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.StoreAndForward)
  return target;
}

size_t StoreAndForward::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.StoreAndForward)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .meshtastic.StoreAndForward.RequestResponse rr = 1;
  if (this->_internal_rr() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_rr());
  }

  switch (variant_case()) {
    // .meshtastic.StoreAndForward.Statistics stats = 2;
    case kStats: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.variant_.stats_);
      break;
    }
    // .meshtastic.StoreAndForward.History history = 3;
    case kHistory: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.variant_.history_);
      break;
    }
    // .meshtastic.StoreAndForward.Heartbeat heartbeat = 4;
    case kHeartbeat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.variant_.heartbeat_);
      break;
    }
    // bytes text = 5;
    case kText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_text());
      break;
    }
    case VARIANT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreAndForward::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StoreAndForward::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreAndForward::GetClassData() const { return &_class_data_; }


void StoreAndForward::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StoreAndForward*>(&to_msg);
  auto& from = static_cast<const StoreAndForward&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.StoreAndForward)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_rr() != 0) {
    _this->_internal_set_rr(from._internal_rr());
  }
  switch (from.variant_case()) {
    case kStats: {
      _this->_internal_mutable_stats()->::meshtastic::StoreAndForward_Statistics::MergeFrom(
          from._internal_stats());
      break;
    }
    case kHistory: {
      _this->_internal_mutable_history()->::meshtastic::StoreAndForward_History::MergeFrom(
          from._internal_history());
      break;
    }
    case kHeartbeat: {
      _this->_internal_mutable_heartbeat()->::meshtastic::StoreAndForward_Heartbeat::MergeFrom(
          from._internal_heartbeat());
      break;
    }
    case kText: {
      _this->_internal_set_text(from._internal_text());
      break;
    }
    case VARIANT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreAndForward::CopyFrom(const StoreAndForward& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.StoreAndForward)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreAndForward::IsInitialized() const {
  return true;
}

void StoreAndForward::InternalSwap(StoreAndForward* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.rr_, other->_impl_.rr_);
  swap(_impl_.variant_, other->_impl_.variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreAndForward::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fstoreforward_2eproto_getter, &descriptor_table_meshtastic_2fstoreforward_2eproto_once,
      file_level_metadata_meshtastic_2fstoreforward_2eproto[3]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace meshtastic
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::meshtastic::StoreAndForward_Statistics*
Arena::CreateMaybeMessage< ::meshtastic::StoreAndForward_Statistics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::StoreAndForward_Statistics >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::StoreAndForward_History*
Arena::CreateMaybeMessage< ::meshtastic::StoreAndForward_History >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::StoreAndForward_History >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::StoreAndForward_Heartbeat*
Arena::CreateMaybeMessage< ::meshtastic::StoreAndForward_Heartbeat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::StoreAndForward_Heartbeat >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::StoreAndForward*
Arena::CreateMaybeMessage< ::meshtastic::StoreAndForward >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::StoreAndForward >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
