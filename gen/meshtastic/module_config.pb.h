// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meshtastic/module_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fmodule_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fmodule_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_meshtastic_2fmodule_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_meshtastic_2fmodule_5fconfig_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_meshtastic_2fmodule_5fconfig_2eproto;
namespace meshtastic {
class ModuleConfig;
struct ModuleConfigDefaultTypeInternal;
extern ModuleConfigDefaultTypeInternal _ModuleConfig_default_instance_;
class ModuleConfig_AmbientLightingConfig;
struct ModuleConfig_AmbientLightingConfigDefaultTypeInternal;
extern ModuleConfig_AmbientLightingConfigDefaultTypeInternal _ModuleConfig_AmbientLightingConfig_default_instance_;
class ModuleConfig_AudioConfig;
struct ModuleConfig_AudioConfigDefaultTypeInternal;
extern ModuleConfig_AudioConfigDefaultTypeInternal _ModuleConfig_AudioConfig_default_instance_;
class ModuleConfig_CannedMessageConfig;
struct ModuleConfig_CannedMessageConfigDefaultTypeInternal;
extern ModuleConfig_CannedMessageConfigDefaultTypeInternal _ModuleConfig_CannedMessageConfig_default_instance_;
class ModuleConfig_DetectionSensorConfig;
struct ModuleConfig_DetectionSensorConfigDefaultTypeInternal;
extern ModuleConfig_DetectionSensorConfigDefaultTypeInternal _ModuleConfig_DetectionSensorConfig_default_instance_;
class ModuleConfig_ExternalNotificationConfig;
struct ModuleConfig_ExternalNotificationConfigDefaultTypeInternal;
extern ModuleConfig_ExternalNotificationConfigDefaultTypeInternal _ModuleConfig_ExternalNotificationConfig_default_instance_;
class ModuleConfig_MQTTConfig;
struct ModuleConfig_MQTTConfigDefaultTypeInternal;
extern ModuleConfig_MQTTConfigDefaultTypeInternal _ModuleConfig_MQTTConfig_default_instance_;
class ModuleConfig_MapReportSettings;
struct ModuleConfig_MapReportSettingsDefaultTypeInternal;
extern ModuleConfig_MapReportSettingsDefaultTypeInternal _ModuleConfig_MapReportSettings_default_instance_;
class ModuleConfig_NeighborInfoConfig;
struct ModuleConfig_NeighborInfoConfigDefaultTypeInternal;
extern ModuleConfig_NeighborInfoConfigDefaultTypeInternal _ModuleConfig_NeighborInfoConfig_default_instance_;
class ModuleConfig_PaxcounterConfig;
struct ModuleConfig_PaxcounterConfigDefaultTypeInternal;
extern ModuleConfig_PaxcounterConfigDefaultTypeInternal _ModuleConfig_PaxcounterConfig_default_instance_;
class ModuleConfig_RangeTestConfig;
struct ModuleConfig_RangeTestConfigDefaultTypeInternal;
extern ModuleConfig_RangeTestConfigDefaultTypeInternal _ModuleConfig_RangeTestConfig_default_instance_;
class ModuleConfig_RemoteHardwareConfig;
struct ModuleConfig_RemoteHardwareConfigDefaultTypeInternal;
extern ModuleConfig_RemoteHardwareConfigDefaultTypeInternal _ModuleConfig_RemoteHardwareConfig_default_instance_;
class ModuleConfig_SerialConfig;
struct ModuleConfig_SerialConfigDefaultTypeInternal;
extern ModuleConfig_SerialConfigDefaultTypeInternal _ModuleConfig_SerialConfig_default_instance_;
class ModuleConfig_StoreForwardConfig;
struct ModuleConfig_StoreForwardConfigDefaultTypeInternal;
extern ModuleConfig_StoreForwardConfigDefaultTypeInternal _ModuleConfig_StoreForwardConfig_default_instance_;
class ModuleConfig_TelemetryConfig;
struct ModuleConfig_TelemetryConfigDefaultTypeInternal;
extern ModuleConfig_TelemetryConfigDefaultTypeInternal _ModuleConfig_TelemetryConfig_default_instance_;
class RemoteHardwarePin;
struct RemoteHardwarePinDefaultTypeInternal;
extern RemoteHardwarePinDefaultTypeInternal _RemoteHardwarePin_default_instance_;
}  // namespace meshtastic
PROTOBUF_NAMESPACE_OPEN
template<> ::meshtastic::ModuleConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_AmbientLightingConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_AmbientLightingConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_AudioConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_AudioConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_CannedMessageConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_CannedMessageConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_DetectionSensorConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_DetectionSensorConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_ExternalNotificationConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_ExternalNotificationConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_MQTTConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_MQTTConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_MapReportSettings* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_MapReportSettings>(Arena*);
template<> ::meshtastic::ModuleConfig_NeighborInfoConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_NeighborInfoConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_PaxcounterConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_PaxcounterConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_RangeTestConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_RangeTestConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_RemoteHardwareConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_RemoteHardwareConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_SerialConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_SerialConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_StoreForwardConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_StoreForwardConfig>(Arena*);
template<> ::meshtastic::ModuleConfig_TelemetryConfig* Arena::CreateMaybeMessage<::meshtastic::ModuleConfig_TelemetryConfig>(Arena*);
template<> ::meshtastic::RemoteHardwarePin* Arena::CreateMaybeMessage<::meshtastic::RemoteHardwarePin>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace meshtastic {

enum ModuleConfig_DetectionSensorConfig_TriggerType : int {
  ModuleConfig_DetectionSensorConfig_TriggerType_LOGIC_LOW = 0,
  ModuleConfig_DetectionSensorConfig_TriggerType_LOGIC_HIGH = 1,
  ModuleConfig_DetectionSensorConfig_TriggerType_FALLING_EDGE = 2,
  ModuleConfig_DetectionSensorConfig_TriggerType_RISING_EDGE = 3,
  ModuleConfig_DetectionSensorConfig_TriggerType_EITHER_EDGE_ACTIVE_LOW = 4,
  ModuleConfig_DetectionSensorConfig_TriggerType_EITHER_EDGE_ACTIVE_HIGH = 5,
  ModuleConfig_DetectionSensorConfig_TriggerType_ModuleConfig_DetectionSensorConfig_TriggerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModuleConfig_DetectionSensorConfig_TriggerType_ModuleConfig_DetectionSensorConfig_TriggerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModuleConfig_DetectionSensorConfig_TriggerType_IsValid(int value);
constexpr ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig_TriggerType_TriggerType_MIN = ModuleConfig_DetectionSensorConfig_TriggerType_LOGIC_LOW;
constexpr ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig_TriggerType_TriggerType_MAX = ModuleConfig_DetectionSensorConfig_TriggerType_EITHER_EDGE_ACTIVE_HIGH;
constexpr int ModuleConfig_DetectionSensorConfig_TriggerType_TriggerType_ARRAYSIZE = ModuleConfig_DetectionSensorConfig_TriggerType_TriggerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleConfig_DetectionSensorConfig_TriggerType_descriptor();
template<typename T>
inline const std::string& ModuleConfig_DetectionSensorConfig_TriggerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModuleConfig_DetectionSensorConfig_TriggerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModuleConfig_DetectionSensorConfig_TriggerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModuleConfig_DetectionSensorConfig_TriggerType_descriptor(), enum_t_value);
}
inline bool ModuleConfig_DetectionSensorConfig_TriggerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModuleConfig_DetectionSensorConfig_TriggerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModuleConfig_DetectionSensorConfig_TriggerType>(
    ModuleConfig_DetectionSensorConfig_TriggerType_descriptor(), name, value);
}
enum ModuleConfig_AudioConfig_Audio_Baud : int {
  ModuleConfig_AudioConfig_Audio_Baud_CODEC2_DEFAULT = 0,
  ModuleConfig_AudioConfig_Audio_Baud_CODEC2_3200 = 1,
  ModuleConfig_AudioConfig_Audio_Baud_CODEC2_2400 = 2,
  ModuleConfig_AudioConfig_Audio_Baud_CODEC2_1600 = 3,
  ModuleConfig_AudioConfig_Audio_Baud_CODEC2_1400 = 4,
  ModuleConfig_AudioConfig_Audio_Baud_CODEC2_1300 = 5,
  ModuleConfig_AudioConfig_Audio_Baud_CODEC2_1200 = 6,
  ModuleConfig_AudioConfig_Audio_Baud_CODEC2_700 = 7,
  ModuleConfig_AudioConfig_Audio_Baud_CODEC2_700B = 8,
  ModuleConfig_AudioConfig_Audio_Baud_ModuleConfig_AudioConfig_Audio_Baud_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModuleConfig_AudioConfig_Audio_Baud_ModuleConfig_AudioConfig_Audio_Baud_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModuleConfig_AudioConfig_Audio_Baud_IsValid(int value);
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig_Audio_Baud_Audio_Baud_MIN = ModuleConfig_AudioConfig_Audio_Baud_CODEC2_DEFAULT;
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig_Audio_Baud_Audio_Baud_MAX = ModuleConfig_AudioConfig_Audio_Baud_CODEC2_700B;
constexpr int ModuleConfig_AudioConfig_Audio_Baud_Audio_Baud_ARRAYSIZE = ModuleConfig_AudioConfig_Audio_Baud_Audio_Baud_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleConfig_AudioConfig_Audio_Baud_descriptor();
template<typename T>
inline const std::string& ModuleConfig_AudioConfig_Audio_Baud_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModuleConfig_AudioConfig_Audio_Baud>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModuleConfig_AudioConfig_Audio_Baud_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModuleConfig_AudioConfig_Audio_Baud_descriptor(), enum_t_value);
}
inline bool ModuleConfig_AudioConfig_Audio_Baud_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModuleConfig_AudioConfig_Audio_Baud* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModuleConfig_AudioConfig_Audio_Baud>(
    ModuleConfig_AudioConfig_Audio_Baud_descriptor(), name, value);
}
enum ModuleConfig_SerialConfig_Serial_Baud : int {
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_DEFAULT = 0,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_110 = 1,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_300 = 2,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_600 = 3,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_1200 = 4,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_2400 = 5,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_4800 = 6,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_9600 = 7,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_19200 = 8,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_38400 = 9,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_57600 = 10,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_115200 = 11,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_230400 = 12,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_460800 = 13,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_576000 = 14,
  ModuleConfig_SerialConfig_Serial_Baud_BAUD_921600 = 15,
  ModuleConfig_SerialConfig_Serial_Baud_ModuleConfig_SerialConfig_Serial_Baud_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModuleConfig_SerialConfig_Serial_Baud_ModuleConfig_SerialConfig_Serial_Baud_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModuleConfig_SerialConfig_Serial_Baud_IsValid(int value);
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig_Serial_Baud_Serial_Baud_MIN = ModuleConfig_SerialConfig_Serial_Baud_BAUD_DEFAULT;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig_Serial_Baud_Serial_Baud_MAX = ModuleConfig_SerialConfig_Serial_Baud_BAUD_921600;
constexpr int ModuleConfig_SerialConfig_Serial_Baud_Serial_Baud_ARRAYSIZE = ModuleConfig_SerialConfig_Serial_Baud_Serial_Baud_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleConfig_SerialConfig_Serial_Baud_descriptor();
template<typename T>
inline const std::string& ModuleConfig_SerialConfig_Serial_Baud_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModuleConfig_SerialConfig_Serial_Baud>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModuleConfig_SerialConfig_Serial_Baud_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModuleConfig_SerialConfig_Serial_Baud_descriptor(), enum_t_value);
}
inline bool ModuleConfig_SerialConfig_Serial_Baud_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModuleConfig_SerialConfig_Serial_Baud* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModuleConfig_SerialConfig_Serial_Baud>(
    ModuleConfig_SerialConfig_Serial_Baud_descriptor(), name, value);
}
enum ModuleConfig_SerialConfig_Serial_Mode : int {
  ModuleConfig_SerialConfig_Serial_Mode_DEFAULT = 0,
  ModuleConfig_SerialConfig_Serial_Mode_SIMPLE = 1,
  ModuleConfig_SerialConfig_Serial_Mode_PROTO = 2,
  ModuleConfig_SerialConfig_Serial_Mode_TEXTMSG = 3,
  ModuleConfig_SerialConfig_Serial_Mode_NMEA = 4,
  ModuleConfig_SerialConfig_Serial_Mode_CALTOPO = 5,
  ModuleConfig_SerialConfig_Serial_Mode_WS85 = 6,
  ModuleConfig_SerialConfig_Serial_Mode_VE_DIRECT = 7,
  ModuleConfig_SerialConfig_Serial_Mode_MS_CONFIG = 8,
  ModuleConfig_SerialConfig_Serial_Mode_ModuleConfig_SerialConfig_Serial_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModuleConfig_SerialConfig_Serial_Mode_ModuleConfig_SerialConfig_Serial_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModuleConfig_SerialConfig_Serial_Mode_IsValid(int value);
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig_Serial_Mode_Serial_Mode_MIN = ModuleConfig_SerialConfig_Serial_Mode_DEFAULT;
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig_Serial_Mode_Serial_Mode_MAX = ModuleConfig_SerialConfig_Serial_Mode_MS_CONFIG;
constexpr int ModuleConfig_SerialConfig_Serial_Mode_Serial_Mode_ARRAYSIZE = ModuleConfig_SerialConfig_Serial_Mode_Serial_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleConfig_SerialConfig_Serial_Mode_descriptor();
template<typename T>
inline const std::string& ModuleConfig_SerialConfig_Serial_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModuleConfig_SerialConfig_Serial_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModuleConfig_SerialConfig_Serial_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModuleConfig_SerialConfig_Serial_Mode_descriptor(), enum_t_value);
}
inline bool ModuleConfig_SerialConfig_Serial_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModuleConfig_SerialConfig_Serial_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModuleConfig_SerialConfig_Serial_Mode>(
    ModuleConfig_SerialConfig_Serial_Mode_descriptor(), name, value);
}
enum ModuleConfig_CannedMessageConfig_InputEventChar : int {
  ModuleConfig_CannedMessageConfig_InputEventChar_NONE = 0,
  ModuleConfig_CannedMessageConfig_InputEventChar_UP = 17,
  ModuleConfig_CannedMessageConfig_InputEventChar_DOWN = 18,
  ModuleConfig_CannedMessageConfig_InputEventChar_LEFT = 19,
  ModuleConfig_CannedMessageConfig_InputEventChar_RIGHT = 20,
  ModuleConfig_CannedMessageConfig_InputEventChar_SELECT = 10,
  ModuleConfig_CannedMessageConfig_InputEventChar_BACK = 27,
  ModuleConfig_CannedMessageConfig_InputEventChar_CANCEL = 24,
  ModuleConfig_CannedMessageConfig_InputEventChar_ModuleConfig_CannedMessageConfig_InputEventChar_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModuleConfig_CannedMessageConfig_InputEventChar_ModuleConfig_CannedMessageConfig_InputEventChar_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModuleConfig_CannedMessageConfig_InputEventChar_IsValid(int value);
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig_InputEventChar_InputEventChar_MIN = ModuleConfig_CannedMessageConfig_InputEventChar_NONE;
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig_InputEventChar_InputEventChar_MAX = ModuleConfig_CannedMessageConfig_InputEventChar_BACK;
constexpr int ModuleConfig_CannedMessageConfig_InputEventChar_InputEventChar_ARRAYSIZE = ModuleConfig_CannedMessageConfig_InputEventChar_InputEventChar_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleConfig_CannedMessageConfig_InputEventChar_descriptor();
template<typename T>
inline const std::string& ModuleConfig_CannedMessageConfig_InputEventChar_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModuleConfig_CannedMessageConfig_InputEventChar>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModuleConfig_CannedMessageConfig_InputEventChar_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModuleConfig_CannedMessageConfig_InputEventChar_descriptor(), enum_t_value);
}
inline bool ModuleConfig_CannedMessageConfig_InputEventChar_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModuleConfig_CannedMessageConfig_InputEventChar* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModuleConfig_CannedMessageConfig_InputEventChar>(
    ModuleConfig_CannedMessageConfig_InputEventChar_descriptor(), name, value);
}
enum RemoteHardwarePinType : int {
  UNKNOWN = 0,
  DIGITAL_READ = 1,
  DIGITAL_WRITE = 2,
  RemoteHardwarePinType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RemoteHardwarePinType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RemoteHardwarePinType_IsValid(int value);
constexpr RemoteHardwarePinType RemoteHardwarePinType_MIN = UNKNOWN;
constexpr RemoteHardwarePinType RemoteHardwarePinType_MAX = DIGITAL_WRITE;
constexpr int RemoteHardwarePinType_ARRAYSIZE = RemoteHardwarePinType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RemoteHardwarePinType_descriptor();
template<typename T>
inline const std::string& RemoteHardwarePinType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RemoteHardwarePinType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RemoteHardwarePinType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RemoteHardwarePinType_descriptor(), enum_t_value);
}
inline bool RemoteHardwarePinType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RemoteHardwarePinType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RemoteHardwarePinType>(
    RemoteHardwarePinType_descriptor(), name, value);
}
// ===================================================================

class ModuleConfig_MQTTConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.MQTTConfig) */ {
 public:
  inline ModuleConfig_MQTTConfig() : ModuleConfig_MQTTConfig(nullptr) {}
  ~ModuleConfig_MQTTConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_MQTTConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_MQTTConfig(const ModuleConfig_MQTTConfig& from);
  ModuleConfig_MQTTConfig(ModuleConfig_MQTTConfig&& from) noexcept
    : ModuleConfig_MQTTConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_MQTTConfig& operator=(const ModuleConfig_MQTTConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_MQTTConfig& operator=(ModuleConfig_MQTTConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_MQTTConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_MQTTConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_MQTTConfig*>(
               &_ModuleConfig_MQTTConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ModuleConfig_MQTTConfig& a, ModuleConfig_MQTTConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_MQTTConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_MQTTConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_MQTTConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_MQTTConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_MQTTConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_MQTTConfig& from) {
    ModuleConfig_MQTTConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_MQTTConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.MQTTConfig";
  }
  protected:
  explicit ModuleConfig_MQTTConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kPasswordFieldNumber = 4,
    kRootFieldNumber = 8,
    kMapReportSettingsFieldNumber = 11,
    kEnabledFieldNumber = 1,
    kEncryptionEnabledFieldNumber = 5,
    kJsonEnabledFieldNumber = 6,
    kTlsEnabledFieldNumber = 7,
    kProxyToClientEnabledFieldNumber = 9,
    kMapReportingEnabledFieldNumber = 10,
  };
  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string root = 8;
  void clear_root();
  const std::string& root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_root();
  PROTOBUF_NODISCARD std::string* release_root();
  void set_allocated_root(std::string* root);
  private:
  const std::string& _internal_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_root(const std::string& value);
  std::string* _internal_mutable_root();
  public:

  // .meshtastic.ModuleConfig.MapReportSettings map_report_settings = 11;
  bool has_map_report_settings() const;
  private:
  bool _internal_has_map_report_settings() const;
  public:
  void clear_map_report_settings();
  const ::meshtastic::ModuleConfig_MapReportSettings& map_report_settings() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_MapReportSettings* release_map_report_settings();
  ::meshtastic::ModuleConfig_MapReportSettings* mutable_map_report_settings();
  void set_allocated_map_report_settings(::meshtastic::ModuleConfig_MapReportSettings* map_report_settings);
  private:
  const ::meshtastic::ModuleConfig_MapReportSettings& _internal_map_report_settings() const;
  ::meshtastic::ModuleConfig_MapReportSettings* _internal_mutable_map_report_settings();
  public:
  void unsafe_arena_set_allocated_map_report_settings(
      ::meshtastic::ModuleConfig_MapReportSettings* map_report_settings);
  ::meshtastic::ModuleConfig_MapReportSettings* unsafe_arena_release_map_report_settings();

  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool encryption_enabled = 5;
  void clear_encryption_enabled();
  bool encryption_enabled() const;
  void set_encryption_enabled(bool value);
  private:
  bool _internal_encryption_enabled() const;
  void _internal_set_encryption_enabled(bool value);
  public:

  // bool json_enabled = 6;
  void clear_json_enabled();
  bool json_enabled() const;
  void set_json_enabled(bool value);
  private:
  bool _internal_json_enabled() const;
  void _internal_set_json_enabled(bool value);
  public:

  // bool tls_enabled = 7;
  void clear_tls_enabled();
  bool tls_enabled() const;
  void set_tls_enabled(bool value);
  private:
  bool _internal_tls_enabled() const;
  void _internal_set_tls_enabled(bool value);
  public:

  // bool proxy_to_client_enabled = 9;
  void clear_proxy_to_client_enabled();
  bool proxy_to_client_enabled() const;
  void set_proxy_to_client_enabled(bool value);
  private:
  bool _internal_proxy_to_client_enabled() const;
  void _internal_set_proxy_to_client_enabled(bool value);
  public:

  // bool map_reporting_enabled = 10;
  void clear_map_reporting_enabled();
  bool map_reporting_enabled() const;
  void set_map_reporting_enabled(bool value);
  private:
  bool _internal_map_reporting_enabled() const;
  void _internal_set_map_reporting_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.MQTTConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_;
    ::meshtastic::ModuleConfig_MapReportSettings* map_report_settings_;
    bool enabled_;
    bool encryption_enabled_;
    bool json_enabled_;
    bool tls_enabled_;
    bool proxy_to_client_enabled_;
    bool map_reporting_enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_MapReportSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.MapReportSettings) */ {
 public:
  inline ModuleConfig_MapReportSettings() : ModuleConfig_MapReportSettings(nullptr) {}
  ~ModuleConfig_MapReportSettings() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_MapReportSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_MapReportSettings(const ModuleConfig_MapReportSettings& from);
  ModuleConfig_MapReportSettings(ModuleConfig_MapReportSettings&& from) noexcept
    : ModuleConfig_MapReportSettings() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_MapReportSettings& operator=(const ModuleConfig_MapReportSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_MapReportSettings& operator=(ModuleConfig_MapReportSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_MapReportSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_MapReportSettings* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_MapReportSettings*>(
               &_ModuleConfig_MapReportSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ModuleConfig_MapReportSettings& a, ModuleConfig_MapReportSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_MapReportSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_MapReportSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_MapReportSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_MapReportSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_MapReportSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_MapReportSettings& from) {
    ModuleConfig_MapReportSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_MapReportSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.MapReportSettings";
  }
  protected:
  explicit ModuleConfig_MapReportSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublishIntervalSecsFieldNumber = 1,
    kPositionPrecisionFieldNumber = 2,
    kShouldReportLocationFieldNumber = 3,
  };
  // uint32 publish_interval_secs = 1;
  void clear_publish_interval_secs();
  uint32_t publish_interval_secs() const;
  void set_publish_interval_secs(uint32_t value);
  private:
  uint32_t _internal_publish_interval_secs() const;
  void _internal_set_publish_interval_secs(uint32_t value);
  public:

  // uint32 position_precision = 2;
  void clear_position_precision();
  uint32_t position_precision() const;
  void set_position_precision(uint32_t value);
  private:
  uint32_t _internal_position_precision() const;
  void _internal_set_position_precision(uint32_t value);
  public:

  // bool should_report_location = 3;
  void clear_should_report_location();
  bool should_report_location() const;
  void set_should_report_location(bool value);
  private:
  bool _internal_should_report_location() const;
  void _internal_set_should_report_location(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.MapReportSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t publish_interval_secs_;
    uint32_t position_precision_;
    bool should_report_location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_RemoteHardwareConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.RemoteHardwareConfig) */ {
 public:
  inline ModuleConfig_RemoteHardwareConfig() : ModuleConfig_RemoteHardwareConfig(nullptr) {}
  ~ModuleConfig_RemoteHardwareConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_RemoteHardwareConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_RemoteHardwareConfig(const ModuleConfig_RemoteHardwareConfig& from);
  ModuleConfig_RemoteHardwareConfig(ModuleConfig_RemoteHardwareConfig&& from) noexcept
    : ModuleConfig_RemoteHardwareConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_RemoteHardwareConfig& operator=(const ModuleConfig_RemoteHardwareConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_RemoteHardwareConfig& operator=(ModuleConfig_RemoteHardwareConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_RemoteHardwareConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_RemoteHardwareConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_RemoteHardwareConfig*>(
               &_ModuleConfig_RemoteHardwareConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ModuleConfig_RemoteHardwareConfig& a, ModuleConfig_RemoteHardwareConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_RemoteHardwareConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_RemoteHardwareConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_RemoteHardwareConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_RemoteHardwareConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_RemoteHardwareConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_RemoteHardwareConfig& from) {
    ModuleConfig_RemoteHardwareConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_RemoteHardwareConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.RemoteHardwareConfig";
  }
  protected:
  explicit ModuleConfig_RemoteHardwareConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailablePinsFieldNumber = 3,
    kEnabledFieldNumber = 1,
    kAllowUndefinedPinAccessFieldNumber = 2,
  };
  // repeated .meshtastic.RemoteHardwarePin available_pins = 3;
  int available_pins_size() const;
  private:
  int _internal_available_pins_size() const;
  public:
  void clear_available_pins();
  ::meshtastic::RemoteHardwarePin* mutable_available_pins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::RemoteHardwarePin >*
      mutable_available_pins();
  private:
  const ::meshtastic::RemoteHardwarePin& _internal_available_pins(int index) const;
  ::meshtastic::RemoteHardwarePin* _internal_add_available_pins();
  public:
  const ::meshtastic::RemoteHardwarePin& available_pins(int index) const;
  ::meshtastic::RemoteHardwarePin* add_available_pins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::RemoteHardwarePin >&
      available_pins() const;

  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool allow_undefined_pin_access = 2;
  void clear_allow_undefined_pin_access();
  bool allow_undefined_pin_access() const;
  void set_allow_undefined_pin_access(bool value);
  private:
  bool _internal_allow_undefined_pin_access() const;
  void _internal_set_allow_undefined_pin_access(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.RemoteHardwareConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::RemoteHardwarePin > available_pins_;
    bool enabled_;
    bool allow_undefined_pin_access_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_NeighborInfoConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.NeighborInfoConfig) */ {
 public:
  inline ModuleConfig_NeighborInfoConfig() : ModuleConfig_NeighborInfoConfig(nullptr) {}
  ~ModuleConfig_NeighborInfoConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_NeighborInfoConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_NeighborInfoConfig(const ModuleConfig_NeighborInfoConfig& from);
  ModuleConfig_NeighborInfoConfig(ModuleConfig_NeighborInfoConfig&& from) noexcept
    : ModuleConfig_NeighborInfoConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_NeighborInfoConfig& operator=(const ModuleConfig_NeighborInfoConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_NeighborInfoConfig& operator=(ModuleConfig_NeighborInfoConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_NeighborInfoConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_NeighborInfoConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_NeighborInfoConfig*>(
               &_ModuleConfig_NeighborInfoConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ModuleConfig_NeighborInfoConfig& a, ModuleConfig_NeighborInfoConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_NeighborInfoConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_NeighborInfoConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_NeighborInfoConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_NeighborInfoConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_NeighborInfoConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_NeighborInfoConfig& from) {
    ModuleConfig_NeighborInfoConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_NeighborInfoConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.NeighborInfoConfig";
  }
  protected:
  explicit ModuleConfig_NeighborInfoConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateIntervalFieldNumber = 2,
    kEnabledFieldNumber = 1,
    kTransmitOverLoraFieldNumber = 3,
  };
  // uint32 update_interval = 2;
  void clear_update_interval();
  uint32_t update_interval() const;
  void set_update_interval(uint32_t value);
  private:
  uint32_t _internal_update_interval() const;
  void _internal_set_update_interval(uint32_t value);
  public:

  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool transmit_over_lora = 3;
  void clear_transmit_over_lora();
  bool transmit_over_lora() const;
  void set_transmit_over_lora(bool value);
  private:
  bool _internal_transmit_over_lora() const;
  void _internal_set_transmit_over_lora(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.NeighborInfoConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t update_interval_;
    bool enabled_;
    bool transmit_over_lora_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_DetectionSensorConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.DetectionSensorConfig) */ {
 public:
  inline ModuleConfig_DetectionSensorConfig() : ModuleConfig_DetectionSensorConfig(nullptr) {}
  ~ModuleConfig_DetectionSensorConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_DetectionSensorConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_DetectionSensorConfig(const ModuleConfig_DetectionSensorConfig& from);
  ModuleConfig_DetectionSensorConfig(ModuleConfig_DetectionSensorConfig&& from) noexcept
    : ModuleConfig_DetectionSensorConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_DetectionSensorConfig& operator=(const ModuleConfig_DetectionSensorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_DetectionSensorConfig& operator=(ModuleConfig_DetectionSensorConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_DetectionSensorConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_DetectionSensorConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_DetectionSensorConfig*>(
               &_ModuleConfig_DetectionSensorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ModuleConfig_DetectionSensorConfig& a, ModuleConfig_DetectionSensorConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_DetectionSensorConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_DetectionSensorConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_DetectionSensorConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_DetectionSensorConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_DetectionSensorConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_DetectionSensorConfig& from) {
    ModuleConfig_DetectionSensorConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_DetectionSensorConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.DetectionSensorConfig";
  }
  protected:
  explicit ModuleConfig_DetectionSensorConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModuleConfig_DetectionSensorConfig_TriggerType TriggerType;
  static constexpr TriggerType LOGIC_LOW =
    ModuleConfig_DetectionSensorConfig_TriggerType_LOGIC_LOW;
  static constexpr TriggerType LOGIC_HIGH =
    ModuleConfig_DetectionSensorConfig_TriggerType_LOGIC_HIGH;
  static constexpr TriggerType FALLING_EDGE =
    ModuleConfig_DetectionSensorConfig_TriggerType_FALLING_EDGE;
  static constexpr TriggerType RISING_EDGE =
    ModuleConfig_DetectionSensorConfig_TriggerType_RISING_EDGE;
  static constexpr TriggerType EITHER_EDGE_ACTIVE_LOW =
    ModuleConfig_DetectionSensorConfig_TriggerType_EITHER_EDGE_ACTIVE_LOW;
  static constexpr TriggerType EITHER_EDGE_ACTIVE_HIGH =
    ModuleConfig_DetectionSensorConfig_TriggerType_EITHER_EDGE_ACTIVE_HIGH;
  static inline bool TriggerType_IsValid(int value) {
    return ModuleConfig_DetectionSensorConfig_TriggerType_IsValid(value);
  }
  static constexpr TriggerType TriggerType_MIN =
    ModuleConfig_DetectionSensorConfig_TriggerType_TriggerType_MIN;
  static constexpr TriggerType TriggerType_MAX =
    ModuleConfig_DetectionSensorConfig_TriggerType_TriggerType_MAX;
  static constexpr int TriggerType_ARRAYSIZE =
    ModuleConfig_DetectionSensorConfig_TriggerType_TriggerType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TriggerType_descriptor() {
    return ModuleConfig_DetectionSensorConfig_TriggerType_descriptor();
  }
  template<typename T>
  static inline const std::string& TriggerType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TriggerType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TriggerType_Name.");
    return ModuleConfig_DetectionSensorConfig_TriggerType_Name(enum_t_value);
  }
  static inline bool TriggerType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TriggerType* value) {
    return ModuleConfig_DetectionSensorConfig_TriggerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 5,
    kMinimumBroadcastSecsFieldNumber = 2,
    kStateBroadcastSecsFieldNumber = 3,
    kEnabledFieldNumber = 1,
    kSendBellFieldNumber = 4,
    kUsePullupFieldNumber = 8,
    kMonitorPinFieldNumber = 6,
    kDetectionTriggerTypeFieldNumber = 7,
  };
  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 minimum_broadcast_secs = 2;
  void clear_minimum_broadcast_secs();
  uint32_t minimum_broadcast_secs() const;
  void set_minimum_broadcast_secs(uint32_t value);
  private:
  uint32_t _internal_minimum_broadcast_secs() const;
  void _internal_set_minimum_broadcast_secs(uint32_t value);
  public:

  // uint32 state_broadcast_secs = 3;
  void clear_state_broadcast_secs();
  uint32_t state_broadcast_secs() const;
  void set_state_broadcast_secs(uint32_t value);
  private:
  uint32_t _internal_state_broadcast_secs() const;
  void _internal_set_state_broadcast_secs(uint32_t value);
  public:

  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool send_bell = 4;
  void clear_send_bell();
  bool send_bell() const;
  void set_send_bell(bool value);
  private:
  bool _internal_send_bell() const;
  void _internal_set_send_bell(bool value);
  public:

  // bool use_pullup = 8;
  void clear_use_pullup();
  bool use_pullup() const;
  void set_use_pullup(bool value);
  private:
  bool _internal_use_pullup() const;
  void _internal_set_use_pullup(bool value);
  public:

  // uint32 monitor_pin = 6;
  void clear_monitor_pin();
  uint32_t monitor_pin() const;
  void set_monitor_pin(uint32_t value);
  private:
  uint32_t _internal_monitor_pin() const;
  void _internal_set_monitor_pin(uint32_t value);
  public:

  // .meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType detection_trigger_type = 7;
  void clear_detection_trigger_type();
  ::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType detection_trigger_type() const;
  void set_detection_trigger_type(::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType value);
  private:
  ::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType _internal_detection_trigger_type() const;
  void _internal_set_detection_trigger_type(::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.DetectionSensorConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t minimum_broadcast_secs_;
    uint32_t state_broadcast_secs_;
    bool enabled_;
    bool send_bell_;
    bool use_pullup_;
    uint32_t monitor_pin_;
    int detection_trigger_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_AudioConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.AudioConfig) */ {
 public:
  inline ModuleConfig_AudioConfig() : ModuleConfig_AudioConfig(nullptr) {}
  ~ModuleConfig_AudioConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_AudioConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_AudioConfig(const ModuleConfig_AudioConfig& from);
  ModuleConfig_AudioConfig(ModuleConfig_AudioConfig&& from) noexcept
    : ModuleConfig_AudioConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_AudioConfig& operator=(const ModuleConfig_AudioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_AudioConfig& operator=(ModuleConfig_AudioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_AudioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_AudioConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_AudioConfig*>(
               &_ModuleConfig_AudioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ModuleConfig_AudioConfig& a, ModuleConfig_AudioConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_AudioConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_AudioConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_AudioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_AudioConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_AudioConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_AudioConfig& from) {
    ModuleConfig_AudioConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_AudioConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.AudioConfig";
  }
  protected:
  explicit ModuleConfig_AudioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModuleConfig_AudioConfig_Audio_Baud Audio_Baud;
  static constexpr Audio_Baud CODEC2_DEFAULT =
    ModuleConfig_AudioConfig_Audio_Baud_CODEC2_DEFAULT;
  static constexpr Audio_Baud CODEC2_3200 =
    ModuleConfig_AudioConfig_Audio_Baud_CODEC2_3200;
  static constexpr Audio_Baud CODEC2_2400 =
    ModuleConfig_AudioConfig_Audio_Baud_CODEC2_2400;
  static constexpr Audio_Baud CODEC2_1600 =
    ModuleConfig_AudioConfig_Audio_Baud_CODEC2_1600;
  static constexpr Audio_Baud CODEC2_1400 =
    ModuleConfig_AudioConfig_Audio_Baud_CODEC2_1400;
  static constexpr Audio_Baud CODEC2_1300 =
    ModuleConfig_AudioConfig_Audio_Baud_CODEC2_1300;
  static constexpr Audio_Baud CODEC2_1200 =
    ModuleConfig_AudioConfig_Audio_Baud_CODEC2_1200;
  static constexpr Audio_Baud CODEC2_700 =
    ModuleConfig_AudioConfig_Audio_Baud_CODEC2_700;
  static constexpr Audio_Baud CODEC2_700B =
    ModuleConfig_AudioConfig_Audio_Baud_CODEC2_700B;
  static inline bool Audio_Baud_IsValid(int value) {
    return ModuleConfig_AudioConfig_Audio_Baud_IsValid(value);
  }
  static constexpr Audio_Baud Audio_Baud_MIN =
    ModuleConfig_AudioConfig_Audio_Baud_Audio_Baud_MIN;
  static constexpr Audio_Baud Audio_Baud_MAX =
    ModuleConfig_AudioConfig_Audio_Baud_Audio_Baud_MAX;
  static constexpr int Audio_Baud_ARRAYSIZE =
    ModuleConfig_AudioConfig_Audio_Baud_Audio_Baud_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Audio_Baud_descriptor() {
    return ModuleConfig_AudioConfig_Audio_Baud_descriptor();
  }
  template<typename T>
  static inline const std::string& Audio_Baud_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Audio_Baud>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Audio_Baud_Name.");
    return ModuleConfig_AudioConfig_Audio_Baud_Name(enum_t_value);
  }
  static inline bool Audio_Baud_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Audio_Baud* value) {
    return ModuleConfig_AudioConfig_Audio_Baud_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodec2EnabledFieldNumber = 1,
    kPttPinFieldNumber = 2,
    kBitrateFieldNumber = 3,
    kI2SWsFieldNumber = 4,
    kI2SSdFieldNumber = 5,
    kI2SDinFieldNumber = 6,
    kI2SSckFieldNumber = 7,
  };
  // bool codec2_enabled = 1;
  void clear_codec2_enabled();
  bool codec2_enabled() const;
  void set_codec2_enabled(bool value);
  private:
  bool _internal_codec2_enabled() const;
  void _internal_set_codec2_enabled(bool value);
  public:

  // uint32 ptt_pin = 2;
  void clear_ptt_pin();
  uint32_t ptt_pin() const;
  void set_ptt_pin(uint32_t value);
  private:
  uint32_t _internal_ptt_pin() const;
  void _internal_set_ptt_pin(uint32_t value);
  public:

  // .meshtastic.ModuleConfig.AudioConfig.Audio_Baud bitrate = 3;
  void clear_bitrate();
  ::meshtastic::ModuleConfig_AudioConfig_Audio_Baud bitrate() const;
  void set_bitrate(::meshtastic::ModuleConfig_AudioConfig_Audio_Baud value);
  private:
  ::meshtastic::ModuleConfig_AudioConfig_Audio_Baud _internal_bitrate() const;
  void _internal_set_bitrate(::meshtastic::ModuleConfig_AudioConfig_Audio_Baud value);
  public:

  // uint32 i2s_ws = 4;
  void clear_i2s_ws();
  uint32_t i2s_ws() const;
  void set_i2s_ws(uint32_t value);
  private:
  uint32_t _internal_i2s_ws() const;
  void _internal_set_i2s_ws(uint32_t value);
  public:

  // uint32 i2s_sd = 5;
  void clear_i2s_sd();
  uint32_t i2s_sd() const;
  void set_i2s_sd(uint32_t value);
  private:
  uint32_t _internal_i2s_sd() const;
  void _internal_set_i2s_sd(uint32_t value);
  public:

  // uint32 i2s_din = 6;
  void clear_i2s_din();
  uint32_t i2s_din() const;
  void set_i2s_din(uint32_t value);
  private:
  uint32_t _internal_i2s_din() const;
  void _internal_set_i2s_din(uint32_t value);
  public:

  // uint32 i2s_sck = 7;
  void clear_i2s_sck();
  uint32_t i2s_sck() const;
  void set_i2s_sck(uint32_t value);
  private:
  uint32_t _internal_i2s_sck() const;
  void _internal_set_i2s_sck(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.AudioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool codec2_enabled_;
    uint32_t ptt_pin_;
    int bitrate_;
    uint32_t i2s_ws_;
    uint32_t i2s_sd_;
    uint32_t i2s_din_;
    uint32_t i2s_sck_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_PaxcounterConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.PaxcounterConfig) */ {
 public:
  inline ModuleConfig_PaxcounterConfig() : ModuleConfig_PaxcounterConfig(nullptr) {}
  ~ModuleConfig_PaxcounterConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_PaxcounterConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_PaxcounterConfig(const ModuleConfig_PaxcounterConfig& from);
  ModuleConfig_PaxcounterConfig(ModuleConfig_PaxcounterConfig&& from) noexcept
    : ModuleConfig_PaxcounterConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_PaxcounterConfig& operator=(const ModuleConfig_PaxcounterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_PaxcounterConfig& operator=(ModuleConfig_PaxcounterConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_PaxcounterConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_PaxcounterConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_PaxcounterConfig*>(
               &_ModuleConfig_PaxcounterConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ModuleConfig_PaxcounterConfig& a, ModuleConfig_PaxcounterConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_PaxcounterConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_PaxcounterConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_PaxcounterConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_PaxcounterConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_PaxcounterConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_PaxcounterConfig& from) {
    ModuleConfig_PaxcounterConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_PaxcounterConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.PaxcounterConfig";
  }
  protected:
  explicit ModuleConfig_PaxcounterConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kPaxcounterUpdateIntervalFieldNumber = 2,
    kWifiThresholdFieldNumber = 3,
    kBleThresholdFieldNumber = 4,
  };
  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // uint32 paxcounter_update_interval = 2;
  void clear_paxcounter_update_interval();
  uint32_t paxcounter_update_interval() const;
  void set_paxcounter_update_interval(uint32_t value);
  private:
  uint32_t _internal_paxcounter_update_interval() const;
  void _internal_set_paxcounter_update_interval(uint32_t value);
  public:

  // int32 wifi_threshold = 3;
  void clear_wifi_threshold();
  int32_t wifi_threshold() const;
  void set_wifi_threshold(int32_t value);
  private:
  int32_t _internal_wifi_threshold() const;
  void _internal_set_wifi_threshold(int32_t value);
  public:

  // int32 ble_threshold = 4;
  void clear_ble_threshold();
  int32_t ble_threshold() const;
  void set_ble_threshold(int32_t value);
  private:
  int32_t _internal_ble_threshold() const;
  void _internal_set_ble_threshold(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.PaxcounterConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enabled_;
    uint32_t paxcounter_update_interval_;
    int32_t wifi_threshold_;
    int32_t ble_threshold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_SerialConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.SerialConfig) */ {
 public:
  inline ModuleConfig_SerialConfig() : ModuleConfig_SerialConfig(nullptr) {}
  ~ModuleConfig_SerialConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_SerialConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_SerialConfig(const ModuleConfig_SerialConfig& from);
  ModuleConfig_SerialConfig(ModuleConfig_SerialConfig&& from) noexcept
    : ModuleConfig_SerialConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_SerialConfig& operator=(const ModuleConfig_SerialConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_SerialConfig& operator=(ModuleConfig_SerialConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_SerialConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_SerialConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_SerialConfig*>(
               &_ModuleConfig_SerialConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ModuleConfig_SerialConfig& a, ModuleConfig_SerialConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_SerialConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_SerialConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_SerialConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_SerialConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_SerialConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_SerialConfig& from) {
    ModuleConfig_SerialConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_SerialConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.SerialConfig";
  }
  protected:
  explicit ModuleConfig_SerialConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModuleConfig_SerialConfig_Serial_Baud Serial_Baud;
  static constexpr Serial_Baud BAUD_DEFAULT =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_DEFAULT;
  static constexpr Serial_Baud BAUD_110 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_110;
  static constexpr Serial_Baud BAUD_300 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_300;
  static constexpr Serial_Baud BAUD_600 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_600;
  static constexpr Serial_Baud BAUD_1200 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_1200;
  static constexpr Serial_Baud BAUD_2400 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_2400;
  static constexpr Serial_Baud BAUD_4800 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_4800;
  static constexpr Serial_Baud BAUD_9600 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_9600;
  static constexpr Serial_Baud BAUD_19200 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_19200;
  static constexpr Serial_Baud BAUD_38400 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_38400;
  static constexpr Serial_Baud BAUD_57600 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_57600;
  static constexpr Serial_Baud BAUD_115200 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_115200;
  static constexpr Serial_Baud BAUD_230400 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_230400;
  static constexpr Serial_Baud BAUD_460800 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_460800;
  static constexpr Serial_Baud BAUD_576000 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_576000;
  static constexpr Serial_Baud BAUD_921600 =
    ModuleConfig_SerialConfig_Serial_Baud_BAUD_921600;
  static inline bool Serial_Baud_IsValid(int value) {
    return ModuleConfig_SerialConfig_Serial_Baud_IsValid(value);
  }
  static constexpr Serial_Baud Serial_Baud_MIN =
    ModuleConfig_SerialConfig_Serial_Baud_Serial_Baud_MIN;
  static constexpr Serial_Baud Serial_Baud_MAX =
    ModuleConfig_SerialConfig_Serial_Baud_Serial_Baud_MAX;
  static constexpr int Serial_Baud_ARRAYSIZE =
    ModuleConfig_SerialConfig_Serial_Baud_Serial_Baud_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Serial_Baud_descriptor() {
    return ModuleConfig_SerialConfig_Serial_Baud_descriptor();
  }
  template<typename T>
  static inline const std::string& Serial_Baud_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Serial_Baud>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Serial_Baud_Name.");
    return ModuleConfig_SerialConfig_Serial_Baud_Name(enum_t_value);
  }
  static inline bool Serial_Baud_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Serial_Baud* value) {
    return ModuleConfig_SerialConfig_Serial_Baud_Parse(name, value);
  }

  typedef ModuleConfig_SerialConfig_Serial_Mode Serial_Mode;
  static constexpr Serial_Mode DEFAULT =
    ModuleConfig_SerialConfig_Serial_Mode_DEFAULT;
  static constexpr Serial_Mode SIMPLE =
    ModuleConfig_SerialConfig_Serial_Mode_SIMPLE;
  static constexpr Serial_Mode PROTO =
    ModuleConfig_SerialConfig_Serial_Mode_PROTO;
  static constexpr Serial_Mode TEXTMSG =
    ModuleConfig_SerialConfig_Serial_Mode_TEXTMSG;
  static constexpr Serial_Mode NMEA =
    ModuleConfig_SerialConfig_Serial_Mode_NMEA;
  static constexpr Serial_Mode CALTOPO =
    ModuleConfig_SerialConfig_Serial_Mode_CALTOPO;
  static constexpr Serial_Mode WS85 =
    ModuleConfig_SerialConfig_Serial_Mode_WS85;
  static constexpr Serial_Mode VE_DIRECT =
    ModuleConfig_SerialConfig_Serial_Mode_VE_DIRECT;
  static constexpr Serial_Mode MS_CONFIG =
    ModuleConfig_SerialConfig_Serial_Mode_MS_CONFIG;
  static inline bool Serial_Mode_IsValid(int value) {
    return ModuleConfig_SerialConfig_Serial_Mode_IsValid(value);
  }
  static constexpr Serial_Mode Serial_Mode_MIN =
    ModuleConfig_SerialConfig_Serial_Mode_Serial_Mode_MIN;
  static constexpr Serial_Mode Serial_Mode_MAX =
    ModuleConfig_SerialConfig_Serial_Mode_Serial_Mode_MAX;
  static constexpr int Serial_Mode_ARRAYSIZE =
    ModuleConfig_SerialConfig_Serial_Mode_Serial_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Serial_Mode_descriptor() {
    return ModuleConfig_SerialConfig_Serial_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Serial_Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Serial_Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Serial_Mode_Name.");
    return ModuleConfig_SerialConfig_Serial_Mode_Name(enum_t_value);
  }
  static inline bool Serial_Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Serial_Mode* value) {
    return ModuleConfig_SerialConfig_Serial_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRxdFieldNumber = 3,
    kEnabledFieldNumber = 1,
    kEchoFieldNumber = 2,
    kOverrideConsoleSerialPortFieldNumber = 8,
    kTxdFieldNumber = 4,
    kBaudFieldNumber = 5,
    kTimeoutFieldNumber = 6,
    kModeFieldNumber = 7,
  };
  // uint32 rxd = 3;
  void clear_rxd();
  uint32_t rxd() const;
  void set_rxd(uint32_t value);
  private:
  uint32_t _internal_rxd() const;
  void _internal_set_rxd(uint32_t value);
  public:

  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool echo = 2;
  void clear_echo();
  bool echo() const;
  void set_echo(bool value);
  private:
  bool _internal_echo() const;
  void _internal_set_echo(bool value);
  public:

  // bool override_console_serial_port = 8;
  void clear_override_console_serial_port();
  bool override_console_serial_port() const;
  void set_override_console_serial_port(bool value);
  private:
  bool _internal_override_console_serial_port() const;
  void _internal_set_override_console_serial_port(bool value);
  public:

  // uint32 txd = 4;
  void clear_txd();
  uint32_t txd() const;
  void set_txd(uint32_t value);
  private:
  uint32_t _internal_txd() const;
  void _internal_set_txd(uint32_t value);
  public:

  // .meshtastic.ModuleConfig.SerialConfig.Serial_Baud baud = 5;
  void clear_baud();
  ::meshtastic::ModuleConfig_SerialConfig_Serial_Baud baud() const;
  void set_baud(::meshtastic::ModuleConfig_SerialConfig_Serial_Baud value);
  private:
  ::meshtastic::ModuleConfig_SerialConfig_Serial_Baud _internal_baud() const;
  void _internal_set_baud(::meshtastic::ModuleConfig_SerialConfig_Serial_Baud value);
  public:

  // uint32 timeout = 6;
  void clear_timeout();
  uint32_t timeout() const;
  void set_timeout(uint32_t value);
  private:
  uint32_t _internal_timeout() const;
  void _internal_set_timeout(uint32_t value);
  public:

  // .meshtastic.ModuleConfig.SerialConfig.Serial_Mode mode = 7;
  void clear_mode();
  ::meshtastic::ModuleConfig_SerialConfig_Serial_Mode mode() const;
  void set_mode(::meshtastic::ModuleConfig_SerialConfig_Serial_Mode value);
  private:
  ::meshtastic::ModuleConfig_SerialConfig_Serial_Mode _internal_mode() const;
  void _internal_set_mode(::meshtastic::ModuleConfig_SerialConfig_Serial_Mode value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.SerialConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t rxd_;
    bool enabled_;
    bool echo_;
    bool override_console_serial_port_;
    uint32_t txd_;
    int baud_;
    uint32_t timeout_;
    int mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_ExternalNotificationConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.ExternalNotificationConfig) */ {
 public:
  inline ModuleConfig_ExternalNotificationConfig() : ModuleConfig_ExternalNotificationConfig(nullptr) {}
  ~ModuleConfig_ExternalNotificationConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_ExternalNotificationConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_ExternalNotificationConfig(const ModuleConfig_ExternalNotificationConfig& from);
  ModuleConfig_ExternalNotificationConfig(ModuleConfig_ExternalNotificationConfig&& from) noexcept
    : ModuleConfig_ExternalNotificationConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_ExternalNotificationConfig& operator=(const ModuleConfig_ExternalNotificationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_ExternalNotificationConfig& operator=(ModuleConfig_ExternalNotificationConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_ExternalNotificationConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_ExternalNotificationConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_ExternalNotificationConfig*>(
               &_ModuleConfig_ExternalNotificationConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ModuleConfig_ExternalNotificationConfig& a, ModuleConfig_ExternalNotificationConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_ExternalNotificationConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_ExternalNotificationConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_ExternalNotificationConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_ExternalNotificationConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_ExternalNotificationConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_ExternalNotificationConfig& from) {
    ModuleConfig_ExternalNotificationConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_ExternalNotificationConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.ExternalNotificationConfig";
  }
  protected:
  explicit ModuleConfig_ExternalNotificationConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputMsFieldNumber = 2,
    kOutputFieldNumber = 3,
    kEnabledFieldNumber = 1,
    kActiveFieldNumber = 4,
    kAlertMessageFieldNumber = 5,
    kAlertMessageVibraFieldNumber = 10,
    kOutputVibraFieldNumber = 8,
    kOutputBuzzerFieldNumber = 9,
    kAlertMessageBuzzerFieldNumber = 11,
    kAlertBellFieldNumber = 6,
    kAlertBellVibraFieldNumber = 12,
    kAlertBellBuzzerFieldNumber = 13,
    kUsePwmFieldNumber = 7,
    kUseI2SAsBuzzerFieldNumber = 15,
    kNagTimeoutFieldNumber = 14,
  };
  // uint32 output_ms = 2;
  void clear_output_ms();
  uint32_t output_ms() const;
  void set_output_ms(uint32_t value);
  private:
  uint32_t _internal_output_ms() const;
  void _internal_set_output_ms(uint32_t value);
  public:

  // uint32 output = 3;
  void clear_output();
  uint32_t output() const;
  void set_output(uint32_t value);
  private:
  uint32_t _internal_output() const;
  void _internal_set_output(uint32_t value);
  public:

  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool active = 4;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // bool alert_message = 5;
  void clear_alert_message();
  bool alert_message() const;
  void set_alert_message(bool value);
  private:
  bool _internal_alert_message() const;
  void _internal_set_alert_message(bool value);
  public:

  // bool alert_message_vibra = 10;
  void clear_alert_message_vibra();
  bool alert_message_vibra() const;
  void set_alert_message_vibra(bool value);
  private:
  bool _internal_alert_message_vibra() const;
  void _internal_set_alert_message_vibra(bool value);
  public:

  // uint32 output_vibra = 8;
  void clear_output_vibra();
  uint32_t output_vibra() const;
  void set_output_vibra(uint32_t value);
  private:
  uint32_t _internal_output_vibra() const;
  void _internal_set_output_vibra(uint32_t value);
  public:

  // uint32 output_buzzer = 9;
  void clear_output_buzzer();
  uint32_t output_buzzer() const;
  void set_output_buzzer(uint32_t value);
  private:
  uint32_t _internal_output_buzzer() const;
  void _internal_set_output_buzzer(uint32_t value);
  public:

  // bool alert_message_buzzer = 11;
  void clear_alert_message_buzzer();
  bool alert_message_buzzer() const;
  void set_alert_message_buzzer(bool value);
  private:
  bool _internal_alert_message_buzzer() const;
  void _internal_set_alert_message_buzzer(bool value);
  public:

  // bool alert_bell = 6;
  void clear_alert_bell();
  bool alert_bell() const;
  void set_alert_bell(bool value);
  private:
  bool _internal_alert_bell() const;
  void _internal_set_alert_bell(bool value);
  public:

  // bool alert_bell_vibra = 12;
  void clear_alert_bell_vibra();
  bool alert_bell_vibra() const;
  void set_alert_bell_vibra(bool value);
  private:
  bool _internal_alert_bell_vibra() const;
  void _internal_set_alert_bell_vibra(bool value);
  public:

  // bool alert_bell_buzzer = 13;
  void clear_alert_bell_buzzer();
  bool alert_bell_buzzer() const;
  void set_alert_bell_buzzer(bool value);
  private:
  bool _internal_alert_bell_buzzer() const;
  void _internal_set_alert_bell_buzzer(bool value);
  public:

  // bool use_pwm = 7;
  void clear_use_pwm();
  bool use_pwm() const;
  void set_use_pwm(bool value);
  private:
  bool _internal_use_pwm() const;
  void _internal_set_use_pwm(bool value);
  public:

  // bool use_i2s_as_buzzer = 15;
  void clear_use_i2s_as_buzzer();
  bool use_i2s_as_buzzer() const;
  void set_use_i2s_as_buzzer(bool value);
  private:
  bool _internal_use_i2s_as_buzzer() const;
  void _internal_set_use_i2s_as_buzzer(bool value);
  public:

  // uint32 nag_timeout = 14;
  void clear_nag_timeout();
  uint32_t nag_timeout() const;
  void set_nag_timeout(uint32_t value);
  private:
  uint32_t _internal_nag_timeout() const;
  void _internal_set_nag_timeout(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.ExternalNotificationConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t output_ms_;
    uint32_t output_;
    bool enabled_;
    bool active_;
    bool alert_message_;
    bool alert_message_vibra_;
    uint32_t output_vibra_;
    uint32_t output_buzzer_;
    bool alert_message_buzzer_;
    bool alert_bell_;
    bool alert_bell_vibra_;
    bool alert_bell_buzzer_;
    bool use_pwm_;
    bool use_i2s_as_buzzer_;
    uint32_t nag_timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_StoreForwardConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.StoreForwardConfig) */ {
 public:
  inline ModuleConfig_StoreForwardConfig() : ModuleConfig_StoreForwardConfig(nullptr) {}
  ~ModuleConfig_StoreForwardConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_StoreForwardConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_StoreForwardConfig(const ModuleConfig_StoreForwardConfig& from);
  ModuleConfig_StoreForwardConfig(ModuleConfig_StoreForwardConfig&& from) noexcept
    : ModuleConfig_StoreForwardConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_StoreForwardConfig& operator=(const ModuleConfig_StoreForwardConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_StoreForwardConfig& operator=(ModuleConfig_StoreForwardConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_StoreForwardConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_StoreForwardConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_StoreForwardConfig*>(
               &_ModuleConfig_StoreForwardConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ModuleConfig_StoreForwardConfig& a, ModuleConfig_StoreForwardConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_StoreForwardConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_StoreForwardConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_StoreForwardConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_StoreForwardConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_StoreForwardConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_StoreForwardConfig& from) {
    ModuleConfig_StoreForwardConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_StoreForwardConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.StoreForwardConfig";
  }
  protected:
  explicit ModuleConfig_StoreForwardConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 3,
    kEnabledFieldNumber = 1,
    kHeartbeatFieldNumber = 2,
    kIsServerFieldNumber = 6,
    kHistoryReturnMaxFieldNumber = 4,
    kHistoryReturnWindowFieldNumber = 5,
  };
  // uint32 records = 3;
  void clear_records();
  uint32_t records() const;
  void set_records(uint32_t value);
  private:
  uint32_t _internal_records() const;
  void _internal_set_records(uint32_t value);
  public:

  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool heartbeat = 2;
  void clear_heartbeat();
  bool heartbeat() const;
  void set_heartbeat(bool value);
  private:
  bool _internal_heartbeat() const;
  void _internal_set_heartbeat(bool value);
  public:

  // bool is_server = 6;
  void clear_is_server();
  bool is_server() const;
  void set_is_server(bool value);
  private:
  bool _internal_is_server() const;
  void _internal_set_is_server(bool value);
  public:

  // uint32 history_return_max = 4;
  void clear_history_return_max();
  uint32_t history_return_max() const;
  void set_history_return_max(uint32_t value);
  private:
  uint32_t _internal_history_return_max() const;
  void _internal_set_history_return_max(uint32_t value);
  public:

  // uint32 history_return_window = 5;
  void clear_history_return_window();
  uint32_t history_return_window() const;
  void set_history_return_window(uint32_t value);
  private:
  uint32_t _internal_history_return_window() const;
  void _internal_set_history_return_window(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.StoreForwardConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t records_;
    bool enabled_;
    bool heartbeat_;
    bool is_server_;
    uint32_t history_return_max_;
    uint32_t history_return_window_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_RangeTestConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.RangeTestConfig) */ {
 public:
  inline ModuleConfig_RangeTestConfig() : ModuleConfig_RangeTestConfig(nullptr) {}
  ~ModuleConfig_RangeTestConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_RangeTestConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_RangeTestConfig(const ModuleConfig_RangeTestConfig& from);
  ModuleConfig_RangeTestConfig(ModuleConfig_RangeTestConfig&& from) noexcept
    : ModuleConfig_RangeTestConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_RangeTestConfig& operator=(const ModuleConfig_RangeTestConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_RangeTestConfig& operator=(ModuleConfig_RangeTestConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_RangeTestConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_RangeTestConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_RangeTestConfig*>(
               &_ModuleConfig_RangeTestConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ModuleConfig_RangeTestConfig& a, ModuleConfig_RangeTestConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_RangeTestConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_RangeTestConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_RangeTestConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_RangeTestConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_RangeTestConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_RangeTestConfig& from) {
    ModuleConfig_RangeTestConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_RangeTestConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.RangeTestConfig";
  }
  protected:
  explicit ModuleConfig_RangeTestConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 2,
    kEnabledFieldNumber = 1,
    kSaveFieldNumber = 3,
    kClearOnRebootFieldNumber = 4,
  };
  // uint32 sender = 2;
  void clear_sender();
  uint32_t sender() const;
  void set_sender(uint32_t value);
  private:
  uint32_t _internal_sender() const;
  void _internal_set_sender(uint32_t value);
  public:

  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool save = 3;
  void clear_save();
  bool save() const;
  void set_save(bool value);
  private:
  bool _internal_save() const;
  void _internal_set_save(bool value);
  public:

  // bool clear_on_reboot = 4;
  void clear_clear_on_reboot();
  bool clear_on_reboot() const;
  void set_clear_on_reboot(bool value);
  private:
  bool _internal_clear_on_reboot() const;
  void _internal_set_clear_on_reboot(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.RangeTestConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t sender_;
    bool enabled_;
    bool save_;
    bool clear_on_reboot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_TelemetryConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.TelemetryConfig) */ {
 public:
  inline ModuleConfig_TelemetryConfig() : ModuleConfig_TelemetryConfig(nullptr) {}
  ~ModuleConfig_TelemetryConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_TelemetryConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_TelemetryConfig(const ModuleConfig_TelemetryConfig& from);
  ModuleConfig_TelemetryConfig(ModuleConfig_TelemetryConfig&& from) noexcept
    : ModuleConfig_TelemetryConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_TelemetryConfig& operator=(const ModuleConfig_TelemetryConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_TelemetryConfig& operator=(ModuleConfig_TelemetryConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_TelemetryConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_TelemetryConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_TelemetryConfig*>(
               &_ModuleConfig_TelemetryConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ModuleConfig_TelemetryConfig& a, ModuleConfig_TelemetryConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_TelemetryConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_TelemetryConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_TelemetryConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_TelemetryConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_TelemetryConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_TelemetryConfig& from) {
    ModuleConfig_TelemetryConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_TelemetryConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.TelemetryConfig";
  }
  protected:
  explicit ModuleConfig_TelemetryConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceUpdateIntervalFieldNumber = 1,
    kEnvironmentUpdateIntervalFieldNumber = 2,
    kEnvironmentMeasurementEnabledFieldNumber = 3,
    kEnvironmentScreenEnabledFieldNumber = 4,
    kEnvironmentDisplayFahrenheitFieldNumber = 5,
    kAirQualityEnabledFieldNumber = 6,
    kAirQualityIntervalFieldNumber = 7,
    kPowerUpdateIntervalFieldNumber = 9,
    kPowerMeasurementEnabledFieldNumber = 8,
    kPowerScreenEnabledFieldNumber = 10,
    kHealthMeasurementEnabledFieldNumber = 11,
    kHealthScreenEnabledFieldNumber = 13,
    kHealthUpdateIntervalFieldNumber = 12,
  };
  // uint32 device_update_interval = 1;
  void clear_device_update_interval();
  uint32_t device_update_interval() const;
  void set_device_update_interval(uint32_t value);
  private:
  uint32_t _internal_device_update_interval() const;
  void _internal_set_device_update_interval(uint32_t value);
  public:

  // uint32 environment_update_interval = 2;
  void clear_environment_update_interval();
  uint32_t environment_update_interval() const;
  void set_environment_update_interval(uint32_t value);
  private:
  uint32_t _internal_environment_update_interval() const;
  void _internal_set_environment_update_interval(uint32_t value);
  public:

  // bool environment_measurement_enabled = 3;
  void clear_environment_measurement_enabled();
  bool environment_measurement_enabled() const;
  void set_environment_measurement_enabled(bool value);
  private:
  bool _internal_environment_measurement_enabled() const;
  void _internal_set_environment_measurement_enabled(bool value);
  public:

  // bool environment_screen_enabled = 4;
  void clear_environment_screen_enabled();
  bool environment_screen_enabled() const;
  void set_environment_screen_enabled(bool value);
  private:
  bool _internal_environment_screen_enabled() const;
  void _internal_set_environment_screen_enabled(bool value);
  public:

  // bool environment_display_fahrenheit = 5;
  void clear_environment_display_fahrenheit();
  bool environment_display_fahrenheit() const;
  void set_environment_display_fahrenheit(bool value);
  private:
  bool _internal_environment_display_fahrenheit() const;
  void _internal_set_environment_display_fahrenheit(bool value);
  public:

  // bool air_quality_enabled = 6;
  void clear_air_quality_enabled();
  bool air_quality_enabled() const;
  void set_air_quality_enabled(bool value);
  private:
  bool _internal_air_quality_enabled() const;
  void _internal_set_air_quality_enabled(bool value);
  public:

  // uint32 air_quality_interval = 7;
  void clear_air_quality_interval();
  uint32_t air_quality_interval() const;
  void set_air_quality_interval(uint32_t value);
  private:
  uint32_t _internal_air_quality_interval() const;
  void _internal_set_air_quality_interval(uint32_t value);
  public:

  // uint32 power_update_interval = 9;
  void clear_power_update_interval();
  uint32_t power_update_interval() const;
  void set_power_update_interval(uint32_t value);
  private:
  uint32_t _internal_power_update_interval() const;
  void _internal_set_power_update_interval(uint32_t value);
  public:

  // bool power_measurement_enabled = 8;
  void clear_power_measurement_enabled();
  bool power_measurement_enabled() const;
  void set_power_measurement_enabled(bool value);
  private:
  bool _internal_power_measurement_enabled() const;
  void _internal_set_power_measurement_enabled(bool value);
  public:

  // bool power_screen_enabled = 10;
  void clear_power_screen_enabled();
  bool power_screen_enabled() const;
  void set_power_screen_enabled(bool value);
  private:
  bool _internal_power_screen_enabled() const;
  void _internal_set_power_screen_enabled(bool value);
  public:

  // bool health_measurement_enabled = 11;
  void clear_health_measurement_enabled();
  bool health_measurement_enabled() const;
  void set_health_measurement_enabled(bool value);
  private:
  bool _internal_health_measurement_enabled() const;
  void _internal_set_health_measurement_enabled(bool value);
  public:

  // bool health_screen_enabled = 13;
  void clear_health_screen_enabled();
  bool health_screen_enabled() const;
  void set_health_screen_enabled(bool value);
  private:
  bool _internal_health_screen_enabled() const;
  void _internal_set_health_screen_enabled(bool value);
  public:

  // uint32 health_update_interval = 12;
  void clear_health_update_interval();
  uint32_t health_update_interval() const;
  void set_health_update_interval(uint32_t value);
  private:
  uint32_t _internal_health_update_interval() const;
  void _internal_set_health_update_interval(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.TelemetryConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t device_update_interval_;
    uint32_t environment_update_interval_;
    bool environment_measurement_enabled_;
    bool environment_screen_enabled_;
    bool environment_display_fahrenheit_;
    bool air_quality_enabled_;
    uint32_t air_quality_interval_;
    uint32_t power_update_interval_;
    bool power_measurement_enabled_;
    bool power_screen_enabled_;
    bool health_measurement_enabled_;
    bool health_screen_enabled_;
    uint32_t health_update_interval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_CannedMessageConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.CannedMessageConfig) */ {
 public:
  inline ModuleConfig_CannedMessageConfig() : ModuleConfig_CannedMessageConfig(nullptr) {}
  ~ModuleConfig_CannedMessageConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_CannedMessageConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_CannedMessageConfig(const ModuleConfig_CannedMessageConfig& from);
  ModuleConfig_CannedMessageConfig(ModuleConfig_CannedMessageConfig&& from) noexcept
    : ModuleConfig_CannedMessageConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_CannedMessageConfig& operator=(const ModuleConfig_CannedMessageConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_CannedMessageConfig& operator=(ModuleConfig_CannedMessageConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_CannedMessageConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_CannedMessageConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_CannedMessageConfig*>(
               &_ModuleConfig_CannedMessageConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ModuleConfig_CannedMessageConfig& a, ModuleConfig_CannedMessageConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_CannedMessageConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_CannedMessageConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_CannedMessageConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_CannedMessageConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_CannedMessageConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_CannedMessageConfig& from) {
    ModuleConfig_CannedMessageConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_CannedMessageConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.CannedMessageConfig";
  }
  protected:
  explicit ModuleConfig_CannedMessageConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModuleConfig_CannedMessageConfig_InputEventChar InputEventChar;
  static constexpr InputEventChar NONE =
    ModuleConfig_CannedMessageConfig_InputEventChar_NONE;
  static constexpr InputEventChar UP =
    ModuleConfig_CannedMessageConfig_InputEventChar_UP;
  static constexpr InputEventChar DOWN =
    ModuleConfig_CannedMessageConfig_InputEventChar_DOWN;
  static constexpr InputEventChar LEFT =
    ModuleConfig_CannedMessageConfig_InputEventChar_LEFT;
  static constexpr InputEventChar RIGHT =
    ModuleConfig_CannedMessageConfig_InputEventChar_RIGHT;
  static constexpr InputEventChar SELECT =
    ModuleConfig_CannedMessageConfig_InputEventChar_SELECT;
  static constexpr InputEventChar BACK =
    ModuleConfig_CannedMessageConfig_InputEventChar_BACK;
  static constexpr InputEventChar CANCEL =
    ModuleConfig_CannedMessageConfig_InputEventChar_CANCEL;
  static inline bool InputEventChar_IsValid(int value) {
    return ModuleConfig_CannedMessageConfig_InputEventChar_IsValid(value);
  }
  static constexpr InputEventChar InputEventChar_MIN =
    ModuleConfig_CannedMessageConfig_InputEventChar_InputEventChar_MIN;
  static constexpr InputEventChar InputEventChar_MAX =
    ModuleConfig_CannedMessageConfig_InputEventChar_InputEventChar_MAX;
  static constexpr int InputEventChar_ARRAYSIZE =
    ModuleConfig_CannedMessageConfig_InputEventChar_InputEventChar_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InputEventChar_descriptor() {
    return ModuleConfig_CannedMessageConfig_InputEventChar_descriptor();
  }
  template<typename T>
  static inline const std::string& InputEventChar_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InputEventChar>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InputEventChar_Name.");
    return ModuleConfig_CannedMessageConfig_InputEventChar_Name(enum_t_value);
  }
  static inline bool InputEventChar_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InputEventChar* value) {
    return ModuleConfig_CannedMessageConfig_InputEventChar_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAllowInputSourceFieldNumber = 10,
    kInputbrokerPinAFieldNumber = 2,
    kInputbrokerPinBFieldNumber = 3,
    kInputbrokerPinPressFieldNumber = 4,
    kInputbrokerEventCwFieldNumber = 5,
    kInputbrokerEventCcwFieldNumber = 6,
    kInputbrokerEventPressFieldNumber = 7,
    kRotary1EnabledFieldNumber = 1,
    kUpdown1EnabledFieldNumber = 8,
    kEnabledFieldNumber = 9,
    kSendBellFieldNumber = 11,
  };
  // string allow_input_source = 10 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_allow_input_source();
  PROTOBUF_DEPRECATED const std::string& allow_input_source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_allow_input_source(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_allow_input_source();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_allow_input_source();
  PROTOBUF_DEPRECATED void set_allocated_allow_input_source(std::string* allow_input_source);
  private:
  const std::string& _internal_allow_input_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_allow_input_source(const std::string& value);
  std::string* _internal_mutable_allow_input_source();
  public:

  // uint32 inputbroker_pin_a = 2;
  void clear_inputbroker_pin_a();
  uint32_t inputbroker_pin_a() const;
  void set_inputbroker_pin_a(uint32_t value);
  private:
  uint32_t _internal_inputbroker_pin_a() const;
  void _internal_set_inputbroker_pin_a(uint32_t value);
  public:

  // uint32 inputbroker_pin_b = 3;
  void clear_inputbroker_pin_b();
  uint32_t inputbroker_pin_b() const;
  void set_inputbroker_pin_b(uint32_t value);
  private:
  uint32_t _internal_inputbroker_pin_b() const;
  void _internal_set_inputbroker_pin_b(uint32_t value);
  public:

  // uint32 inputbroker_pin_press = 4;
  void clear_inputbroker_pin_press();
  uint32_t inputbroker_pin_press() const;
  void set_inputbroker_pin_press(uint32_t value);
  private:
  uint32_t _internal_inputbroker_pin_press() const;
  void _internal_set_inputbroker_pin_press(uint32_t value);
  public:

  // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_cw = 5;
  void clear_inputbroker_event_cw();
  ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar inputbroker_event_cw() const;
  void set_inputbroker_event_cw(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value);
  private:
  ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar _internal_inputbroker_event_cw() const;
  void _internal_set_inputbroker_event_cw(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value);
  public:

  // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_ccw = 6;
  void clear_inputbroker_event_ccw();
  ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar inputbroker_event_ccw() const;
  void set_inputbroker_event_ccw(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value);
  private:
  ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar _internal_inputbroker_event_ccw() const;
  void _internal_set_inputbroker_event_ccw(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value);
  public:

  // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_press = 7;
  void clear_inputbroker_event_press();
  ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar inputbroker_event_press() const;
  void set_inputbroker_event_press(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value);
  private:
  ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar _internal_inputbroker_event_press() const;
  void _internal_set_inputbroker_event_press(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value);
  public:

  // bool rotary1_enabled = 1;
  void clear_rotary1_enabled();
  bool rotary1_enabled() const;
  void set_rotary1_enabled(bool value);
  private:
  bool _internal_rotary1_enabled() const;
  void _internal_set_rotary1_enabled(bool value);
  public:

  // bool updown1_enabled = 8;
  void clear_updown1_enabled();
  bool updown1_enabled() const;
  void set_updown1_enabled(bool value);
  private:
  bool _internal_updown1_enabled() const;
  void _internal_set_updown1_enabled(bool value);
  public:

  // bool enabled = 9 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_enabled();
  PROTOBUF_DEPRECATED bool enabled() const;
  PROTOBUF_DEPRECATED void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // bool send_bell = 11;
  void clear_send_bell();
  bool send_bell() const;
  void set_send_bell(bool value);
  private:
  bool _internal_send_bell() const;
  void _internal_set_send_bell(bool value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.CannedMessageConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr allow_input_source_;
    uint32_t inputbroker_pin_a_;
    uint32_t inputbroker_pin_b_;
    uint32_t inputbroker_pin_press_;
    int inputbroker_event_cw_;
    int inputbroker_event_ccw_;
    int inputbroker_event_press_;
    bool rotary1_enabled_;
    bool updown1_enabled_;
    bool enabled_;
    bool send_bell_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig_AmbientLightingConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig.AmbientLightingConfig) */ {
 public:
  inline ModuleConfig_AmbientLightingConfig() : ModuleConfig_AmbientLightingConfig(nullptr) {}
  ~ModuleConfig_AmbientLightingConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig_AmbientLightingConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig_AmbientLightingConfig(const ModuleConfig_AmbientLightingConfig& from);
  ModuleConfig_AmbientLightingConfig(ModuleConfig_AmbientLightingConfig&& from) noexcept
    : ModuleConfig_AmbientLightingConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig_AmbientLightingConfig& operator=(const ModuleConfig_AmbientLightingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig_AmbientLightingConfig& operator=(ModuleConfig_AmbientLightingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig_AmbientLightingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleConfig_AmbientLightingConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig_AmbientLightingConfig*>(
               &_ModuleConfig_AmbientLightingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ModuleConfig_AmbientLightingConfig& a, ModuleConfig_AmbientLightingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig_AmbientLightingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig_AmbientLightingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig_AmbientLightingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig_AmbientLightingConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig_AmbientLightingConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig_AmbientLightingConfig& from) {
    ModuleConfig_AmbientLightingConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig_AmbientLightingConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig.AmbientLightingConfig";
  }
  protected:
  explicit ModuleConfig_AmbientLightingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLedStateFieldNumber = 1,
    kCurrentFieldNumber = 2,
    kRedFieldNumber = 3,
    kGreenFieldNumber = 4,
    kBlueFieldNumber = 5,
  };
  // bool led_state = 1;
  void clear_led_state();
  bool led_state() const;
  void set_led_state(bool value);
  private:
  bool _internal_led_state() const;
  void _internal_set_led_state(bool value);
  public:

  // uint32 current = 2;
  void clear_current();
  uint32_t current() const;
  void set_current(uint32_t value);
  private:
  uint32_t _internal_current() const;
  void _internal_set_current(uint32_t value);
  public:

  // uint32 red = 3;
  void clear_red();
  uint32_t red() const;
  void set_red(uint32_t value);
  private:
  uint32_t _internal_red() const;
  void _internal_set_red(uint32_t value);
  public:

  // uint32 green = 4;
  void clear_green();
  uint32_t green() const;
  void set_green(uint32_t value);
  private:
  uint32_t _internal_green() const;
  void _internal_set_green(uint32_t value);
  public:

  // uint32 blue = 5;
  void clear_blue();
  uint32_t blue() const;
  void set_blue(uint32_t value);
  private:
  uint32_t _internal_blue() const;
  void _internal_set_blue(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig.AmbientLightingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool led_state_;
    uint32_t current_;
    uint32_t red_;
    uint32_t green_;
    uint32_t blue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModuleConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.ModuleConfig) */ {
 public:
  inline ModuleConfig() : ModuleConfig(nullptr) {}
  ~ModuleConfig() override;
  explicit PROTOBUF_CONSTEXPR ModuleConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleConfig(const ModuleConfig& from);
  ModuleConfig(ModuleConfig&& from) noexcept
    : ModuleConfig() {
    *this = ::std::move(from);
  }

  inline ModuleConfig& operator=(const ModuleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleConfig& operator=(ModuleConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleConfig& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadVariantCase {
    kMqtt = 1,
    kSerial = 2,
    kExternalNotification = 3,
    kStoreForward = 4,
    kRangeTest = 5,
    kTelemetry = 6,
    kCannedMessage = 7,
    kAudio = 8,
    kRemoteHardware = 9,
    kNeighborInfo = 10,
    kAmbientLighting = 11,
    kDetectionSensor = 12,
    kPaxcounter = 13,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };

  static inline const ModuleConfig* internal_default_instance() {
    return reinterpret_cast<const ModuleConfig*>(
               &_ModuleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ModuleConfig& a, ModuleConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModuleConfig& from) {
    ModuleConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.ModuleConfig";
  }
  protected:
  explicit ModuleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModuleConfig_MQTTConfig MQTTConfig;
  typedef ModuleConfig_MapReportSettings MapReportSettings;
  typedef ModuleConfig_RemoteHardwareConfig RemoteHardwareConfig;
  typedef ModuleConfig_NeighborInfoConfig NeighborInfoConfig;
  typedef ModuleConfig_DetectionSensorConfig DetectionSensorConfig;
  typedef ModuleConfig_AudioConfig AudioConfig;
  typedef ModuleConfig_PaxcounterConfig PaxcounterConfig;
  typedef ModuleConfig_SerialConfig SerialConfig;
  typedef ModuleConfig_ExternalNotificationConfig ExternalNotificationConfig;
  typedef ModuleConfig_StoreForwardConfig StoreForwardConfig;
  typedef ModuleConfig_RangeTestConfig RangeTestConfig;
  typedef ModuleConfig_TelemetryConfig TelemetryConfig;
  typedef ModuleConfig_CannedMessageConfig CannedMessageConfig;
  typedef ModuleConfig_AmbientLightingConfig AmbientLightingConfig;

  // accessors -------------------------------------------------------

  enum : int {
    kMqttFieldNumber = 1,
    kSerialFieldNumber = 2,
    kExternalNotificationFieldNumber = 3,
    kStoreForwardFieldNumber = 4,
    kRangeTestFieldNumber = 5,
    kTelemetryFieldNumber = 6,
    kCannedMessageFieldNumber = 7,
    kAudioFieldNumber = 8,
    kRemoteHardwareFieldNumber = 9,
    kNeighborInfoFieldNumber = 10,
    kAmbientLightingFieldNumber = 11,
    kDetectionSensorFieldNumber = 12,
    kPaxcounterFieldNumber = 13,
  };
  // .meshtastic.ModuleConfig.MQTTConfig mqtt = 1;
  bool has_mqtt() const;
  private:
  bool _internal_has_mqtt() const;
  public:
  void clear_mqtt();
  const ::meshtastic::ModuleConfig_MQTTConfig& mqtt() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_MQTTConfig* release_mqtt();
  ::meshtastic::ModuleConfig_MQTTConfig* mutable_mqtt();
  void set_allocated_mqtt(::meshtastic::ModuleConfig_MQTTConfig* mqtt);
  private:
  const ::meshtastic::ModuleConfig_MQTTConfig& _internal_mqtt() const;
  ::meshtastic::ModuleConfig_MQTTConfig* _internal_mutable_mqtt();
  public:
  void unsafe_arena_set_allocated_mqtt(
      ::meshtastic::ModuleConfig_MQTTConfig* mqtt);
  ::meshtastic::ModuleConfig_MQTTConfig* unsafe_arena_release_mqtt();

  // .meshtastic.ModuleConfig.SerialConfig serial = 2;
  bool has_serial() const;
  private:
  bool _internal_has_serial() const;
  public:
  void clear_serial();
  const ::meshtastic::ModuleConfig_SerialConfig& serial() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_SerialConfig* release_serial();
  ::meshtastic::ModuleConfig_SerialConfig* mutable_serial();
  void set_allocated_serial(::meshtastic::ModuleConfig_SerialConfig* serial);
  private:
  const ::meshtastic::ModuleConfig_SerialConfig& _internal_serial() const;
  ::meshtastic::ModuleConfig_SerialConfig* _internal_mutable_serial();
  public:
  void unsafe_arena_set_allocated_serial(
      ::meshtastic::ModuleConfig_SerialConfig* serial);
  ::meshtastic::ModuleConfig_SerialConfig* unsafe_arena_release_serial();

  // .meshtastic.ModuleConfig.ExternalNotificationConfig external_notification = 3;
  bool has_external_notification() const;
  private:
  bool _internal_has_external_notification() const;
  public:
  void clear_external_notification();
  const ::meshtastic::ModuleConfig_ExternalNotificationConfig& external_notification() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_ExternalNotificationConfig* release_external_notification();
  ::meshtastic::ModuleConfig_ExternalNotificationConfig* mutable_external_notification();
  void set_allocated_external_notification(::meshtastic::ModuleConfig_ExternalNotificationConfig* external_notification);
  private:
  const ::meshtastic::ModuleConfig_ExternalNotificationConfig& _internal_external_notification() const;
  ::meshtastic::ModuleConfig_ExternalNotificationConfig* _internal_mutable_external_notification();
  public:
  void unsafe_arena_set_allocated_external_notification(
      ::meshtastic::ModuleConfig_ExternalNotificationConfig* external_notification);
  ::meshtastic::ModuleConfig_ExternalNotificationConfig* unsafe_arena_release_external_notification();

  // .meshtastic.ModuleConfig.StoreForwardConfig store_forward = 4;
  bool has_store_forward() const;
  private:
  bool _internal_has_store_forward() const;
  public:
  void clear_store_forward();
  const ::meshtastic::ModuleConfig_StoreForwardConfig& store_forward() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_StoreForwardConfig* release_store_forward();
  ::meshtastic::ModuleConfig_StoreForwardConfig* mutable_store_forward();
  void set_allocated_store_forward(::meshtastic::ModuleConfig_StoreForwardConfig* store_forward);
  private:
  const ::meshtastic::ModuleConfig_StoreForwardConfig& _internal_store_forward() const;
  ::meshtastic::ModuleConfig_StoreForwardConfig* _internal_mutable_store_forward();
  public:
  void unsafe_arena_set_allocated_store_forward(
      ::meshtastic::ModuleConfig_StoreForwardConfig* store_forward);
  ::meshtastic::ModuleConfig_StoreForwardConfig* unsafe_arena_release_store_forward();

  // .meshtastic.ModuleConfig.RangeTestConfig range_test = 5;
  bool has_range_test() const;
  private:
  bool _internal_has_range_test() const;
  public:
  void clear_range_test();
  const ::meshtastic::ModuleConfig_RangeTestConfig& range_test() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_RangeTestConfig* release_range_test();
  ::meshtastic::ModuleConfig_RangeTestConfig* mutable_range_test();
  void set_allocated_range_test(::meshtastic::ModuleConfig_RangeTestConfig* range_test);
  private:
  const ::meshtastic::ModuleConfig_RangeTestConfig& _internal_range_test() const;
  ::meshtastic::ModuleConfig_RangeTestConfig* _internal_mutable_range_test();
  public:
  void unsafe_arena_set_allocated_range_test(
      ::meshtastic::ModuleConfig_RangeTestConfig* range_test);
  ::meshtastic::ModuleConfig_RangeTestConfig* unsafe_arena_release_range_test();

  // .meshtastic.ModuleConfig.TelemetryConfig telemetry = 6;
  bool has_telemetry() const;
  private:
  bool _internal_has_telemetry() const;
  public:
  void clear_telemetry();
  const ::meshtastic::ModuleConfig_TelemetryConfig& telemetry() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_TelemetryConfig* release_telemetry();
  ::meshtastic::ModuleConfig_TelemetryConfig* mutable_telemetry();
  void set_allocated_telemetry(::meshtastic::ModuleConfig_TelemetryConfig* telemetry);
  private:
  const ::meshtastic::ModuleConfig_TelemetryConfig& _internal_telemetry() const;
  ::meshtastic::ModuleConfig_TelemetryConfig* _internal_mutable_telemetry();
  public:
  void unsafe_arena_set_allocated_telemetry(
      ::meshtastic::ModuleConfig_TelemetryConfig* telemetry);
  ::meshtastic::ModuleConfig_TelemetryConfig* unsafe_arena_release_telemetry();

  // .meshtastic.ModuleConfig.CannedMessageConfig canned_message = 7;
  bool has_canned_message() const;
  private:
  bool _internal_has_canned_message() const;
  public:
  void clear_canned_message();
  const ::meshtastic::ModuleConfig_CannedMessageConfig& canned_message() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_CannedMessageConfig* release_canned_message();
  ::meshtastic::ModuleConfig_CannedMessageConfig* mutable_canned_message();
  void set_allocated_canned_message(::meshtastic::ModuleConfig_CannedMessageConfig* canned_message);
  private:
  const ::meshtastic::ModuleConfig_CannedMessageConfig& _internal_canned_message() const;
  ::meshtastic::ModuleConfig_CannedMessageConfig* _internal_mutable_canned_message();
  public:
  void unsafe_arena_set_allocated_canned_message(
      ::meshtastic::ModuleConfig_CannedMessageConfig* canned_message);
  ::meshtastic::ModuleConfig_CannedMessageConfig* unsafe_arena_release_canned_message();

  // .meshtastic.ModuleConfig.AudioConfig audio = 8;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::meshtastic::ModuleConfig_AudioConfig& audio() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_AudioConfig* release_audio();
  ::meshtastic::ModuleConfig_AudioConfig* mutable_audio();
  void set_allocated_audio(::meshtastic::ModuleConfig_AudioConfig* audio);
  private:
  const ::meshtastic::ModuleConfig_AudioConfig& _internal_audio() const;
  ::meshtastic::ModuleConfig_AudioConfig* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::meshtastic::ModuleConfig_AudioConfig* audio);
  ::meshtastic::ModuleConfig_AudioConfig* unsafe_arena_release_audio();

  // .meshtastic.ModuleConfig.RemoteHardwareConfig remote_hardware = 9;
  bool has_remote_hardware() const;
  private:
  bool _internal_has_remote_hardware() const;
  public:
  void clear_remote_hardware();
  const ::meshtastic::ModuleConfig_RemoteHardwareConfig& remote_hardware() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_RemoteHardwareConfig* release_remote_hardware();
  ::meshtastic::ModuleConfig_RemoteHardwareConfig* mutable_remote_hardware();
  void set_allocated_remote_hardware(::meshtastic::ModuleConfig_RemoteHardwareConfig* remote_hardware);
  private:
  const ::meshtastic::ModuleConfig_RemoteHardwareConfig& _internal_remote_hardware() const;
  ::meshtastic::ModuleConfig_RemoteHardwareConfig* _internal_mutable_remote_hardware();
  public:
  void unsafe_arena_set_allocated_remote_hardware(
      ::meshtastic::ModuleConfig_RemoteHardwareConfig* remote_hardware);
  ::meshtastic::ModuleConfig_RemoteHardwareConfig* unsafe_arena_release_remote_hardware();

  // .meshtastic.ModuleConfig.NeighborInfoConfig neighbor_info = 10;
  bool has_neighbor_info() const;
  private:
  bool _internal_has_neighbor_info() const;
  public:
  void clear_neighbor_info();
  const ::meshtastic::ModuleConfig_NeighborInfoConfig& neighbor_info() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_NeighborInfoConfig* release_neighbor_info();
  ::meshtastic::ModuleConfig_NeighborInfoConfig* mutable_neighbor_info();
  void set_allocated_neighbor_info(::meshtastic::ModuleConfig_NeighborInfoConfig* neighbor_info);
  private:
  const ::meshtastic::ModuleConfig_NeighborInfoConfig& _internal_neighbor_info() const;
  ::meshtastic::ModuleConfig_NeighborInfoConfig* _internal_mutable_neighbor_info();
  public:
  void unsafe_arena_set_allocated_neighbor_info(
      ::meshtastic::ModuleConfig_NeighborInfoConfig* neighbor_info);
  ::meshtastic::ModuleConfig_NeighborInfoConfig* unsafe_arena_release_neighbor_info();

  // .meshtastic.ModuleConfig.AmbientLightingConfig ambient_lighting = 11;
  bool has_ambient_lighting() const;
  private:
  bool _internal_has_ambient_lighting() const;
  public:
  void clear_ambient_lighting();
  const ::meshtastic::ModuleConfig_AmbientLightingConfig& ambient_lighting() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_AmbientLightingConfig* release_ambient_lighting();
  ::meshtastic::ModuleConfig_AmbientLightingConfig* mutable_ambient_lighting();
  void set_allocated_ambient_lighting(::meshtastic::ModuleConfig_AmbientLightingConfig* ambient_lighting);
  private:
  const ::meshtastic::ModuleConfig_AmbientLightingConfig& _internal_ambient_lighting() const;
  ::meshtastic::ModuleConfig_AmbientLightingConfig* _internal_mutable_ambient_lighting();
  public:
  void unsafe_arena_set_allocated_ambient_lighting(
      ::meshtastic::ModuleConfig_AmbientLightingConfig* ambient_lighting);
  ::meshtastic::ModuleConfig_AmbientLightingConfig* unsafe_arena_release_ambient_lighting();

  // .meshtastic.ModuleConfig.DetectionSensorConfig detection_sensor = 12;
  bool has_detection_sensor() const;
  private:
  bool _internal_has_detection_sensor() const;
  public:
  void clear_detection_sensor();
  const ::meshtastic::ModuleConfig_DetectionSensorConfig& detection_sensor() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_DetectionSensorConfig* release_detection_sensor();
  ::meshtastic::ModuleConfig_DetectionSensorConfig* mutable_detection_sensor();
  void set_allocated_detection_sensor(::meshtastic::ModuleConfig_DetectionSensorConfig* detection_sensor);
  private:
  const ::meshtastic::ModuleConfig_DetectionSensorConfig& _internal_detection_sensor() const;
  ::meshtastic::ModuleConfig_DetectionSensorConfig* _internal_mutable_detection_sensor();
  public:
  void unsafe_arena_set_allocated_detection_sensor(
      ::meshtastic::ModuleConfig_DetectionSensorConfig* detection_sensor);
  ::meshtastic::ModuleConfig_DetectionSensorConfig* unsafe_arena_release_detection_sensor();

  // .meshtastic.ModuleConfig.PaxcounterConfig paxcounter = 13;
  bool has_paxcounter() const;
  private:
  bool _internal_has_paxcounter() const;
  public:
  void clear_paxcounter();
  const ::meshtastic::ModuleConfig_PaxcounterConfig& paxcounter() const;
  PROTOBUF_NODISCARD ::meshtastic::ModuleConfig_PaxcounterConfig* release_paxcounter();
  ::meshtastic::ModuleConfig_PaxcounterConfig* mutable_paxcounter();
  void set_allocated_paxcounter(::meshtastic::ModuleConfig_PaxcounterConfig* paxcounter);
  private:
  const ::meshtastic::ModuleConfig_PaxcounterConfig& _internal_paxcounter() const;
  ::meshtastic::ModuleConfig_PaxcounterConfig* _internal_mutable_paxcounter();
  public:
  void unsafe_arena_set_allocated_paxcounter(
      ::meshtastic::ModuleConfig_PaxcounterConfig* paxcounter);
  ::meshtastic::ModuleConfig_PaxcounterConfig* unsafe_arena_release_paxcounter();

  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.ModuleConfig)
 private:
  class _Internal;
  void set_has_mqtt();
  void set_has_serial();
  void set_has_external_notification();
  void set_has_store_forward();
  void set_has_range_test();
  void set_has_telemetry();
  void set_has_canned_message();
  void set_has_audio();
  void set_has_remote_hardware();
  void set_has_neighbor_info();
  void set_has_ambient_lighting();
  void set_has_detection_sensor();
  void set_has_paxcounter();

  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::meshtastic::ModuleConfig_MQTTConfig* mqtt_;
      ::meshtastic::ModuleConfig_SerialConfig* serial_;
      ::meshtastic::ModuleConfig_ExternalNotificationConfig* external_notification_;
      ::meshtastic::ModuleConfig_StoreForwardConfig* store_forward_;
      ::meshtastic::ModuleConfig_RangeTestConfig* range_test_;
      ::meshtastic::ModuleConfig_TelemetryConfig* telemetry_;
      ::meshtastic::ModuleConfig_CannedMessageConfig* canned_message_;
      ::meshtastic::ModuleConfig_AudioConfig* audio_;
      ::meshtastic::ModuleConfig_RemoteHardwareConfig* remote_hardware_;
      ::meshtastic::ModuleConfig_NeighborInfoConfig* neighbor_info_;
      ::meshtastic::ModuleConfig_AmbientLightingConfig* ambient_lighting_;
      ::meshtastic::ModuleConfig_DetectionSensorConfig* detection_sensor_;
      ::meshtastic::ModuleConfig_PaxcounterConfig* paxcounter_;
    } payload_variant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class RemoteHardwarePin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meshtastic.RemoteHardwarePin) */ {
 public:
  inline RemoteHardwarePin() : RemoteHardwarePin(nullptr) {}
  ~RemoteHardwarePin() override;
  explicit PROTOBUF_CONSTEXPR RemoteHardwarePin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteHardwarePin(const RemoteHardwarePin& from);
  RemoteHardwarePin(RemoteHardwarePin&& from) noexcept
    : RemoteHardwarePin() {
    *this = ::std::move(from);
  }

  inline RemoteHardwarePin& operator=(const RemoteHardwarePin& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteHardwarePin& operator=(RemoteHardwarePin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteHardwarePin& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteHardwarePin* internal_default_instance() {
    return reinterpret_cast<const RemoteHardwarePin*>(
               &_RemoteHardwarePin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RemoteHardwarePin& a, RemoteHardwarePin& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteHardwarePin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteHardwarePin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteHardwarePin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteHardwarePin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteHardwarePin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoteHardwarePin& from) {
    RemoteHardwarePin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteHardwarePin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "meshtastic.RemoteHardwarePin";
  }
  protected:
  explicit RemoteHardwarePin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kGpioPinFieldNumber = 1,
    kTypeFieldNumber = 3,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 gpio_pin = 1;
  void clear_gpio_pin();
  uint32_t gpio_pin() const;
  void set_gpio_pin(uint32_t value);
  private:
  uint32_t _internal_gpio_pin() const;
  void _internal_set_gpio_pin(uint32_t value);
  public:

  // .meshtastic.RemoteHardwarePinType type = 3;
  void clear_type();
  ::meshtastic::RemoteHardwarePinType type() const;
  void set_type(::meshtastic::RemoteHardwarePinType value);
  private:
  ::meshtastic::RemoteHardwarePinType _internal_type() const;
  void _internal_set_type(::meshtastic::RemoteHardwarePinType value);
  public:

  // @@protoc_insertion_point(class_scope:meshtastic.RemoteHardwarePin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t gpio_pin_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fmodule_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModuleConfig_MQTTConfig

// bool enabled = 1;
inline void ModuleConfig_MQTTConfig::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool ModuleConfig_MQTTConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool ModuleConfig_MQTTConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MQTTConfig.enabled)
  return _internal_enabled();
}
inline void ModuleConfig_MQTTConfig::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void ModuleConfig_MQTTConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MQTTConfig.enabled)
}

// string address = 2;
inline void ModuleConfig_MQTTConfig::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& ModuleConfig_MQTTConfig::address() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MQTTConfig.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleConfig_MQTTConfig::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MQTTConfig.address)
}
inline std::string* ModuleConfig_MQTTConfig::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.MQTTConfig.address)
  return _s;
}
inline const std::string& ModuleConfig_MQTTConfig::_internal_address() const {
  return _impl_.address_.Get();
}
inline void ModuleConfig_MQTTConfig::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleConfig_MQTTConfig::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleConfig_MQTTConfig::release_address() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.MQTTConfig.address)
  return _impl_.address_.Release();
}
inline void ModuleConfig_MQTTConfig::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.MQTTConfig.address)
}

// string username = 3;
inline void ModuleConfig_MQTTConfig::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& ModuleConfig_MQTTConfig::username() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MQTTConfig.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleConfig_MQTTConfig::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MQTTConfig.username)
}
inline std::string* ModuleConfig_MQTTConfig::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.MQTTConfig.username)
  return _s;
}
inline const std::string& ModuleConfig_MQTTConfig::_internal_username() const {
  return _impl_.username_.Get();
}
inline void ModuleConfig_MQTTConfig::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleConfig_MQTTConfig::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleConfig_MQTTConfig::release_username() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.MQTTConfig.username)
  return _impl_.username_.Release();
}
inline void ModuleConfig_MQTTConfig::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.MQTTConfig.username)
}

// string password = 4;
inline void ModuleConfig_MQTTConfig::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& ModuleConfig_MQTTConfig::password() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MQTTConfig.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleConfig_MQTTConfig::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MQTTConfig.password)
}
inline std::string* ModuleConfig_MQTTConfig::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.MQTTConfig.password)
  return _s;
}
inline const std::string& ModuleConfig_MQTTConfig::_internal_password() const {
  return _impl_.password_.Get();
}
inline void ModuleConfig_MQTTConfig::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleConfig_MQTTConfig::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleConfig_MQTTConfig::release_password() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.MQTTConfig.password)
  return _impl_.password_.Release();
}
inline void ModuleConfig_MQTTConfig::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.MQTTConfig.password)
}

// bool encryption_enabled = 5;
inline void ModuleConfig_MQTTConfig::clear_encryption_enabled() {
  _impl_.encryption_enabled_ = false;
}
inline bool ModuleConfig_MQTTConfig::_internal_encryption_enabled() const {
  return _impl_.encryption_enabled_;
}
inline bool ModuleConfig_MQTTConfig::encryption_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MQTTConfig.encryption_enabled)
  return _internal_encryption_enabled();
}
inline void ModuleConfig_MQTTConfig::_internal_set_encryption_enabled(bool value) {
  
  _impl_.encryption_enabled_ = value;
}
inline void ModuleConfig_MQTTConfig::set_encryption_enabled(bool value) {
  _internal_set_encryption_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MQTTConfig.encryption_enabled)
}

// bool json_enabled = 6;
inline void ModuleConfig_MQTTConfig::clear_json_enabled() {
  _impl_.json_enabled_ = false;
}
inline bool ModuleConfig_MQTTConfig::_internal_json_enabled() const {
  return _impl_.json_enabled_;
}
inline bool ModuleConfig_MQTTConfig::json_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MQTTConfig.json_enabled)
  return _internal_json_enabled();
}
inline void ModuleConfig_MQTTConfig::_internal_set_json_enabled(bool value) {
  
  _impl_.json_enabled_ = value;
}
inline void ModuleConfig_MQTTConfig::set_json_enabled(bool value) {
  _internal_set_json_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MQTTConfig.json_enabled)
}

// bool tls_enabled = 7;
inline void ModuleConfig_MQTTConfig::clear_tls_enabled() {
  _impl_.tls_enabled_ = false;
}
inline bool ModuleConfig_MQTTConfig::_internal_tls_enabled() const {
  return _impl_.tls_enabled_;
}
inline bool ModuleConfig_MQTTConfig::tls_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MQTTConfig.tls_enabled)
  return _internal_tls_enabled();
}
inline void ModuleConfig_MQTTConfig::_internal_set_tls_enabled(bool value) {
  
  _impl_.tls_enabled_ = value;
}
inline void ModuleConfig_MQTTConfig::set_tls_enabled(bool value) {
  _internal_set_tls_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MQTTConfig.tls_enabled)
}

// string root = 8;
inline void ModuleConfig_MQTTConfig::clear_root() {
  _impl_.root_.ClearToEmpty();
}
inline const std::string& ModuleConfig_MQTTConfig::root() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MQTTConfig.root)
  return _internal_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleConfig_MQTTConfig::set_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.root_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MQTTConfig.root)
}
inline std::string* ModuleConfig_MQTTConfig::mutable_root() {
  std::string* _s = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.MQTTConfig.root)
  return _s;
}
inline const std::string& ModuleConfig_MQTTConfig::_internal_root() const {
  return _impl_.root_.Get();
}
inline void ModuleConfig_MQTTConfig::_internal_set_root(const std::string& value) {
  
  _impl_.root_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleConfig_MQTTConfig::_internal_mutable_root() {
  
  return _impl_.root_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleConfig_MQTTConfig::release_root() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.MQTTConfig.root)
  return _impl_.root_.Release();
}
inline void ModuleConfig_MQTTConfig::set_allocated_root(std::string* root) {
  if (root != nullptr) {
    
  } else {
    
  }
  _impl_.root_.SetAllocated(root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.root_.IsDefault()) {
    _impl_.root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.MQTTConfig.root)
}

// bool proxy_to_client_enabled = 9;
inline void ModuleConfig_MQTTConfig::clear_proxy_to_client_enabled() {
  _impl_.proxy_to_client_enabled_ = false;
}
inline bool ModuleConfig_MQTTConfig::_internal_proxy_to_client_enabled() const {
  return _impl_.proxy_to_client_enabled_;
}
inline bool ModuleConfig_MQTTConfig::proxy_to_client_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MQTTConfig.proxy_to_client_enabled)
  return _internal_proxy_to_client_enabled();
}
inline void ModuleConfig_MQTTConfig::_internal_set_proxy_to_client_enabled(bool value) {
  
  _impl_.proxy_to_client_enabled_ = value;
}
inline void ModuleConfig_MQTTConfig::set_proxy_to_client_enabled(bool value) {
  _internal_set_proxy_to_client_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MQTTConfig.proxy_to_client_enabled)
}

// bool map_reporting_enabled = 10;
inline void ModuleConfig_MQTTConfig::clear_map_reporting_enabled() {
  _impl_.map_reporting_enabled_ = false;
}
inline bool ModuleConfig_MQTTConfig::_internal_map_reporting_enabled() const {
  return _impl_.map_reporting_enabled_;
}
inline bool ModuleConfig_MQTTConfig::map_reporting_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MQTTConfig.map_reporting_enabled)
  return _internal_map_reporting_enabled();
}
inline void ModuleConfig_MQTTConfig::_internal_set_map_reporting_enabled(bool value) {
  
  _impl_.map_reporting_enabled_ = value;
}
inline void ModuleConfig_MQTTConfig::set_map_reporting_enabled(bool value) {
  _internal_set_map_reporting_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MQTTConfig.map_reporting_enabled)
}

// .meshtastic.ModuleConfig.MapReportSettings map_report_settings = 11;
inline bool ModuleConfig_MQTTConfig::_internal_has_map_report_settings() const {
  return this != internal_default_instance() && _impl_.map_report_settings_ != nullptr;
}
inline bool ModuleConfig_MQTTConfig::has_map_report_settings() const {
  return _internal_has_map_report_settings();
}
inline void ModuleConfig_MQTTConfig::clear_map_report_settings() {
  if (GetArenaForAllocation() == nullptr && _impl_.map_report_settings_ != nullptr) {
    delete _impl_.map_report_settings_;
  }
  _impl_.map_report_settings_ = nullptr;
}
inline const ::meshtastic::ModuleConfig_MapReportSettings& ModuleConfig_MQTTConfig::_internal_map_report_settings() const {
  const ::meshtastic::ModuleConfig_MapReportSettings* p = _impl_.map_report_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ModuleConfig_MapReportSettings&>(
      ::meshtastic::_ModuleConfig_MapReportSettings_default_instance_);
}
inline const ::meshtastic::ModuleConfig_MapReportSettings& ModuleConfig_MQTTConfig::map_report_settings() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MQTTConfig.map_report_settings)
  return _internal_map_report_settings();
}
inline void ModuleConfig_MQTTConfig::unsafe_arena_set_allocated_map_report_settings(
    ::meshtastic::ModuleConfig_MapReportSettings* map_report_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_report_settings_);
  }
  _impl_.map_report_settings_ = map_report_settings;
  if (map_report_settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.MQTTConfig.map_report_settings)
}
inline ::meshtastic::ModuleConfig_MapReportSettings* ModuleConfig_MQTTConfig::release_map_report_settings() {
  
  ::meshtastic::ModuleConfig_MapReportSettings* temp = _impl_.map_report_settings_;
  _impl_.map_report_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::meshtastic::ModuleConfig_MapReportSettings* ModuleConfig_MQTTConfig::unsafe_arena_release_map_report_settings() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.MQTTConfig.map_report_settings)
  
  ::meshtastic::ModuleConfig_MapReportSettings* temp = _impl_.map_report_settings_;
  _impl_.map_report_settings_ = nullptr;
  return temp;
}
inline ::meshtastic::ModuleConfig_MapReportSettings* ModuleConfig_MQTTConfig::_internal_mutable_map_report_settings() {
  
  if (_impl_.map_report_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::meshtastic::ModuleConfig_MapReportSettings>(GetArenaForAllocation());
    _impl_.map_report_settings_ = p;
  }
  return _impl_.map_report_settings_;
}
inline ::meshtastic::ModuleConfig_MapReportSettings* ModuleConfig_MQTTConfig::mutable_map_report_settings() {
  ::meshtastic::ModuleConfig_MapReportSettings* _msg = _internal_mutable_map_report_settings();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.MQTTConfig.map_report_settings)
  return _msg;
}
inline void ModuleConfig_MQTTConfig::set_allocated_map_report_settings(::meshtastic::ModuleConfig_MapReportSettings* map_report_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.map_report_settings_;
  }
  if (map_report_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_report_settings);
    if (message_arena != submessage_arena) {
      map_report_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_report_settings, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.map_report_settings_ = map_report_settings;
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.MQTTConfig.map_report_settings)
}

// -------------------------------------------------------------------

// ModuleConfig_MapReportSettings

// uint32 publish_interval_secs = 1;
inline void ModuleConfig_MapReportSettings::clear_publish_interval_secs() {
  _impl_.publish_interval_secs_ = 0u;
}
inline uint32_t ModuleConfig_MapReportSettings::_internal_publish_interval_secs() const {
  return _impl_.publish_interval_secs_;
}
inline uint32_t ModuleConfig_MapReportSettings::publish_interval_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MapReportSettings.publish_interval_secs)
  return _internal_publish_interval_secs();
}
inline void ModuleConfig_MapReportSettings::_internal_set_publish_interval_secs(uint32_t value) {
  
  _impl_.publish_interval_secs_ = value;
}
inline void ModuleConfig_MapReportSettings::set_publish_interval_secs(uint32_t value) {
  _internal_set_publish_interval_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MapReportSettings.publish_interval_secs)
}

// uint32 position_precision = 2;
inline void ModuleConfig_MapReportSettings::clear_position_precision() {
  _impl_.position_precision_ = 0u;
}
inline uint32_t ModuleConfig_MapReportSettings::_internal_position_precision() const {
  return _impl_.position_precision_;
}
inline uint32_t ModuleConfig_MapReportSettings::position_precision() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MapReportSettings.position_precision)
  return _internal_position_precision();
}
inline void ModuleConfig_MapReportSettings::_internal_set_position_precision(uint32_t value) {
  
  _impl_.position_precision_ = value;
}
inline void ModuleConfig_MapReportSettings::set_position_precision(uint32_t value) {
  _internal_set_position_precision(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MapReportSettings.position_precision)
}

// bool should_report_location = 3;
inline void ModuleConfig_MapReportSettings::clear_should_report_location() {
  _impl_.should_report_location_ = false;
}
inline bool ModuleConfig_MapReportSettings::_internal_should_report_location() const {
  return _impl_.should_report_location_;
}
inline bool ModuleConfig_MapReportSettings::should_report_location() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.MapReportSettings.should_report_location)
  return _internal_should_report_location();
}
inline void ModuleConfig_MapReportSettings::_internal_set_should_report_location(bool value) {
  
  _impl_.should_report_location_ = value;
}
inline void ModuleConfig_MapReportSettings::set_should_report_location(bool value) {
  _internal_set_should_report_location(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.MapReportSettings.should_report_location)
}

// -------------------------------------------------------------------

// ModuleConfig_RemoteHardwareConfig

// bool enabled = 1;
inline void ModuleConfig_RemoteHardwareConfig::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool ModuleConfig_RemoteHardwareConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool ModuleConfig_RemoteHardwareConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.RemoteHardwareConfig.enabled)
  return _internal_enabled();
}
inline void ModuleConfig_RemoteHardwareConfig::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void ModuleConfig_RemoteHardwareConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.RemoteHardwareConfig.enabled)
}

// bool allow_undefined_pin_access = 2;
inline void ModuleConfig_RemoteHardwareConfig::clear_allow_undefined_pin_access() {
  _impl_.allow_undefined_pin_access_ = false;
}
inline bool ModuleConfig_RemoteHardwareConfig::_internal_allow_undefined_pin_access() const {
  return _impl_.allow_undefined_pin_access_;
}
inline bool ModuleConfig_RemoteHardwareConfig::allow_undefined_pin_access() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.RemoteHardwareConfig.allow_undefined_pin_access)
  return _internal_allow_undefined_pin_access();
}
inline void ModuleConfig_RemoteHardwareConfig::_internal_set_allow_undefined_pin_access(bool value) {
  
  _impl_.allow_undefined_pin_access_ = value;
}
inline void ModuleConfig_RemoteHardwareConfig::set_allow_undefined_pin_access(bool value) {
  _internal_set_allow_undefined_pin_access(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.RemoteHardwareConfig.allow_undefined_pin_access)
}

// repeated .meshtastic.RemoteHardwarePin available_pins = 3;
inline int ModuleConfig_RemoteHardwareConfig::_internal_available_pins_size() const {
  return _impl_.available_pins_.size();
}
inline int ModuleConfig_RemoteHardwareConfig::available_pins_size() const {
  return _internal_available_pins_size();
}
inline void ModuleConfig_RemoteHardwareConfig::clear_available_pins() {
  _impl_.available_pins_.Clear();
}
inline ::meshtastic::RemoteHardwarePin* ModuleConfig_RemoteHardwareConfig::mutable_available_pins(int index) {
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.RemoteHardwareConfig.available_pins)
  return _impl_.available_pins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::RemoteHardwarePin >*
ModuleConfig_RemoteHardwareConfig::mutable_available_pins() {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.ModuleConfig.RemoteHardwareConfig.available_pins)
  return &_impl_.available_pins_;
}
inline const ::meshtastic::RemoteHardwarePin& ModuleConfig_RemoteHardwareConfig::_internal_available_pins(int index) const {
  return _impl_.available_pins_.Get(index);
}
inline const ::meshtastic::RemoteHardwarePin& ModuleConfig_RemoteHardwareConfig::available_pins(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.RemoteHardwareConfig.available_pins)
  return _internal_available_pins(index);
}
inline ::meshtastic::RemoteHardwarePin* ModuleConfig_RemoteHardwareConfig::_internal_add_available_pins() {
  return _impl_.available_pins_.Add();
}
inline ::meshtastic::RemoteHardwarePin* ModuleConfig_RemoteHardwareConfig::add_available_pins() {
  ::meshtastic::RemoteHardwarePin* _add = _internal_add_available_pins();
  // @@protoc_insertion_point(field_add:meshtastic.ModuleConfig.RemoteHardwareConfig.available_pins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::meshtastic::RemoteHardwarePin >&
ModuleConfig_RemoteHardwareConfig::available_pins() const {
  // @@protoc_insertion_point(field_list:meshtastic.ModuleConfig.RemoteHardwareConfig.available_pins)
  return _impl_.available_pins_;
}

// -------------------------------------------------------------------

// ModuleConfig_NeighborInfoConfig

// bool enabled = 1;
inline void ModuleConfig_NeighborInfoConfig::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool ModuleConfig_NeighborInfoConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool ModuleConfig_NeighborInfoConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.NeighborInfoConfig.enabled)
  return _internal_enabled();
}
inline void ModuleConfig_NeighborInfoConfig::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void ModuleConfig_NeighborInfoConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.NeighborInfoConfig.enabled)
}

// uint32 update_interval = 2;
inline void ModuleConfig_NeighborInfoConfig::clear_update_interval() {
  _impl_.update_interval_ = 0u;
}
inline uint32_t ModuleConfig_NeighborInfoConfig::_internal_update_interval() const {
  return _impl_.update_interval_;
}
inline uint32_t ModuleConfig_NeighborInfoConfig::update_interval() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.NeighborInfoConfig.update_interval)
  return _internal_update_interval();
}
inline void ModuleConfig_NeighborInfoConfig::_internal_set_update_interval(uint32_t value) {
  
  _impl_.update_interval_ = value;
}
inline void ModuleConfig_NeighborInfoConfig::set_update_interval(uint32_t value) {
  _internal_set_update_interval(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.NeighborInfoConfig.update_interval)
}

// bool transmit_over_lora = 3;
inline void ModuleConfig_NeighborInfoConfig::clear_transmit_over_lora() {
  _impl_.transmit_over_lora_ = false;
}
inline bool ModuleConfig_NeighborInfoConfig::_internal_transmit_over_lora() const {
  return _impl_.transmit_over_lora_;
}
inline bool ModuleConfig_NeighborInfoConfig::transmit_over_lora() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.NeighborInfoConfig.transmit_over_lora)
  return _internal_transmit_over_lora();
}
inline void ModuleConfig_NeighborInfoConfig::_internal_set_transmit_over_lora(bool value) {
  
  _impl_.transmit_over_lora_ = value;
}
inline void ModuleConfig_NeighborInfoConfig::set_transmit_over_lora(bool value) {
  _internal_set_transmit_over_lora(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.NeighborInfoConfig.transmit_over_lora)
}

// -------------------------------------------------------------------

// ModuleConfig_DetectionSensorConfig

// bool enabled = 1;
inline void ModuleConfig_DetectionSensorConfig::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool ModuleConfig_DetectionSensorConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool ModuleConfig_DetectionSensorConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.DetectionSensorConfig.enabled)
  return _internal_enabled();
}
inline void ModuleConfig_DetectionSensorConfig::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void ModuleConfig_DetectionSensorConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.DetectionSensorConfig.enabled)
}

// uint32 minimum_broadcast_secs = 2;
inline void ModuleConfig_DetectionSensorConfig::clear_minimum_broadcast_secs() {
  _impl_.minimum_broadcast_secs_ = 0u;
}
inline uint32_t ModuleConfig_DetectionSensorConfig::_internal_minimum_broadcast_secs() const {
  return _impl_.minimum_broadcast_secs_;
}
inline uint32_t ModuleConfig_DetectionSensorConfig::minimum_broadcast_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.DetectionSensorConfig.minimum_broadcast_secs)
  return _internal_minimum_broadcast_secs();
}
inline void ModuleConfig_DetectionSensorConfig::_internal_set_minimum_broadcast_secs(uint32_t value) {
  
  _impl_.minimum_broadcast_secs_ = value;
}
inline void ModuleConfig_DetectionSensorConfig::set_minimum_broadcast_secs(uint32_t value) {
  _internal_set_minimum_broadcast_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.DetectionSensorConfig.minimum_broadcast_secs)
}

// uint32 state_broadcast_secs = 3;
inline void ModuleConfig_DetectionSensorConfig::clear_state_broadcast_secs() {
  _impl_.state_broadcast_secs_ = 0u;
}
inline uint32_t ModuleConfig_DetectionSensorConfig::_internal_state_broadcast_secs() const {
  return _impl_.state_broadcast_secs_;
}
inline uint32_t ModuleConfig_DetectionSensorConfig::state_broadcast_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.DetectionSensorConfig.state_broadcast_secs)
  return _internal_state_broadcast_secs();
}
inline void ModuleConfig_DetectionSensorConfig::_internal_set_state_broadcast_secs(uint32_t value) {
  
  _impl_.state_broadcast_secs_ = value;
}
inline void ModuleConfig_DetectionSensorConfig::set_state_broadcast_secs(uint32_t value) {
  _internal_set_state_broadcast_secs(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.DetectionSensorConfig.state_broadcast_secs)
}

// bool send_bell = 4;
inline void ModuleConfig_DetectionSensorConfig::clear_send_bell() {
  _impl_.send_bell_ = false;
}
inline bool ModuleConfig_DetectionSensorConfig::_internal_send_bell() const {
  return _impl_.send_bell_;
}
inline bool ModuleConfig_DetectionSensorConfig::send_bell() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.DetectionSensorConfig.send_bell)
  return _internal_send_bell();
}
inline void ModuleConfig_DetectionSensorConfig::_internal_set_send_bell(bool value) {
  
  _impl_.send_bell_ = value;
}
inline void ModuleConfig_DetectionSensorConfig::set_send_bell(bool value) {
  _internal_set_send_bell(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.DetectionSensorConfig.send_bell)
}

// string name = 5;
inline void ModuleConfig_DetectionSensorConfig::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModuleConfig_DetectionSensorConfig::name() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.DetectionSensorConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleConfig_DetectionSensorConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.DetectionSensorConfig.name)
}
inline std::string* ModuleConfig_DetectionSensorConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.DetectionSensorConfig.name)
  return _s;
}
inline const std::string& ModuleConfig_DetectionSensorConfig::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModuleConfig_DetectionSensorConfig::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleConfig_DetectionSensorConfig::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleConfig_DetectionSensorConfig::release_name() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.DetectionSensorConfig.name)
  return _impl_.name_.Release();
}
inline void ModuleConfig_DetectionSensorConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.DetectionSensorConfig.name)
}

// uint32 monitor_pin = 6;
inline void ModuleConfig_DetectionSensorConfig::clear_monitor_pin() {
  _impl_.monitor_pin_ = 0u;
}
inline uint32_t ModuleConfig_DetectionSensorConfig::_internal_monitor_pin() const {
  return _impl_.monitor_pin_;
}
inline uint32_t ModuleConfig_DetectionSensorConfig::monitor_pin() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.DetectionSensorConfig.monitor_pin)
  return _internal_monitor_pin();
}
inline void ModuleConfig_DetectionSensorConfig::_internal_set_monitor_pin(uint32_t value) {
  
  _impl_.monitor_pin_ = value;
}
inline void ModuleConfig_DetectionSensorConfig::set_monitor_pin(uint32_t value) {
  _internal_set_monitor_pin(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.DetectionSensorConfig.monitor_pin)
}

// .meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType detection_trigger_type = 7;
inline void ModuleConfig_DetectionSensorConfig::clear_detection_trigger_type() {
  _impl_.detection_trigger_type_ = 0;
}
inline ::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig::_internal_detection_trigger_type() const {
  return static_cast< ::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType >(_impl_.detection_trigger_type_);
}
inline ::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig::detection_trigger_type() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.DetectionSensorConfig.detection_trigger_type)
  return _internal_detection_trigger_type();
}
inline void ModuleConfig_DetectionSensorConfig::_internal_set_detection_trigger_type(::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType value) {
  
  _impl_.detection_trigger_type_ = value;
}
inline void ModuleConfig_DetectionSensorConfig::set_detection_trigger_type(::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType value) {
  _internal_set_detection_trigger_type(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.DetectionSensorConfig.detection_trigger_type)
}

// bool use_pullup = 8;
inline void ModuleConfig_DetectionSensorConfig::clear_use_pullup() {
  _impl_.use_pullup_ = false;
}
inline bool ModuleConfig_DetectionSensorConfig::_internal_use_pullup() const {
  return _impl_.use_pullup_;
}
inline bool ModuleConfig_DetectionSensorConfig::use_pullup() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.DetectionSensorConfig.use_pullup)
  return _internal_use_pullup();
}
inline void ModuleConfig_DetectionSensorConfig::_internal_set_use_pullup(bool value) {
  
  _impl_.use_pullup_ = value;
}
inline void ModuleConfig_DetectionSensorConfig::set_use_pullup(bool value) {
  _internal_set_use_pullup(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.DetectionSensorConfig.use_pullup)
}

// -------------------------------------------------------------------

// ModuleConfig_AudioConfig

// bool codec2_enabled = 1;
inline void ModuleConfig_AudioConfig::clear_codec2_enabled() {
  _impl_.codec2_enabled_ = false;
}
inline bool ModuleConfig_AudioConfig::_internal_codec2_enabled() const {
  return _impl_.codec2_enabled_;
}
inline bool ModuleConfig_AudioConfig::codec2_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AudioConfig.codec2_enabled)
  return _internal_codec2_enabled();
}
inline void ModuleConfig_AudioConfig::_internal_set_codec2_enabled(bool value) {
  
  _impl_.codec2_enabled_ = value;
}
inline void ModuleConfig_AudioConfig::set_codec2_enabled(bool value) {
  _internal_set_codec2_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AudioConfig.codec2_enabled)
}

// uint32 ptt_pin = 2;
inline void ModuleConfig_AudioConfig::clear_ptt_pin() {
  _impl_.ptt_pin_ = 0u;
}
inline uint32_t ModuleConfig_AudioConfig::_internal_ptt_pin() const {
  return _impl_.ptt_pin_;
}
inline uint32_t ModuleConfig_AudioConfig::ptt_pin() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AudioConfig.ptt_pin)
  return _internal_ptt_pin();
}
inline void ModuleConfig_AudioConfig::_internal_set_ptt_pin(uint32_t value) {
  
  _impl_.ptt_pin_ = value;
}
inline void ModuleConfig_AudioConfig::set_ptt_pin(uint32_t value) {
  _internal_set_ptt_pin(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AudioConfig.ptt_pin)
}

// .meshtastic.ModuleConfig.AudioConfig.Audio_Baud bitrate = 3;
inline void ModuleConfig_AudioConfig::clear_bitrate() {
  _impl_.bitrate_ = 0;
}
inline ::meshtastic::ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::_internal_bitrate() const {
  return static_cast< ::meshtastic::ModuleConfig_AudioConfig_Audio_Baud >(_impl_.bitrate_);
}
inline ::meshtastic::ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::bitrate() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AudioConfig.bitrate)
  return _internal_bitrate();
}
inline void ModuleConfig_AudioConfig::_internal_set_bitrate(::meshtastic::ModuleConfig_AudioConfig_Audio_Baud value) {
  
  _impl_.bitrate_ = value;
}
inline void ModuleConfig_AudioConfig::set_bitrate(::meshtastic::ModuleConfig_AudioConfig_Audio_Baud value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AudioConfig.bitrate)
}

// uint32 i2s_ws = 4;
inline void ModuleConfig_AudioConfig::clear_i2s_ws() {
  _impl_.i2s_ws_ = 0u;
}
inline uint32_t ModuleConfig_AudioConfig::_internal_i2s_ws() const {
  return _impl_.i2s_ws_;
}
inline uint32_t ModuleConfig_AudioConfig::i2s_ws() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AudioConfig.i2s_ws)
  return _internal_i2s_ws();
}
inline void ModuleConfig_AudioConfig::_internal_set_i2s_ws(uint32_t value) {
  
  _impl_.i2s_ws_ = value;
}
inline void ModuleConfig_AudioConfig::set_i2s_ws(uint32_t value) {
  _internal_set_i2s_ws(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AudioConfig.i2s_ws)
}

// uint32 i2s_sd = 5;
inline void ModuleConfig_AudioConfig::clear_i2s_sd() {
  _impl_.i2s_sd_ = 0u;
}
inline uint32_t ModuleConfig_AudioConfig::_internal_i2s_sd() const {
  return _impl_.i2s_sd_;
}
inline uint32_t ModuleConfig_AudioConfig::i2s_sd() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AudioConfig.i2s_sd)
  return _internal_i2s_sd();
}
inline void ModuleConfig_AudioConfig::_internal_set_i2s_sd(uint32_t value) {
  
  _impl_.i2s_sd_ = value;
}
inline void ModuleConfig_AudioConfig::set_i2s_sd(uint32_t value) {
  _internal_set_i2s_sd(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AudioConfig.i2s_sd)
}

// uint32 i2s_din = 6;
inline void ModuleConfig_AudioConfig::clear_i2s_din() {
  _impl_.i2s_din_ = 0u;
}
inline uint32_t ModuleConfig_AudioConfig::_internal_i2s_din() const {
  return _impl_.i2s_din_;
}
inline uint32_t ModuleConfig_AudioConfig::i2s_din() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AudioConfig.i2s_din)
  return _internal_i2s_din();
}
inline void ModuleConfig_AudioConfig::_internal_set_i2s_din(uint32_t value) {
  
  _impl_.i2s_din_ = value;
}
inline void ModuleConfig_AudioConfig::set_i2s_din(uint32_t value) {
  _internal_set_i2s_din(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AudioConfig.i2s_din)
}

// uint32 i2s_sck = 7;
inline void ModuleConfig_AudioConfig::clear_i2s_sck() {
  _impl_.i2s_sck_ = 0u;
}
inline uint32_t ModuleConfig_AudioConfig::_internal_i2s_sck() const {
  return _impl_.i2s_sck_;
}
inline uint32_t ModuleConfig_AudioConfig::i2s_sck() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AudioConfig.i2s_sck)
  return _internal_i2s_sck();
}
inline void ModuleConfig_AudioConfig::_internal_set_i2s_sck(uint32_t value) {
  
  _impl_.i2s_sck_ = value;
}
inline void ModuleConfig_AudioConfig::set_i2s_sck(uint32_t value) {
  _internal_set_i2s_sck(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AudioConfig.i2s_sck)
}

// -------------------------------------------------------------------

// ModuleConfig_PaxcounterConfig

// bool enabled = 1;
inline void ModuleConfig_PaxcounterConfig::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool ModuleConfig_PaxcounterConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool ModuleConfig_PaxcounterConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.PaxcounterConfig.enabled)
  return _internal_enabled();
}
inline void ModuleConfig_PaxcounterConfig::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void ModuleConfig_PaxcounterConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.PaxcounterConfig.enabled)
}

// uint32 paxcounter_update_interval = 2;
inline void ModuleConfig_PaxcounterConfig::clear_paxcounter_update_interval() {
  _impl_.paxcounter_update_interval_ = 0u;
}
inline uint32_t ModuleConfig_PaxcounterConfig::_internal_paxcounter_update_interval() const {
  return _impl_.paxcounter_update_interval_;
}
inline uint32_t ModuleConfig_PaxcounterConfig::paxcounter_update_interval() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.PaxcounterConfig.paxcounter_update_interval)
  return _internal_paxcounter_update_interval();
}
inline void ModuleConfig_PaxcounterConfig::_internal_set_paxcounter_update_interval(uint32_t value) {
  
  _impl_.paxcounter_update_interval_ = value;
}
inline void ModuleConfig_PaxcounterConfig::set_paxcounter_update_interval(uint32_t value) {
  _internal_set_paxcounter_update_interval(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.PaxcounterConfig.paxcounter_update_interval)
}

// int32 wifi_threshold = 3;
inline void ModuleConfig_PaxcounterConfig::clear_wifi_threshold() {
  _impl_.wifi_threshold_ = 0;
}
inline int32_t ModuleConfig_PaxcounterConfig::_internal_wifi_threshold() const {
  return _impl_.wifi_threshold_;
}
inline int32_t ModuleConfig_PaxcounterConfig::wifi_threshold() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.PaxcounterConfig.wifi_threshold)
  return _internal_wifi_threshold();
}
inline void ModuleConfig_PaxcounterConfig::_internal_set_wifi_threshold(int32_t value) {
  
  _impl_.wifi_threshold_ = value;
}
inline void ModuleConfig_PaxcounterConfig::set_wifi_threshold(int32_t value) {
  _internal_set_wifi_threshold(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.PaxcounterConfig.wifi_threshold)
}

// int32 ble_threshold = 4;
inline void ModuleConfig_PaxcounterConfig::clear_ble_threshold() {
  _impl_.ble_threshold_ = 0;
}
inline int32_t ModuleConfig_PaxcounterConfig::_internal_ble_threshold() const {
  return _impl_.ble_threshold_;
}
inline int32_t ModuleConfig_PaxcounterConfig::ble_threshold() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.PaxcounterConfig.ble_threshold)
  return _internal_ble_threshold();
}
inline void ModuleConfig_PaxcounterConfig::_internal_set_ble_threshold(int32_t value) {
  
  _impl_.ble_threshold_ = value;
}
inline void ModuleConfig_PaxcounterConfig::set_ble_threshold(int32_t value) {
  _internal_set_ble_threshold(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.PaxcounterConfig.ble_threshold)
}

// -------------------------------------------------------------------

// ModuleConfig_SerialConfig

// bool enabled = 1;
inline void ModuleConfig_SerialConfig::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool ModuleConfig_SerialConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool ModuleConfig_SerialConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.SerialConfig.enabled)
  return _internal_enabled();
}
inline void ModuleConfig_SerialConfig::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void ModuleConfig_SerialConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.SerialConfig.enabled)
}

// bool echo = 2;
inline void ModuleConfig_SerialConfig::clear_echo() {
  _impl_.echo_ = false;
}
inline bool ModuleConfig_SerialConfig::_internal_echo() const {
  return _impl_.echo_;
}
inline bool ModuleConfig_SerialConfig::echo() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.SerialConfig.echo)
  return _internal_echo();
}
inline void ModuleConfig_SerialConfig::_internal_set_echo(bool value) {
  
  _impl_.echo_ = value;
}
inline void ModuleConfig_SerialConfig::set_echo(bool value) {
  _internal_set_echo(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.SerialConfig.echo)
}

// uint32 rxd = 3;
inline void ModuleConfig_SerialConfig::clear_rxd() {
  _impl_.rxd_ = 0u;
}
inline uint32_t ModuleConfig_SerialConfig::_internal_rxd() const {
  return _impl_.rxd_;
}
inline uint32_t ModuleConfig_SerialConfig::rxd() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.SerialConfig.rxd)
  return _internal_rxd();
}
inline void ModuleConfig_SerialConfig::_internal_set_rxd(uint32_t value) {
  
  _impl_.rxd_ = value;
}
inline void ModuleConfig_SerialConfig::set_rxd(uint32_t value) {
  _internal_set_rxd(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.SerialConfig.rxd)
}

// uint32 txd = 4;
inline void ModuleConfig_SerialConfig::clear_txd() {
  _impl_.txd_ = 0u;
}
inline uint32_t ModuleConfig_SerialConfig::_internal_txd() const {
  return _impl_.txd_;
}
inline uint32_t ModuleConfig_SerialConfig::txd() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.SerialConfig.txd)
  return _internal_txd();
}
inline void ModuleConfig_SerialConfig::_internal_set_txd(uint32_t value) {
  
  _impl_.txd_ = value;
}
inline void ModuleConfig_SerialConfig::set_txd(uint32_t value) {
  _internal_set_txd(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.SerialConfig.txd)
}

// .meshtastic.ModuleConfig.SerialConfig.Serial_Baud baud = 5;
inline void ModuleConfig_SerialConfig::clear_baud() {
  _impl_.baud_ = 0;
}
inline ::meshtastic::ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::_internal_baud() const {
  return static_cast< ::meshtastic::ModuleConfig_SerialConfig_Serial_Baud >(_impl_.baud_);
}
inline ::meshtastic::ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::baud() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.SerialConfig.baud)
  return _internal_baud();
}
inline void ModuleConfig_SerialConfig::_internal_set_baud(::meshtastic::ModuleConfig_SerialConfig_Serial_Baud value) {
  
  _impl_.baud_ = value;
}
inline void ModuleConfig_SerialConfig::set_baud(::meshtastic::ModuleConfig_SerialConfig_Serial_Baud value) {
  _internal_set_baud(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.SerialConfig.baud)
}

// uint32 timeout = 6;
inline void ModuleConfig_SerialConfig::clear_timeout() {
  _impl_.timeout_ = 0u;
}
inline uint32_t ModuleConfig_SerialConfig::_internal_timeout() const {
  return _impl_.timeout_;
}
inline uint32_t ModuleConfig_SerialConfig::timeout() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.SerialConfig.timeout)
  return _internal_timeout();
}
inline void ModuleConfig_SerialConfig::_internal_set_timeout(uint32_t value) {
  
  _impl_.timeout_ = value;
}
inline void ModuleConfig_SerialConfig::set_timeout(uint32_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.SerialConfig.timeout)
}

// .meshtastic.ModuleConfig.SerialConfig.Serial_Mode mode = 7;
inline void ModuleConfig_SerialConfig::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::meshtastic::ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::_internal_mode() const {
  return static_cast< ::meshtastic::ModuleConfig_SerialConfig_Serial_Mode >(_impl_.mode_);
}
inline ::meshtastic::ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.SerialConfig.mode)
  return _internal_mode();
}
inline void ModuleConfig_SerialConfig::_internal_set_mode(::meshtastic::ModuleConfig_SerialConfig_Serial_Mode value) {
  
  _impl_.mode_ = value;
}
inline void ModuleConfig_SerialConfig::set_mode(::meshtastic::ModuleConfig_SerialConfig_Serial_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.SerialConfig.mode)
}

// bool override_console_serial_port = 8;
inline void ModuleConfig_SerialConfig::clear_override_console_serial_port() {
  _impl_.override_console_serial_port_ = false;
}
inline bool ModuleConfig_SerialConfig::_internal_override_console_serial_port() const {
  return _impl_.override_console_serial_port_;
}
inline bool ModuleConfig_SerialConfig::override_console_serial_port() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.SerialConfig.override_console_serial_port)
  return _internal_override_console_serial_port();
}
inline void ModuleConfig_SerialConfig::_internal_set_override_console_serial_port(bool value) {
  
  _impl_.override_console_serial_port_ = value;
}
inline void ModuleConfig_SerialConfig::set_override_console_serial_port(bool value) {
  _internal_set_override_console_serial_port(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.SerialConfig.override_console_serial_port)
}

// -------------------------------------------------------------------

// ModuleConfig_ExternalNotificationConfig

// bool enabled = 1;
inline void ModuleConfig_ExternalNotificationConfig::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool ModuleConfig_ExternalNotificationConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool ModuleConfig_ExternalNotificationConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.enabled)
  return _internal_enabled();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.enabled)
}

// uint32 output_ms = 2;
inline void ModuleConfig_ExternalNotificationConfig::clear_output_ms() {
  _impl_.output_ms_ = 0u;
}
inline uint32_t ModuleConfig_ExternalNotificationConfig::_internal_output_ms() const {
  return _impl_.output_ms_;
}
inline uint32_t ModuleConfig_ExternalNotificationConfig::output_ms() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.output_ms)
  return _internal_output_ms();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_output_ms(uint32_t value) {
  
  _impl_.output_ms_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_output_ms(uint32_t value) {
  _internal_set_output_ms(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.output_ms)
}

// uint32 output = 3;
inline void ModuleConfig_ExternalNotificationConfig::clear_output() {
  _impl_.output_ = 0u;
}
inline uint32_t ModuleConfig_ExternalNotificationConfig::_internal_output() const {
  return _impl_.output_;
}
inline uint32_t ModuleConfig_ExternalNotificationConfig::output() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.output)
  return _internal_output();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_output(uint32_t value) {
  
  _impl_.output_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_output(uint32_t value) {
  _internal_set_output(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.output)
}

// uint32 output_vibra = 8;
inline void ModuleConfig_ExternalNotificationConfig::clear_output_vibra() {
  _impl_.output_vibra_ = 0u;
}
inline uint32_t ModuleConfig_ExternalNotificationConfig::_internal_output_vibra() const {
  return _impl_.output_vibra_;
}
inline uint32_t ModuleConfig_ExternalNotificationConfig::output_vibra() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.output_vibra)
  return _internal_output_vibra();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_output_vibra(uint32_t value) {
  
  _impl_.output_vibra_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_output_vibra(uint32_t value) {
  _internal_set_output_vibra(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.output_vibra)
}

// uint32 output_buzzer = 9;
inline void ModuleConfig_ExternalNotificationConfig::clear_output_buzzer() {
  _impl_.output_buzzer_ = 0u;
}
inline uint32_t ModuleConfig_ExternalNotificationConfig::_internal_output_buzzer() const {
  return _impl_.output_buzzer_;
}
inline uint32_t ModuleConfig_ExternalNotificationConfig::output_buzzer() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.output_buzzer)
  return _internal_output_buzzer();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_output_buzzer(uint32_t value) {
  
  _impl_.output_buzzer_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_output_buzzer(uint32_t value) {
  _internal_set_output_buzzer(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.output_buzzer)
}

// bool active = 4;
inline void ModuleConfig_ExternalNotificationConfig::clear_active() {
  _impl_.active_ = false;
}
inline bool ModuleConfig_ExternalNotificationConfig::_internal_active() const {
  return _impl_.active_;
}
inline bool ModuleConfig_ExternalNotificationConfig::active() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.active)
  return _internal_active();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_active(bool value) {
  
  _impl_.active_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.active)
}

// bool alert_message = 5;
inline void ModuleConfig_ExternalNotificationConfig::clear_alert_message() {
  _impl_.alert_message_ = false;
}
inline bool ModuleConfig_ExternalNotificationConfig::_internal_alert_message() const {
  return _impl_.alert_message_;
}
inline bool ModuleConfig_ExternalNotificationConfig::alert_message() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_message)
  return _internal_alert_message();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_alert_message(bool value) {
  
  _impl_.alert_message_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_alert_message(bool value) {
  _internal_set_alert_message(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_message)
}

// bool alert_message_vibra = 10;
inline void ModuleConfig_ExternalNotificationConfig::clear_alert_message_vibra() {
  _impl_.alert_message_vibra_ = false;
}
inline bool ModuleConfig_ExternalNotificationConfig::_internal_alert_message_vibra() const {
  return _impl_.alert_message_vibra_;
}
inline bool ModuleConfig_ExternalNotificationConfig::alert_message_vibra() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_message_vibra)
  return _internal_alert_message_vibra();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_alert_message_vibra(bool value) {
  
  _impl_.alert_message_vibra_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_alert_message_vibra(bool value) {
  _internal_set_alert_message_vibra(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_message_vibra)
}

// bool alert_message_buzzer = 11;
inline void ModuleConfig_ExternalNotificationConfig::clear_alert_message_buzzer() {
  _impl_.alert_message_buzzer_ = false;
}
inline bool ModuleConfig_ExternalNotificationConfig::_internal_alert_message_buzzer() const {
  return _impl_.alert_message_buzzer_;
}
inline bool ModuleConfig_ExternalNotificationConfig::alert_message_buzzer() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_message_buzzer)
  return _internal_alert_message_buzzer();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_alert_message_buzzer(bool value) {
  
  _impl_.alert_message_buzzer_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_alert_message_buzzer(bool value) {
  _internal_set_alert_message_buzzer(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_message_buzzer)
}

// bool alert_bell = 6;
inline void ModuleConfig_ExternalNotificationConfig::clear_alert_bell() {
  _impl_.alert_bell_ = false;
}
inline bool ModuleConfig_ExternalNotificationConfig::_internal_alert_bell() const {
  return _impl_.alert_bell_;
}
inline bool ModuleConfig_ExternalNotificationConfig::alert_bell() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_bell)
  return _internal_alert_bell();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_alert_bell(bool value) {
  
  _impl_.alert_bell_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_alert_bell(bool value) {
  _internal_set_alert_bell(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_bell)
}

// bool alert_bell_vibra = 12;
inline void ModuleConfig_ExternalNotificationConfig::clear_alert_bell_vibra() {
  _impl_.alert_bell_vibra_ = false;
}
inline bool ModuleConfig_ExternalNotificationConfig::_internal_alert_bell_vibra() const {
  return _impl_.alert_bell_vibra_;
}
inline bool ModuleConfig_ExternalNotificationConfig::alert_bell_vibra() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_bell_vibra)
  return _internal_alert_bell_vibra();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_alert_bell_vibra(bool value) {
  
  _impl_.alert_bell_vibra_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_alert_bell_vibra(bool value) {
  _internal_set_alert_bell_vibra(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_bell_vibra)
}

// bool alert_bell_buzzer = 13;
inline void ModuleConfig_ExternalNotificationConfig::clear_alert_bell_buzzer() {
  _impl_.alert_bell_buzzer_ = false;
}
inline bool ModuleConfig_ExternalNotificationConfig::_internal_alert_bell_buzzer() const {
  return _impl_.alert_bell_buzzer_;
}
inline bool ModuleConfig_ExternalNotificationConfig::alert_bell_buzzer() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_bell_buzzer)
  return _internal_alert_bell_buzzer();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_alert_bell_buzzer(bool value) {
  
  _impl_.alert_bell_buzzer_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_alert_bell_buzzer(bool value) {
  _internal_set_alert_bell_buzzer(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.alert_bell_buzzer)
}

// bool use_pwm = 7;
inline void ModuleConfig_ExternalNotificationConfig::clear_use_pwm() {
  _impl_.use_pwm_ = false;
}
inline bool ModuleConfig_ExternalNotificationConfig::_internal_use_pwm() const {
  return _impl_.use_pwm_;
}
inline bool ModuleConfig_ExternalNotificationConfig::use_pwm() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.use_pwm)
  return _internal_use_pwm();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_use_pwm(bool value) {
  
  _impl_.use_pwm_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_use_pwm(bool value) {
  _internal_set_use_pwm(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.use_pwm)
}

// uint32 nag_timeout = 14;
inline void ModuleConfig_ExternalNotificationConfig::clear_nag_timeout() {
  _impl_.nag_timeout_ = 0u;
}
inline uint32_t ModuleConfig_ExternalNotificationConfig::_internal_nag_timeout() const {
  return _impl_.nag_timeout_;
}
inline uint32_t ModuleConfig_ExternalNotificationConfig::nag_timeout() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.nag_timeout)
  return _internal_nag_timeout();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_nag_timeout(uint32_t value) {
  
  _impl_.nag_timeout_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_nag_timeout(uint32_t value) {
  _internal_set_nag_timeout(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.nag_timeout)
}

// bool use_i2s_as_buzzer = 15;
inline void ModuleConfig_ExternalNotificationConfig::clear_use_i2s_as_buzzer() {
  _impl_.use_i2s_as_buzzer_ = false;
}
inline bool ModuleConfig_ExternalNotificationConfig::_internal_use_i2s_as_buzzer() const {
  return _impl_.use_i2s_as_buzzer_;
}
inline bool ModuleConfig_ExternalNotificationConfig::use_i2s_as_buzzer() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ExternalNotificationConfig.use_i2s_as_buzzer)
  return _internal_use_i2s_as_buzzer();
}
inline void ModuleConfig_ExternalNotificationConfig::_internal_set_use_i2s_as_buzzer(bool value) {
  
  _impl_.use_i2s_as_buzzer_ = value;
}
inline void ModuleConfig_ExternalNotificationConfig::set_use_i2s_as_buzzer(bool value) {
  _internal_set_use_i2s_as_buzzer(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.ExternalNotificationConfig.use_i2s_as_buzzer)
}

// -------------------------------------------------------------------

// ModuleConfig_StoreForwardConfig

// bool enabled = 1;
inline void ModuleConfig_StoreForwardConfig::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool ModuleConfig_StoreForwardConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool ModuleConfig_StoreForwardConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.StoreForwardConfig.enabled)
  return _internal_enabled();
}
inline void ModuleConfig_StoreForwardConfig::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void ModuleConfig_StoreForwardConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.StoreForwardConfig.enabled)
}

// bool heartbeat = 2;
inline void ModuleConfig_StoreForwardConfig::clear_heartbeat() {
  _impl_.heartbeat_ = false;
}
inline bool ModuleConfig_StoreForwardConfig::_internal_heartbeat() const {
  return _impl_.heartbeat_;
}
inline bool ModuleConfig_StoreForwardConfig::heartbeat() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.StoreForwardConfig.heartbeat)
  return _internal_heartbeat();
}
inline void ModuleConfig_StoreForwardConfig::_internal_set_heartbeat(bool value) {
  
  _impl_.heartbeat_ = value;
}
inline void ModuleConfig_StoreForwardConfig::set_heartbeat(bool value) {
  _internal_set_heartbeat(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.StoreForwardConfig.heartbeat)
}

// uint32 records = 3;
inline void ModuleConfig_StoreForwardConfig::clear_records() {
  _impl_.records_ = 0u;
}
inline uint32_t ModuleConfig_StoreForwardConfig::_internal_records() const {
  return _impl_.records_;
}
inline uint32_t ModuleConfig_StoreForwardConfig::records() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.StoreForwardConfig.records)
  return _internal_records();
}
inline void ModuleConfig_StoreForwardConfig::_internal_set_records(uint32_t value) {
  
  _impl_.records_ = value;
}
inline void ModuleConfig_StoreForwardConfig::set_records(uint32_t value) {
  _internal_set_records(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.StoreForwardConfig.records)
}

// uint32 history_return_max = 4;
inline void ModuleConfig_StoreForwardConfig::clear_history_return_max() {
  _impl_.history_return_max_ = 0u;
}
inline uint32_t ModuleConfig_StoreForwardConfig::_internal_history_return_max() const {
  return _impl_.history_return_max_;
}
inline uint32_t ModuleConfig_StoreForwardConfig::history_return_max() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.StoreForwardConfig.history_return_max)
  return _internal_history_return_max();
}
inline void ModuleConfig_StoreForwardConfig::_internal_set_history_return_max(uint32_t value) {
  
  _impl_.history_return_max_ = value;
}
inline void ModuleConfig_StoreForwardConfig::set_history_return_max(uint32_t value) {
  _internal_set_history_return_max(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.StoreForwardConfig.history_return_max)
}

// uint32 history_return_window = 5;
inline void ModuleConfig_StoreForwardConfig::clear_history_return_window() {
  _impl_.history_return_window_ = 0u;
}
inline uint32_t ModuleConfig_StoreForwardConfig::_internal_history_return_window() const {
  return _impl_.history_return_window_;
}
inline uint32_t ModuleConfig_StoreForwardConfig::history_return_window() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.StoreForwardConfig.history_return_window)
  return _internal_history_return_window();
}
inline void ModuleConfig_StoreForwardConfig::_internal_set_history_return_window(uint32_t value) {
  
  _impl_.history_return_window_ = value;
}
inline void ModuleConfig_StoreForwardConfig::set_history_return_window(uint32_t value) {
  _internal_set_history_return_window(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.StoreForwardConfig.history_return_window)
}

// bool is_server = 6;
inline void ModuleConfig_StoreForwardConfig::clear_is_server() {
  _impl_.is_server_ = false;
}
inline bool ModuleConfig_StoreForwardConfig::_internal_is_server() const {
  return _impl_.is_server_;
}
inline bool ModuleConfig_StoreForwardConfig::is_server() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.StoreForwardConfig.is_server)
  return _internal_is_server();
}
inline void ModuleConfig_StoreForwardConfig::_internal_set_is_server(bool value) {
  
  _impl_.is_server_ = value;
}
inline void ModuleConfig_StoreForwardConfig::set_is_server(bool value) {
  _internal_set_is_server(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.StoreForwardConfig.is_server)
}

// -------------------------------------------------------------------

// ModuleConfig_RangeTestConfig

// bool enabled = 1;
inline void ModuleConfig_RangeTestConfig::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool ModuleConfig_RangeTestConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool ModuleConfig_RangeTestConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.RangeTestConfig.enabled)
  return _internal_enabled();
}
inline void ModuleConfig_RangeTestConfig::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void ModuleConfig_RangeTestConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.RangeTestConfig.enabled)
}

// uint32 sender = 2;
inline void ModuleConfig_RangeTestConfig::clear_sender() {
  _impl_.sender_ = 0u;
}
inline uint32_t ModuleConfig_RangeTestConfig::_internal_sender() const {
  return _impl_.sender_;
}
inline uint32_t ModuleConfig_RangeTestConfig::sender() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.RangeTestConfig.sender)
  return _internal_sender();
}
inline void ModuleConfig_RangeTestConfig::_internal_set_sender(uint32_t value) {
  
  _impl_.sender_ = value;
}
inline void ModuleConfig_RangeTestConfig::set_sender(uint32_t value) {
  _internal_set_sender(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.RangeTestConfig.sender)
}

// bool save = 3;
inline void ModuleConfig_RangeTestConfig::clear_save() {
  _impl_.save_ = false;
}
inline bool ModuleConfig_RangeTestConfig::_internal_save() const {
  return _impl_.save_;
}
inline bool ModuleConfig_RangeTestConfig::save() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.RangeTestConfig.save)
  return _internal_save();
}
inline void ModuleConfig_RangeTestConfig::_internal_set_save(bool value) {
  
  _impl_.save_ = value;
}
inline void ModuleConfig_RangeTestConfig::set_save(bool value) {
  _internal_set_save(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.RangeTestConfig.save)
}

// bool clear_on_reboot = 4;
inline void ModuleConfig_RangeTestConfig::clear_clear_on_reboot() {
  _impl_.clear_on_reboot_ = false;
}
inline bool ModuleConfig_RangeTestConfig::_internal_clear_on_reboot() const {
  return _impl_.clear_on_reboot_;
}
inline bool ModuleConfig_RangeTestConfig::clear_on_reboot() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.RangeTestConfig.clear_on_reboot)
  return _internal_clear_on_reboot();
}
inline void ModuleConfig_RangeTestConfig::_internal_set_clear_on_reboot(bool value) {
  
  _impl_.clear_on_reboot_ = value;
}
inline void ModuleConfig_RangeTestConfig::set_clear_on_reboot(bool value) {
  _internal_set_clear_on_reboot(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.RangeTestConfig.clear_on_reboot)
}

// -------------------------------------------------------------------

// ModuleConfig_TelemetryConfig

// uint32 device_update_interval = 1;
inline void ModuleConfig_TelemetryConfig::clear_device_update_interval() {
  _impl_.device_update_interval_ = 0u;
}
inline uint32_t ModuleConfig_TelemetryConfig::_internal_device_update_interval() const {
  return _impl_.device_update_interval_;
}
inline uint32_t ModuleConfig_TelemetryConfig::device_update_interval() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.device_update_interval)
  return _internal_device_update_interval();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_device_update_interval(uint32_t value) {
  
  _impl_.device_update_interval_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_device_update_interval(uint32_t value) {
  _internal_set_device_update_interval(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.device_update_interval)
}

// uint32 environment_update_interval = 2;
inline void ModuleConfig_TelemetryConfig::clear_environment_update_interval() {
  _impl_.environment_update_interval_ = 0u;
}
inline uint32_t ModuleConfig_TelemetryConfig::_internal_environment_update_interval() const {
  return _impl_.environment_update_interval_;
}
inline uint32_t ModuleConfig_TelemetryConfig::environment_update_interval() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.environment_update_interval)
  return _internal_environment_update_interval();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_environment_update_interval(uint32_t value) {
  
  _impl_.environment_update_interval_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_environment_update_interval(uint32_t value) {
  _internal_set_environment_update_interval(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.environment_update_interval)
}

// bool environment_measurement_enabled = 3;
inline void ModuleConfig_TelemetryConfig::clear_environment_measurement_enabled() {
  _impl_.environment_measurement_enabled_ = false;
}
inline bool ModuleConfig_TelemetryConfig::_internal_environment_measurement_enabled() const {
  return _impl_.environment_measurement_enabled_;
}
inline bool ModuleConfig_TelemetryConfig::environment_measurement_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.environment_measurement_enabled)
  return _internal_environment_measurement_enabled();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_environment_measurement_enabled(bool value) {
  
  _impl_.environment_measurement_enabled_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_environment_measurement_enabled(bool value) {
  _internal_set_environment_measurement_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.environment_measurement_enabled)
}

// bool environment_screen_enabled = 4;
inline void ModuleConfig_TelemetryConfig::clear_environment_screen_enabled() {
  _impl_.environment_screen_enabled_ = false;
}
inline bool ModuleConfig_TelemetryConfig::_internal_environment_screen_enabled() const {
  return _impl_.environment_screen_enabled_;
}
inline bool ModuleConfig_TelemetryConfig::environment_screen_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.environment_screen_enabled)
  return _internal_environment_screen_enabled();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_environment_screen_enabled(bool value) {
  
  _impl_.environment_screen_enabled_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_environment_screen_enabled(bool value) {
  _internal_set_environment_screen_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.environment_screen_enabled)
}

// bool environment_display_fahrenheit = 5;
inline void ModuleConfig_TelemetryConfig::clear_environment_display_fahrenheit() {
  _impl_.environment_display_fahrenheit_ = false;
}
inline bool ModuleConfig_TelemetryConfig::_internal_environment_display_fahrenheit() const {
  return _impl_.environment_display_fahrenheit_;
}
inline bool ModuleConfig_TelemetryConfig::environment_display_fahrenheit() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.environment_display_fahrenheit)
  return _internal_environment_display_fahrenheit();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_environment_display_fahrenheit(bool value) {
  
  _impl_.environment_display_fahrenheit_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_environment_display_fahrenheit(bool value) {
  _internal_set_environment_display_fahrenheit(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.environment_display_fahrenheit)
}

// bool air_quality_enabled = 6;
inline void ModuleConfig_TelemetryConfig::clear_air_quality_enabled() {
  _impl_.air_quality_enabled_ = false;
}
inline bool ModuleConfig_TelemetryConfig::_internal_air_quality_enabled() const {
  return _impl_.air_quality_enabled_;
}
inline bool ModuleConfig_TelemetryConfig::air_quality_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.air_quality_enabled)
  return _internal_air_quality_enabled();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_air_quality_enabled(bool value) {
  
  _impl_.air_quality_enabled_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_air_quality_enabled(bool value) {
  _internal_set_air_quality_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.air_quality_enabled)
}

// uint32 air_quality_interval = 7;
inline void ModuleConfig_TelemetryConfig::clear_air_quality_interval() {
  _impl_.air_quality_interval_ = 0u;
}
inline uint32_t ModuleConfig_TelemetryConfig::_internal_air_quality_interval() const {
  return _impl_.air_quality_interval_;
}
inline uint32_t ModuleConfig_TelemetryConfig::air_quality_interval() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.air_quality_interval)
  return _internal_air_quality_interval();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_air_quality_interval(uint32_t value) {
  
  _impl_.air_quality_interval_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_air_quality_interval(uint32_t value) {
  _internal_set_air_quality_interval(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.air_quality_interval)
}

// bool power_measurement_enabled = 8;
inline void ModuleConfig_TelemetryConfig::clear_power_measurement_enabled() {
  _impl_.power_measurement_enabled_ = false;
}
inline bool ModuleConfig_TelemetryConfig::_internal_power_measurement_enabled() const {
  return _impl_.power_measurement_enabled_;
}
inline bool ModuleConfig_TelemetryConfig::power_measurement_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.power_measurement_enabled)
  return _internal_power_measurement_enabled();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_power_measurement_enabled(bool value) {
  
  _impl_.power_measurement_enabled_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_power_measurement_enabled(bool value) {
  _internal_set_power_measurement_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.power_measurement_enabled)
}

// uint32 power_update_interval = 9;
inline void ModuleConfig_TelemetryConfig::clear_power_update_interval() {
  _impl_.power_update_interval_ = 0u;
}
inline uint32_t ModuleConfig_TelemetryConfig::_internal_power_update_interval() const {
  return _impl_.power_update_interval_;
}
inline uint32_t ModuleConfig_TelemetryConfig::power_update_interval() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.power_update_interval)
  return _internal_power_update_interval();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_power_update_interval(uint32_t value) {
  
  _impl_.power_update_interval_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_power_update_interval(uint32_t value) {
  _internal_set_power_update_interval(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.power_update_interval)
}

// bool power_screen_enabled = 10;
inline void ModuleConfig_TelemetryConfig::clear_power_screen_enabled() {
  _impl_.power_screen_enabled_ = false;
}
inline bool ModuleConfig_TelemetryConfig::_internal_power_screen_enabled() const {
  return _impl_.power_screen_enabled_;
}
inline bool ModuleConfig_TelemetryConfig::power_screen_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.power_screen_enabled)
  return _internal_power_screen_enabled();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_power_screen_enabled(bool value) {
  
  _impl_.power_screen_enabled_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_power_screen_enabled(bool value) {
  _internal_set_power_screen_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.power_screen_enabled)
}

// bool health_measurement_enabled = 11;
inline void ModuleConfig_TelemetryConfig::clear_health_measurement_enabled() {
  _impl_.health_measurement_enabled_ = false;
}
inline bool ModuleConfig_TelemetryConfig::_internal_health_measurement_enabled() const {
  return _impl_.health_measurement_enabled_;
}
inline bool ModuleConfig_TelemetryConfig::health_measurement_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.health_measurement_enabled)
  return _internal_health_measurement_enabled();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_health_measurement_enabled(bool value) {
  
  _impl_.health_measurement_enabled_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_health_measurement_enabled(bool value) {
  _internal_set_health_measurement_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.health_measurement_enabled)
}

// uint32 health_update_interval = 12;
inline void ModuleConfig_TelemetryConfig::clear_health_update_interval() {
  _impl_.health_update_interval_ = 0u;
}
inline uint32_t ModuleConfig_TelemetryConfig::_internal_health_update_interval() const {
  return _impl_.health_update_interval_;
}
inline uint32_t ModuleConfig_TelemetryConfig::health_update_interval() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.health_update_interval)
  return _internal_health_update_interval();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_health_update_interval(uint32_t value) {
  
  _impl_.health_update_interval_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_health_update_interval(uint32_t value) {
  _internal_set_health_update_interval(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.health_update_interval)
}

// bool health_screen_enabled = 13;
inline void ModuleConfig_TelemetryConfig::clear_health_screen_enabled() {
  _impl_.health_screen_enabled_ = false;
}
inline bool ModuleConfig_TelemetryConfig::_internal_health_screen_enabled() const {
  return _impl_.health_screen_enabled_;
}
inline bool ModuleConfig_TelemetryConfig::health_screen_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.TelemetryConfig.health_screen_enabled)
  return _internal_health_screen_enabled();
}
inline void ModuleConfig_TelemetryConfig::_internal_set_health_screen_enabled(bool value) {
  
  _impl_.health_screen_enabled_ = value;
}
inline void ModuleConfig_TelemetryConfig::set_health_screen_enabled(bool value) {
  _internal_set_health_screen_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.TelemetryConfig.health_screen_enabled)
}

// -------------------------------------------------------------------

// ModuleConfig_CannedMessageConfig

// bool rotary1_enabled = 1;
inline void ModuleConfig_CannedMessageConfig::clear_rotary1_enabled() {
  _impl_.rotary1_enabled_ = false;
}
inline bool ModuleConfig_CannedMessageConfig::_internal_rotary1_enabled() const {
  return _impl_.rotary1_enabled_;
}
inline bool ModuleConfig_CannedMessageConfig::rotary1_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.CannedMessageConfig.rotary1_enabled)
  return _internal_rotary1_enabled();
}
inline void ModuleConfig_CannedMessageConfig::_internal_set_rotary1_enabled(bool value) {
  
  _impl_.rotary1_enabled_ = value;
}
inline void ModuleConfig_CannedMessageConfig::set_rotary1_enabled(bool value) {
  _internal_set_rotary1_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.CannedMessageConfig.rotary1_enabled)
}

// uint32 inputbroker_pin_a = 2;
inline void ModuleConfig_CannedMessageConfig::clear_inputbroker_pin_a() {
  _impl_.inputbroker_pin_a_ = 0u;
}
inline uint32_t ModuleConfig_CannedMessageConfig::_internal_inputbroker_pin_a() const {
  return _impl_.inputbroker_pin_a_;
}
inline uint32_t ModuleConfig_CannedMessageConfig::inputbroker_pin_a() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_pin_a)
  return _internal_inputbroker_pin_a();
}
inline void ModuleConfig_CannedMessageConfig::_internal_set_inputbroker_pin_a(uint32_t value) {
  
  _impl_.inputbroker_pin_a_ = value;
}
inline void ModuleConfig_CannedMessageConfig::set_inputbroker_pin_a(uint32_t value) {
  _internal_set_inputbroker_pin_a(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_pin_a)
}

// uint32 inputbroker_pin_b = 3;
inline void ModuleConfig_CannedMessageConfig::clear_inputbroker_pin_b() {
  _impl_.inputbroker_pin_b_ = 0u;
}
inline uint32_t ModuleConfig_CannedMessageConfig::_internal_inputbroker_pin_b() const {
  return _impl_.inputbroker_pin_b_;
}
inline uint32_t ModuleConfig_CannedMessageConfig::inputbroker_pin_b() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_pin_b)
  return _internal_inputbroker_pin_b();
}
inline void ModuleConfig_CannedMessageConfig::_internal_set_inputbroker_pin_b(uint32_t value) {
  
  _impl_.inputbroker_pin_b_ = value;
}
inline void ModuleConfig_CannedMessageConfig::set_inputbroker_pin_b(uint32_t value) {
  _internal_set_inputbroker_pin_b(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_pin_b)
}

// uint32 inputbroker_pin_press = 4;
inline void ModuleConfig_CannedMessageConfig::clear_inputbroker_pin_press() {
  _impl_.inputbroker_pin_press_ = 0u;
}
inline uint32_t ModuleConfig_CannedMessageConfig::_internal_inputbroker_pin_press() const {
  return _impl_.inputbroker_pin_press_;
}
inline uint32_t ModuleConfig_CannedMessageConfig::inputbroker_pin_press() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_pin_press)
  return _internal_inputbroker_pin_press();
}
inline void ModuleConfig_CannedMessageConfig::_internal_set_inputbroker_pin_press(uint32_t value) {
  
  _impl_.inputbroker_pin_press_ = value;
}
inline void ModuleConfig_CannedMessageConfig::set_inputbroker_pin_press(uint32_t value) {
  _internal_set_inputbroker_pin_press(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_pin_press)
}

// .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_cw = 5;
inline void ModuleConfig_CannedMessageConfig::clear_inputbroker_event_cw() {
  _impl_.inputbroker_event_cw_ = 0;
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::_internal_inputbroker_event_cw() const {
  return static_cast< ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar >(_impl_.inputbroker_event_cw_);
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::inputbroker_event_cw() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_event_cw)
  return _internal_inputbroker_event_cw();
}
inline void ModuleConfig_CannedMessageConfig::_internal_set_inputbroker_event_cw(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value) {
  
  _impl_.inputbroker_event_cw_ = value;
}
inline void ModuleConfig_CannedMessageConfig::set_inputbroker_event_cw(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value) {
  _internal_set_inputbroker_event_cw(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_event_cw)
}

// .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_ccw = 6;
inline void ModuleConfig_CannedMessageConfig::clear_inputbroker_event_ccw() {
  _impl_.inputbroker_event_ccw_ = 0;
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::_internal_inputbroker_event_ccw() const {
  return static_cast< ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar >(_impl_.inputbroker_event_ccw_);
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::inputbroker_event_ccw() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_event_ccw)
  return _internal_inputbroker_event_ccw();
}
inline void ModuleConfig_CannedMessageConfig::_internal_set_inputbroker_event_ccw(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value) {
  
  _impl_.inputbroker_event_ccw_ = value;
}
inline void ModuleConfig_CannedMessageConfig::set_inputbroker_event_ccw(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value) {
  _internal_set_inputbroker_event_ccw(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_event_ccw)
}

// .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_press = 7;
inline void ModuleConfig_CannedMessageConfig::clear_inputbroker_event_press() {
  _impl_.inputbroker_event_press_ = 0;
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::_internal_inputbroker_event_press() const {
  return static_cast< ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar >(_impl_.inputbroker_event_press_);
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::inputbroker_event_press() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_event_press)
  return _internal_inputbroker_event_press();
}
inline void ModuleConfig_CannedMessageConfig::_internal_set_inputbroker_event_press(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value) {
  
  _impl_.inputbroker_event_press_ = value;
}
inline void ModuleConfig_CannedMessageConfig::set_inputbroker_event_press(::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar value) {
  _internal_set_inputbroker_event_press(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_event_press)
}

// bool updown1_enabled = 8;
inline void ModuleConfig_CannedMessageConfig::clear_updown1_enabled() {
  _impl_.updown1_enabled_ = false;
}
inline bool ModuleConfig_CannedMessageConfig::_internal_updown1_enabled() const {
  return _impl_.updown1_enabled_;
}
inline bool ModuleConfig_CannedMessageConfig::updown1_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.CannedMessageConfig.updown1_enabled)
  return _internal_updown1_enabled();
}
inline void ModuleConfig_CannedMessageConfig::_internal_set_updown1_enabled(bool value) {
  
  _impl_.updown1_enabled_ = value;
}
inline void ModuleConfig_CannedMessageConfig::set_updown1_enabled(bool value) {
  _internal_set_updown1_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.CannedMessageConfig.updown1_enabled)
}

// bool enabled = 9 [deprecated = true];
inline void ModuleConfig_CannedMessageConfig::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool ModuleConfig_CannedMessageConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool ModuleConfig_CannedMessageConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.CannedMessageConfig.enabled)
  return _internal_enabled();
}
inline void ModuleConfig_CannedMessageConfig::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void ModuleConfig_CannedMessageConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.CannedMessageConfig.enabled)
}

// string allow_input_source = 10 [deprecated = true];
inline void ModuleConfig_CannedMessageConfig::clear_allow_input_source() {
  _impl_.allow_input_source_.ClearToEmpty();
}
inline const std::string& ModuleConfig_CannedMessageConfig::allow_input_source() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.CannedMessageConfig.allow_input_source)
  return _internal_allow_input_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModuleConfig_CannedMessageConfig::set_allow_input_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.allow_input_source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.CannedMessageConfig.allow_input_source)
}
inline std::string* ModuleConfig_CannedMessageConfig::mutable_allow_input_source() {
  std::string* _s = _internal_mutable_allow_input_source();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.CannedMessageConfig.allow_input_source)
  return _s;
}
inline const std::string& ModuleConfig_CannedMessageConfig::_internal_allow_input_source() const {
  return _impl_.allow_input_source_.Get();
}
inline void ModuleConfig_CannedMessageConfig::_internal_set_allow_input_source(const std::string& value) {
  
  _impl_.allow_input_source_.Set(value, GetArenaForAllocation());
}
inline std::string* ModuleConfig_CannedMessageConfig::_internal_mutable_allow_input_source() {
  
  return _impl_.allow_input_source_.Mutable(GetArenaForAllocation());
}
inline std::string* ModuleConfig_CannedMessageConfig::release_allow_input_source() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.CannedMessageConfig.allow_input_source)
  return _impl_.allow_input_source_.Release();
}
inline void ModuleConfig_CannedMessageConfig::set_allocated_allow_input_source(std::string* allow_input_source) {
  if (allow_input_source != nullptr) {
    
  } else {
    
  }
  _impl_.allow_input_source_.SetAllocated(allow_input_source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.allow_input_source_.IsDefault()) {
    _impl_.allow_input_source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.CannedMessageConfig.allow_input_source)
}

// bool send_bell = 11;
inline void ModuleConfig_CannedMessageConfig::clear_send_bell() {
  _impl_.send_bell_ = false;
}
inline bool ModuleConfig_CannedMessageConfig::_internal_send_bell() const {
  return _impl_.send_bell_;
}
inline bool ModuleConfig_CannedMessageConfig::send_bell() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.CannedMessageConfig.send_bell)
  return _internal_send_bell();
}
inline void ModuleConfig_CannedMessageConfig::_internal_set_send_bell(bool value) {
  
  _impl_.send_bell_ = value;
}
inline void ModuleConfig_CannedMessageConfig::set_send_bell(bool value) {
  _internal_set_send_bell(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.CannedMessageConfig.send_bell)
}

// -------------------------------------------------------------------

// ModuleConfig_AmbientLightingConfig

// bool led_state = 1;
inline void ModuleConfig_AmbientLightingConfig::clear_led_state() {
  _impl_.led_state_ = false;
}
inline bool ModuleConfig_AmbientLightingConfig::_internal_led_state() const {
  return _impl_.led_state_;
}
inline bool ModuleConfig_AmbientLightingConfig::led_state() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AmbientLightingConfig.led_state)
  return _internal_led_state();
}
inline void ModuleConfig_AmbientLightingConfig::_internal_set_led_state(bool value) {
  
  _impl_.led_state_ = value;
}
inline void ModuleConfig_AmbientLightingConfig::set_led_state(bool value) {
  _internal_set_led_state(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AmbientLightingConfig.led_state)
}

// uint32 current = 2;
inline void ModuleConfig_AmbientLightingConfig::clear_current() {
  _impl_.current_ = 0u;
}
inline uint32_t ModuleConfig_AmbientLightingConfig::_internal_current() const {
  return _impl_.current_;
}
inline uint32_t ModuleConfig_AmbientLightingConfig::current() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AmbientLightingConfig.current)
  return _internal_current();
}
inline void ModuleConfig_AmbientLightingConfig::_internal_set_current(uint32_t value) {
  
  _impl_.current_ = value;
}
inline void ModuleConfig_AmbientLightingConfig::set_current(uint32_t value) {
  _internal_set_current(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AmbientLightingConfig.current)
}

// uint32 red = 3;
inline void ModuleConfig_AmbientLightingConfig::clear_red() {
  _impl_.red_ = 0u;
}
inline uint32_t ModuleConfig_AmbientLightingConfig::_internal_red() const {
  return _impl_.red_;
}
inline uint32_t ModuleConfig_AmbientLightingConfig::red() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AmbientLightingConfig.red)
  return _internal_red();
}
inline void ModuleConfig_AmbientLightingConfig::_internal_set_red(uint32_t value) {
  
  _impl_.red_ = value;
}
inline void ModuleConfig_AmbientLightingConfig::set_red(uint32_t value) {
  _internal_set_red(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AmbientLightingConfig.red)
}

// uint32 green = 4;
inline void ModuleConfig_AmbientLightingConfig::clear_green() {
  _impl_.green_ = 0u;
}
inline uint32_t ModuleConfig_AmbientLightingConfig::_internal_green() const {
  return _impl_.green_;
}
inline uint32_t ModuleConfig_AmbientLightingConfig::green() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AmbientLightingConfig.green)
  return _internal_green();
}
inline void ModuleConfig_AmbientLightingConfig::_internal_set_green(uint32_t value) {
  
  _impl_.green_ = value;
}
inline void ModuleConfig_AmbientLightingConfig::set_green(uint32_t value) {
  _internal_set_green(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AmbientLightingConfig.green)
}

// uint32 blue = 5;
inline void ModuleConfig_AmbientLightingConfig::clear_blue() {
  _impl_.blue_ = 0u;
}
inline uint32_t ModuleConfig_AmbientLightingConfig::_internal_blue() const {
  return _impl_.blue_;
}
inline uint32_t ModuleConfig_AmbientLightingConfig::blue() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.AmbientLightingConfig.blue)
  return _internal_blue();
}
inline void ModuleConfig_AmbientLightingConfig::_internal_set_blue(uint32_t value) {
  
  _impl_.blue_ = value;
}
inline void ModuleConfig_AmbientLightingConfig::set_blue(uint32_t value) {
  _internal_set_blue(value);
  // @@protoc_insertion_point(field_set:meshtastic.ModuleConfig.AmbientLightingConfig.blue)
}

// -------------------------------------------------------------------

// ModuleConfig

// .meshtastic.ModuleConfig.MQTTConfig mqtt = 1;
inline bool ModuleConfig::_internal_has_mqtt() const {
  return payload_variant_case() == kMqtt;
}
inline bool ModuleConfig::has_mqtt() const {
  return _internal_has_mqtt();
}
inline void ModuleConfig::set_has_mqtt() {
  _impl_._oneof_case_[0] = kMqtt;
}
inline void ModuleConfig::clear_mqtt() {
  if (_internal_has_mqtt()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.mqtt_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_MQTTConfig* ModuleConfig::release_mqtt() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.mqtt)
  if (_internal_has_mqtt()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_MQTTConfig* temp = _impl_.payload_variant_.mqtt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.mqtt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_MQTTConfig& ModuleConfig::_internal_mqtt() const {
  return _internal_has_mqtt()
      ? *_impl_.payload_variant_.mqtt_
      : reinterpret_cast< ::meshtastic::ModuleConfig_MQTTConfig&>(::meshtastic::_ModuleConfig_MQTTConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_MQTTConfig& ModuleConfig::mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.mqtt)
  return _internal_mqtt();
}
inline ::meshtastic::ModuleConfig_MQTTConfig* ModuleConfig::unsafe_arena_release_mqtt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.mqtt)
  if (_internal_has_mqtt()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_MQTTConfig* temp = _impl_.payload_variant_.mqtt_;
    _impl_.payload_variant_.mqtt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_mqtt(::meshtastic::ModuleConfig_MQTTConfig* mqtt) {
  clear_payload_variant();
  if (mqtt) {
    set_has_mqtt();
    _impl_.payload_variant_.mqtt_ = mqtt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.mqtt)
}
inline ::meshtastic::ModuleConfig_MQTTConfig* ModuleConfig::_internal_mutable_mqtt() {
  if (!_internal_has_mqtt()) {
    clear_payload_variant();
    set_has_mqtt();
    _impl_.payload_variant_.mqtt_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_MQTTConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.mqtt_;
}
inline ::meshtastic::ModuleConfig_MQTTConfig* ModuleConfig::mutable_mqtt() {
  ::meshtastic::ModuleConfig_MQTTConfig* _msg = _internal_mutable_mqtt();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.mqtt)
  return _msg;
}

// .meshtastic.ModuleConfig.SerialConfig serial = 2;
inline bool ModuleConfig::_internal_has_serial() const {
  return payload_variant_case() == kSerial;
}
inline bool ModuleConfig::has_serial() const {
  return _internal_has_serial();
}
inline void ModuleConfig::set_has_serial() {
  _impl_._oneof_case_[0] = kSerial;
}
inline void ModuleConfig::clear_serial() {
  if (_internal_has_serial()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.serial_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_SerialConfig* ModuleConfig::release_serial() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.serial)
  if (_internal_has_serial()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_SerialConfig* temp = _impl_.payload_variant_.serial_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.serial_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_SerialConfig& ModuleConfig::_internal_serial() const {
  return _internal_has_serial()
      ? *_impl_.payload_variant_.serial_
      : reinterpret_cast< ::meshtastic::ModuleConfig_SerialConfig&>(::meshtastic::_ModuleConfig_SerialConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_SerialConfig& ModuleConfig::serial() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.serial)
  return _internal_serial();
}
inline ::meshtastic::ModuleConfig_SerialConfig* ModuleConfig::unsafe_arena_release_serial() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.serial)
  if (_internal_has_serial()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_SerialConfig* temp = _impl_.payload_variant_.serial_;
    _impl_.payload_variant_.serial_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_serial(::meshtastic::ModuleConfig_SerialConfig* serial) {
  clear_payload_variant();
  if (serial) {
    set_has_serial();
    _impl_.payload_variant_.serial_ = serial;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.serial)
}
inline ::meshtastic::ModuleConfig_SerialConfig* ModuleConfig::_internal_mutable_serial() {
  if (!_internal_has_serial()) {
    clear_payload_variant();
    set_has_serial();
    _impl_.payload_variant_.serial_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_SerialConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.serial_;
}
inline ::meshtastic::ModuleConfig_SerialConfig* ModuleConfig::mutable_serial() {
  ::meshtastic::ModuleConfig_SerialConfig* _msg = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.serial)
  return _msg;
}

// .meshtastic.ModuleConfig.ExternalNotificationConfig external_notification = 3;
inline bool ModuleConfig::_internal_has_external_notification() const {
  return payload_variant_case() == kExternalNotification;
}
inline bool ModuleConfig::has_external_notification() const {
  return _internal_has_external_notification();
}
inline void ModuleConfig::set_has_external_notification() {
  _impl_._oneof_case_[0] = kExternalNotification;
}
inline void ModuleConfig::clear_external_notification() {
  if (_internal_has_external_notification()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.external_notification_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_ExternalNotificationConfig* ModuleConfig::release_external_notification() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.external_notification)
  if (_internal_has_external_notification()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_ExternalNotificationConfig* temp = _impl_.payload_variant_.external_notification_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.external_notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_ExternalNotificationConfig& ModuleConfig::_internal_external_notification() const {
  return _internal_has_external_notification()
      ? *_impl_.payload_variant_.external_notification_
      : reinterpret_cast< ::meshtastic::ModuleConfig_ExternalNotificationConfig&>(::meshtastic::_ModuleConfig_ExternalNotificationConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_ExternalNotificationConfig& ModuleConfig::external_notification() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.external_notification)
  return _internal_external_notification();
}
inline ::meshtastic::ModuleConfig_ExternalNotificationConfig* ModuleConfig::unsafe_arena_release_external_notification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.external_notification)
  if (_internal_has_external_notification()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_ExternalNotificationConfig* temp = _impl_.payload_variant_.external_notification_;
    _impl_.payload_variant_.external_notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_external_notification(::meshtastic::ModuleConfig_ExternalNotificationConfig* external_notification) {
  clear_payload_variant();
  if (external_notification) {
    set_has_external_notification();
    _impl_.payload_variant_.external_notification_ = external_notification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.external_notification)
}
inline ::meshtastic::ModuleConfig_ExternalNotificationConfig* ModuleConfig::_internal_mutable_external_notification() {
  if (!_internal_has_external_notification()) {
    clear_payload_variant();
    set_has_external_notification();
    _impl_.payload_variant_.external_notification_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_ExternalNotificationConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.external_notification_;
}
inline ::meshtastic::ModuleConfig_ExternalNotificationConfig* ModuleConfig::mutable_external_notification() {
  ::meshtastic::ModuleConfig_ExternalNotificationConfig* _msg = _internal_mutable_external_notification();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.external_notification)
  return _msg;
}

// .meshtastic.ModuleConfig.StoreForwardConfig store_forward = 4;
inline bool ModuleConfig::_internal_has_store_forward() const {
  return payload_variant_case() == kStoreForward;
}
inline bool ModuleConfig::has_store_forward() const {
  return _internal_has_store_forward();
}
inline void ModuleConfig::set_has_store_forward() {
  _impl_._oneof_case_[0] = kStoreForward;
}
inline void ModuleConfig::clear_store_forward() {
  if (_internal_has_store_forward()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.store_forward_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_StoreForwardConfig* ModuleConfig::release_store_forward() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.store_forward)
  if (_internal_has_store_forward()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_StoreForwardConfig* temp = _impl_.payload_variant_.store_forward_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.store_forward_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_StoreForwardConfig& ModuleConfig::_internal_store_forward() const {
  return _internal_has_store_forward()
      ? *_impl_.payload_variant_.store_forward_
      : reinterpret_cast< ::meshtastic::ModuleConfig_StoreForwardConfig&>(::meshtastic::_ModuleConfig_StoreForwardConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_StoreForwardConfig& ModuleConfig::store_forward() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.store_forward)
  return _internal_store_forward();
}
inline ::meshtastic::ModuleConfig_StoreForwardConfig* ModuleConfig::unsafe_arena_release_store_forward() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.store_forward)
  if (_internal_has_store_forward()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_StoreForwardConfig* temp = _impl_.payload_variant_.store_forward_;
    _impl_.payload_variant_.store_forward_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_store_forward(::meshtastic::ModuleConfig_StoreForwardConfig* store_forward) {
  clear_payload_variant();
  if (store_forward) {
    set_has_store_forward();
    _impl_.payload_variant_.store_forward_ = store_forward;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.store_forward)
}
inline ::meshtastic::ModuleConfig_StoreForwardConfig* ModuleConfig::_internal_mutable_store_forward() {
  if (!_internal_has_store_forward()) {
    clear_payload_variant();
    set_has_store_forward();
    _impl_.payload_variant_.store_forward_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_StoreForwardConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.store_forward_;
}
inline ::meshtastic::ModuleConfig_StoreForwardConfig* ModuleConfig::mutable_store_forward() {
  ::meshtastic::ModuleConfig_StoreForwardConfig* _msg = _internal_mutable_store_forward();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.store_forward)
  return _msg;
}

// .meshtastic.ModuleConfig.RangeTestConfig range_test = 5;
inline bool ModuleConfig::_internal_has_range_test() const {
  return payload_variant_case() == kRangeTest;
}
inline bool ModuleConfig::has_range_test() const {
  return _internal_has_range_test();
}
inline void ModuleConfig::set_has_range_test() {
  _impl_._oneof_case_[0] = kRangeTest;
}
inline void ModuleConfig::clear_range_test() {
  if (_internal_has_range_test()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.range_test_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_RangeTestConfig* ModuleConfig::release_range_test() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.range_test)
  if (_internal_has_range_test()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_RangeTestConfig* temp = _impl_.payload_variant_.range_test_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.range_test_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_RangeTestConfig& ModuleConfig::_internal_range_test() const {
  return _internal_has_range_test()
      ? *_impl_.payload_variant_.range_test_
      : reinterpret_cast< ::meshtastic::ModuleConfig_RangeTestConfig&>(::meshtastic::_ModuleConfig_RangeTestConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_RangeTestConfig& ModuleConfig::range_test() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.range_test)
  return _internal_range_test();
}
inline ::meshtastic::ModuleConfig_RangeTestConfig* ModuleConfig::unsafe_arena_release_range_test() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.range_test)
  if (_internal_has_range_test()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_RangeTestConfig* temp = _impl_.payload_variant_.range_test_;
    _impl_.payload_variant_.range_test_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_range_test(::meshtastic::ModuleConfig_RangeTestConfig* range_test) {
  clear_payload_variant();
  if (range_test) {
    set_has_range_test();
    _impl_.payload_variant_.range_test_ = range_test;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.range_test)
}
inline ::meshtastic::ModuleConfig_RangeTestConfig* ModuleConfig::_internal_mutable_range_test() {
  if (!_internal_has_range_test()) {
    clear_payload_variant();
    set_has_range_test();
    _impl_.payload_variant_.range_test_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_RangeTestConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.range_test_;
}
inline ::meshtastic::ModuleConfig_RangeTestConfig* ModuleConfig::mutable_range_test() {
  ::meshtastic::ModuleConfig_RangeTestConfig* _msg = _internal_mutable_range_test();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.range_test)
  return _msg;
}

// .meshtastic.ModuleConfig.TelemetryConfig telemetry = 6;
inline bool ModuleConfig::_internal_has_telemetry() const {
  return payload_variant_case() == kTelemetry;
}
inline bool ModuleConfig::has_telemetry() const {
  return _internal_has_telemetry();
}
inline void ModuleConfig::set_has_telemetry() {
  _impl_._oneof_case_[0] = kTelemetry;
}
inline void ModuleConfig::clear_telemetry() {
  if (_internal_has_telemetry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.telemetry_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_TelemetryConfig* ModuleConfig::release_telemetry() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.telemetry)
  if (_internal_has_telemetry()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_TelemetryConfig* temp = _impl_.payload_variant_.telemetry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.telemetry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_TelemetryConfig& ModuleConfig::_internal_telemetry() const {
  return _internal_has_telemetry()
      ? *_impl_.payload_variant_.telemetry_
      : reinterpret_cast< ::meshtastic::ModuleConfig_TelemetryConfig&>(::meshtastic::_ModuleConfig_TelemetryConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_TelemetryConfig& ModuleConfig::telemetry() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.telemetry)
  return _internal_telemetry();
}
inline ::meshtastic::ModuleConfig_TelemetryConfig* ModuleConfig::unsafe_arena_release_telemetry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.telemetry)
  if (_internal_has_telemetry()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_TelemetryConfig* temp = _impl_.payload_variant_.telemetry_;
    _impl_.payload_variant_.telemetry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_telemetry(::meshtastic::ModuleConfig_TelemetryConfig* telemetry) {
  clear_payload_variant();
  if (telemetry) {
    set_has_telemetry();
    _impl_.payload_variant_.telemetry_ = telemetry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.telemetry)
}
inline ::meshtastic::ModuleConfig_TelemetryConfig* ModuleConfig::_internal_mutable_telemetry() {
  if (!_internal_has_telemetry()) {
    clear_payload_variant();
    set_has_telemetry();
    _impl_.payload_variant_.telemetry_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_TelemetryConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.telemetry_;
}
inline ::meshtastic::ModuleConfig_TelemetryConfig* ModuleConfig::mutable_telemetry() {
  ::meshtastic::ModuleConfig_TelemetryConfig* _msg = _internal_mutable_telemetry();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.telemetry)
  return _msg;
}

// .meshtastic.ModuleConfig.CannedMessageConfig canned_message = 7;
inline bool ModuleConfig::_internal_has_canned_message() const {
  return payload_variant_case() == kCannedMessage;
}
inline bool ModuleConfig::has_canned_message() const {
  return _internal_has_canned_message();
}
inline void ModuleConfig::set_has_canned_message() {
  _impl_._oneof_case_[0] = kCannedMessage;
}
inline void ModuleConfig::clear_canned_message() {
  if (_internal_has_canned_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.canned_message_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig* ModuleConfig::release_canned_message() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.canned_message)
  if (_internal_has_canned_message()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_CannedMessageConfig* temp = _impl_.payload_variant_.canned_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.canned_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_CannedMessageConfig& ModuleConfig::_internal_canned_message() const {
  return _internal_has_canned_message()
      ? *_impl_.payload_variant_.canned_message_
      : reinterpret_cast< ::meshtastic::ModuleConfig_CannedMessageConfig&>(::meshtastic::_ModuleConfig_CannedMessageConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_CannedMessageConfig& ModuleConfig::canned_message() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.canned_message)
  return _internal_canned_message();
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig* ModuleConfig::unsafe_arena_release_canned_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.canned_message)
  if (_internal_has_canned_message()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_CannedMessageConfig* temp = _impl_.payload_variant_.canned_message_;
    _impl_.payload_variant_.canned_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_canned_message(::meshtastic::ModuleConfig_CannedMessageConfig* canned_message) {
  clear_payload_variant();
  if (canned_message) {
    set_has_canned_message();
    _impl_.payload_variant_.canned_message_ = canned_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.canned_message)
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig* ModuleConfig::_internal_mutable_canned_message() {
  if (!_internal_has_canned_message()) {
    clear_payload_variant();
    set_has_canned_message();
    _impl_.payload_variant_.canned_message_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_CannedMessageConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.canned_message_;
}
inline ::meshtastic::ModuleConfig_CannedMessageConfig* ModuleConfig::mutable_canned_message() {
  ::meshtastic::ModuleConfig_CannedMessageConfig* _msg = _internal_mutable_canned_message();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.canned_message)
  return _msg;
}

// .meshtastic.ModuleConfig.AudioConfig audio = 8;
inline bool ModuleConfig::_internal_has_audio() const {
  return payload_variant_case() == kAudio;
}
inline bool ModuleConfig::has_audio() const {
  return _internal_has_audio();
}
inline void ModuleConfig::set_has_audio() {
  _impl_._oneof_case_[0] = kAudio;
}
inline void ModuleConfig::clear_audio() {
  if (_internal_has_audio()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.audio_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_AudioConfig* ModuleConfig::release_audio() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.audio)
  if (_internal_has_audio()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_AudioConfig* temp = _impl_.payload_variant_.audio_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_AudioConfig& ModuleConfig::_internal_audio() const {
  return _internal_has_audio()
      ? *_impl_.payload_variant_.audio_
      : reinterpret_cast< ::meshtastic::ModuleConfig_AudioConfig&>(::meshtastic::_ModuleConfig_AudioConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_AudioConfig& ModuleConfig::audio() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.audio)
  return _internal_audio();
}
inline ::meshtastic::ModuleConfig_AudioConfig* ModuleConfig::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.audio)
  if (_internal_has_audio()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_AudioConfig* temp = _impl_.payload_variant_.audio_;
    _impl_.payload_variant_.audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_audio(::meshtastic::ModuleConfig_AudioConfig* audio) {
  clear_payload_variant();
  if (audio) {
    set_has_audio();
    _impl_.payload_variant_.audio_ = audio;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.audio)
}
inline ::meshtastic::ModuleConfig_AudioConfig* ModuleConfig::_internal_mutable_audio() {
  if (!_internal_has_audio()) {
    clear_payload_variant();
    set_has_audio();
    _impl_.payload_variant_.audio_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_AudioConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.audio_;
}
inline ::meshtastic::ModuleConfig_AudioConfig* ModuleConfig::mutable_audio() {
  ::meshtastic::ModuleConfig_AudioConfig* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.audio)
  return _msg;
}

// .meshtastic.ModuleConfig.RemoteHardwareConfig remote_hardware = 9;
inline bool ModuleConfig::_internal_has_remote_hardware() const {
  return payload_variant_case() == kRemoteHardware;
}
inline bool ModuleConfig::has_remote_hardware() const {
  return _internal_has_remote_hardware();
}
inline void ModuleConfig::set_has_remote_hardware() {
  _impl_._oneof_case_[0] = kRemoteHardware;
}
inline void ModuleConfig::clear_remote_hardware() {
  if (_internal_has_remote_hardware()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.remote_hardware_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_RemoteHardwareConfig* ModuleConfig::release_remote_hardware() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.remote_hardware)
  if (_internal_has_remote_hardware()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_RemoteHardwareConfig* temp = _impl_.payload_variant_.remote_hardware_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.remote_hardware_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_RemoteHardwareConfig& ModuleConfig::_internal_remote_hardware() const {
  return _internal_has_remote_hardware()
      ? *_impl_.payload_variant_.remote_hardware_
      : reinterpret_cast< ::meshtastic::ModuleConfig_RemoteHardwareConfig&>(::meshtastic::_ModuleConfig_RemoteHardwareConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_RemoteHardwareConfig& ModuleConfig::remote_hardware() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.remote_hardware)
  return _internal_remote_hardware();
}
inline ::meshtastic::ModuleConfig_RemoteHardwareConfig* ModuleConfig::unsafe_arena_release_remote_hardware() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.remote_hardware)
  if (_internal_has_remote_hardware()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_RemoteHardwareConfig* temp = _impl_.payload_variant_.remote_hardware_;
    _impl_.payload_variant_.remote_hardware_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_remote_hardware(::meshtastic::ModuleConfig_RemoteHardwareConfig* remote_hardware) {
  clear_payload_variant();
  if (remote_hardware) {
    set_has_remote_hardware();
    _impl_.payload_variant_.remote_hardware_ = remote_hardware;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.remote_hardware)
}
inline ::meshtastic::ModuleConfig_RemoteHardwareConfig* ModuleConfig::_internal_mutable_remote_hardware() {
  if (!_internal_has_remote_hardware()) {
    clear_payload_variant();
    set_has_remote_hardware();
    _impl_.payload_variant_.remote_hardware_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_RemoteHardwareConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.remote_hardware_;
}
inline ::meshtastic::ModuleConfig_RemoteHardwareConfig* ModuleConfig::mutable_remote_hardware() {
  ::meshtastic::ModuleConfig_RemoteHardwareConfig* _msg = _internal_mutable_remote_hardware();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.remote_hardware)
  return _msg;
}

// .meshtastic.ModuleConfig.NeighborInfoConfig neighbor_info = 10;
inline bool ModuleConfig::_internal_has_neighbor_info() const {
  return payload_variant_case() == kNeighborInfo;
}
inline bool ModuleConfig::has_neighbor_info() const {
  return _internal_has_neighbor_info();
}
inline void ModuleConfig::set_has_neighbor_info() {
  _impl_._oneof_case_[0] = kNeighborInfo;
}
inline void ModuleConfig::clear_neighbor_info() {
  if (_internal_has_neighbor_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.neighbor_info_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_NeighborInfoConfig* ModuleConfig::release_neighbor_info() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.neighbor_info)
  if (_internal_has_neighbor_info()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_NeighborInfoConfig* temp = _impl_.payload_variant_.neighbor_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.neighbor_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_NeighborInfoConfig& ModuleConfig::_internal_neighbor_info() const {
  return _internal_has_neighbor_info()
      ? *_impl_.payload_variant_.neighbor_info_
      : reinterpret_cast< ::meshtastic::ModuleConfig_NeighborInfoConfig&>(::meshtastic::_ModuleConfig_NeighborInfoConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_NeighborInfoConfig& ModuleConfig::neighbor_info() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.neighbor_info)
  return _internal_neighbor_info();
}
inline ::meshtastic::ModuleConfig_NeighborInfoConfig* ModuleConfig::unsafe_arena_release_neighbor_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.neighbor_info)
  if (_internal_has_neighbor_info()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_NeighborInfoConfig* temp = _impl_.payload_variant_.neighbor_info_;
    _impl_.payload_variant_.neighbor_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_neighbor_info(::meshtastic::ModuleConfig_NeighborInfoConfig* neighbor_info) {
  clear_payload_variant();
  if (neighbor_info) {
    set_has_neighbor_info();
    _impl_.payload_variant_.neighbor_info_ = neighbor_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.neighbor_info)
}
inline ::meshtastic::ModuleConfig_NeighborInfoConfig* ModuleConfig::_internal_mutable_neighbor_info() {
  if (!_internal_has_neighbor_info()) {
    clear_payload_variant();
    set_has_neighbor_info();
    _impl_.payload_variant_.neighbor_info_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_NeighborInfoConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.neighbor_info_;
}
inline ::meshtastic::ModuleConfig_NeighborInfoConfig* ModuleConfig::mutable_neighbor_info() {
  ::meshtastic::ModuleConfig_NeighborInfoConfig* _msg = _internal_mutable_neighbor_info();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.neighbor_info)
  return _msg;
}

// .meshtastic.ModuleConfig.AmbientLightingConfig ambient_lighting = 11;
inline bool ModuleConfig::_internal_has_ambient_lighting() const {
  return payload_variant_case() == kAmbientLighting;
}
inline bool ModuleConfig::has_ambient_lighting() const {
  return _internal_has_ambient_lighting();
}
inline void ModuleConfig::set_has_ambient_lighting() {
  _impl_._oneof_case_[0] = kAmbientLighting;
}
inline void ModuleConfig::clear_ambient_lighting() {
  if (_internal_has_ambient_lighting()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.ambient_lighting_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_AmbientLightingConfig* ModuleConfig::release_ambient_lighting() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.ambient_lighting)
  if (_internal_has_ambient_lighting()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_AmbientLightingConfig* temp = _impl_.payload_variant_.ambient_lighting_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.ambient_lighting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_AmbientLightingConfig& ModuleConfig::_internal_ambient_lighting() const {
  return _internal_has_ambient_lighting()
      ? *_impl_.payload_variant_.ambient_lighting_
      : reinterpret_cast< ::meshtastic::ModuleConfig_AmbientLightingConfig&>(::meshtastic::_ModuleConfig_AmbientLightingConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_AmbientLightingConfig& ModuleConfig::ambient_lighting() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.ambient_lighting)
  return _internal_ambient_lighting();
}
inline ::meshtastic::ModuleConfig_AmbientLightingConfig* ModuleConfig::unsafe_arena_release_ambient_lighting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.ambient_lighting)
  if (_internal_has_ambient_lighting()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_AmbientLightingConfig* temp = _impl_.payload_variant_.ambient_lighting_;
    _impl_.payload_variant_.ambient_lighting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_ambient_lighting(::meshtastic::ModuleConfig_AmbientLightingConfig* ambient_lighting) {
  clear_payload_variant();
  if (ambient_lighting) {
    set_has_ambient_lighting();
    _impl_.payload_variant_.ambient_lighting_ = ambient_lighting;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.ambient_lighting)
}
inline ::meshtastic::ModuleConfig_AmbientLightingConfig* ModuleConfig::_internal_mutable_ambient_lighting() {
  if (!_internal_has_ambient_lighting()) {
    clear_payload_variant();
    set_has_ambient_lighting();
    _impl_.payload_variant_.ambient_lighting_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_AmbientLightingConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.ambient_lighting_;
}
inline ::meshtastic::ModuleConfig_AmbientLightingConfig* ModuleConfig::mutable_ambient_lighting() {
  ::meshtastic::ModuleConfig_AmbientLightingConfig* _msg = _internal_mutable_ambient_lighting();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.ambient_lighting)
  return _msg;
}

// .meshtastic.ModuleConfig.DetectionSensorConfig detection_sensor = 12;
inline bool ModuleConfig::_internal_has_detection_sensor() const {
  return payload_variant_case() == kDetectionSensor;
}
inline bool ModuleConfig::has_detection_sensor() const {
  return _internal_has_detection_sensor();
}
inline void ModuleConfig::set_has_detection_sensor() {
  _impl_._oneof_case_[0] = kDetectionSensor;
}
inline void ModuleConfig::clear_detection_sensor() {
  if (_internal_has_detection_sensor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.detection_sensor_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_DetectionSensorConfig* ModuleConfig::release_detection_sensor() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.detection_sensor)
  if (_internal_has_detection_sensor()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_DetectionSensorConfig* temp = _impl_.payload_variant_.detection_sensor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.detection_sensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_DetectionSensorConfig& ModuleConfig::_internal_detection_sensor() const {
  return _internal_has_detection_sensor()
      ? *_impl_.payload_variant_.detection_sensor_
      : reinterpret_cast< ::meshtastic::ModuleConfig_DetectionSensorConfig&>(::meshtastic::_ModuleConfig_DetectionSensorConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_DetectionSensorConfig& ModuleConfig::detection_sensor() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.detection_sensor)
  return _internal_detection_sensor();
}
inline ::meshtastic::ModuleConfig_DetectionSensorConfig* ModuleConfig::unsafe_arena_release_detection_sensor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.detection_sensor)
  if (_internal_has_detection_sensor()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_DetectionSensorConfig* temp = _impl_.payload_variant_.detection_sensor_;
    _impl_.payload_variant_.detection_sensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_detection_sensor(::meshtastic::ModuleConfig_DetectionSensorConfig* detection_sensor) {
  clear_payload_variant();
  if (detection_sensor) {
    set_has_detection_sensor();
    _impl_.payload_variant_.detection_sensor_ = detection_sensor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.detection_sensor)
}
inline ::meshtastic::ModuleConfig_DetectionSensorConfig* ModuleConfig::_internal_mutable_detection_sensor() {
  if (!_internal_has_detection_sensor()) {
    clear_payload_variant();
    set_has_detection_sensor();
    _impl_.payload_variant_.detection_sensor_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_DetectionSensorConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.detection_sensor_;
}
inline ::meshtastic::ModuleConfig_DetectionSensorConfig* ModuleConfig::mutable_detection_sensor() {
  ::meshtastic::ModuleConfig_DetectionSensorConfig* _msg = _internal_mutable_detection_sensor();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.detection_sensor)
  return _msg;
}

// .meshtastic.ModuleConfig.PaxcounterConfig paxcounter = 13;
inline bool ModuleConfig::_internal_has_paxcounter() const {
  return payload_variant_case() == kPaxcounter;
}
inline bool ModuleConfig::has_paxcounter() const {
  return _internal_has_paxcounter();
}
inline void ModuleConfig::set_has_paxcounter() {
  _impl_._oneof_case_[0] = kPaxcounter;
}
inline void ModuleConfig::clear_paxcounter() {
  if (_internal_has_paxcounter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.paxcounter_;
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::ModuleConfig_PaxcounterConfig* ModuleConfig::release_paxcounter() {
  // @@protoc_insertion_point(field_release:meshtastic.ModuleConfig.paxcounter)
  if (_internal_has_paxcounter()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_PaxcounterConfig* temp = _impl_.payload_variant_.paxcounter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.paxcounter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::ModuleConfig_PaxcounterConfig& ModuleConfig::_internal_paxcounter() const {
  return _internal_has_paxcounter()
      ? *_impl_.payload_variant_.paxcounter_
      : reinterpret_cast< ::meshtastic::ModuleConfig_PaxcounterConfig&>(::meshtastic::_ModuleConfig_PaxcounterConfig_default_instance_);
}
inline const ::meshtastic::ModuleConfig_PaxcounterConfig& ModuleConfig::paxcounter() const {
  // @@protoc_insertion_point(field_get:meshtastic.ModuleConfig.paxcounter)
  return _internal_paxcounter();
}
inline ::meshtastic::ModuleConfig_PaxcounterConfig* ModuleConfig::unsafe_arena_release_paxcounter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.ModuleConfig.paxcounter)
  if (_internal_has_paxcounter()) {
    clear_has_payload_variant();
    ::meshtastic::ModuleConfig_PaxcounterConfig* temp = _impl_.payload_variant_.paxcounter_;
    _impl_.payload_variant_.paxcounter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModuleConfig::unsafe_arena_set_allocated_paxcounter(::meshtastic::ModuleConfig_PaxcounterConfig* paxcounter) {
  clear_payload_variant();
  if (paxcounter) {
    set_has_paxcounter();
    _impl_.payload_variant_.paxcounter_ = paxcounter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.ModuleConfig.paxcounter)
}
inline ::meshtastic::ModuleConfig_PaxcounterConfig* ModuleConfig::_internal_mutable_paxcounter() {
  if (!_internal_has_paxcounter()) {
    clear_payload_variant();
    set_has_paxcounter();
    _impl_.payload_variant_.paxcounter_ = CreateMaybeMessage< ::meshtastic::ModuleConfig_PaxcounterConfig >(GetArenaForAllocation());
  }
  return _impl_.payload_variant_.paxcounter_;
}
inline ::meshtastic::ModuleConfig_PaxcounterConfig* ModuleConfig::mutable_paxcounter() {
  ::meshtastic::ModuleConfig_PaxcounterConfig* _msg = _internal_mutable_paxcounter();
  // @@protoc_insertion_point(field_mutable:meshtastic.ModuleConfig.paxcounter)
  return _msg;
}

inline bool ModuleConfig::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void ModuleConfig::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline ModuleConfig::PayloadVariantCase ModuleConfig::payload_variant_case() const {
  return ModuleConfig::PayloadVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RemoteHardwarePin

// uint32 gpio_pin = 1;
inline void RemoteHardwarePin::clear_gpio_pin() {
  _impl_.gpio_pin_ = 0u;
}
inline uint32_t RemoteHardwarePin::_internal_gpio_pin() const {
  return _impl_.gpio_pin_;
}
inline uint32_t RemoteHardwarePin::gpio_pin() const {
  // @@protoc_insertion_point(field_get:meshtastic.RemoteHardwarePin.gpio_pin)
  return _internal_gpio_pin();
}
inline void RemoteHardwarePin::_internal_set_gpio_pin(uint32_t value) {
  
  _impl_.gpio_pin_ = value;
}
inline void RemoteHardwarePin::set_gpio_pin(uint32_t value) {
  _internal_set_gpio_pin(value);
  // @@protoc_insertion_point(field_set:meshtastic.RemoteHardwarePin.gpio_pin)
}

// string name = 2;
inline void RemoteHardwarePin::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RemoteHardwarePin::name() const {
  // @@protoc_insertion_point(field_get:meshtastic.RemoteHardwarePin.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteHardwarePin::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:meshtastic.RemoteHardwarePin.name)
}
inline std::string* RemoteHardwarePin::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.RemoteHardwarePin.name)
  return _s;
}
inline const std::string& RemoteHardwarePin::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RemoteHardwarePin::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoteHardwarePin::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoteHardwarePin::release_name() {
  // @@protoc_insertion_point(field_release:meshtastic.RemoteHardwarePin.name)
  return _impl_.name_.Release();
}
inline void RemoteHardwarePin::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:meshtastic.RemoteHardwarePin.name)
}

// .meshtastic.RemoteHardwarePinType type = 3;
inline void RemoteHardwarePin::clear_type() {
  _impl_.type_ = 0;
}
inline ::meshtastic::RemoteHardwarePinType RemoteHardwarePin::_internal_type() const {
  return static_cast< ::meshtastic::RemoteHardwarePinType >(_impl_.type_);
}
inline ::meshtastic::RemoteHardwarePinType RemoteHardwarePin::type() const {
  // @@protoc_insertion_point(field_get:meshtastic.RemoteHardwarePin.type)
  return _internal_type();
}
inline void RemoteHardwarePin::_internal_set_type(::meshtastic::RemoteHardwarePinType value) {
  
  _impl_.type_ = value;
}
inline void RemoteHardwarePin::set_type(::meshtastic::RemoteHardwarePinType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:meshtastic.RemoteHardwarePin.type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meshtastic

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType>() {
  return ::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::ModuleConfig_AudioConfig_Audio_Baud> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::ModuleConfig_AudioConfig_Audio_Baud>() {
  return ::meshtastic::ModuleConfig_AudioConfig_Audio_Baud_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::ModuleConfig_SerialConfig_Serial_Baud> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::ModuleConfig_SerialConfig_Serial_Baud>() {
  return ::meshtastic::ModuleConfig_SerialConfig_Serial_Baud_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::ModuleConfig_SerialConfig_Serial_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::ModuleConfig_SerialConfig_Serial_Mode>() {
  return ::meshtastic::ModuleConfig_SerialConfig_Serial_Mode_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar>() {
  return ::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar_descriptor();
}
template <> struct is_proto_enum< ::meshtastic::RemoteHardwarePinType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::meshtastic::RemoteHardwarePinType>() {
  return ::meshtastic::RemoteHardwarePinType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_meshtastic_2fmodule_5fconfig_2eproto
