// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meshtastic/mesh.proto

#include "meshtastic/mesh.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace meshtastic {
PROTOBUF_CONSTEXPR Position::Position(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.latitude_i_)*/0
  , /*decltype(_impl_.longitude_i_)*/0
  , /*decltype(_impl_.altitude_)*/0
  , /*decltype(_impl_.time_)*/0u
  , /*decltype(_impl_.location_source_)*/0
  , /*decltype(_impl_.altitude_source_)*/0
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.timestamp_millis_adjust_)*/0
  , /*decltype(_impl_.altitude_hae_)*/0
  , /*decltype(_impl_.altitude_geoidal_separation_)*/0
  , /*decltype(_impl_.pdop_)*/0u
  , /*decltype(_impl_.hdop_)*/0u
  , /*decltype(_impl_.vdop_)*/0u
  , /*decltype(_impl_.gps_accuracy_)*/0u
  , /*decltype(_impl_.ground_speed_)*/0u
  , /*decltype(_impl_.ground_track_)*/0u
  , /*decltype(_impl_.fix_quality_)*/0u
  , /*decltype(_impl_.fix_type_)*/0u
  , /*decltype(_impl_.sats_in_view_)*/0u
  , /*decltype(_impl_.sensor_id_)*/0u
  , /*decltype(_impl_.next_update_)*/0u
  , /*decltype(_impl_.seq_number_)*/0u
  , /*decltype(_impl_.precision_bits_)*/0u} {}
struct PositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionDefaultTypeInternal() {}
  union {
    Position _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionDefaultTypeInternal _Position_default_instance_;
PROTOBUF_CONSTEXPR User::User(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.long_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.short_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.macaddr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hw_model_)*/0
  , /*decltype(_impl_.role_)*/0
  , /*decltype(_impl_.is_licensed_)*/false
  , /*decltype(_impl_.is_unmessagable_)*/false} {}
struct UserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserDefaultTypeInternal() {}
  union {
    User _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDefaultTypeInternal _User_default_instance_;
PROTOBUF_CONSTEXPR RouteDiscovery::RouteDiscovery(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.route_)*/{}
  , /*decltype(_impl_.snr_towards_)*/{}
  , /*decltype(_impl_._snr_towards_cached_byte_size_)*/{0}
  , /*decltype(_impl_.route_back_)*/{}
  , /*decltype(_impl_.snr_back_)*/{}
  , /*decltype(_impl_._snr_back_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RouteDiscoveryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteDiscoveryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteDiscoveryDefaultTypeInternal() {}
  union {
    RouteDiscovery _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteDiscoveryDefaultTypeInternal _RouteDiscovery_default_instance_;
PROTOBUF_CONSTEXPR Routing::Routing(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.variant_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RoutingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoutingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoutingDefaultTypeInternal() {}
  union {
    Routing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoutingDefaultTypeInternal _Routing_default_instance_;
PROTOBUF_CONSTEXPR Data::Data(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.payload_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.portnum_)*/0
  , /*decltype(_impl_.want_response_)*/false
  , /*decltype(_impl_.dest_)*/0u
  , /*decltype(_impl_.source_)*/0u
  , /*decltype(_impl_.request_id_)*/0u
  , /*decltype(_impl_.reply_id_)*/0u
  , /*decltype(_impl_.emoji_)*/0u
  , /*decltype(_impl_.bitfield_)*/0u} {}
struct DataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataDefaultTypeInternal() {}
  union {
    Data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataDefaultTypeInternal _Data_default_instance_;
PROTOBUF_CONSTEXPR KeyVerification::KeyVerification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hash1_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hash2_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nonce_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeyVerificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyVerificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyVerificationDefaultTypeInternal() {}
  union {
    KeyVerification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyVerificationDefaultTypeInternal _KeyVerification_default_instance_;
PROTOBUF_CONSTEXPR Waypoint::Waypoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.latitude_i_)*/0
  , /*decltype(_impl_.longitude_i_)*/0
  , /*decltype(_impl_.expire_)*/0u
  , /*decltype(_impl_.locked_to_)*/0u
  , /*decltype(_impl_.icon_)*/0u} {}
struct WaypointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WaypointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WaypointDefaultTypeInternal() {}
  union {
    Waypoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WaypointDefaultTypeInternal _Waypoint_default_instance_;
PROTOBUF_CONSTEXPR MqttClientProxyMessage::MqttClientProxyMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.topic_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.retained_)*/false
  , /*decltype(_impl_.payload_variant_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct MqttClientProxyMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MqttClientProxyMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MqttClientProxyMessageDefaultTypeInternal() {}
  union {
    MqttClientProxyMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MqttClientProxyMessageDefaultTypeInternal _MqttClientProxyMessage_default_instance_;
PROTOBUF_CONSTEXPR MeshPacket::MeshPacket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.from_)*/0u
  , /*decltype(_impl_.to_)*/0u
  , /*decltype(_impl_.channel_)*/0u
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.rx_time_)*/0u
  , /*decltype(_impl_.rx_snr_)*/0
  , /*decltype(_impl_.hop_limit_)*/0u
  , /*decltype(_impl_.priority_)*/0
  , /*decltype(_impl_.rx_rssi_)*/0
  , /*decltype(_impl_.delayed_)*/0
  , /*decltype(_impl_.want_ack_)*/false
  , /*decltype(_impl_.via_mqtt_)*/false
  , /*decltype(_impl_.pki_encrypted_)*/false
  , /*decltype(_impl_.hop_start_)*/0u
  , /*decltype(_impl_.next_hop_)*/0u
  , /*decltype(_impl_.relay_node_)*/0u
  , /*decltype(_impl_.tx_after_)*/0u
  , /*decltype(_impl_.transport_mechanism_)*/0
  , /*decltype(_impl_.payload_variant_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct MeshPacketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MeshPacketDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MeshPacketDefaultTypeInternal() {}
  union {
    MeshPacket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MeshPacketDefaultTypeInternal _MeshPacket_default_instance_;
PROTOBUF_CONSTEXPR NodeInfo::NodeInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_)*/nullptr
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.device_metrics_)*/nullptr
  , /*decltype(_impl_.num_)*/0u
  , /*decltype(_impl_.snr_)*/0
  , /*decltype(_impl_.last_heard_)*/0u
  , /*decltype(_impl_.channel_)*/0u
  , /*decltype(_impl_.hops_away_)*/0u
  , /*decltype(_impl_.via_mqtt_)*/false
  , /*decltype(_impl_.is_favorite_)*/false
  , /*decltype(_impl_.is_ignored_)*/false
  , /*decltype(_impl_.is_key_manually_verified_)*/false} {}
struct NodeInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeInfoDefaultTypeInternal() {}
  union {
    NodeInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
PROTOBUF_CONSTEXPR MyNodeInfo::MyNodeInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.device_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pio_env_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.my_node_num_)*/0u
  , /*decltype(_impl_.reboot_count_)*/0u
  , /*decltype(_impl_.min_app_version_)*/0u
  , /*decltype(_impl_.firmware_edition_)*/0
  , /*decltype(_impl_.nodedb_count_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MyNodeInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MyNodeInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MyNodeInfoDefaultTypeInternal() {}
  union {
    MyNodeInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MyNodeInfoDefaultTypeInternal _MyNodeInfo_default_instance_;
PROTOBUF_CONSTEXPR LogRecord::LogRecord(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.source_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.time_)*/0u
  , /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LogRecordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogRecordDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogRecordDefaultTypeInternal() {}
  union {
    LogRecord _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogRecordDefaultTypeInternal _LogRecord_default_instance_;
PROTOBUF_CONSTEXPR QueueStatus::QueueStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.res_)*/0
  , /*decltype(_impl_.free_)*/0u
  , /*decltype(_impl_.maxlen_)*/0u
  , /*decltype(_impl_.mesh_packet_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QueueStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QueueStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QueueStatusDefaultTypeInternal() {}
  union {
    QueueStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QueueStatusDefaultTypeInternal _QueueStatus_default_instance_;
PROTOBUF_CONSTEXPR FromRadio::FromRadio(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.payload_variant_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct FromRadioDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FromRadioDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FromRadioDefaultTypeInternal() {}
  union {
    FromRadio _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FromRadioDefaultTypeInternal _FromRadio_default_instance_;
PROTOBUF_CONSTEXPR ClientNotification::ClientNotification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reply_id_)*/0u
  , /*decltype(_impl_.time_)*/0u
  , /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_.payload_variant_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ClientNotificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientNotificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientNotificationDefaultTypeInternal() {}
  union {
    ClientNotification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientNotificationDefaultTypeInternal _ClientNotification_default_instance_;
PROTOBUF_CONSTEXPR KeyVerificationNumberInform::KeyVerificationNumberInform(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.remote_longname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nonce_)*/uint64_t{0u}
  , /*decltype(_impl_.security_number_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeyVerificationNumberInformDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyVerificationNumberInformDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyVerificationNumberInformDefaultTypeInternal() {}
  union {
    KeyVerificationNumberInform _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyVerificationNumberInformDefaultTypeInternal _KeyVerificationNumberInform_default_instance_;
PROTOBUF_CONSTEXPR KeyVerificationNumberRequest::KeyVerificationNumberRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.remote_longname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nonce_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeyVerificationNumberRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyVerificationNumberRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyVerificationNumberRequestDefaultTypeInternal() {}
  union {
    KeyVerificationNumberRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyVerificationNumberRequestDefaultTypeInternal _KeyVerificationNumberRequest_default_instance_;
PROTOBUF_CONSTEXPR KeyVerificationFinal::KeyVerificationFinal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.remote_longname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.verification_characters_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nonce_)*/uint64_t{0u}
  , /*decltype(_impl_.issender_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeyVerificationFinalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyVerificationFinalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyVerificationFinalDefaultTypeInternal() {}
  union {
    KeyVerificationFinal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyVerificationFinalDefaultTypeInternal _KeyVerificationFinal_default_instance_;
PROTOBUF_CONSTEXPR DuplicatedPublicKey::DuplicatedPublicKey(
    ::_pbi::ConstantInitialized) {}
struct DuplicatedPublicKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DuplicatedPublicKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DuplicatedPublicKeyDefaultTypeInternal() {}
  union {
    DuplicatedPublicKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DuplicatedPublicKeyDefaultTypeInternal _DuplicatedPublicKey_default_instance_;
PROTOBUF_CONSTEXPR LowEntropyKey::LowEntropyKey(
    ::_pbi::ConstantInitialized) {}
struct LowEntropyKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LowEntropyKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LowEntropyKeyDefaultTypeInternal() {}
  union {
    LowEntropyKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LowEntropyKeyDefaultTypeInternal _LowEntropyKey_default_instance_;
PROTOBUF_CONSTEXPR FileInfo::FileInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.file_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.size_bytes_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FileInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileInfoDefaultTypeInternal() {}
  union {
    FileInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileInfoDefaultTypeInternal _FileInfo_default_instance_;
PROTOBUF_CONSTEXPR ToRadio::ToRadio(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payload_variant_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ToRadioDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ToRadioDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ToRadioDefaultTypeInternal() {}
  union {
    ToRadio _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ToRadioDefaultTypeInternal _ToRadio_default_instance_;
PROTOBUF_CONSTEXPR Compressed::Compressed(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.portnum_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CompressedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompressedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompressedDefaultTypeInternal() {}
  union {
    Compressed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompressedDefaultTypeInternal _Compressed_default_instance_;
PROTOBUF_CONSTEXPR NeighborInfo::NeighborInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.neighbors_)*/{}
  , /*decltype(_impl_.node_id_)*/0u
  , /*decltype(_impl_.last_sent_by_id_)*/0u
  , /*decltype(_impl_.node_broadcast_interval_secs_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NeighborInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NeighborInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NeighborInfoDefaultTypeInternal() {}
  union {
    NeighborInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NeighborInfoDefaultTypeInternal _NeighborInfo_default_instance_;
PROTOBUF_CONSTEXPR Neighbor::Neighbor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.node_id_)*/0u
  , /*decltype(_impl_.snr_)*/0
  , /*decltype(_impl_.last_rx_time_)*/0u
  , /*decltype(_impl_.node_broadcast_interval_secs_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NeighborDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NeighborDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NeighborDefaultTypeInternal() {}
  union {
    Neighbor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NeighborDefaultTypeInternal _Neighbor_default_instance_;
PROTOBUF_CONSTEXPR DeviceMetadata::DeviceMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.firmware_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_state_version_)*/0u
  , /*decltype(_impl_.canshutdown_)*/false
  , /*decltype(_impl_.haswifi_)*/false
  , /*decltype(_impl_.hasbluetooth_)*/false
  , /*decltype(_impl_.hasethernet_)*/false
  , /*decltype(_impl_.role_)*/0
  , /*decltype(_impl_.position_flags_)*/0u
  , /*decltype(_impl_.hw_model_)*/0
  , /*decltype(_impl_.hasremotehardware_)*/false
  , /*decltype(_impl_.haspkc_)*/false
  , /*decltype(_impl_.excluded_modules_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceMetadataDefaultTypeInternal() {}
  union {
    DeviceMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceMetadataDefaultTypeInternal _DeviceMetadata_default_instance_;
PROTOBUF_CONSTEXPR Heartbeat::Heartbeat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nonce_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeartbeatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeartbeatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeartbeatDefaultTypeInternal() {}
  union {
    Heartbeat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
PROTOBUF_CONSTEXPR NodeRemoteHardwarePin::NodeRemoteHardwarePin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pin_)*/nullptr
  , /*decltype(_impl_.node_num_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NodeRemoteHardwarePinDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeRemoteHardwarePinDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeRemoteHardwarePinDefaultTypeInternal() {}
  union {
    NodeRemoteHardwarePin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeRemoteHardwarePinDefaultTypeInternal _NodeRemoteHardwarePin_default_instance_;
PROTOBUF_CONSTEXPR ChunkedPayload::ChunkedPayload(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payload_chunk_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.payload_id_)*/0u
  , /*decltype(_impl_.chunk_count_)*/0u
  , /*decltype(_impl_.chunk_index_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ChunkedPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChunkedPayloadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChunkedPayloadDefaultTypeInternal() {}
  union {
    ChunkedPayload _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChunkedPayloadDefaultTypeInternal _ChunkedPayload_default_instance_;
PROTOBUF_CONSTEXPR resend_chunks::resend_chunks(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.chunks_)*/{}
  , /*decltype(_impl_._chunks_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct resend_chunksDefaultTypeInternal {
  PROTOBUF_CONSTEXPR resend_chunksDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~resend_chunksDefaultTypeInternal() {}
  union {
    resend_chunks _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 resend_chunksDefaultTypeInternal _resend_chunks_default_instance_;
PROTOBUF_CONSTEXPR ChunkedPayloadResponse::ChunkedPayloadResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payload_id_)*/0u
  , /*decltype(_impl_.payload_variant_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ChunkedPayloadResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChunkedPayloadResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChunkedPayloadResponseDefaultTypeInternal() {}
  union {
    ChunkedPayloadResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChunkedPayloadResponseDefaultTypeInternal _ChunkedPayloadResponse_default_instance_;
}  // namespace meshtastic
static ::_pb::Metadata file_level_metadata_meshtastic_2fmesh_2eproto[31];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_meshtastic_2fmesh_2eproto[12];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_meshtastic_2fmesh_2eproto = nullptr;

const uint32_t TableStruct_meshtastic_2fmesh_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.latitude_i_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.longitude_i_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.altitude_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.time_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.location_source_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.altitude_source_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.timestamp_millis_adjust_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.altitude_hae_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.altitude_geoidal_separation_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.pdop_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.hdop_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.vdop_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.gps_accuracy_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.ground_speed_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.ground_track_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.fix_quality_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.fix_type_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.sats_in_view_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.sensor_id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.next_update_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.seq_number_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.precision_bits_),
  0,
  1,
  2,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  3,
  4,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  5,
  6,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::User, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.long_name_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.short_name_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.macaddr_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.hw_model_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.is_licensed_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.role_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.public_key_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.is_unmessagable_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::RouteDiscovery, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::RouteDiscovery, _impl_.route_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::RouteDiscovery, _impl_.snr_towards_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::RouteDiscovery, _impl_.route_back_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::RouteDiscovery, _impl_.snr_back_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::Routing, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::meshtastic::Routing, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::meshtastic::Routing, _impl_.variant_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.portnum_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.payload_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.want_response_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.dest_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.source_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.reply_id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.emoji_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.bitfield_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerification, _impl_.nonce_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerification, _impl_.hash1_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerification, _impl_.hash2_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.latitude_i_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.longitude_i_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.expire_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.locked_to_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.icon_),
  ~0u,
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::MqttClientProxyMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::meshtastic::MqttClientProxyMessage, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::MqttClientProxyMessage, _impl_.topic_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::meshtastic::MqttClientProxyMessage, _impl_.retained_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MqttClientProxyMessage, _impl_.payload_variant_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.from_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.to_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.channel_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.rx_time_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.rx_snr_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.hop_limit_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.want_ack_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.priority_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.rx_rssi_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.delayed_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.via_mqtt_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.hop_start_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.public_key_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.pki_encrypted_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.next_hop_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.relay_node_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.tx_after_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.transport_mechanism_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.payload_variant_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.num_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.snr_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.last_heard_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.device_metrics_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.via_mqtt_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.hops_away_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.is_favorite_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.is_ignored_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.is_key_manually_verified_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.my_node_num_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.reboot_count_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.min_app_version_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.device_id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.pio_env_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.firmware_edition_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.nodedb_count_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::LogRecord, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::LogRecord, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::LogRecord, _impl_.time_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::LogRecord, _impl_.source_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::LogRecord, _impl_.level_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::QueueStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::QueueStatus, _impl_.res_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::QueueStatus, _impl_.free_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::QueueStatus, _impl_.maxlen_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::QueueStatus, _impl_.mesh_packet_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::FromRadio, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::meshtastic::FromRadio, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::FromRadio, _impl_.id_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::meshtastic::FromRadio, _impl_.payload_variant_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_.reply_id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_.time_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_.message_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_.payload_variant_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberInform, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberInform, _impl_.nonce_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberInform, _impl_.remote_longname_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberInform, _impl_.security_number_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberRequest, _impl_.nonce_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberRequest, _impl_.remote_longname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationFinal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationFinal, _impl_.nonce_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationFinal, _impl_.remote_longname_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationFinal, _impl_.issender_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationFinal, _impl_.verification_characters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::DuplicatedPublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::LowEntropyKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::FileInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::FileInfo, _impl_.file_name_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::FileInfo, _impl_.size_bytes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ToRadio, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ToRadio, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::meshtastic::ToRadio, _impl_.payload_variant_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::Compressed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::Compressed, _impl_.portnum_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Compressed, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::NeighborInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::NeighborInfo, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NeighborInfo, _impl_.last_sent_by_id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NeighborInfo, _impl_.node_broadcast_interval_secs_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NeighborInfo, _impl_.neighbors_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::Neighbor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::Neighbor, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Neighbor, _impl_.snr_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Neighbor, _impl_.last_rx_time_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::Neighbor, _impl_.node_broadcast_interval_secs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.firmware_version_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.device_state_version_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.canshutdown_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.haswifi_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.hasbluetooth_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.hasethernet_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.role_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.position_flags_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.hw_model_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.hasremotehardware_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.haspkc_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.excluded_modules_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::Heartbeat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::Heartbeat, _impl_.nonce_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeRemoteHardwarePin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeRemoteHardwarePin, _impl_.node_num_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::NodeRemoteHardwarePin, _impl_.pin_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayload, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayload, _impl_.payload_id_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayload, _impl_.chunk_count_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayload, _impl_.chunk_index_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayload, _impl_.payload_chunk_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::resend_chunks, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::resend_chunks, _impl_.chunks_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayloadResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayloadResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayloadResponse, _impl_.payload_id_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayloadResponse, _impl_.payload_variant_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 29, -1, sizeof(::meshtastic::Position)},
  { 52, 67, -1, sizeof(::meshtastic::User)},
  { 76, -1, -1, sizeof(::meshtastic::RouteDiscovery)},
  { 86, -1, -1, sizeof(::meshtastic::Routing)},
  { 96, 111, -1, sizeof(::meshtastic::Data)},
  { 120, -1, -1, sizeof(::meshtastic::KeyVerification)},
  { 129, 143, -1, sizeof(::meshtastic::Waypoint)},
  { 151, -1, -1, sizeof(::meshtastic::MqttClientProxyMessage)},
  { 162, -1, -1, sizeof(::meshtastic::MeshPacket)},
  { 190, 208, -1, sizeof(::meshtastic::NodeInfo)},
  { 220, -1, -1, sizeof(::meshtastic::MyNodeInfo)},
  { 233, -1, -1, sizeof(::meshtastic::LogRecord)},
  { 243, -1, -1, sizeof(::meshtastic::QueueStatus)},
  { 253, -1, -1, sizeof(::meshtastic::FromRadio)},
  { 277, 293, -1, sizeof(::meshtastic::ClientNotification)},
  { 302, -1, -1, sizeof(::meshtastic::KeyVerificationNumberInform)},
  { 311, -1, -1, sizeof(::meshtastic::KeyVerificationNumberRequest)},
  { 319, -1, -1, sizeof(::meshtastic::KeyVerificationFinal)},
  { 329, -1, -1, sizeof(::meshtastic::DuplicatedPublicKey)},
  { 335, -1, -1, sizeof(::meshtastic::LowEntropyKey)},
  { 341, -1, -1, sizeof(::meshtastic::FileInfo)},
  { 349, -1, -1, sizeof(::meshtastic::ToRadio)},
  { 362, -1, -1, sizeof(::meshtastic::Compressed)},
  { 370, -1, -1, sizeof(::meshtastic::NeighborInfo)},
  { 380, -1, -1, sizeof(::meshtastic::Neighbor)},
  { 390, -1, -1, sizeof(::meshtastic::DeviceMetadata)},
  { 408, -1, -1, sizeof(::meshtastic::Heartbeat)},
  { 415, -1, -1, sizeof(::meshtastic::NodeRemoteHardwarePin)},
  { 423, -1, -1, sizeof(::meshtastic::ChunkedPayload)},
  { 433, -1, -1, sizeof(::meshtastic::resend_chunks)},
  { 440, -1, -1, sizeof(::meshtastic::ChunkedPayloadResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::meshtastic::_Position_default_instance_._instance,
  &::meshtastic::_User_default_instance_._instance,
  &::meshtastic::_RouteDiscovery_default_instance_._instance,
  &::meshtastic::_Routing_default_instance_._instance,
  &::meshtastic::_Data_default_instance_._instance,
  &::meshtastic::_KeyVerification_default_instance_._instance,
  &::meshtastic::_Waypoint_default_instance_._instance,
  &::meshtastic::_MqttClientProxyMessage_default_instance_._instance,
  &::meshtastic::_MeshPacket_default_instance_._instance,
  &::meshtastic::_NodeInfo_default_instance_._instance,
  &::meshtastic::_MyNodeInfo_default_instance_._instance,
  &::meshtastic::_LogRecord_default_instance_._instance,
  &::meshtastic::_QueueStatus_default_instance_._instance,
  &::meshtastic::_FromRadio_default_instance_._instance,
  &::meshtastic::_ClientNotification_default_instance_._instance,
  &::meshtastic::_KeyVerificationNumberInform_default_instance_._instance,
  &::meshtastic::_KeyVerificationNumberRequest_default_instance_._instance,
  &::meshtastic::_KeyVerificationFinal_default_instance_._instance,
  &::meshtastic::_DuplicatedPublicKey_default_instance_._instance,
  &::meshtastic::_LowEntropyKey_default_instance_._instance,
  &::meshtastic::_FileInfo_default_instance_._instance,
  &::meshtastic::_ToRadio_default_instance_._instance,
  &::meshtastic::_Compressed_default_instance_._instance,
  &::meshtastic::_NeighborInfo_default_instance_._instance,
  &::meshtastic::_Neighbor_default_instance_._instance,
  &::meshtastic::_DeviceMetadata_default_instance_._instance,
  &::meshtastic::_Heartbeat_default_instance_._instance,
  &::meshtastic::_NodeRemoteHardwarePin_default_instance_._instance,
  &::meshtastic::_ChunkedPayload_default_instance_._instance,
  &::meshtastic::_resend_chunks_default_instance_._instance,
  &::meshtastic::_ChunkedPayloadResponse_default_instance_._instance,
};

const char descriptor_table_protodef_meshtastic_2fmesh_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025meshtastic/mesh.proto\022\nmeshtastic\032\030mes"
  "htastic/channel.proto\032\027meshtastic/config"
  ".proto\032\032meshtastic/device_ui.proto\032\036mesh"
  "tastic/module_config.proto\032\031meshtastic/p"
  "ortnums.proto\032\032meshtastic/telemetry.prot"
  "o\032\027meshtastic/xmodem.proto\"\207\007\n\010Position\022"
  "\027\n\nlatitude_i\030\001 \001(\017H\000\210\001\001\022\030\n\013longitude_i\030"
  "\002 \001(\017H\001\210\001\001\022\025\n\010altitude\030\003 \001(\005H\002\210\001\001\022\014\n\004tim"
  "e\030\004 \001(\007\0227\n\017location_source\030\005 \001(\0162\036.mesht"
  "astic.Position.LocSource\0227\n\017altitude_sou"
  "rce\030\006 \001(\0162\036.meshtastic.Position.AltSourc"
  "e\022\021\n\ttimestamp\030\007 \001(\007\022\037\n\027timestamp_millis"
  "_adjust\030\010 \001(\005\022\031\n\014altitude_hae\030\t \001(\021H\003\210\001\001"
  "\022(\n\033altitude_geoidal_separation\030\n \001(\021H\004\210"
  "\001\001\022\014\n\004PDOP\030\013 \001(\r\022\014\n\004HDOP\030\014 \001(\r\022\014\n\004VDOP\030\r"
  " \001(\r\022\024\n\014gps_accuracy\030\016 \001(\r\022\031\n\014ground_spe"
  "ed\030\017 \001(\rH\005\210\001\001\022\031\n\014ground_track\030\020 \001(\rH\006\210\001\001"
  "\022\023\n\013fix_quality\030\021 \001(\r\022\020\n\010fix_type\030\022 \001(\r\022"
  "\024\n\014sats_in_view\030\023 \001(\r\022\021\n\tsensor_id\030\024 \001(\r"
  "\022\023\n\013next_update\030\025 \001(\r\022\022\n\nseq_number\030\026 \001("
  "\r\022\026\n\016precision_bits\030\027 \001(\r\"N\n\tLocSource\022\r"
  "\n\tLOC_UNSET\020\000\022\016\n\nLOC_MANUAL\020\001\022\020\n\014LOC_INT"
  "ERNAL\020\002\022\020\n\014LOC_EXTERNAL\020\003\"b\n\tAltSource\022\r"
  "\n\tALT_UNSET\020\000\022\016\n\nALT_MANUAL\020\001\022\020\n\014ALT_INT"
  "ERNAL\020\002\022\020\n\014ALT_EXTERNAL\020\003\022\022\n\016ALT_BAROMET"
  "RIC\020\004B\r\n\013_latitude_iB\016\n\014_longitude_iB\013\n\t"
  "_altitudeB\017\n\r_altitude_haeB\036\n\034_altitude_"
  "geoidal_separationB\017\n\r_ground_speedB\017\n\r_"
  "ground_track\"\212\002\n\004User\022\n\n\002id\030\001 \001(\t\022\021\n\tlon"
  "g_name\030\002 \001(\t\022\022\n\nshort_name\030\003 \001(\t\022\023\n\007maca"
  "ddr\030\004 \001(\014B\002\030\001\022+\n\010hw_model\030\005 \001(\0162\031.meshta"
  "stic.HardwareModel\022\023\n\013is_licensed\030\006 \001(\010\022"
  "2\n\004role\030\007 \001(\0162$.meshtastic.Config.Device"
  "Config.Role\022\022\n\npublic_key\030\010 \001(\014\022\034\n\017is_un"
  "messagable\030\t \001(\010H\000\210\001\001B\022\n\020_is_unmessagabl"
  "e\"Z\n\016RouteDiscovery\022\r\n\005route\030\001 \003(\007\022\023\n\013sn"
  "r_towards\030\002 \003(\005\022\022\n\nroute_back\030\003 \003(\007\022\020\n\010s"
  "nr_back\030\004 \003(\005\"\373\003\n\007Routing\0223\n\rroute_reque"
  "st\030\001 \001(\0132\032.meshtastic.RouteDiscoveryH\000\0221"
  "\n\013route_reply\030\002 \001(\0132\032.meshtastic.RouteDi"
  "scoveryH\000\0221\n\014error_reason\030\003 \001(\0162\031.meshta"
  "stic.Routing.ErrorH\000\"\311\002\n\005Error\022\010\n\004NONE\020\000"
  "\022\014\n\010NO_ROUTE\020\001\022\013\n\007GOT_NAK\020\002\022\013\n\007TIMEOUT\020\003"
  "\022\020\n\014NO_INTERFACE\020\004\022\022\n\016MAX_RETRANSMIT\020\005\022\016"
  "\n\nNO_CHANNEL\020\006\022\r\n\tTOO_LARGE\020\007\022\017\n\013NO_RESP"
  "ONSE\020\010\022\024\n\020DUTY_CYCLE_LIMIT\020\t\022\017\n\013BAD_REQU"
  "EST\020 \022\022\n\016NOT_AUTHORIZED\020!\022\016\n\nPKI_FAILED\020"
  "\"\022\026\n\022PKI_UNKNOWN_PUBKEY\020#\022\031\n\025ADMIN_BAD_S"
  "ESSION_KEY\020$\022!\n\035ADMIN_PUBLIC_KEY_UNAUTHO"
  "RIZED\020%\022\027\n\023RATE_LIMIT_EXCEEDED\020&B\t\n\007vari"
  "ant\"\313\001\n\004Data\022$\n\007portnum\030\001 \001(\0162\023.meshtast"
  "ic.PortNum\022\017\n\007payload\030\002 \001(\014\022\025\n\rwant_resp"
  "onse\030\003 \001(\010\022\014\n\004dest\030\004 \001(\007\022\016\n\006source\030\005 \001(\007"
  "\022\022\n\nrequest_id\030\006 \001(\007\022\020\n\010reply_id\030\007 \001(\007\022\r"
  "\n\005emoji\030\010 \001(\007\022\025\n\010bitfield\030\t \001(\rH\000\210\001\001B\013\n\t"
  "_bitfield\">\n\017KeyVerification\022\r\n\005nonce\030\001 "
  "\001(\004\022\r\n\005hash1\030\002 \001(\014\022\r\n\005hash2\030\003 \001(\014\"\274\001\n\010Wa"
  "ypoint\022\n\n\002id\030\001 \001(\r\022\027\n\nlatitude_i\030\002 \001(\017H\000"
  "\210\001\001\022\030\n\013longitude_i\030\003 \001(\017H\001\210\001\001\022\016\n\006expire\030"
  "\004 \001(\r\022\021\n\tlocked_to\030\005 \001(\r\022\014\n\004name\030\006 \001(\t\022\023"
  "\n\013description\030\007 \001(\t\022\014\n\004icon\030\010 \001(\007B\r\n\013_la"
  "titude_iB\016\n\014_longitude_i\"l\n\026MqttClientPr"
  "oxyMessage\022\r\n\005topic\030\001 \001(\t\022\016\n\004data\030\002 \001(\014H"
  "\000\022\016\n\004text\030\003 \001(\tH\000\022\020\n\010retained\030\004 \001(\010B\021\n\017p"
  "ayload_variant\"\265\007\n\nMeshPacket\022\014\n\004from\030\001 "
  "\001(\007\022\n\n\002to\030\002 \001(\007\022\017\n\007channel\030\003 \001(\r\022#\n\007deco"
  "ded\030\004 \001(\0132\020.meshtastic.DataH\000\022\023\n\tencrypt"
  "ed\030\005 \001(\014H\000\022\n\n\002id\030\006 \001(\007\022\017\n\007rx_time\030\007 \001(\007\022"
  "\016\n\006rx_snr\030\010 \001(\002\022\021\n\thop_limit\030\t \001(\r\022\020\n\010wa"
  "nt_ack\030\n \001(\010\0221\n\010priority\030\013 \001(\0162\037.meshtas"
  "tic.MeshPacket.Priority\022\017\n\007rx_rssi\030\014 \001(\005"
  "\0223\n\007delayed\030\r \001(\0162\036.meshtastic.MeshPacke"
  "t.DelayedB\002\030\001\022\020\n\010via_mqtt\030\016 \001(\010\022\021\n\thop_s"
  "tart\030\017 \001(\r\022\022\n\npublic_key\030\020 \001(\014\022\025\n\rpki_en"
  "crypted\030\021 \001(\010\022\020\n\010next_hop\030\022 \001(\r\022\022\n\nrelay"
  "_node\030\023 \001(\r\022\020\n\010tx_after\030\024 \001(\r\022F\n\023transpo"
  "rt_mechanism\030\025 \001(\0162).meshtastic.MeshPack"
  "et.TransportMechanism\"~\n\010Priority\022\t\n\005UNS"
  "ET\020\000\022\007\n\003MIN\020\001\022\016\n\nBACKGROUND\020\n\022\013\n\007DEFAULT"
  "\020@\022\014\n\010RELIABLE\020F\022\014\n\010RESPONSE\020P\022\010\n\004HIGH\020d"
  "\022\t\n\005ALERT\020n\022\007\n\003ACK\020x\022\007\n\003MAX\020\177\"B\n\007Delayed"
  "\022\014\n\010NO_DELAY\020\000\022\025\n\021DELAYED_BROADCAST\020\001\022\022\n"
  "\016DELAYED_DIRECT\020\002\"\317\001\n\022TransportMechanism"
  "\022\026\n\022TRANSPORT_INTERNAL\020\000\022\022\n\016TRANSPORT_LO"
  "RA\020\001\022\027\n\023TRANSPORT_LORA_ALT1\020\002\022\027\n\023TRANSPO"
  "RT_LORA_ALT2\020\003\022\027\n\023TRANSPORT_LORA_ALT3\020\004\022"
  "\022\n\016TRANSPORT_MQTT\020\005\022\033\n\027TRANSPORT_MULTICA"
  "ST_UDP\020\006\022\021\n\rTRANSPORT_API\020\007B\021\n\017payload_v"
  "ariant\"\307\002\n\010NodeInfo\022\013\n\003num\030\001 \001(\r\022\036\n\004user"
  "\030\002 \001(\0132\020.meshtastic.User\022&\n\010position\030\003 \001"
  "(\0132\024.meshtastic.Position\022\013\n\003snr\030\004 \001(\002\022\022\n"
  "\nlast_heard\030\005 \001(\007\0221\n\016device_metrics\030\006 \001("
  "\0132\031.meshtastic.DeviceMetrics\022\017\n\007channel\030"
  "\007 \001(\r\022\020\n\010via_mqtt\030\010 \001(\010\022\026\n\thops_away\030\t \001"
  "(\rH\000\210\001\001\022\023\n\013is_favorite\030\n \001(\010\022\022\n\nis_ignor"
  "ed\030\013 \001(\010\022 \n\030is_key_manually_verified\030\014 \001"
  "(\010B\014\n\n_hops_away\"\301\001\n\nMyNodeInfo\022\023\n\013my_no"
  "de_num\030\001 \001(\r\022\024\n\014reboot_count\030\010 \001(\r\022\027\n\017mi"
  "n_app_version\030\013 \001(\r\022\021\n\tdevice_id\030\014 \001(\014\022\017"
  "\n\007pio_env\030\r \001(\t\0225\n\020firmware_edition\030\016 \001("
  "\0162\033.meshtastic.FirmwareEdition\022\024\n\014nodedb"
  "_count\030\017 \001(\r\"\300\001\n\tLogRecord\022\017\n\007message\030\001 "
  "\001(\t\022\014\n\004time\030\002 \001(\007\022\016\n\006source\030\003 \001(\t\022*\n\005lev"
  "el\030\004 \001(\0162\033.meshtastic.LogRecord.Level\"X\n"
  "\005Level\022\t\n\005UNSET\020\000\022\014\n\010CRITICAL\0202\022\t\n\005ERROR"
  "\020(\022\013\n\007WARNING\020\036\022\010\n\004INFO\020\024\022\t\n\005DEBUG\020\n\022\t\n\005"
  "TRACE\020\005\"P\n\013QueueStatus\022\013\n\003res\030\001 \001(\005\022\014\n\004f"
  "ree\030\002 \001(\r\022\016\n\006maxlen\030\003 \001(\r\022\026\n\016mesh_packet"
  "_id\030\004 \001(\r\"\371\005\n\tFromRadio\022\n\n\002id\030\001 \001(\r\022(\n\006p"
  "acket\030\002 \001(\0132\026.meshtastic.MeshPacketH\000\022)\n"
  "\007my_info\030\003 \001(\0132\026.meshtastic.MyNodeInfoH\000"
  "\022)\n\tnode_info\030\004 \001(\0132\024.meshtastic.NodeInf"
  "oH\000\022$\n\006config\030\005 \001(\0132\022.meshtastic.ConfigH"
  "\000\022+\n\nlog_record\030\006 \001(\0132\025.meshtastic.LogRe"
  "cordH\000\022\034\n\022config_complete_id\030\007 \001(\rH\000\022\022\n\010"
  "rebooted\030\010 \001(\010H\000\0220\n\014moduleConfig\030\t \001(\0132\030"
  ".meshtastic.ModuleConfigH\000\022&\n\007channel\030\n "
  "\001(\0132\023.meshtastic.ChannelH\000\022.\n\013queueStatu"
  "s\030\013 \001(\0132\027.meshtastic.QueueStatusH\000\022*\n\014xm"
  "odemPacket\030\014 \001(\0132\022.meshtastic.XModemH\000\022."
  "\n\010metadata\030\r \001(\0132\032.meshtastic.DeviceMeta"
  "dataH\000\022D\n\026mqttClientProxyMessage\030\016 \001(\0132\""
  ".meshtastic.MqttClientProxyMessageH\000\022(\n\010"
  "fileInfo\030\017 \001(\0132\024.meshtastic.FileInfoH\000\022<"
  "\n\022clientNotification\030\020 \001(\0132\036.meshtastic."
  "ClientNotificationH\000\0224\n\016deviceuiConfig\030\021"
  " \001(\0132\032.meshtastic.DeviceUIConfigH\000B\021\n\017pa"
  "yload_variant\"\372\003\n\022ClientNotification\022\025\n\010"
  "reply_id\030\001 \001(\rH\001\210\001\001\022\014\n\004time\030\002 \001(\007\022*\n\005lev"
  "el\030\003 \001(\0162\033.meshtastic.LogRecord.Level\022\017\n"
  "\007message\030\004 \001(\t\022Q\n\036key_verification_numbe"
  "r_inform\030\013 \001(\0132\'.meshtastic.KeyVerificat"
  "ionNumberInformH\000\022S\n\037key_verification_nu"
  "mber_request\030\014 \001(\0132(.meshtastic.KeyVerif"
  "icationNumberRequestH\000\022B\n\026key_verificati"
  "on_final\030\r \001(\0132 .meshtastic.KeyVerificat"
  "ionFinalH\000\022@\n\025duplicated_public_key\030\016 \001("
  "\0132\037.meshtastic.DuplicatedPublicKeyH\000\0224\n\017"
  "low_entropy_key\030\017 \001(\0132\031.meshtastic.LowEn"
  "tropyKeyH\000B\021\n\017payload_variantB\013\n\t_reply_"
  "id\"^\n\033KeyVerificationNumberInform\022\r\n\005non"
  "ce\030\001 \001(\004\022\027\n\017remote_longname\030\002 \001(\t\022\027\n\017sec"
  "urity_number\030\003 \001(\r\"F\n\034KeyVerificationNum"
  "berRequest\022\r\n\005nonce\030\001 \001(\004\022\027\n\017remote_long"
  "name\030\002 \001(\t\"q\n\024KeyVerificationFinal\022\r\n\005no"
  "nce\030\001 \001(\004\022\027\n\017remote_longname\030\002 \001(\t\022\020\n\010is"
  "Sender\030\003 \001(\010\022\037\n\027verification_characters\030"
  "\004 \001(\t\"\025\n\023DuplicatedPublicKey\"\017\n\rLowEntro"
  "pyKey\"1\n\010FileInfo\022\021\n\tfile_name\030\001 \001(\t\022\022\n\n"
  "size_bytes\030\002 \001(\r\"\224\002\n\007ToRadio\022(\n\006packet\030\001"
  " \001(\0132\026.meshtastic.MeshPacketH\000\022\030\n\016want_c"
  "onfig_id\030\003 \001(\rH\000\022\024\n\ndisconnect\030\004 \001(\010H\000\022*"
  "\n\014xmodemPacket\030\005 \001(\0132\022.meshtastic.XModem"
  "H\000\022D\n\026mqttClientProxyMessage\030\006 \001(\0132\".mes"
  "htastic.MqttClientProxyMessageH\000\022*\n\thear"
  "tbeat\030\007 \001(\0132\025.meshtastic.HeartbeatH\000B\021\n\017"
  "payload_variant\"@\n\nCompressed\022$\n\007portnum"
  "\030\001 \001(\0162\023.meshtastic.PortNum\022\014\n\004data\030\002 \001("
  "\014\"\207\001\n\014NeighborInfo\022\017\n\007node_id\030\001 \001(\r\022\027\n\017l"
  "ast_sent_by_id\030\002 \001(\r\022$\n\034node_broadcast_i"
  "nterval_secs\030\003 \001(\r\022\'\n\tneighbors\030\004 \003(\0132\024."
  "meshtastic.Neighbor\"d\n\010Neighbor\022\017\n\007node_"
  "id\030\001 \001(\r\022\013\n\003snr\030\002 \001(\002\022\024\n\014last_rx_time\030\003 "
  "\001(\007\022$\n\034node_broadcast_interval_secs\030\004 \001("
  "\r\"\327\002\n\016DeviceMetadata\022\030\n\020firmware_version"
  "\030\001 \001(\t\022\034\n\024device_state_version\030\002 \001(\r\022\023\n\013"
  "canShutdown\030\003 \001(\010\022\017\n\007hasWifi\030\004 \001(\010\022\024\n\014ha"
  "sBluetooth\030\005 \001(\010\022\023\n\013hasEthernet\030\006 \001(\010\0222\n"
  "\004role\030\007 \001(\0162$.meshtastic.Config.DeviceCo"
  "nfig.Role\022\026\n\016position_flags\030\010 \001(\r\022+\n\010hw_"
  "model\030\t \001(\0162\031.meshtastic.HardwareModel\022\031"
  "\n\021hasRemoteHardware\030\n \001(\010\022\016\n\006hasPKC\030\013 \001("
  "\010\022\030\n\020excluded_modules\030\014 \001(\r\"\032\n\tHeartbeat"
  "\022\r\n\005nonce\030\001 \001(\r\"U\n\025NodeRemoteHardwarePin"
  "\022\020\n\010node_num\030\001 \001(\r\022*\n\003pin\030\002 \001(\0132\035.meshta"
  "stic.RemoteHardwarePin\"e\n\016ChunkedPayload"
  "\022\022\n\npayload_id\030\001 \001(\r\022\023\n\013chunk_count\030\002 \001("
  "\r\022\023\n\013chunk_index\030\003 \001(\r\022\025\n\rpayload_chunk\030"
  "\004 \001(\014\"\037\n\rresend_chunks\022\016\n\006chunks\030\001 \003(\r\"\252"
  "\001\n\026ChunkedPayloadResponse\022\022\n\npayload_id\030"
  "\001 \001(\r\022\032\n\020request_transfer\030\002 \001(\010H\000\022\031\n\017acc"
  "ept_transfer\030\003 \001(\010H\000\0222\n\rresend_chunks\030\004 "
  "\001(\0132\031.meshtastic.resend_chunksH\000B\021\n\017payl"
  "oad_variant*\346\020\n\rHardwareModel\022\t\n\005UNSET\020\000"
  "\022\014\n\010TLORA_V2\020\001\022\014\n\010TLORA_V1\020\002\022\022\n\016TLORA_V2"
  "_1_1P6\020\003\022\t\n\005TBEAM\020\004\022\017\n\013HELTEC_V2_0\020\005\022\016\n\n"
  "TBEAM_V0P7\020\006\022\n\n\006T_ECHO\020\007\022\020\n\014TLORA_V1_1P3"
  "\020\010\022\013\n\007RAK4631\020\t\022\017\n\013HELTEC_V2_1\020\n\022\r\n\tHELT"
  "EC_V1\020\013\022\030\n\024LILYGO_TBEAM_S3_CORE\020\014\022\014\n\010RAK"
  "11200\020\r\022\013\n\007NANO_G1\020\016\022\022\n\016TLORA_V2_1_1P8\020\017"
  "\022\017\n\013TLORA_T3_S3\020\020\022\024\n\020NANO_G1_EXPLORER\020\021\022"
  "\021\n\rNANO_G2_ULTRA\020\022\022\r\n\tLORA_TYPE\020\023\022\013\n\007WIP"
  "HONE\020\024\022\016\n\nWIO_WM1110\020\025\022\013\n\007RAK2560\020\026\022\023\n\017H"
  "ELTEC_HRU_3601\020\027\022\032\n\026HELTEC_WIRELESS_BRID"
  "GE\020\030\022\016\n\nSTATION_G1\020\031\022\014\n\010RAK11310\020\032\022\024\n\020SE"
  "NSELORA_RP2040\020\033\022\020\n\014SENSELORA_S3\020\034\022\r\n\tCA"
  "NARYONE\020\035\022\017\n\013RP2040_LORA\020\036\022\016\n\nSTATION_G2"
  "\020\037\022\021\n\rLORA_RELAY_V1\020 \022\016\n\nNRF52840DK\020!\022\007\n"
  "\003PPR\020\"\022\017\n\013GENIEBLOCKS\020#\022\021\n\rNRF52_UNKNOWN"
  "\020$\022\r\n\tPORTDUINO\020%\022\017\n\013ANDROID_SIM\020&\022\n\n\006DI"
  "Y_V1\020\'\022\025\n\021NRF52840_PCA10059\020(\022\n\n\006DR_DEV\020"
  ")\022\013\n\007M5STACK\020*\022\r\n\tHELTEC_V3\020+\022\021\n\rHELTEC_"
  "WSL_V3\020,\022\023\n\017BETAFPV_2400_TX\020-\022\027\n\023BETAFPV"
  "_900_NANO_TX\020.\022\014\n\010RPI_PICO\020/\022\033\n\027HELTEC_W"
  "IRELESS_TRACKER\0200\022\031\n\025HELTEC_WIRELESS_PAP"
  "ER\0201\022\n\n\006T_DECK\0202\022\016\n\nT_WATCH_S3\0203\022\021\n\rPICO"
  "MPUTER_S3\0204\022\017\n\013HELTEC_HT62\0205\022\022\n\016EBYTE_ES"
  "P32_S3\0206\022\021\n\rESP32_S3_PICO\0207\022\r\n\tCHATTER_2"
  "\0208\022\036\n\032HELTEC_WIRELESS_PAPER_V1_0\0209\022 \n\034HE"
  "LTEC_WIRELESS_TRACKER_V1_0\020:\022\013\n\007UNPHONE\020"
  ";\022\014\n\010TD_LORAC\020<\022\023\n\017CDEBYTE_EORA_S3\020=\022\017\n\013"
  "TWC_MESH_V4\020>\022\026\n\022NRF52_PROMICRO_DIY\020\?\022\037\n"
  "\033RADIOMASTER_900_BANDIT_NANO\020@\022\034\n\030HELTEC"
  "_CAPSULE_SENSOR_V3\020A\022\035\n\031HELTEC_VISION_MA"
  "STER_T190\020B\022\035\n\031HELTEC_VISION_MASTER_E213"
  "\020C\022\035\n\031HELTEC_VISION_MASTER_E290\020D\022\031\n\025HEL"
  "TEC_MESH_NODE_T114\020E\022\026\n\022SENSECAP_INDICAT"
  "OR\020F\022\023\n\017TRACKER_T1000_E\020G\022\013\n\007RAK3172\020H\022\n"
  "\n\006WIO_E5\020I\022\032\n\026RADIOMASTER_900_BANDIT\020J\022\023"
  "\n\017ME25LS01_4Y10TD\020K\022\030\n\024RP2040_FEATHER_RF"
  "M95\020L\022\025\n\021M5STACK_COREBASIC\020M\022\021\n\rM5STACK_"
  "CORE2\020N\022\r\n\tRPI_PICO2\020O\022\022\n\016M5STACK_CORES3"
  "\020P\022\021\n\rSEEED_XIAO_S3\020Q\022\013\n\007MS24SF1\020R\022\014\n\010TL"
  "ORA_C6\020S\022\017\n\013WISMESH_TAP\020T\022\r\n\tROUTASTIC\020U"
  "\022\014\n\010MESH_TAB\020V\022\014\n\010MESHLINK\020W\022\022\n\016XIAO_NRF"
  "52_KIT\020X\022\020\n\014THINKNODE_M1\020Y\022\020\n\014THINKNODE_"
  "M2\020Z\022\017\n\013T_ETH_ELITE\020[\022\025\n\021HELTEC_SENSOR_H"
  "UB\020\\\022\032\n\026RESERVED_FRIED_CHICKEN\020]\022\026\n\022HELT"
  "EC_MESH_POCKET\020^\022\024\n\020SEEED_SOLAR_NODE\020_\022\030"
  "\n\024NOMADSTAR_METEOR_PRO\020`\022\r\n\tCROWPANEL\020a\022"
  "\013\n\007LINK_32\020b\022\030\n\024SEEED_WIO_TRACKER_L1\020c\022\035"
  "\n\031SEEED_WIO_TRACKER_L1_EINK\020d\022\024\n\020QWANTZ_"
  "TINY_ARMS\020e\022\016\n\nT_DECK_PRO\020f\022\020\n\014T_LORA_PA"
  "GER\020g\022\024\n\020M5STACK_RESERVED\020h\022\017\n\013WISMESH_T"
  "AG\020i\022\013\n\007RAK3312\020j\022\020\n\014THINKNODE_M5\020k\022\025\n\021H"
  "ELTEC_MESH_SOLAR\020l\022\017\n\013T_ECHO_LITE\020m\022\r\n\tH"
  "ELTEC_V4\020n\022\017\n\013M5STACK_C6L\020o\022\017\n\nPRIVATE_H"
  "W\020\377\001*,\n\tConstants\022\010\n\004ZERO\020\000\022\025\n\020DATA_PAYL"
  "OAD_LEN\020\351\001*\264\002\n\021CriticalErrorCode\022\010\n\004NONE"
  "\020\000\022\017\n\013TX_WATCHDOG\020\001\022\024\n\020SLEEP_ENTER_WAIT\020"
  "\002\022\014\n\010NO_RADIO\020\003\022\017\n\013UNSPECIFIED\020\004\022\025\n\021UBLO"
  "X_UNIT_FAILED\020\005\022\r\n\tNO_AXP192\020\006\022\031\n\025INVALI"
  "D_RADIO_SETTING\020\007\022\023\n\017TRANSMIT_FAILED\020\010\022\014"
  "\n\010BROWNOUT\020\t\022\022\n\016SX1262_FAILURE\020\n\022\021\n\rRADI"
  "O_SPI_BUG\020\013\022 \n\034FLASH_CORRUPTION_RECOVERA"
  "BLE\020\014\022\"\n\036FLASH_CORRUPTION_UNRECOVERABLE\020"
  "\r*\177\n\017FirmwareEdition\022\013\n\007VANILLA\020\000\022\021\n\rSMA"
  "RT_CITIZEN\020\001\022\016\n\nOPEN_SAUCE\020\020\022\n\n\006DEFCON\020\021"
  "\022\017\n\013BURNING_MAN\020\022\022\016\n\nHAMVENTION\020\023\022\017\n\013DIY"
  "_EDITION\020\177*\200\003\n\017ExcludedModules\022\021\n\rEXCLUD"
  "ED_NONE\020\000\022\017\n\013MQTT_CONFIG\020\001\022\021\n\rSERIAL_CON"
  "FIG\020\002\022\023\n\017EXTNOTIF_CONFIG\020\004\022\027\n\023STOREFORWA"
  "RD_CONFIG\020\010\022\024\n\020RANGETEST_CONFIG\020\020\022\024\n\020TEL"
  "EMETRY_CONFIG\020 \022\024\n\020CANNEDMSG_CONFIG\020@\022\021\n"
  "\014AUDIO_CONFIG\020\200\001\022\032\n\025REMOTEHARDWARE_CONFI"
  "G\020\200\002\022\030\n\023NEIGHBORINFO_CONFIG\020\200\004\022\033\n\026AMBIEN"
  "TLIGHTING_CONFIG\020\200\010\022\033\n\026DETECTIONSENSOR_C"
  "ONFIG\020\200\020\022\026\n\021PAXCOUNTER_CONFIG\020\200 \022\025\n\020BLUE"
  "TOOTH_CONFIG\020\200@\022\024\n\016NETWORK_CONFIG\020\200\200\001B_\n"
  "\023com.geeksville.meshB\nMeshProtosZ\"github"
  ".com/meshtastic/go/generated\252\002\024Meshtasti"
  "c.Protobufs\272\002\000b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_meshtastic_2fmesh_2eproto_deps[7] = {
  &::descriptor_table_meshtastic_2fchannel_2eproto,
  &::descriptor_table_meshtastic_2fconfig_2eproto,
  &::descriptor_table_meshtastic_2fdevice_5fui_2eproto,
  &::descriptor_table_meshtastic_2fmodule_5fconfig_2eproto,
  &::descriptor_table_meshtastic_2fportnums_2eproto,
  &::descriptor_table_meshtastic_2ftelemetry_2eproto,
  &::descriptor_table_meshtastic_2fxmodem_2eproto,
};
static ::_pbi::once_flag descriptor_table_meshtastic_2fmesh_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_meshtastic_2fmesh_2eproto = {
    false, false, 10462, descriptor_table_protodef_meshtastic_2fmesh_2eproto,
    "meshtastic/mesh.proto",
    &descriptor_table_meshtastic_2fmesh_2eproto_once, descriptor_table_meshtastic_2fmesh_2eproto_deps, 7, 31,
    schemas, file_default_instances, TableStruct_meshtastic_2fmesh_2eproto::offsets,
    file_level_metadata_meshtastic_2fmesh_2eproto, file_level_enum_descriptors_meshtastic_2fmesh_2eproto,
    file_level_service_descriptors_meshtastic_2fmesh_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_meshtastic_2fmesh_2eproto_getter() {
  return &descriptor_table_meshtastic_2fmesh_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_meshtastic_2fmesh_2eproto(&descriptor_table_meshtastic_2fmesh_2eproto);
namespace meshtastic {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Position_LocSource_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[0];
}
bool Position_LocSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Position_LocSource Position::LOC_UNSET;
constexpr Position_LocSource Position::LOC_MANUAL;
constexpr Position_LocSource Position::LOC_INTERNAL;
constexpr Position_LocSource Position::LOC_EXTERNAL;
constexpr Position_LocSource Position::LocSource_MIN;
constexpr Position_LocSource Position::LocSource_MAX;
constexpr int Position::LocSource_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Position_AltSource_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[1];
}
bool Position_AltSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Position_AltSource Position::ALT_UNSET;
constexpr Position_AltSource Position::ALT_MANUAL;
constexpr Position_AltSource Position::ALT_INTERNAL;
constexpr Position_AltSource Position::ALT_EXTERNAL;
constexpr Position_AltSource Position::ALT_BAROMETRIC;
constexpr Position_AltSource Position::AltSource_MIN;
constexpr Position_AltSource Position::AltSource_MAX;
constexpr int Position::AltSource_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Routing_Error_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[2];
}
bool Routing_Error_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Routing_Error Routing::NONE;
constexpr Routing_Error Routing::NO_ROUTE;
constexpr Routing_Error Routing::GOT_NAK;
constexpr Routing_Error Routing::TIMEOUT;
constexpr Routing_Error Routing::NO_INTERFACE;
constexpr Routing_Error Routing::MAX_RETRANSMIT;
constexpr Routing_Error Routing::NO_CHANNEL;
constexpr Routing_Error Routing::TOO_LARGE;
constexpr Routing_Error Routing::NO_RESPONSE;
constexpr Routing_Error Routing::DUTY_CYCLE_LIMIT;
constexpr Routing_Error Routing::BAD_REQUEST;
constexpr Routing_Error Routing::NOT_AUTHORIZED;
constexpr Routing_Error Routing::PKI_FAILED;
constexpr Routing_Error Routing::PKI_UNKNOWN_PUBKEY;
constexpr Routing_Error Routing::ADMIN_BAD_SESSION_KEY;
constexpr Routing_Error Routing::ADMIN_PUBLIC_KEY_UNAUTHORIZED;
constexpr Routing_Error Routing::RATE_LIMIT_EXCEEDED;
constexpr Routing_Error Routing::Error_MIN;
constexpr Routing_Error Routing::Error_MAX;
constexpr int Routing::Error_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MeshPacket_Priority_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[3];
}
bool MeshPacket_Priority_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 10:
    case 64:
    case 70:
    case 80:
    case 100:
    case 110:
    case 120:
    case 127:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MeshPacket_Priority MeshPacket::UNSET;
constexpr MeshPacket_Priority MeshPacket::MIN;
constexpr MeshPacket_Priority MeshPacket::BACKGROUND;
constexpr MeshPacket_Priority MeshPacket::DEFAULT;
constexpr MeshPacket_Priority MeshPacket::RELIABLE;
constexpr MeshPacket_Priority MeshPacket::RESPONSE;
constexpr MeshPacket_Priority MeshPacket::HIGH;
constexpr MeshPacket_Priority MeshPacket::ALERT;
constexpr MeshPacket_Priority MeshPacket::ACK;
constexpr MeshPacket_Priority MeshPacket::MAX;
constexpr MeshPacket_Priority MeshPacket::Priority_MIN;
constexpr MeshPacket_Priority MeshPacket::Priority_MAX;
constexpr int MeshPacket::Priority_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MeshPacket_Delayed_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[4];
}
bool MeshPacket_Delayed_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MeshPacket_Delayed MeshPacket::NO_DELAY;
constexpr MeshPacket_Delayed MeshPacket::DELAYED_BROADCAST;
constexpr MeshPacket_Delayed MeshPacket::DELAYED_DIRECT;
constexpr MeshPacket_Delayed MeshPacket::Delayed_MIN;
constexpr MeshPacket_Delayed MeshPacket::Delayed_MAX;
constexpr int MeshPacket::Delayed_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MeshPacket_TransportMechanism_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[5];
}
bool MeshPacket_TransportMechanism_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MeshPacket_TransportMechanism MeshPacket::TRANSPORT_INTERNAL;
constexpr MeshPacket_TransportMechanism MeshPacket::TRANSPORT_LORA;
constexpr MeshPacket_TransportMechanism MeshPacket::TRANSPORT_LORA_ALT1;
constexpr MeshPacket_TransportMechanism MeshPacket::TRANSPORT_LORA_ALT2;
constexpr MeshPacket_TransportMechanism MeshPacket::TRANSPORT_LORA_ALT3;
constexpr MeshPacket_TransportMechanism MeshPacket::TRANSPORT_MQTT;
constexpr MeshPacket_TransportMechanism MeshPacket::TRANSPORT_MULTICAST_UDP;
constexpr MeshPacket_TransportMechanism MeshPacket::TRANSPORT_API;
constexpr MeshPacket_TransportMechanism MeshPacket::TransportMechanism_MIN;
constexpr MeshPacket_TransportMechanism MeshPacket::TransportMechanism_MAX;
constexpr int MeshPacket::TransportMechanism_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogRecord_Level_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[6];
}
bool LogRecord_Level_IsValid(int value) {
  switch (value) {
    case 0:
    case 5:
    case 10:
    case 20:
    case 30:
    case 40:
    case 50:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LogRecord_Level LogRecord::UNSET;
constexpr LogRecord_Level LogRecord::CRITICAL;
constexpr LogRecord_Level LogRecord::ERROR;
constexpr LogRecord_Level LogRecord::WARNING;
constexpr LogRecord_Level LogRecord::INFO;
constexpr LogRecord_Level LogRecord::DEBUG;
constexpr LogRecord_Level LogRecord::TRACE;
constexpr LogRecord_Level LogRecord::Level_MIN;
constexpr LogRecord_Level LogRecord::Level_MAX;
constexpr int LogRecord::Level_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HardwareModel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[7];
}
bool HardwareModel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 255:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Constants_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[8];
}
bool Constants_IsValid(int value) {
  switch (value) {
    case 0:
    case 233:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CriticalErrorCode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[9];
}
bool CriticalErrorCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FirmwareEdition_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[10];
}
bool FirmwareEdition_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 16:
    case 17:
    case 18:
    case 19:
    case 127:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExcludedModules_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[11];
}
bool ExcludedModules_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Position::_Internal {
 public:
  using HasBits = decltype(std::declval<Position>()._impl_._has_bits_);
  static void set_has_latitude_i(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_longitude_i(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_altitude(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_altitude_hae(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_altitude_geoidal_separation(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ground_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ground_track(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Position::Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Position)
}
Position::Position(const Position& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Position* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latitude_i_){}
    , decltype(_impl_.longitude_i_){}
    , decltype(_impl_.altitude_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.location_source_){}
    , decltype(_impl_.altitude_source_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.timestamp_millis_adjust_){}
    , decltype(_impl_.altitude_hae_){}
    , decltype(_impl_.altitude_geoidal_separation_){}
    , decltype(_impl_.pdop_){}
    , decltype(_impl_.hdop_){}
    , decltype(_impl_.vdop_){}
    , decltype(_impl_.gps_accuracy_){}
    , decltype(_impl_.ground_speed_){}
    , decltype(_impl_.ground_track_){}
    , decltype(_impl_.fix_quality_){}
    , decltype(_impl_.fix_type_){}
    , decltype(_impl_.sats_in_view_){}
    , decltype(_impl_.sensor_id_){}
    , decltype(_impl_.next_update_){}
    , decltype(_impl_.seq_number_){}
    , decltype(_impl_.precision_bits_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.latitude_i_, &from._impl_.latitude_i_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.precision_bits_) -
    reinterpret_cast<char*>(&_impl_.latitude_i_)) + sizeof(_impl_.precision_bits_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.Position)
}

inline void Position::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latitude_i_){0}
    , decltype(_impl_.longitude_i_){0}
    , decltype(_impl_.altitude_){0}
    , decltype(_impl_.time_){0u}
    , decltype(_impl_.location_source_){0}
    , decltype(_impl_.altitude_source_){0}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.timestamp_millis_adjust_){0}
    , decltype(_impl_.altitude_hae_){0}
    , decltype(_impl_.altitude_geoidal_separation_){0}
    , decltype(_impl_.pdop_){0u}
    , decltype(_impl_.hdop_){0u}
    , decltype(_impl_.vdop_){0u}
    , decltype(_impl_.gps_accuracy_){0u}
    , decltype(_impl_.ground_speed_){0u}
    , decltype(_impl_.ground_track_){0u}
    , decltype(_impl_.fix_quality_){0u}
    , decltype(_impl_.fix_type_){0u}
    , decltype(_impl_.sats_in_view_){0u}
    , decltype(_impl_.sensor_id_){0u}
    , decltype(_impl_.next_update_){0u}
    , decltype(_impl_.seq_number_){0u}
    , decltype(_impl_.precision_bits_){0u}
  };
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:meshtastic.Position)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Position::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Position::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Position::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Position)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.latitude_i_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.altitude_) -
        reinterpret_cast<char*>(&_impl_.latitude_i_)) + sizeof(_impl_.altitude_));
  }
  ::memset(&_impl_.time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.timestamp_millis_adjust_) -
      reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.timestamp_millis_adjust_));
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.altitude_hae_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.altitude_geoidal_separation_) -
        reinterpret_cast<char*>(&_impl_.altitude_hae_)) + sizeof(_impl_.altitude_geoidal_separation_));
  }
  ::memset(&_impl_.pdop_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.gps_accuracy_) -
      reinterpret_cast<char*>(&_impl_.pdop_)) + sizeof(_impl_.gps_accuracy_));
  if (cached_has_bits & 0x00000060u) {
    ::memset(&_impl_.ground_speed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ground_track_) -
        reinterpret_cast<char*>(&_impl_.ground_speed_)) + sizeof(_impl_.ground_track_));
  }
  ::memset(&_impl_.fix_quality_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.precision_bits_) -
      reinterpret_cast<char*>(&_impl_.fix_quality_)) + sizeof(_impl_.precision_bits_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Position::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sfixed32 latitude_i = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_latitude_i(&has_bits);
          _impl_.latitude_i_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int32_t>(ptr);
          ptr += sizeof(int32_t);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed32 longitude_i = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_longitude_i(&has_bits);
          _impl_.longitude_i_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int32_t>(ptr);
          ptr += sizeof(int32_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 altitude = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_altitude(&has_bits);
          _impl_.altitude_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // fixed32 time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.Position.LocSource location_source = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_location_source(static_cast<::meshtastic::Position_LocSource>(val));
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.Position.AltSource altitude_source = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_altitude_source(static_cast<::meshtastic::Position_AltSource>(val));
        } else
          goto handle_unusual;
        continue;
      // fixed32 timestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // int32 timestamp_millis_adjust = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.timestamp_millis_adjust_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 altitude_hae = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_altitude_hae(&has_bits);
          _impl_.altitude_hae_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 altitude_geoidal_separation = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_altitude_geoidal_separation(&has_bits);
          _impl_.altitude_geoidal_separation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 PDOP = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.pdop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 HDOP = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.hdop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 VDOP = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.vdop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 gps_accuracy = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.gps_accuracy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ground_speed = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_ground_speed(&has_bits);
          _impl_.ground_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ground_track = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_ground_track(&has_bits);
          _impl_.ground_track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 fix_quality = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _impl_.fix_quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 fix_type = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _impl_.fix_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sats_in_view = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.sats_in_view_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sensor_id = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _impl_.sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 next_update = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _impl_.next_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 seq_number = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _impl_.seq_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 precision_bits = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _impl_.precision_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Position::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Position)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional sfixed32 latitude_i = 1;
  if (_internal_has_latitude_i()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(1, this->_internal_latitude_i(), target);
  }

  // optional sfixed32 longitude_i = 2;
  if (_internal_has_longitude_i()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(2, this->_internal_longitude_i(), target);
  }

  // optional int32 altitude = 3;
  if (_internal_has_altitude()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_altitude(), target);
  }

  // fixed32 time = 4;
  if (this->_internal_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_time(), target);
  }

  // .meshtastic.Position.LocSource location_source = 5;
  if (this->_internal_location_source() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_location_source(), target);
  }

  // .meshtastic.Position.AltSource altitude_source = 6;
  if (this->_internal_altitude_source() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_altitude_source(), target);
  }

  // fixed32 timestamp = 7;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_timestamp(), target);
  }

  // int32 timestamp_millis_adjust = 8;
  if (this->_internal_timestamp_millis_adjust() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_timestamp_millis_adjust(), target);
  }

  // optional sint32 altitude_hae = 9;
  if (_internal_has_altitude_hae()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(9, this->_internal_altitude_hae(), target);
  }

  // optional sint32 altitude_geoidal_separation = 10;
  if (_internal_has_altitude_geoidal_separation()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(10, this->_internal_altitude_geoidal_separation(), target);
  }

  // uint32 PDOP = 11;
  if (this->_internal_pdop() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_pdop(), target);
  }

  // uint32 HDOP = 12;
  if (this->_internal_hdop() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_hdop(), target);
  }

  // uint32 VDOP = 13;
  if (this->_internal_vdop() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_vdop(), target);
  }

  // uint32 gps_accuracy = 14;
  if (this->_internal_gps_accuracy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_gps_accuracy(), target);
  }

  // optional uint32 ground_speed = 15;
  if (_internal_has_ground_speed()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_ground_speed(), target);
  }

  // optional uint32 ground_track = 16;
  if (_internal_has_ground_track()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_ground_track(), target);
  }

  // uint32 fix_quality = 17;
  if (this->_internal_fix_quality() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_fix_quality(), target);
  }

  // uint32 fix_type = 18;
  if (this->_internal_fix_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_fix_type(), target);
  }

  // uint32 sats_in_view = 19;
  if (this->_internal_sats_in_view() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_sats_in_view(), target);
  }

  // uint32 sensor_id = 20;
  if (this->_internal_sensor_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_sensor_id(), target);
  }

  // uint32 next_update = 21;
  if (this->_internal_next_update() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_next_update(), target);
  }

  // uint32 seq_number = 22;
  if (this->_internal_seq_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_seq_number(), target);
  }

  // uint32 precision_bits = 23;
  if (this->_internal_precision_bits() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_precision_bits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Position)
  return target;
}

size_t Position::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.Position)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional sfixed32 latitude_i = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 longitude_i = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional int32 altitude = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_altitude());
    }

  }
  // fixed32 time = 4;
  if (this->_internal_time() != 0) {
    total_size += 1 + 4;
  }

  // .meshtastic.Position.LocSource location_source = 5;
  if (this->_internal_location_source() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_location_source());
  }

  // .meshtastic.Position.AltSource altitude_source = 6;
  if (this->_internal_altitude_source() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_altitude_source());
  }

  // fixed32 timestamp = 7;
  if (this->_internal_timestamp() != 0) {
    total_size += 1 + 4;
  }

  // int32 timestamp_millis_adjust = 8;
  if (this->_internal_timestamp_millis_adjust() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timestamp_millis_adjust());
  }

  if (cached_has_bits & 0x00000018u) {
    // optional sint32 altitude_hae = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_altitude_hae());
    }

    // optional sint32 altitude_geoidal_separation = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_altitude_geoidal_separation());
    }

  }
  // uint32 PDOP = 11;
  if (this->_internal_pdop() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pdop());
  }

  // uint32 HDOP = 12;
  if (this->_internal_hdop() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hdop());
  }

  // uint32 VDOP = 13;
  if (this->_internal_vdop() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vdop());
  }

  // uint32 gps_accuracy = 14;
  if (this->_internal_gps_accuracy() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gps_accuracy());
  }

  if (cached_has_bits & 0x00000060u) {
    // optional uint32 ground_speed = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ground_speed());
    }

    // optional uint32 ground_track = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_ground_track());
    }

  }
  // uint32 fix_quality = 17;
  if (this->_internal_fix_quality() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_fix_quality());
  }

  // uint32 fix_type = 18;
  if (this->_internal_fix_type() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_fix_type());
  }

  // uint32 sats_in_view = 19;
  if (this->_internal_sats_in_view() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_sats_in_view());
  }

  // uint32 sensor_id = 20;
  if (this->_internal_sensor_id() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_sensor_id());
  }

  // uint32 next_update = 21;
  if (this->_internal_next_update() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_next_update());
  }

  // uint32 seq_number = 22;
  if (this->_internal_seq_number() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_seq_number());
  }

  // uint32 precision_bits = 23;
  if (this->_internal_precision_bits() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_precision_bits());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Position::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Position::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Position::GetClassData() const { return &_class_data_; }


void Position::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Position*>(&to_msg);
  auto& from = static_cast<const Position&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Position)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.latitude_i_ = from._impl_.latitude_i_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.longitude_i_ = from._impl_.longitude_i_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.altitude_ = from._impl_.altitude_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_time() != 0) {
    _this->_internal_set_time(from._internal_time());
  }
  if (from._internal_location_source() != 0) {
    _this->_internal_set_location_source(from._internal_location_source());
  }
  if (from._internal_altitude_source() != 0) {
    _this->_internal_set_altitude_source(from._internal_altitude_source());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (from._internal_timestamp_millis_adjust() != 0) {
    _this->_internal_set_timestamp_millis_adjust(from._internal_timestamp_millis_adjust());
  }
  if (cached_has_bits & 0x00000018u) {
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.altitude_hae_ = from._impl_.altitude_hae_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.altitude_geoidal_separation_ = from._impl_.altitude_geoidal_separation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_pdop() != 0) {
    _this->_internal_set_pdop(from._internal_pdop());
  }
  if (from._internal_hdop() != 0) {
    _this->_internal_set_hdop(from._internal_hdop());
  }
  if (from._internal_vdop() != 0) {
    _this->_internal_set_vdop(from._internal_vdop());
  }
  if (from._internal_gps_accuracy() != 0) {
    _this->_internal_set_gps_accuracy(from._internal_gps_accuracy());
  }
  if (cached_has_bits & 0x00000060u) {
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ground_speed_ = from._impl_.ground_speed_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ground_track_ = from._impl_.ground_track_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_fix_quality() != 0) {
    _this->_internal_set_fix_quality(from._internal_fix_quality());
  }
  if (from._internal_fix_type() != 0) {
    _this->_internal_set_fix_type(from._internal_fix_type());
  }
  if (from._internal_sats_in_view() != 0) {
    _this->_internal_set_sats_in_view(from._internal_sats_in_view());
  }
  if (from._internal_sensor_id() != 0) {
    _this->_internal_set_sensor_id(from._internal_sensor_id());
  }
  if (from._internal_next_update() != 0) {
    _this->_internal_set_next_update(from._internal_next_update());
  }
  if (from._internal_seq_number() != 0) {
    _this->_internal_set_seq_number(from._internal_seq_number());
  }
  if (from._internal_precision_bits() != 0) {
    _this->_internal_set_precision_bits(from._internal_precision_bits());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Position::CopyFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  return true;
}

void Position::InternalSwap(Position* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Position, _impl_.precision_bits_)
      + sizeof(Position::_impl_.precision_bits_)
      - PROTOBUF_FIELD_OFFSET(Position, _impl_.latitude_i_)>(
          reinterpret_cast<char*>(&_impl_.latitude_i_),
          reinterpret_cast<char*>(&other->_impl_.latitude_i_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Position::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[0]);
}

// ===================================================================

class User::_Internal {
 public:
  using HasBits = decltype(std::declval<User>()._impl_._has_bits_);
  static void set_has_is_unmessagable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

User::User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.User)
}
User::User(const User& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  User* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.long_name_){}
    , decltype(_impl_.short_name_){}
    , decltype(_impl_.macaddr_){}
    , decltype(_impl_.public_key_){}
    , decltype(_impl_.hw_model_){}
    , decltype(_impl_.role_){}
    , decltype(_impl_.is_licensed_){}
    , decltype(_impl_.is_unmessagable_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.long_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.long_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_long_name().empty()) {
    _this->_impl_.long_name_.Set(from._internal_long_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.short_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.short_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_short_name().empty()) {
    _this->_impl_.short_name_.Set(from._internal_short_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.macaddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.macaddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_macaddr().empty()) {
    _this->_impl_.macaddr_.Set(from._internal_macaddr(), 
      _this->GetArenaForAllocation());
  }
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_public_key().empty()) {
    _this->_impl_.public_key_.Set(from._internal_public_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.hw_model_, &from._impl_.hw_model_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_unmessagable_) -
    reinterpret_cast<char*>(&_impl_.hw_model_)) + sizeof(_impl_.is_unmessagable_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.User)
}

inline void User::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.long_name_){}
    , decltype(_impl_.short_name_){}
    , decltype(_impl_.macaddr_){}
    , decltype(_impl_.public_key_){}
    , decltype(_impl_.hw_model_){0}
    , decltype(_impl_.role_){0}
    , decltype(_impl_.is_licensed_){false}
    , decltype(_impl_.is_unmessagable_){false}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.long_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.long_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.short_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.short_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.macaddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.macaddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

User::~User() {
  // @@protoc_insertion_point(destructor:meshtastic.User)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void User::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.long_name_.Destroy();
  _impl_.short_name_.Destroy();
  _impl_.macaddr_.Destroy();
  _impl_.public_key_.Destroy();
}

void User::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void User::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.User)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  _impl_.long_name_.ClearToEmpty();
  _impl_.short_name_.ClearToEmpty();
  _impl_.macaddr_.ClearToEmpty();
  _impl_.public_key_.ClearToEmpty();
  ::memset(&_impl_.hw_model_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_licensed_) -
      reinterpret_cast<char*>(&_impl_.hw_model_)) + sizeof(_impl_.is_licensed_));
  _impl_.is_unmessagable_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* User::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.User.id"));
        } else
          goto handle_unusual;
        continue;
      // string long_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_long_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.User.long_name"));
        } else
          goto handle_unusual;
        continue;
      // string short_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_short_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.User.short_name"));
        } else
          goto handle_unusual;
        continue;
      // bytes macaddr = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_macaddr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.HardwareModel hw_model = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hw_model(static_cast<::meshtastic::HardwareModel>(val));
        } else
          goto handle_unusual;
        continue;
      // bool is_licensed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.is_licensed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.Config.DeviceConfig.Role role = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_role(static_cast<::meshtastic::Config_DeviceConfig_Role>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes public_key = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_unmessagable = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_unmessagable(&has_bits);
          _impl_.is_unmessagable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* User::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.User)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.User.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // string long_name = 2;
  if (!this->_internal_long_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_long_name().data(), static_cast<int>(this->_internal_long_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.User.long_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_long_name(), target);
  }

  // string short_name = 3;
  if (!this->_internal_short_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_short_name().data(), static_cast<int>(this->_internal_short_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.User.short_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_short_name(), target);
  }

  // bytes macaddr = 4 [deprecated = true];
  if (!this->_internal_macaddr().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_macaddr(), target);
  }

  // .meshtastic.HardwareModel hw_model = 5;
  if (this->_internal_hw_model() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_hw_model(), target);
  }

  // bool is_licensed = 6;
  if (this->_internal_is_licensed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_licensed(), target);
  }

  // .meshtastic.Config.DeviceConfig.Role role = 7;
  if (this->_internal_role() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_role(), target);
  }

  // bytes public_key = 8;
  if (!this->_internal_public_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_public_key(), target);
  }

  // optional bool is_unmessagable = 9;
  if (_internal_has_is_unmessagable()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_unmessagable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.User)
  return target;
}

size_t User::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.User)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string long_name = 2;
  if (!this->_internal_long_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_long_name());
  }

  // string short_name = 3;
  if (!this->_internal_short_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_short_name());
  }

  // bytes macaddr = 4 [deprecated = true];
  if (!this->_internal_macaddr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_macaddr());
  }

  // bytes public_key = 8;
  if (!this->_internal_public_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_public_key());
  }

  // .meshtastic.HardwareModel hw_model = 5;
  if (this->_internal_hw_model() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_hw_model());
  }

  // .meshtastic.Config.DeviceConfig.Role role = 7;
  if (this->_internal_role() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_role());
  }

  // bool is_licensed = 6;
  if (this->_internal_is_licensed() != 0) {
    total_size += 1 + 1;
  }

  // optional bool is_unmessagable = 9;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData User::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    User::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*User::GetClassData() const { return &_class_data_; }


void User::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<User*>(&to_msg);
  auto& from = static_cast<const User&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.User)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_long_name().empty()) {
    _this->_internal_set_long_name(from._internal_long_name());
  }
  if (!from._internal_short_name().empty()) {
    _this->_internal_set_short_name(from._internal_short_name());
  }
  if (!from._internal_macaddr().empty()) {
    _this->_internal_set_macaddr(from._internal_macaddr());
  }
  if (!from._internal_public_key().empty()) {
    _this->_internal_set_public_key(from._internal_public_key());
  }
  if (from._internal_hw_model() != 0) {
    _this->_internal_set_hw_model(from._internal_hw_model());
  }
  if (from._internal_role() != 0) {
    _this->_internal_set_role(from._internal_role());
  }
  if (from._internal_is_licensed() != 0) {
    _this->_internal_set_is_licensed(from._internal_is_licensed());
  }
  if (from._internal_has_is_unmessagable()) {
    _this->_internal_set_is_unmessagable(from._internal_is_unmessagable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void User::CopyFrom(const User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool User::IsInitialized() const {
  return true;
}

void User::InternalSwap(User* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.long_name_, lhs_arena,
      &other->_impl_.long_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.short_name_, lhs_arena,
      &other->_impl_.short_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.macaddr_, lhs_arena,
      &other->_impl_.macaddr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.public_key_, lhs_arena,
      &other->_impl_.public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(User, _impl_.is_unmessagable_)
      + sizeof(User::_impl_.is_unmessagable_)
      - PROTOBUF_FIELD_OFFSET(User, _impl_.hw_model_)>(
          reinterpret_cast<char*>(&_impl_.hw_model_),
          reinterpret_cast<char*>(&other->_impl_.hw_model_));
}

::PROTOBUF_NAMESPACE_ID::Metadata User::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[1]);
}

// ===================================================================

class RouteDiscovery::_Internal {
 public:
};

RouteDiscovery::RouteDiscovery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.RouteDiscovery)
}
RouteDiscovery::RouteDiscovery(const RouteDiscovery& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RouteDiscovery* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.route_){from._impl_.route_}
    , decltype(_impl_.snr_towards_){from._impl_.snr_towards_}
    , /*decltype(_impl_._snr_towards_cached_byte_size_)*/{0}
    , decltype(_impl_.route_back_){from._impl_.route_back_}
    , decltype(_impl_.snr_back_){from._impl_.snr_back_}
    , /*decltype(_impl_._snr_back_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:meshtastic.RouteDiscovery)
}

inline void RouteDiscovery::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.route_){arena}
    , decltype(_impl_.snr_towards_){arena}
    , /*decltype(_impl_._snr_towards_cached_byte_size_)*/{0}
    , decltype(_impl_.route_back_){arena}
    , decltype(_impl_.snr_back_){arena}
    , /*decltype(_impl_._snr_back_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RouteDiscovery::~RouteDiscovery() {
  // @@protoc_insertion_point(destructor:meshtastic.RouteDiscovery)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouteDiscovery::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.route_.~RepeatedField();
  _impl_.snr_towards_.~RepeatedField();
  _impl_.route_back_.~RepeatedField();
  _impl_.snr_back_.~RepeatedField();
}

void RouteDiscovery::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RouteDiscovery::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.RouteDiscovery)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.route_.Clear();
  _impl_.snr_towards_.Clear();
  _impl_.route_back_.Clear();
  _impl_.snr_back_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RouteDiscovery::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated fixed32 route = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_route(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_route(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 snr_towards = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_snr_towards(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_snr_towards(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 route_back = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_route_back(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 29) {
          _internal_add_route_back(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 snr_back = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_snr_back(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_snr_back(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouteDiscovery::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.RouteDiscovery)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated fixed32 route = 1;
  if (this->_internal_route_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_route(), target);
  }

  // repeated int32 snr_towards = 2;
  {
    int byte_size = _impl_._snr_towards_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_snr_towards(), byte_size, target);
    }
  }

  // repeated fixed32 route_back = 3;
  if (this->_internal_route_back_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_route_back(), target);
  }

  // repeated int32 snr_back = 4;
  {
    int byte_size = _impl_._snr_back_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          4, _internal_snr_back(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.RouteDiscovery)
  return target;
}

size_t RouteDiscovery::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.RouteDiscovery)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 route = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_route_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated int32 snr_towards = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.snr_towards_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._snr_towards_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated fixed32 route_back = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_route_back_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated int32 snr_back = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.snr_back_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._snr_back_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RouteDiscovery::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RouteDiscovery::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RouteDiscovery::GetClassData() const { return &_class_data_; }


void RouteDiscovery::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RouteDiscovery*>(&to_msg);
  auto& from = static_cast<const RouteDiscovery&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.RouteDiscovery)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.route_.MergeFrom(from._impl_.route_);
  _this->_impl_.snr_towards_.MergeFrom(from._impl_.snr_towards_);
  _this->_impl_.route_back_.MergeFrom(from._impl_.route_back_);
  _this->_impl_.snr_back_.MergeFrom(from._impl_.snr_back_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RouteDiscovery::CopyFrom(const RouteDiscovery& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.RouteDiscovery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteDiscovery::IsInitialized() const {
  return true;
}

void RouteDiscovery::InternalSwap(RouteDiscovery* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.route_.InternalSwap(&other->_impl_.route_);
  _impl_.snr_towards_.InternalSwap(&other->_impl_.snr_towards_);
  _impl_.route_back_.InternalSwap(&other->_impl_.route_back_);
  _impl_.snr_back_.InternalSwap(&other->_impl_.snr_back_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RouteDiscovery::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[2]);
}

// ===================================================================

class Routing::_Internal {
 public:
  static const ::meshtastic::RouteDiscovery& route_request(const Routing* msg);
  static const ::meshtastic::RouteDiscovery& route_reply(const Routing* msg);
};

const ::meshtastic::RouteDiscovery&
Routing::_Internal::route_request(const Routing* msg) {
  return *msg->_impl_.variant_.route_request_;
}
const ::meshtastic::RouteDiscovery&
Routing::_Internal::route_reply(const Routing* msg) {
  return *msg->_impl_.variant_.route_reply_;
}
void Routing::set_allocated_route_request(::meshtastic::RouteDiscovery* route_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_variant();
  if (route_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(route_request);
    if (message_arena != submessage_arena) {
      route_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route_request, submessage_arena);
    }
    set_has_route_request();
    _impl_.variant_.route_request_ = route_request;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Routing.route_request)
}
void Routing::set_allocated_route_reply(::meshtastic::RouteDiscovery* route_reply) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_variant();
  if (route_reply) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(route_reply);
    if (message_arena != submessage_arena) {
      route_reply = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route_reply, submessage_arena);
    }
    set_has_route_reply();
    _impl_.variant_.route_reply_ = route_reply;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Routing.route_reply)
}
Routing::Routing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Routing)
}
Routing::Routing(const Routing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Routing* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_variant();
  switch (from.variant_case()) {
    case kRouteRequest: {
      _this->_internal_mutable_route_request()->::meshtastic::RouteDiscovery::MergeFrom(
          from._internal_route_request());
      break;
    }
    case kRouteReply: {
      _this->_internal_mutable_route_reply()->::meshtastic::RouteDiscovery::MergeFrom(
          from._internal_route_reply());
      break;
    }
    case kErrorReason: {
      _this->_internal_set_error_reason(from._internal_error_reason());
      break;
    }
    case VARIANT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:meshtastic.Routing)
}

inline void Routing::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_variant();
}

Routing::~Routing() {
  // @@protoc_insertion_point(destructor:meshtastic.Routing)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Routing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_variant()) {
    clear_variant();
  }
}

void Routing::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Routing::clear_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.Routing)
  switch (variant_case()) {
    case kRouteRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.variant_.route_request_;
      }
      break;
    }
    case kRouteReply: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.variant_.route_reply_;
      }
      break;
    }
    case kErrorReason: {
      // No need to clear
      break;
    }
    case VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}


void Routing::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Routing)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_variant();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Routing::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .meshtastic.RouteDiscovery route_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_route_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.RouteDiscovery route_reply = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_route_reply(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.Routing.Error error_reason = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_error_reason(static_cast<::meshtastic::Routing_Error>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Routing::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Routing)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .meshtastic.RouteDiscovery route_request = 1;
  if (_internal_has_route_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::route_request(this),
        _Internal::route_request(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.RouteDiscovery route_reply = 2;
  if (_internal_has_route_reply()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::route_reply(this),
        _Internal::route_reply(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.Routing.Error error_reason = 3;
  if (_internal_has_error_reason()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_error_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Routing)
  return target;
}

size_t Routing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.Routing)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (variant_case()) {
    // .meshtastic.RouteDiscovery route_request = 1;
    case kRouteRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.variant_.route_request_);
      break;
    }
    // .meshtastic.RouteDiscovery route_reply = 2;
    case kRouteReply: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.variant_.route_reply_);
      break;
    }
    // .meshtastic.Routing.Error error_reason = 3;
    case kErrorReason: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_error_reason());
      break;
    }
    case VARIANT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Routing::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Routing::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Routing::GetClassData() const { return &_class_data_; }


void Routing::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Routing*>(&to_msg);
  auto& from = static_cast<const Routing&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Routing)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.variant_case()) {
    case kRouteRequest: {
      _this->_internal_mutable_route_request()->::meshtastic::RouteDiscovery::MergeFrom(
          from._internal_route_request());
      break;
    }
    case kRouteReply: {
      _this->_internal_mutable_route_reply()->::meshtastic::RouteDiscovery::MergeFrom(
          from._internal_route_reply());
      break;
    }
    case kErrorReason: {
      _this->_internal_set_error_reason(from._internal_error_reason());
      break;
    }
    case VARIANT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Routing::CopyFrom(const Routing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Routing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Routing::IsInitialized() const {
  return true;
}

void Routing::InternalSwap(Routing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.variant_, other->_impl_.variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Routing::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[3]);
}

// ===================================================================

class Data::_Internal {
 public:
  using HasBits = decltype(std::declval<Data>()._impl_._has_bits_);
  static void set_has_bitfield(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Data::Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Data)
}
Data::Data(const Data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Data* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.portnum_){}
    , decltype(_impl_.want_response_){}
    , decltype(_impl_.dest_){}
    , decltype(_impl_.source_){}
    , decltype(_impl_.request_id_){}
    , decltype(_impl_.reply_id_){}
    , decltype(_impl_.emoji_){}
    , decltype(_impl_.bitfield_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_payload().empty()) {
    _this->_impl_.payload_.Set(from._internal_payload(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.portnum_, &from._impl_.portnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bitfield_) -
    reinterpret_cast<char*>(&_impl_.portnum_)) + sizeof(_impl_.bitfield_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.Data)
}

inline void Data::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.portnum_){0}
    , decltype(_impl_.want_response_){false}
    , decltype(_impl_.dest_){0u}
    , decltype(_impl_.source_){0u}
    , decltype(_impl_.request_id_){0u}
    , decltype(_impl_.reply_id_){0u}
    , decltype(_impl_.emoji_){0u}
    , decltype(_impl_.bitfield_){0u}
  };
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Data::~Data() {
  // @@protoc_insertion_point(destructor:meshtastic.Data)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.payload_.Destroy();
}

void Data::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Data::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Data)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.payload_.ClearToEmpty();
  ::memset(&_impl_.portnum_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.emoji_) -
      reinterpret_cast<char*>(&_impl_.portnum_)) + sizeof(_impl_.emoji_));
  _impl_.bitfield_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Data::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .meshtastic.PortNum portnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_portnum(static_cast<::meshtastic::PortNum>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes payload = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool want_response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.want_response_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // fixed32 dest = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.dest_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // fixed32 source = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.source_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // fixed32 request_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // fixed32 reply_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.reply_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // fixed32 emoji = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.emoji_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bitfield = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_bitfield(&has_bits);
          _impl_.bitfield_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Data::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Data)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .meshtastic.PortNum portnum = 1;
  if (this->_internal_portnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_portnum(), target);
  }

  // bytes payload = 2;
  if (!this->_internal_payload().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_payload(), target);
  }

  // bool want_response = 3;
  if (this->_internal_want_response() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_want_response(), target);
  }

  // fixed32 dest = 4;
  if (this->_internal_dest() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_dest(), target);
  }

  // fixed32 source = 5;
  if (this->_internal_source() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_source(), target);
  }

  // fixed32 request_id = 6;
  if (this->_internal_request_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_request_id(), target);
  }

  // fixed32 reply_id = 7;
  if (this->_internal_reply_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_reply_id(), target);
  }

  // fixed32 emoji = 8;
  if (this->_internal_emoji() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(8, this->_internal_emoji(), target);
  }

  // optional uint32 bitfield = 9;
  if (_internal_has_bitfield()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_bitfield(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Data)
  return target;
}

size_t Data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.Data)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes payload = 2;
  if (!this->_internal_payload().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_payload());
  }

  // .meshtastic.PortNum portnum = 1;
  if (this->_internal_portnum() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_portnum());
  }

  // bool want_response = 3;
  if (this->_internal_want_response() != 0) {
    total_size += 1 + 1;
  }

  // fixed32 dest = 4;
  if (this->_internal_dest() != 0) {
    total_size += 1 + 4;
  }

  // fixed32 source = 5;
  if (this->_internal_source() != 0) {
    total_size += 1 + 4;
  }

  // fixed32 request_id = 6;
  if (this->_internal_request_id() != 0) {
    total_size += 1 + 4;
  }

  // fixed32 reply_id = 7;
  if (this->_internal_reply_id() != 0) {
    total_size += 1 + 4;
  }

  // fixed32 emoji = 8;
  if (this->_internal_emoji() != 0) {
    total_size += 1 + 4;
  }

  // optional uint32 bitfield = 9;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bitfield());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Data::GetClassData() const { return &_class_data_; }


void Data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Data*>(&to_msg);
  auto& from = static_cast<const Data&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Data)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_payload().empty()) {
    _this->_internal_set_payload(from._internal_payload());
  }
  if (from._internal_portnum() != 0) {
    _this->_internal_set_portnum(from._internal_portnum());
  }
  if (from._internal_want_response() != 0) {
    _this->_internal_set_want_response(from._internal_want_response());
  }
  if (from._internal_dest() != 0) {
    _this->_internal_set_dest(from._internal_dest());
  }
  if (from._internal_source() != 0) {
    _this->_internal_set_source(from._internal_source());
  }
  if (from._internal_request_id() != 0) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  if (from._internal_reply_id() != 0) {
    _this->_internal_set_reply_id(from._internal_reply_id());
  }
  if (from._internal_emoji() != 0) {
    _this->_internal_set_emoji(from._internal_emoji());
  }
  if (from._internal_has_bitfield()) {
    _this->_internal_set_bitfield(from._internal_bitfield());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Data::CopyFrom(const Data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Data::IsInitialized() const {
  return true;
}

void Data::InternalSwap(Data* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.payload_, lhs_arena,
      &other->_impl_.payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Data, _impl_.bitfield_)
      + sizeof(Data::_impl_.bitfield_)
      - PROTOBUF_FIELD_OFFSET(Data, _impl_.portnum_)>(
          reinterpret_cast<char*>(&_impl_.portnum_),
          reinterpret_cast<char*>(&other->_impl_.portnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Data::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[4]);
}

// ===================================================================

class KeyVerification::_Internal {
 public:
};

KeyVerification::KeyVerification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.KeyVerification)
}
KeyVerification::KeyVerification(const KeyVerification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyVerification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hash1_){}
    , decltype(_impl_.hash2_){}
    , decltype(_impl_.nonce_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hash1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hash1().empty()) {
    _this->_impl_.hash1_.Set(from._internal_hash1(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hash2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hash2().empty()) {
    _this->_impl_.hash2_.Set(from._internal_hash2(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.nonce_ = from._impl_.nonce_;
  // @@protoc_insertion_point(copy_constructor:meshtastic.KeyVerification)
}

inline void KeyVerification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hash1_){}
    , decltype(_impl_.hash2_){}
    , decltype(_impl_.nonce_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.hash1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hash2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyVerification::~KeyVerification() {
  // @@protoc_insertion_point(destructor:meshtastic.KeyVerification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyVerification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash1_.Destroy();
  _impl_.hash2_.Destroy();
}

void KeyVerification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyVerification::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.KeyVerification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hash1_.ClearToEmpty();
  _impl_.hash2_.ClearToEmpty();
  _impl_.nonce_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyVerification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 nonce = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes hash1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hash1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes hash2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_hash2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyVerification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.KeyVerification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 nonce = 1;
  if (this->_internal_nonce() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_nonce(), target);
  }

  // bytes hash1 = 2;
  if (!this->_internal_hash1().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_hash1(), target);
  }

  // bytes hash2 = 3;
  if (!this->_internal_hash2().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_hash2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.KeyVerification)
  return target;
}

size_t KeyVerification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.KeyVerification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes hash1 = 2;
  if (!this->_internal_hash1().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash1());
  }

  // bytes hash2 = 3;
  if (!this->_internal_hash2().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash2());
  }

  // uint64 nonce = 1;
  if (this->_internal_nonce() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_nonce());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyVerification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyVerification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyVerification::GetClassData() const { return &_class_data_; }


void KeyVerification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyVerification*>(&to_msg);
  auto& from = static_cast<const KeyVerification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.KeyVerification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_hash1().empty()) {
    _this->_internal_set_hash1(from._internal_hash1());
  }
  if (!from._internal_hash2().empty()) {
    _this->_internal_set_hash2(from._internal_hash2());
  }
  if (from._internal_nonce() != 0) {
    _this->_internal_set_nonce(from._internal_nonce());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyVerification::CopyFrom(const KeyVerification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.KeyVerification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyVerification::IsInitialized() const {
  return true;
}

void KeyVerification::InternalSwap(KeyVerification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash1_, lhs_arena,
      &other->_impl_.hash1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash2_, lhs_arena,
      &other->_impl_.hash2_, rhs_arena
  );
  swap(_impl_.nonce_, other->_impl_.nonce_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyVerification::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[5]);
}

// ===================================================================

class Waypoint::_Internal {
 public:
  using HasBits = decltype(std::declval<Waypoint>()._impl_._has_bits_);
  static void set_has_latitude_i(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_longitude_i(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Waypoint::Waypoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Waypoint)
}
Waypoint::Waypoint(const Waypoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Waypoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.latitude_i_){}
    , decltype(_impl_.longitude_i_){}
    , decltype(_impl_.expire_){}
    , decltype(_impl_.locked_to_){}
    , decltype(_impl_.icon_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.icon_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.icon_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.Waypoint)
}

inline void Waypoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.latitude_i_){0}
    , decltype(_impl_.longitude_i_){0}
    , decltype(_impl_.expire_){0u}
    , decltype(_impl_.locked_to_){0u}
    , decltype(_impl_.icon_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Waypoint::~Waypoint() {
  // @@protoc_insertion_point(destructor:meshtastic.Waypoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Waypoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
}

void Waypoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Waypoint::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Waypoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.id_ = 0u;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.latitude_i_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.longitude_i_) -
        reinterpret_cast<char*>(&_impl_.latitude_i_)) + sizeof(_impl_.longitude_i_));
  }
  ::memset(&_impl_.expire_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.icon_) -
      reinterpret_cast<char*>(&_impl_.expire_)) + sizeof(_impl_.icon_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Waypoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed32 latitude_i = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_latitude_i(&has_bits);
          _impl_.latitude_i_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int32_t>(ptr);
          ptr += sizeof(int32_t);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed32 longitude_i = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_longitude_i(&has_bits);
          _impl_.longitude_i_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<int32_t>(ptr);
          ptr += sizeof(int32_t);
        } else
          goto handle_unusual;
        continue;
      // uint32 expire = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.expire_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 locked_to = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.locked_to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.Waypoint.name"));
        } else
          goto handle_unusual;
        continue;
      // string description = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.Waypoint.description"));
        } else
          goto handle_unusual;
        continue;
      // fixed32 icon = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.icon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Waypoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Waypoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional sfixed32 latitude_i = 2;
  if (_internal_has_latitude_i()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(2, this->_internal_latitude_i(), target);
  }

  // optional sfixed32 longitude_i = 3;
  if (_internal_has_longitude_i()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(3, this->_internal_longitude_i(), target);
  }

  // uint32 expire = 4;
  if (this->_internal_expire() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_expire(), target);
  }

  // uint32 locked_to = 5;
  if (this->_internal_locked_to() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_locked_to(), target);
  }

  // string name = 6;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.Waypoint.name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_name(), target);
  }

  // string description = 7;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.Waypoint.description");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_description(), target);
  }

  // fixed32 icon = 8;
  if (this->_internal_icon() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(8, this->_internal_icon(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Waypoint)
  return target;
}

size_t Waypoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.Waypoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 6;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string description = 7;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional sfixed32 latitude_i = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional sfixed32 longitude_i = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  // uint32 expire = 4;
  if (this->_internal_expire() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_expire());
  }

  // uint32 locked_to = 5;
  if (this->_internal_locked_to() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_locked_to());
  }

  // fixed32 icon = 8;
  if (this->_internal_icon() != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Waypoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Waypoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Waypoint::GetClassData() const { return &_class_data_; }


void Waypoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Waypoint*>(&to_msg);
  auto& from = static_cast<const Waypoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Waypoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.latitude_i_ = from._impl_.latitude_i_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.longitude_i_ = from._impl_.longitude_i_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_expire() != 0) {
    _this->_internal_set_expire(from._internal_expire());
  }
  if (from._internal_locked_to() != 0) {
    _this->_internal_set_locked_to(from._internal_locked_to());
  }
  if (from._internal_icon() != 0) {
    _this->_internal_set_icon(from._internal_icon());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Waypoint::CopyFrom(const Waypoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Waypoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Waypoint::IsInitialized() const {
  return true;
}

void Waypoint::InternalSwap(Waypoint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.icon_)
      + sizeof(Waypoint::_impl_.icon_)
      - PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Waypoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[6]);
}

// ===================================================================

class MqttClientProxyMessage::_Internal {
 public:
};

MqttClientProxyMessage::MqttClientProxyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.MqttClientProxyMessage)
}
MqttClientProxyMessage::MqttClientProxyMessage(const MqttClientProxyMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MqttClientProxyMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.topic_){}
    , decltype(_impl_.retained_){}
    , decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_topic().empty()) {
    _this->_impl_.topic_.Set(from._internal_topic(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.retained_ = from._impl_.retained_;
  clear_has_payload_variant();
  switch (from.payload_variant_case()) {
    case kData: {
      _this->_internal_set_data(from._internal_data());
      break;
    }
    case kText: {
      _this->_internal_set_text(from._internal_text());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:meshtastic.MqttClientProxyMessage)
}

inline void MqttClientProxyMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.topic_){}
    , decltype(_impl_.retained_){false}
    , decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_payload_variant();
}

MqttClientProxyMessage::~MqttClientProxyMessage() {
  // @@protoc_insertion_point(destructor:meshtastic.MqttClientProxyMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MqttClientProxyMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.topic_.Destroy();
  if (has_payload_variant()) {
    clear_payload_variant();
  }
}

void MqttClientProxyMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MqttClientProxyMessage::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.MqttClientProxyMessage)
  switch (payload_variant_case()) {
    case kData: {
      _impl_.payload_variant_.data_.Destroy();
      break;
    }
    case kText: {
      _impl_.payload_variant_.text_.Destroy();
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


void MqttClientProxyMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.MqttClientProxyMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.topic_.ClearToEmpty();
  _impl_.retained_ = false;
  clear_payload_variant();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MqttClientProxyMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string topic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_topic();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.MqttClientProxyMessage.topic"));
        } else
          goto handle_unusual;
        continue;
      // bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.MqttClientProxyMessage.text"));
        } else
          goto handle_unusual;
        continue;
      // bool retained = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.retained_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MqttClientProxyMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.MqttClientProxyMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string topic = 1;
  if (!this->_internal_topic().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_topic().data(), static_cast<int>(this->_internal_topic().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.MqttClientProxyMessage.topic");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic(), target);
  }

  // bytes data = 2;
  if (_internal_has_data()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  // string text = 3;
  if (_internal_has_text()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.MqttClientProxyMessage.text");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_text(), target);
  }

  // bool retained = 4;
  if (this->_internal_retained() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_retained(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.MqttClientProxyMessage)
  return target;
}

size_t MqttClientProxyMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.MqttClientProxyMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string topic = 1;
  if (!this->_internal_topic().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());
  }

  // bool retained = 4;
  if (this->_internal_retained() != 0) {
    total_size += 1 + 1;
  }

  switch (payload_variant_case()) {
    // bytes data = 2;
    case kData: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
      break;
    }
    // string text = 3;
    case kText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MqttClientProxyMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MqttClientProxyMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MqttClientProxyMessage::GetClassData() const { return &_class_data_; }


void MqttClientProxyMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MqttClientProxyMessage*>(&to_msg);
  auto& from = static_cast<const MqttClientProxyMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.MqttClientProxyMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_topic().empty()) {
    _this->_internal_set_topic(from._internal_topic());
  }
  if (from._internal_retained() != 0) {
    _this->_internal_set_retained(from._internal_retained());
  }
  switch (from.payload_variant_case()) {
    case kData: {
      _this->_internal_set_data(from._internal_data());
      break;
    }
    case kText: {
      _this->_internal_set_text(from._internal_text());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MqttClientProxyMessage::CopyFrom(const MqttClientProxyMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.MqttClientProxyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MqttClientProxyMessage::IsInitialized() const {
  return true;
}

void MqttClientProxyMessage::InternalSwap(MqttClientProxyMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.topic_, lhs_arena,
      &other->_impl_.topic_, rhs_arena
  );
  swap(_impl_.retained_, other->_impl_.retained_);
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata MqttClientProxyMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[7]);
}

// ===================================================================

class MeshPacket::_Internal {
 public:
  static const ::meshtastic::Data& decoded(const MeshPacket* msg);
};

const ::meshtastic::Data&
MeshPacket::_Internal::decoded(const MeshPacket* msg) {
  return *msg->_impl_.payload_variant_.decoded_;
}
void MeshPacket::set_allocated_decoded(::meshtastic::Data* decoded) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (decoded) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(decoded);
    if (message_arena != submessage_arena) {
      decoded = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decoded, submessage_arena);
    }
    set_has_decoded();
    _impl_.payload_variant_.decoded_ = decoded;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MeshPacket.decoded)
}
MeshPacket::MeshPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.MeshPacket)
}
MeshPacket::MeshPacket(const MeshPacket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MeshPacket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.public_key_){}
    , decltype(_impl_.from_){}
    , decltype(_impl_.to_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.rx_time_){}
    , decltype(_impl_.rx_snr_){}
    , decltype(_impl_.hop_limit_){}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.rx_rssi_){}
    , decltype(_impl_.delayed_){}
    , decltype(_impl_.want_ack_){}
    , decltype(_impl_.via_mqtt_){}
    , decltype(_impl_.pki_encrypted_){}
    , decltype(_impl_.hop_start_){}
    , decltype(_impl_.next_hop_){}
    , decltype(_impl_.relay_node_){}
    , decltype(_impl_.tx_after_){}
    , decltype(_impl_.transport_mechanism_){}
    , decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_public_key().empty()) {
    _this->_impl_.public_key_.Set(from._internal_public_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.from_, &from._impl_.from_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.transport_mechanism_) -
    reinterpret_cast<char*>(&_impl_.from_)) + sizeof(_impl_.transport_mechanism_));
  clear_has_payload_variant();
  switch (from.payload_variant_case()) {
    case kDecoded: {
      _this->_internal_mutable_decoded()->::meshtastic::Data::MergeFrom(
          from._internal_decoded());
      break;
    }
    case kEncrypted: {
      _this->_internal_set_encrypted(from._internal_encrypted());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:meshtastic.MeshPacket)
}

inline void MeshPacket::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.public_key_){}
    , decltype(_impl_.from_){0u}
    , decltype(_impl_.to_){0u}
    , decltype(_impl_.channel_){0u}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.rx_time_){0u}
    , decltype(_impl_.rx_snr_){0}
    , decltype(_impl_.hop_limit_){0u}
    , decltype(_impl_.priority_){0}
    , decltype(_impl_.rx_rssi_){0}
    , decltype(_impl_.delayed_){0}
    , decltype(_impl_.want_ack_){false}
    , decltype(_impl_.via_mqtt_){false}
    , decltype(_impl_.pki_encrypted_){false}
    , decltype(_impl_.hop_start_){0u}
    , decltype(_impl_.next_hop_){0u}
    , decltype(_impl_.relay_node_){0u}
    , decltype(_impl_.tx_after_){0u}
    , decltype(_impl_.transport_mechanism_){0}
    , decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_payload_variant();
}

MeshPacket::~MeshPacket() {
  // @@protoc_insertion_point(destructor:meshtastic.MeshPacket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MeshPacket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.public_key_.Destroy();
  if (has_payload_variant()) {
    clear_payload_variant();
  }
}

void MeshPacket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MeshPacket::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.MeshPacket)
  switch (payload_variant_case()) {
    case kDecoded: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.decoded_;
      }
      break;
    }
    case kEncrypted: {
      _impl_.payload_variant_.encrypted_.Destroy();
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


void MeshPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.MeshPacket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.public_key_.ClearToEmpty();
  ::memset(&_impl_.from_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.transport_mechanism_) -
      reinterpret_cast<char*>(&_impl_.from_)) + sizeof(_impl_.transport_mechanism_));
  clear_payload_variant();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MeshPacket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed32 from = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // fixed32 to = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.to_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // uint32 channel = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.Data decoded = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_decoded(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes encrypted = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_encrypted();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // fixed32 id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // fixed32 rx_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.rx_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // float rx_snr = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.rx_snr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint32 hop_limit = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.hop_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool want_ack = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.want_ack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.MeshPacket.Priority priority = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_priority(static_cast<::meshtastic::MeshPacket_Priority>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 rx_rssi = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.rx_rssi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_delayed(static_cast<::meshtastic::MeshPacket_Delayed>(val));
        } else
          goto handle_unusual;
        continue;
      // bool via_mqtt = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.via_mqtt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 hop_start = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.hop_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes public_key = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool pki_encrypted = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _impl_.pki_encrypted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 next_hop = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _impl_.next_hop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 relay_node = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.relay_node_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 tx_after = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _impl_.tx_after_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_transport_mechanism(static_cast<::meshtastic::MeshPacket_TransportMechanism>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MeshPacket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.MeshPacket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed32 from = 1;
  if (this->_internal_from() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_from(), target);
  }

  // fixed32 to = 2;
  if (this->_internal_to() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_to(), target);
  }

  // uint32 channel = 3;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_channel(), target);
  }

  // .meshtastic.Data decoded = 4;
  if (_internal_has_decoded()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::decoded(this),
        _Internal::decoded(this).GetCachedSize(), target, stream);
  }

  // bytes encrypted = 5;
  if (_internal_has_encrypted()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_encrypted(), target);
  }

  // fixed32 id = 6;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_id(), target);
  }

  // fixed32 rx_time = 7;
  if (this->_internal_rx_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_rx_time(), target);
  }

  // float rx_snr = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rx_snr = this->_internal_rx_snr();
  uint32_t raw_rx_snr;
  memcpy(&raw_rx_snr, &tmp_rx_snr, sizeof(tmp_rx_snr));
  if (raw_rx_snr != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_rx_snr(), target);
  }

  // uint32 hop_limit = 9;
  if (this->_internal_hop_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_hop_limit(), target);
  }

  // bool want_ack = 10;
  if (this->_internal_want_ack() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_want_ack(), target);
  }

  // .meshtastic.MeshPacket.Priority priority = 11;
  if (this->_internal_priority() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      11, this->_internal_priority(), target);
  }

  // int32 rx_rssi = 12;
  if (this->_internal_rx_rssi() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_rx_rssi(), target);
  }

  // .meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
  if (this->_internal_delayed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      13, this->_internal_delayed(), target);
  }

  // bool via_mqtt = 14;
  if (this->_internal_via_mqtt() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_via_mqtt(), target);
  }

  // uint32 hop_start = 15;
  if (this->_internal_hop_start() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_hop_start(), target);
  }

  // bytes public_key = 16;
  if (!this->_internal_public_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        16, this->_internal_public_key(), target);
  }

  // bool pki_encrypted = 17;
  if (this->_internal_pki_encrypted() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_pki_encrypted(), target);
  }

  // uint32 next_hop = 18;
  if (this->_internal_next_hop() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_next_hop(), target);
  }

  // uint32 relay_node = 19;
  if (this->_internal_relay_node() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_relay_node(), target);
  }

  // uint32 tx_after = 20;
  if (this->_internal_tx_after() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_tx_after(), target);
  }

  // .meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;
  if (this->_internal_transport_mechanism() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      21, this->_internal_transport_mechanism(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.MeshPacket)
  return target;
}

size_t MeshPacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.MeshPacket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes public_key = 16;
  if (!this->_internal_public_key().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_public_key());
  }

  // fixed32 from = 1;
  if (this->_internal_from() != 0) {
    total_size += 1 + 4;
  }

  // fixed32 to = 2;
  if (this->_internal_to() != 0) {
    total_size += 1 + 4;
  }

  // uint32 channel = 3;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channel());
  }

  // fixed32 id = 6;
  if (this->_internal_id() != 0) {
    total_size += 1 + 4;
  }

  // fixed32 rx_time = 7;
  if (this->_internal_rx_time() != 0) {
    total_size += 1 + 4;
  }

  // float rx_snr = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rx_snr = this->_internal_rx_snr();
  uint32_t raw_rx_snr;
  memcpy(&raw_rx_snr, &tmp_rx_snr, sizeof(tmp_rx_snr));
  if (raw_rx_snr != 0) {
    total_size += 1 + 4;
  }

  // uint32 hop_limit = 9;
  if (this->_internal_hop_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hop_limit());
  }

  // .meshtastic.MeshPacket.Priority priority = 11;
  if (this->_internal_priority() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_priority());
  }

  // int32 rx_rssi = 12;
  if (this->_internal_rx_rssi() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rx_rssi());
  }

  // .meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
  if (this->_internal_delayed() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_delayed());
  }

  // bool want_ack = 10;
  if (this->_internal_want_ack() != 0) {
    total_size += 1 + 1;
  }

  // bool via_mqtt = 14;
  if (this->_internal_via_mqtt() != 0) {
    total_size += 1 + 1;
  }

  // bool pki_encrypted = 17;
  if (this->_internal_pki_encrypted() != 0) {
    total_size += 2 + 1;
  }

  // uint32 hop_start = 15;
  if (this->_internal_hop_start() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hop_start());
  }

  // uint32 next_hop = 18;
  if (this->_internal_next_hop() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_next_hop());
  }

  // uint32 relay_node = 19;
  if (this->_internal_relay_node() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_relay_node());
  }

  // uint32 tx_after = 20;
  if (this->_internal_tx_after() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_tx_after());
  }

  // .meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;
  if (this->_internal_transport_mechanism() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_transport_mechanism());
  }

  switch (payload_variant_case()) {
    // .meshtastic.Data decoded = 4;
    case kDecoded: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.decoded_);
      break;
    }
    // bytes encrypted = 5;
    case kEncrypted: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encrypted());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MeshPacket::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MeshPacket::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MeshPacket::GetClassData() const { return &_class_data_; }


void MeshPacket::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MeshPacket*>(&to_msg);
  auto& from = static_cast<const MeshPacket&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.MeshPacket)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_public_key().empty()) {
    _this->_internal_set_public_key(from._internal_public_key());
  }
  if (from._internal_from() != 0) {
    _this->_internal_set_from(from._internal_from());
  }
  if (from._internal_to() != 0) {
    _this->_internal_set_to(from._internal_to());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_rx_time() != 0) {
    _this->_internal_set_rx_time(from._internal_rx_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rx_snr = from._internal_rx_snr();
  uint32_t raw_rx_snr;
  memcpy(&raw_rx_snr, &tmp_rx_snr, sizeof(tmp_rx_snr));
  if (raw_rx_snr != 0) {
    _this->_internal_set_rx_snr(from._internal_rx_snr());
  }
  if (from._internal_hop_limit() != 0) {
    _this->_internal_set_hop_limit(from._internal_hop_limit());
  }
  if (from._internal_priority() != 0) {
    _this->_internal_set_priority(from._internal_priority());
  }
  if (from._internal_rx_rssi() != 0) {
    _this->_internal_set_rx_rssi(from._internal_rx_rssi());
  }
  if (from._internal_delayed() != 0) {
    _this->_internal_set_delayed(from._internal_delayed());
  }
  if (from._internal_want_ack() != 0) {
    _this->_internal_set_want_ack(from._internal_want_ack());
  }
  if (from._internal_via_mqtt() != 0) {
    _this->_internal_set_via_mqtt(from._internal_via_mqtt());
  }
  if (from._internal_pki_encrypted() != 0) {
    _this->_internal_set_pki_encrypted(from._internal_pki_encrypted());
  }
  if (from._internal_hop_start() != 0) {
    _this->_internal_set_hop_start(from._internal_hop_start());
  }
  if (from._internal_next_hop() != 0) {
    _this->_internal_set_next_hop(from._internal_next_hop());
  }
  if (from._internal_relay_node() != 0) {
    _this->_internal_set_relay_node(from._internal_relay_node());
  }
  if (from._internal_tx_after() != 0) {
    _this->_internal_set_tx_after(from._internal_tx_after());
  }
  if (from._internal_transport_mechanism() != 0) {
    _this->_internal_set_transport_mechanism(from._internal_transport_mechanism());
  }
  switch (from.payload_variant_case()) {
    case kDecoded: {
      _this->_internal_mutable_decoded()->::meshtastic::Data::MergeFrom(
          from._internal_decoded());
      break;
    }
    case kEncrypted: {
      _this->_internal_set_encrypted(from._internal_encrypted());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MeshPacket::CopyFrom(const MeshPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.MeshPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MeshPacket::IsInitialized() const {
  return true;
}

void MeshPacket::InternalSwap(MeshPacket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.public_key_, lhs_arena,
      &other->_impl_.public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.transport_mechanism_)
      + sizeof(MeshPacket::_impl_.transport_mechanism_)
      - PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.from_)>(
          reinterpret_cast<char*>(&_impl_.from_),
          reinterpret_cast<char*>(&other->_impl_.from_));
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata MeshPacket::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[8]);
}

// ===================================================================

class NodeInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeInfo>()._impl_._has_bits_);
  static const ::meshtastic::User& user(const NodeInfo* msg);
  static const ::meshtastic::Position& position(const NodeInfo* msg);
  static const ::meshtastic::DeviceMetrics& device_metrics(const NodeInfo* msg);
  static void set_has_hops_away(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::meshtastic::User&
NodeInfo::_Internal::user(const NodeInfo* msg) {
  return *msg->_impl_.user_;
}
const ::meshtastic::Position&
NodeInfo::_Internal::position(const NodeInfo* msg) {
  return *msg->_impl_.position_;
}
const ::meshtastic::DeviceMetrics&
NodeInfo::_Internal::device_metrics(const NodeInfo* msg) {
  return *msg->_impl_.device_metrics_;
}
void NodeInfo::clear_device_metrics() {
  if (GetArenaForAllocation() == nullptr && _impl_.device_metrics_ != nullptr) {
    delete _impl_.device_metrics_;
  }
  _impl_.device_metrics_ = nullptr;
}
NodeInfo::NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.NodeInfo)
}
NodeInfo::NodeInfo(const NodeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.device_metrics_){nullptr}
    , decltype(_impl_.num_){}
    , decltype(_impl_.snr_){}
    , decltype(_impl_.last_heard_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.hops_away_){}
    , decltype(_impl_.via_mqtt_){}
    , decltype(_impl_.is_favorite_){}
    , decltype(_impl_.is_ignored_){}
    , decltype(_impl_.is_key_manually_verified_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user()) {
    _this->_impl_.user_ = new ::meshtastic::User(*from._impl_.user_);
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::meshtastic::Position(*from._impl_.position_);
  }
  if (from._internal_has_device_metrics()) {
    _this->_impl_.device_metrics_ = new ::meshtastic::DeviceMetrics(*from._impl_.device_metrics_);
  }
  ::memcpy(&_impl_.num_, &from._impl_.num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_key_manually_verified_) -
    reinterpret_cast<char*>(&_impl_.num_)) + sizeof(_impl_.is_key_manually_verified_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.NodeInfo)
}

inline void NodeInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.device_metrics_){nullptr}
    , decltype(_impl_.num_){0u}
    , decltype(_impl_.snr_){0}
    , decltype(_impl_.last_heard_){0u}
    , decltype(_impl_.channel_){0u}
    , decltype(_impl_.hops_away_){0u}
    , decltype(_impl_.via_mqtt_){false}
    , decltype(_impl_.is_favorite_){false}
    , decltype(_impl_.is_ignored_){false}
    , decltype(_impl_.is_key_manually_verified_){false}
  };
}

NodeInfo::~NodeInfo() {
  // @@protoc_insertion_point(destructor:meshtastic.NodeInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.user_;
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.device_metrics_;
}

void NodeInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.NodeInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.device_metrics_ != nullptr) {
    delete _impl_.device_metrics_;
  }
  _impl_.device_metrics_ = nullptr;
  ::memset(&_impl_.num_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.channel_) -
      reinterpret_cast<char*>(&_impl_.num_)) + sizeof(_impl_.channel_));
  _impl_.hops_away_ = 0u;
  ::memset(&_impl_.via_mqtt_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_key_manually_verified_) -
      reinterpret_cast<char*>(&_impl_.via_mqtt_)) + sizeof(_impl_.is_key_manually_verified_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.User user = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.Position position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float snr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.snr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // fixed32 last_heard = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.last_heard_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.DeviceMetrics device_metrics = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_metrics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 channel = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool via_mqtt = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.via_mqtt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hops_away = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_hops_away(&has_bits);
          _impl_.hops_away_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_favorite = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.is_favorite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_ignored = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.is_ignored_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_key_manually_verified = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.is_key_manually_verified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.NodeInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 num = 1;
  if (this->_internal_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num(), target);
  }

  // .meshtastic.User user = 2;
  if (this->_internal_has_user()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::user(this),
        _Internal::user(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.Position position = 3;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // float snr = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_snr = this->_internal_snr();
  uint32_t raw_snr;
  memcpy(&raw_snr, &tmp_snr, sizeof(tmp_snr));
  if (raw_snr != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_snr(), target);
  }

  // fixed32 last_heard = 5;
  if (this->_internal_last_heard() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_last_heard(), target);
  }

  // .meshtastic.DeviceMetrics device_metrics = 6;
  if (this->_internal_has_device_metrics()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::device_metrics(this),
        _Internal::device_metrics(this).GetCachedSize(), target, stream);
  }

  // uint32 channel = 7;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_channel(), target);
  }

  // bool via_mqtt = 8;
  if (this->_internal_via_mqtt() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_via_mqtt(), target);
  }

  // optional uint32 hops_away = 9;
  if (_internal_has_hops_away()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_hops_away(), target);
  }

  // bool is_favorite = 10;
  if (this->_internal_is_favorite() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_favorite(), target);
  }

  // bool is_ignored = 11;
  if (this->_internal_is_ignored() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_is_ignored(), target);
  }

  // bool is_key_manually_verified = 12;
  if (this->_internal_is_key_manually_verified() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_is_key_manually_verified(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.NodeInfo)
  return target;
}

size_t NodeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.NodeInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .meshtastic.User user = 2;
  if (this->_internal_has_user()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.user_);
  }

  // .meshtastic.Position position = 3;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // .meshtastic.DeviceMetrics device_metrics = 6;
  if (this->_internal_has_device_metrics()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.device_metrics_);
  }

  // uint32 num = 1;
  if (this->_internal_num() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num());
  }

  // float snr = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_snr = this->_internal_snr();
  uint32_t raw_snr;
  memcpy(&raw_snr, &tmp_snr, sizeof(tmp_snr));
  if (raw_snr != 0) {
    total_size += 1 + 4;
  }

  // fixed32 last_heard = 5;
  if (this->_internal_last_heard() != 0) {
    total_size += 1 + 4;
  }

  // uint32 channel = 7;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channel());
  }

  // optional uint32 hops_away = 9;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hops_away());
  }

  // bool via_mqtt = 8;
  if (this->_internal_via_mqtt() != 0) {
    total_size += 1 + 1;
  }

  // bool is_favorite = 10;
  if (this->_internal_is_favorite() != 0) {
    total_size += 1 + 1;
  }

  // bool is_ignored = 11;
  if (this->_internal_is_ignored() != 0) {
    total_size += 1 + 1;
  }

  // bool is_key_manually_verified = 12;
  if (this->_internal_is_key_manually_verified() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeInfo::GetClassData() const { return &_class_data_; }


void NodeInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeInfo*>(&to_msg);
  auto& from = static_cast<const NodeInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.NodeInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user()) {
    _this->_internal_mutable_user()->::meshtastic::User::MergeFrom(
        from._internal_user());
  }
  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::meshtastic::Position::MergeFrom(
        from._internal_position());
  }
  if (from._internal_has_device_metrics()) {
    _this->_internal_mutable_device_metrics()->::meshtastic::DeviceMetrics::MergeFrom(
        from._internal_device_metrics());
  }
  if (from._internal_num() != 0) {
    _this->_internal_set_num(from._internal_num());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_snr = from._internal_snr();
  uint32_t raw_snr;
  memcpy(&raw_snr, &tmp_snr, sizeof(tmp_snr));
  if (raw_snr != 0) {
    _this->_internal_set_snr(from._internal_snr());
  }
  if (from._internal_last_heard() != 0) {
    _this->_internal_set_last_heard(from._internal_last_heard());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  if (from._internal_has_hops_away()) {
    _this->_internal_set_hops_away(from._internal_hops_away());
  }
  if (from._internal_via_mqtt() != 0) {
    _this->_internal_set_via_mqtt(from._internal_via_mqtt());
  }
  if (from._internal_is_favorite() != 0) {
    _this->_internal_set_is_favorite(from._internal_is_favorite());
  }
  if (from._internal_is_ignored() != 0) {
    _this->_internal_set_is_ignored(from._internal_is_ignored());
  }
  if (from._internal_is_key_manually_verified() != 0) {
    _this->_internal_set_is_key_manually_verified(from._internal_is_key_manually_verified());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeInfo::CopyFrom(const NodeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.NodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeInfo::IsInitialized() const {
  return true;
}

void NodeInfo::InternalSwap(NodeInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.is_key_manually_verified_)
      + sizeof(NodeInfo::_impl_.is_key_manually_verified_)
      - PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.user_)>(
          reinterpret_cast<char*>(&_impl_.user_),
          reinterpret_cast<char*>(&other->_impl_.user_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[9]);
}

// ===================================================================

class MyNodeInfo::_Internal {
 public:
};

MyNodeInfo::MyNodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.MyNodeInfo)
}
MyNodeInfo::MyNodeInfo(const MyNodeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MyNodeInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.device_id_){}
    , decltype(_impl_.pio_env_){}
    , decltype(_impl_.my_node_num_){}
    , decltype(_impl_.reboot_count_){}
    , decltype(_impl_.min_app_version_){}
    , decltype(_impl_.firmware_edition_){}
    , decltype(_impl_.nodedb_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_device_id().empty()) {
    _this->_impl_.device_id_.Set(from._internal_device_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pio_env_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pio_env_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pio_env().empty()) {
    _this->_impl_.pio_env_.Set(from._internal_pio_env(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.my_node_num_, &from._impl_.my_node_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nodedb_count_) -
    reinterpret_cast<char*>(&_impl_.my_node_num_)) + sizeof(_impl_.nodedb_count_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.MyNodeInfo)
}

inline void MyNodeInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.device_id_){}
    , decltype(_impl_.pio_env_){}
    , decltype(_impl_.my_node_num_){0u}
    , decltype(_impl_.reboot_count_){0u}
    , decltype(_impl_.min_app_version_){0u}
    , decltype(_impl_.firmware_edition_){0}
    , decltype(_impl_.nodedb_count_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pio_env_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pio_env_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MyNodeInfo::~MyNodeInfo() {
  // @@protoc_insertion_point(destructor:meshtastic.MyNodeInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MyNodeInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_id_.Destroy();
  _impl_.pio_env_.Destroy();
}

void MyNodeInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MyNodeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.MyNodeInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_id_.ClearToEmpty();
  _impl_.pio_env_.ClearToEmpty();
  ::memset(&_impl_.my_node_num_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nodedb_count_) -
      reinterpret_cast<char*>(&_impl_.my_node_num_)) + sizeof(_impl_.nodedb_count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MyNodeInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 my_node_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.my_node_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 reboot_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.reboot_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 min_app_version = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.min_app_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes device_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string pio_env = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_pio_env();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.MyNodeInfo.pio_env"));
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.FirmwareEdition firmware_edition = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_firmware_edition(static_cast<::meshtastic::FirmwareEdition>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 nodedb_count = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.nodedb_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MyNodeInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.MyNodeInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 my_node_num = 1;
  if (this->_internal_my_node_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_my_node_num(), target);
  }

  // uint32 reboot_count = 8;
  if (this->_internal_reboot_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_reboot_count(), target);
  }

  // uint32 min_app_version = 11;
  if (this->_internal_min_app_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_min_app_version(), target);
  }

  // bytes device_id = 12;
  if (!this->_internal_device_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        12, this->_internal_device_id(), target);
  }

  // string pio_env = 13;
  if (!this->_internal_pio_env().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pio_env().data(), static_cast<int>(this->_internal_pio_env().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.MyNodeInfo.pio_env");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_pio_env(), target);
  }

  // .meshtastic.FirmwareEdition firmware_edition = 14;
  if (this->_internal_firmware_edition() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_firmware_edition(), target);
  }

  // uint32 nodedb_count = 15;
  if (this->_internal_nodedb_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_nodedb_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.MyNodeInfo)
  return target;
}

size_t MyNodeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.MyNodeInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes device_id = 12;
  if (!this->_internal_device_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_device_id());
  }

  // string pio_env = 13;
  if (!this->_internal_pio_env().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pio_env());
  }

  // uint32 my_node_num = 1;
  if (this->_internal_my_node_num() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_my_node_num());
  }

  // uint32 reboot_count = 8;
  if (this->_internal_reboot_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reboot_count());
  }

  // uint32 min_app_version = 11;
  if (this->_internal_min_app_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_min_app_version());
  }

  // .meshtastic.FirmwareEdition firmware_edition = 14;
  if (this->_internal_firmware_edition() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_firmware_edition());
  }

  // uint32 nodedb_count = 15;
  if (this->_internal_nodedb_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nodedb_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MyNodeInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MyNodeInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MyNodeInfo::GetClassData() const { return &_class_data_; }


void MyNodeInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MyNodeInfo*>(&to_msg);
  auto& from = static_cast<const MyNodeInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.MyNodeInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_device_id().empty()) {
    _this->_internal_set_device_id(from._internal_device_id());
  }
  if (!from._internal_pio_env().empty()) {
    _this->_internal_set_pio_env(from._internal_pio_env());
  }
  if (from._internal_my_node_num() != 0) {
    _this->_internal_set_my_node_num(from._internal_my_node_num());
  }
  if (from._internal_reboot_count() != 0) {
    _this->_internal_set_reboot_count(from._internal_reboot_count());
  }
  if (from._internal_min_app_version() != 0) {
    _this->_internal_set_min_app_version(from._internal_min_app_version());
  }
  if (from._internal_firmware_edition() != 0) {
    _this->_internal_set_firmware_edition(from._internal_firmware_edition());
  }
  if (from._internal_nodedb_count() != 0) {
    _this->_internal_set_nodedb_count(from._internal_nodedb_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MyNodeInfo::CopyFrom(const MyNodeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.MyNodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MyNodeInfo::IsInitialized() const {
  return true;
}

void MyNodeInfo::InternalSwap(MyNodeInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_id_, lhs_arena,
      &other->_impl_.device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pio_env_, lhs_arena,
      &other->_impl_.pio_env_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.nodedb_count_)
      + sizeof(MyNodeInfo::_impl_.nodedb_count_)
      - PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.my_node_num_)>(
          reinterpret_cast<char*>(&_impl_.my_node_num_),
          reinterpret_cast<char*>(&other->_impl_.my_node_num_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MyNodeInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[10]);
}

// ===================================================================

class LogRecord::_Internal {
 public:
};

LogRecord::LogRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.LogRecord)
}
LogRecord::LogRecord(const LogRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LogRecord* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.source_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.level_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source().empty()) {
    _this->_impl_.source_.Set(from._internal_source(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.time_, &from._impl_.time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.level_) -
    reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.level_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.LogRecord)
}

inline void LogRecord::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.source_){}
    , decltype(_impl_.time_){0u}
    , decltype(_impl_.level_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LogRecord::~LogRecord() {
  // @@protoc_insertion_point(destructor:meshtastic.LogRecord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogRecord::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  _impl_.source_.Destroy();
}

void LogRecord::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.LogRecord)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.source_.ClearToEmpty();
  ::memset(&_impl_.time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.level_) -
      reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.level_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogRecord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.LogRecord.message"));
        } else
          goto handle_unusual;
        continue;
      // fixed32 time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // string source = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_source();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.LogRecord.source"));
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.LogRecord.Level level = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::meshtastic::LogRecord_Level>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogRecord::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.LogRecord)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.LogRecord.message");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  // fixed32 time = 2;
  if (this->_internal_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_time(), target);
  }

  // string source = 3;
  if (!this->_internal_source().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_source().data(), static_cast<int>(this->_internal_source().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.LogRecord.source");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_source(), target);
  }

  // .meshtastic.LogRecord.Level level = 4;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.LogRecord)
  return target;
}

size_t LogRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.LogRecord)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  // string source = 3;
  if (!this->_internal_source().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_source());
  }

  // fixed32 time = 2;
  if (this->_internal_time() != 0) {
    total_size += 1 + 4;
  }

  // .meshtastic.LogRecord.Level level = 4;
  if (this->_internal_level() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogRecord::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LogRecord::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogRecord::GetClassData() const { return &_class_data_; }


void LogRecord::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LogRecord*>(&to_msg);
  auto& from = static_cast<const LogRecord&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.LogRecord)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (!from._internal_source().empty()) {
    _this->_internal_set_source(from._internal_source());
  }
  if (from._internal_time() != 0) {
    _this->_internal_set_time(from._internal_time());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogRecord::CopyFrom(const LogRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.LogRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogRecord::IsInitialized() const {
  return true;
}

void LogRecord::InternalSwap(LogRecord* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.source_, lhs_arena,
      &other->_impl_.source_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.level_)
      + sizeof(LogRecord::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogRecord::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[11]);
}

// ===================================================================

class QueueStatus::_Internal {
 public:
};

QueueStatus::QueueStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.QueueStatus)
}
QueueStatus::QueueStatus(const QueueStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QueueStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.res_){}
    , decltype(_impl_.free_){}
    , decltype(_impl_.maxlen_){}
    , decltype(_impl_.mesh_packet_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.res_, &from._impl_.res_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mesh_packet_id_) -
    reinterpret_cast<char*>(&_impl_.res_)) + sizeof(_impl_.mesh_packet_id_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.QueueStatus)
}

inline void QueueStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.res_){0}
    , decltype(_impl_.free_){0u}
    , decltype(_impl_.maxlen_){0u}
    , decltype(_impl_.mesh_packet_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

QueueStatus::~QueueStatus() {
  // @@protoc_insertion_point(destructor:meshtastic.QueueStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QueueStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void QueueStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QueueStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.QueueStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.res_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.mesh_packet_id_) -
      reinterpret_cast<char*>(&_impl_.res_)) + sizeof(_impl_.mesh_packet_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QueueStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 res = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.res_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 free = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.free_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 maxlen = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.maxlen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 mesh_packet_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.mesh_packet_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QueueStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.QueueStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 res = 1;
  if (this->_internal_res() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_res(), target);
  }

  // uint32 free = 2;
  if (this->_internal_free() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_free(), target);
  }

  // uint32 maxlen = 3;
  if (this->_internal_maxlen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_maxlen(), target);
  }

  // uint32 mesh_packet_id = 4;
  if (this->_internal_mesh_packet_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mesh_packet_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.QueueStatus)
  return target;
}

size_t QueueStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.QueueStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 res = 1;
  if (this->_internal_res() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_res());
  }

  // uint32 free = 2;
  if (this->_internal_free() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_free());
  }

  // uint32 maxlen = 3;
  if (this->_internal_maxlen() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxlen());
  }

  // uint32 mesh_packet_id = 4;
  if (this->_internal_mesh_packet_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mesh_packet_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QueueStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QueueStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QueueStatus::GetClassData() const { return &_class_data_; }


void QueueStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QueueStatus*>(&to_msg);
  auto& from = static_cast<const QueueStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.QueueStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_res() != 0) {
    _this->_internal_set_res(from._internal_res());
  }
  if (from._internal_free() != 0) {
    _this->_internal_set_free(from._internal_free());
  }
  if (from._internal_maxlen() != 0) {
    _this->_internal_set_maxlen(from._internal_maxlen());
  }
  if (from._internal_mesh_packet_id() != 0) {
    _this->_internal_set_mesh_packet_id(from._internal_mesh_packet_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QueueStatus::CopyFrom(const QueueStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.QueueStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueueStatus::IsInitialized() const {
  return true;
}

void QueueStatus::InternalSwap(QueueStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.mesh_packet_id_)
      + sizeof(QueueStatus::_impl_.mesh_packet_id_)
      - PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.res_)>(
          reinterpret_cast<char*>(&_impl_.res_),
          reinterpret_cast<char*>(&other->_impl_.res_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QueueStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[12]);
}

// ===================================================================

class FromRadio::_Internal {
 public:
  static const ::meshtastic::MeshPacket& packet(const FromRadio* msg);
  static const ::meshtastic::MyNodeInfo& my_info(const FromRadio* msg);
  static const ::meshtastic::NodeInfo& node_info(const FromRadio* msg);
  static const ::meshtastic::Config& config(const FromRadio* msg);
  static const ::meshtastic::LogRecord& log_record(const FromRadio* msg);
  static const ::meshtastic::ModuleConfig& moduleconfig(const FromRadio* msg);
  static const ::meshtastic::Channel& channel(const FromRadio* msg);
  static const ::meshtastic::QueueStatus& queuestatus(const FromRadio* msg);
  static const ::meshtastic::XModem& xmodempacket(const FromRadio* msg);
  static const ::meshtastic::DeviceMetadata& metadata(const FromRadio* msg);
  static const ::meshtastic::MqttClientProxyMessage& mqttclientproxymessage(const FromRadio* msg);
  static const ::meshtastic::FileInfo& fileinfo(const FromRadio* msg);
  static const ::meshtastic::ClientNotification& clientnotification(const FromRadio* msg);
  static const ::meshtastic::DeviceUIConfig& deviceuiconfig(const FromRadio* msg);
};

const ::meshtastic::MeshPacket&
FromRadio::_Internal::packet(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.packet_;
}
const ::meshtastic::MyNodeInfo&
FromRadio::_Internal::my_info(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.my_info_;
}
const ::meshtastic::NodeInfo&
FromRadio::_Internal::node_info(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.node_info_;
}
const ::meshtastic::Config&
FromRadio::_Internal::config(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.config_;
}
const ::meshtastic::LogRecord&
FromRadio::_Internal::log_record(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.log_record_;
}
const ::meshtastic::ModuleConfig&
FromRadio::_Internal::moduleconfig(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.moduleconfig_;
}
const ::meshtastic::Channel&
FromRadio::_Internal::channel(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.channel_;
}
const ::meshtastic::QueueStatus&
FromRadio::_Internal::queuestatus(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.queuestatus_;
}
const ::meshtastic::XModem&
FromRadio::_Internal::xmodempacket(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.xmodempacket_;
}
const ::meshtastic::DeviceMetadata&
FromRadio::_Internal::metadata(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.metadata_;
}
const ::meshtastic::MqttClientProxyMessage&
FromRadio::_Internal::mqttclientproxymessage(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.mqttclientproxymessage_;
}
const ::meshtastic::FileInfo&
FromRadio::_Internal::fileinfo(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.fileinfo_;
}
const ::meshtastic::ClientNotification&
FromRadio::_Internal::clientnotification(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.clientnotification_;
}
const ::meshtastic::DeviceUIConfig&
FromRadio::_Internal::deviceuiconfig(const FromRadio* msg) {
  return *msg->_impl_.payload_variant_.deviceuiconfig_;
}
void FromRadio::set_allocated_packet(::meshtastic::MeshPacket* packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(packet);
    if (message_arena != submessage_arena) {
      packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet, submessage_arena);
    }
    set_has_packet();
    _impl_.payload_variant_.packet_ = packet;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.packet)
}
void FromRadio::set_allocated_my_info(::meshtastic::MyNodeInfo* my_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (my_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(my_info);
    if (message_arena != submessage_arena) {
      my_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, my_info, submessage_arena);
    }
    set_has_my_info();
    _impl_.payload_variant_.my_info_ = my_info;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.my_info)
}
void FromRadio::set_allocated_node_info(::meshtastic::NodeInfo* node_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (node_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(node_info);
    if (message_arena != submessage_arena) {
      node_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_info, submessage_arena);
    }
    set_has_node_info();
    _impl_.payload_variant_.node_info_ = node_info;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.node_info)
}
void FromRadio::set_allocated_config(::meshtastic::Config* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config));
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    set_has_config();
    _impl_.payload_variant_.config_ = config;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.config)
}
void FromRadio::clear_config() {
  if (_internal_has_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.config_;
    }
    clear_has_payload_variant();
  }
}
void FromRadio::set_allocated_log_record(::meshtastic::LogRecord* log_record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (log_record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(log_record);
    if (message_arena != submessage_arena) {
      log_record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_record, submessage_arena);
    }
    set_has_log_record();
    _impl_.payload_variant_.log_record_ = log_record;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.log_record)
}
void FromRadio::set_allocated_moduleconfig(::meshtastic::ModuleConfig* moduleconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (moduleconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(moduleconfig));
    if (message_arena != submessage_arena) {
      moduleconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, moduleconfig, submessage_arena);
    }
    set_has_moduleconfig();
    _impl_.payload_variant_.moduleconfig_ = moduleconfig;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.moduleConfig)
}
void FromRadio::clear_moduleconfig() {
  if (_internal_has_moduleconfig()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.moduleconfig_;
    }
    clear_has_payload_variant();
  }
}
void FromRadio::set_allocated_channel(::meshtastic::Channel* channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(channel));
    if (message_arena != submessage_arena) {
      channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    set_has_channel();
    _impl_.payload_variant_.channel_ = channel;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.channel)
}
void FromRadio::clear_channel() {
  if (_internal_has_channel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.channel_;
    }
    clear_has_payload_variant();
  }
}
void FromRadio::set_allocated_queuestatus(::meshtastic::QueueStatus* queuestatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (queuestatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(queuestatus);
    if (message_arena != submessage_arena) {
      queuestatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, queuestatus, submessage_arena);
    }
    set_has_queuestatus();
    _impl_.payload_variant_.queuestatus_ = queuestatus;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.queueStatus)
}
void FromRadio::set_allocated_xmodempacket(::meshtastic::XModem* xmodempacket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (xmodempacket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(xmodempacket));
    if (message_arena != submessage_arena) {
      xmodempacket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xmodempacket, submessage_arena);
    }
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ = xmodempacket;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.xmodemPacket)
}
void FromRadio::clear_xmodempacket() {
  if (_internal_has_xmodempacket()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.xmodempacket_;
    }
    clear_has_payload_variant();
  }
}
void FromRadio::set_allocated_metadata(::meshtastic::DeviceMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    set_has_metadata();
    _impl_.payload_variant_.metadata_ = metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.metadata)
}
void FromRadio::set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* mqttclientproxymessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (mqttclientproxymessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mqttclientproxymessage);
    if (message_arena != submessage_arena) {
      mqttclientproxymessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mqttclientproxymessage, submessage_arena);
    }
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ = mqttclientproxymessage;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.mqttClientProxyMessage)
}
void FromRadio::set_allocated_fileinfo(::meshtastic::FileInfo* fileinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (fileinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fileinfo);
    if (message_arena != submessage_arena) {
      fileinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fileinfo, submessage_arena);
    }
    set_has_fileinfo();
    _impl_.payload_variant_.fileinfo_ = fileinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.fileInfo)
}
void FromRadio::set_allocated_clientnotification(::meshtastic::ClientNotification* clientnotification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (clientnotification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clientnotification);
    if (message_arena != submessage_arena) {
      clientnotification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clientnotification, submessage_arena);
    }
    set_has_clientnotification();
    _impl_.payload_variant_.clientnotification_ = clientnotification;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.clientNotification)
}
void FromRadio::set_allocated_deviceuiconfig(::meshtastic::DeviceUIConfig* deviceuiconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (deviceuiconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deviceuiconfig));
    if (message_arena != submessage_arena) {
      deviceuiconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deviceuiconfig, submessage_arena);
    }
    set_has_deviceuiconfig();
    _impl_.payload_variant_.deviceuiconfig_ = deviceuiconfig;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.deviceuiConfig)
}
void FromRadio::clear_deviceuiconfig() {
  if (_internal_has_deviceuiconfig()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.deviceuiconfig_;
    }
    clear_has_payload_variant();
  }
}
FromRadio::FromRadio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.FromRadio)
}
FromRadio::FromRadio(const FromRadio& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FromRadio* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  clear_has_payload_variant();
  switch (from.payload_variant_case()) {
    case kPacket: {
      _this->_internal_mutable_packet()->::meshtastic::MeshPacket::MergeFrom(
          from._internal_packet());
      break;
    }
    case kMyInfo: {
      _this->_internal_mutable_my_info()->::meshtastic::MyNodeInfo::MergeFrom(
          from._internal_my_info());
      break;
    }
    case kNodeInfo: {
      _this->_internal_mutable_node_info()->::meshtastic::NodeInfo::MergeFrom(
          from._internal_node_info());
      break;
    }
    case kConfig: {
      _this->_internal_mutable_config()->::meshtastic::Config::MergeFrom(
          from._internal_config());
      break;
    }
    case kLogRecord: {
      _this->_internal_mutable_log_record()->::meshtastic::LogRecord::MergeFrom(
          from._internal_log_record());
      break;
    }
    case kConfigCompleteId: {
      _this->_internal_set_config_complete_id(from._internal_config_complete_id());
      break;
    }
    case kRebooted: {
      _this->_internal_set_rebooted(from._internal_rebooted());
      break;
    }
    case kModuleConfig: {
      _this->_internal_mutable_moduleconfig()->::meshtastic::ModuleConfig::MergeFrom(
          from._internal_moduleconfig());
      break;
    }
    case kChannel: {
      _this->_internal_mutable_channel()->::meshtastic::Channel::MergeFrom(
          from._internal_channel());
      break;
    }
    case kQueueStatus: {
      _this->_internal_mutable_queuestatus()->::meshtastic::QueueStatus::MergeFrom(
          from._internal_queuestatus());
      break;
    }
    case kXmodemPacket: {
      _this->_internal_mutable_xmodempacket()->::meshtastic::XModem::MergeFrom(
          from._internal_xmodempacket());
      break;
    }
    case kMetadata: {
      _this->_internal_mutable_metadata()->::meshtastic::DeviceMetadata::MergeFrom(
          from._internal_metadata());
      break;
    }
    case kMqttClientProxyMessage: {
      _this->_internal_mutable_mqttclientproxymessage()->::meshtastic::MqttClientProxyMessage::MergeFrom(
          from._internal_mqttclientproxymessage());
      break;
    }
    case kFileInfo: {
      _this->_internal_mutable_fileinfo()->::meshtastic::FileInfo::MergeFrom(
          from._internal_fileinfo());
      break;
    }
    case kClientNotification: {
      _this->_internal_mutable_clientnotification()->::meshtastic::ClientNotification::MergeFrom(
          from._internal_clientnotification());
      break;
    }
    case kDeviceuiConfig: {
      _this->_internal_mutable_deviceuiconfig()->::meshtastic::DeviceUIConfig::MergeFrom(
          from._internal_deviceuiconfig());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:meshtastic.FromRadio)
}

inline void FromRadio::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){0u}
    , decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload_variant();
}

FromRadio::~FromRadio() {
  // @@protoc_insertion_point(destructor:meshtastic.FromRadio)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FromRadio::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
}

void FromRadio::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FromRadio::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.FromRadio)
  switch (payload_variant_case()) {
    case kPacket: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.packet_;
      }
      break;
    }
    case kMyInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.my_info_;
      }
      break;
    }
    case kNodeInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.node_info_;
      }
      break;
    }
    case kConfig: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.config_;
      }
      break;
    }
    case kLogRecord: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.log_record_;
      }
      break;
    }
    case kConfigCompleteId: {
      // No need to clear
      break;
    }
    case kRebooted: {
      // No need to clear
      break;
    }
    case kModuleConfig: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.moduleconfig_;
      }
      break;
    }
    case kChannel: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.channel_;
      }
      break;
    }
    case kQueueStatus: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.queuestatus_;
      }
      break;
    }
    case kXmodemPacket: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.xmodempacket_;
      }
      break;
    }
    case kMetadata: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.metadata_;
      }
      break;
    }
    case kMqttClientProxyMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.mqttclientproxymessage_;
      }
      break;
    }
    case kFileInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.fileinfo_;
      }
      break;
    }
    case kClientNotification: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.clientnotification_;
      }
      break;
    }
    case kDeviceuiConfig: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.deviceuiconfig_;
      }
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


void FromRadio::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.FromRadio)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = 0u;
  clear_payload_variant();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FromRadio::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.MeshPacket packet = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_packet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.MyNodeInfo my_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_my_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.NodeInfo node_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_node_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.Config config = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.LogRecord log_record = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_log_record(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 config_complete_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _internal_set_config_complete_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool rebooted = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _internal_set_rebooted(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig moduleConfig = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_moduleconfig(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.Channel channel = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_channel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.QueueStatus queueStatus = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_queuestatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.XModem xmodemPacket = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_xmodempacket(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.DeviceMetadata metadata = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_mqttclientproxymessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.FileInfo fileInfo = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_fileinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ClientNotification clientNotification = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_clientnotification(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.DeviceUIConfig deviceuiConfig = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_deviceuiconfig(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FromRadio::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.FromRadio)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // .meshtastic.MeshPacket packet = 2;
  if (_internal_has_packet()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::packet(this),
        _Internal::packet(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.MyNodeInfo my_info = 3;
  if (_internal_has_my_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::my_info(this),
        _Internal::my_info(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.NodeInfo node_info = 4;
  if (_internal_has_node_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::node_info(this),
        _Internal::node_info(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.Config config = 5;
  if (_internal_has_config()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::config(this),
        _Internal::config(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.LogRecord log_record = 6;
  if (_internal_has_log_record()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::log_record(this),
        _Internal::log_record(this).GetCachedSize(), target, stream);
  }

  // uint32 config_complete_id = 7;
  if (_internal_has_config_complete_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_config_complete_id(), target);
  }

  // bool rebooted = 8;
  if (_internal_has_rebooted()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_rebooted(), target);
  }

  // .meshtastic.ModuleConfig moduleConfig = 9;
  if (_internal_has_moduleconfig()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::moduleconfig(this),
        _Internal::moduleconfig(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.Channel channel = 10;
  if (_internal_has_channel()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::channel(this),
        _Internal::channel(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.QueueStatus queueStatus = 11;
  if (_internal_has_queuestatus()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::queuestatus(this),
        _Internal::queuestatus(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.XModem xmodemPacket = 12;
  if (_internal_has_xmodempacket()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::xmodempacket(this),
        _Internal::xmodempacket(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.DeviceMetadata metadata = 13;
  if (_internal_has_metadata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 14;
  if (_internal_has_mqttclientproxymessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::mqttclientproxymessage(this),
        _Internal::mqttclientproxymessage(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.FileInfo fileInfo = 15;
  if (_internal_has_fileinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::fileinfo(this),
        _Internal::fileinfo(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ClientNotification clientNotification = 16;
  if (_internal_has_clientnotification()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::clientnotification(this),
        _Internal::clientnotification(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.DeviceUIConfig deviceuiConfig = 17;
  if (_internal_has_deviceuiconfig()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::deviceuiconfig(this),
        _Internal::deviceuiconfig(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.FromRadio)
  return target;
}

size_t FromRadio::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.FromRadio)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  switch (payload_variant_case()) {
    // .meshtastic.MeshPacket packet = 2;
    case kPacket: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.packet_);
      break;
    }
    // .meshtastic.MyNodeInfo my_info = 3;
    case kMyInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.my_info_);
      break;
    }
    // .meshtastic.NodeInfo node_info = 4;
    case kNodeInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.node_info_);
      break;
    }
    // .meshtastic.Config config = 5;
    case kConfig: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.config_);
      break;
    }
    // .meshtastic.LogRecord log_record = 6;
    case kLogRecord: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.log_record_);
      break;
    }
    // uint32 config_complete_id = 7;
    case kConfigCompleteId: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_config_complete_id());
      break;
    }
    // bool rebooted = 8;
    case kRebooted: {
      total_size += 1 + 1;
      break;
    }
    // .meshtastic.ModuleConfig moduleConfig = 9;
    case kModuleConfig: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.moduleconfig_);
      break;
    }
    // .meshtastic.Channel channel = 10;
    case kChannel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.channel_);
      break;
    }
    // .meshtastic.QueueStatus queueStatus = 11;
    case kQueueStatus: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.queuestatus_);
      break;
    }
    // .meshtastic.XModem xmodemPacket = 12;
    case kXmodemPacket: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.xmodempacket_);
      break;
    }
    // .meshtastic.DeviceMetadata metadata = 13;
    case kMetadata: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.metadata_);
      break;
    }
    // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 14;
    case kMqttClientProxyMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.mqttclientproxymessage_);
      break;
    }
    // .meshtastic.FileInfo fileInfo = 15;
    case kFileInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.fileinfo_);
      break;
    }
    // .meshtastic.ClientNotification clientNotification = 16;
    case kClientNotification: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.clientnotification_);
      break;
    }
    // .meshtastic.DeviceUIConfig deviceuiConfig = 17;
    case kDeviceuiConfig: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.deviceuiconfig_);
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FromRadio::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FromRadio::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FromRadio::GetClassData() const { return &_class_data_; }


void FromRadio::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FromRadio*>(&to_msg);
  auto& from = static_cast<const FromRadio&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.FromRadio)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  switch (from.payload_variant_case()) {
    case kPacket: {
      _this->_internal_mutable_packet()->::meshtastic::MeshPacket::MergeFrom(
          from._internal_packet());
      break;
    }
    case kMyInfo: {
      _this->_internal_mutable_my_info()->::meshtastic::MyNodeInfo::MergeFrom(
          from._internal_my_info());
      break;
    }
    case kNodeInfo: {
      _this->_internal_mutable_node_info()->::meshtastic::NodeInfo::MergeFrom(
          from._internal_node_info());
      break;
    }
    case kConfig: {
      _this->_internal_mutable_config()->::meshtastic::Config::MergeFrom(
          from._internal_config());
      break;
    }
    case kLogRecord: {
      _this->_internal_mutable_log_record()->::meshtastic::LogRecord::MergeFrom(
          from._internal_log_record());
      break;
    }
    case kConfigCompleteId: {
      _this->_internal_set_config_complete_id(from._internal_config_complete_id());
      break;
    }
    case kRebooted: {
      _this->_internal_set_rebooted(from._internal_rebooted());
      break;
    }
    case kModuleConfig: {
      _this->_internal_mutable_moduleconfig()->::meshtastic::ModuleConfig::MergeFrom(
          from._internal_moduleconfig());
      break;
    }
    case kChannel: {
      _this->_internal_mutable_channel()->::meshtastic::Channel::MergeFrom(
          from._internal_channel());
      break;
    }
    case kQueueStatus: {
      _this->_internal_mutable_queuestatus()->::meshtastic::QueueStatus::MergeFrom(
          from._internal_queuestatus());
      break;
    }
    case kXmodemPacket: {
      _this->_internal_mutable_xmodempacket()->::meshtastic::XModem::MergeFrom(
          from._internal_xmodempacket());
      break;
    }
    case kMetadata: {
      _this->_internal_mutable_metadata()->::meshtastic::DeviceMetadata::MergeFrom(
          from._internal_metadata());
      break;
    }
    case kMqttClientProxyMessage: {
      _this->_internal_mutable_mqttclientproxymessage()->::meshtastic::MqttClientProxyMessage::MergeFrom(
          from._internal_mqttclientproxymessage());
      break;
    }
    case kFileInfo: {
      _this->_internal_mutable_fileinfo()->::meshtastic::FileInfo::MergeFrom(
          from._internal_fileinfo());
      break;
    }
    case kClientNotification: {
      _this->_internal_mutable_clientnotification()->::meshtastic::ClientNotification::MergeFrom(
          from._internal_clientnotification());
      break;
    }
    case kDeviceuiConfig: {
      _this->_internal_mutable_deviceuiconfig()->::meshtastic::DeviceUIConfig::MergeFrom(
          from._internal_deviceuiconfig());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FromRadio::CopyFrom(const FromRadio& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.FromRadio)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FromRadio::IsInitialized() const {
  return true;
}

void FromRadio::InternalSwap(FromRadio* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.id_, other->_impl_.id_);
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FromRadio::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[13]);
}

// ===================================================================

class ClientNotification::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientNotification>()._impl_._has_bits_);
  static void set_has_reply_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::meshtastic::KeyVerificationNumberInform& key_verification_number_inform(const ClientNotification* msg);
  static const ::meshtastic::KeyVerificationNumberRequest& key_verification_number_request(const ClientNotification* msg);
  static const ::meshtastic::KeyVerificationFinal& key_verification_final(const ClientNotification* msg);
  static const ::meshtastic::DuplicatedPublicKey& duplicated_public_key(const ClientNotification* msg);
  static const ::meshtastic::LowEntropyKey& low_entropy_key(const ClientNotification* msg);
};

const ::meshtastic::KeyVerificationNumberInform&
ClientNotification::_Internal::key_verification_number_inform(const ClientNotification* msg) {
  return *msg->_impl_.payload_variant_.key_verification_number_inform_;
}
const ::meshtastic::KeyVerificationNumberRequest&
ClientNotification::_Internal::key_verification_number_request(const ClientNotification* msg) {
  return *msg->_impl_.payload_variant_.key_verification_number_request_;
}
const ::meshtastic::KeyVerificationFinal&
ClientNotification::_Internal::key_verification_final(const ClientNotification* msg) {
  return *msg->_impl_.payload_variant_.key_verification_final_;
}
const ::meshtastic::DuplicatedPublicKey&
ClientNotification::_Internal::duplicated_public_key(const ClientNotification* msg) {
  return *msg->_impl_.payload_variant_.duplicated_public_key_;
}
const ::meshtastic::LowEntropyKey&
ClientNotification::_Internal::low_entropy_key(const ClientNotification* msg) {
  return *msg->_impl_.payload_variant_.low_entropy_key_;
}
void ClientNotification::set_allocated_key_verification_number_inform(::meshtastic::KeyVerificationNumberInform* key_verification_number_inform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (key_verification_number_inform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key_verification_number_inform);
    if (message_arena != submessage_arena) {
      key_verification_number_inform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_verification_number_inform, submessage_arena);
    }
    set_has_key_verification_number_inform();
    _impl_.payload_variant_.key_verification_number_inform_ = key_verification_number_inform;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.key_verification_number_inform)
}
void ClientNotification::set_allocated_key_verification_number_request(::meshtastic::KeyVerificationNumberRequest* key_verification_number_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (key_verification_number_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key_verification_number_request);
    if (message_arena != submessage_arena) {
      key_verification_number_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_verification_number_request, submessage_arena);
    }
    set_has_key_verification_number_request();
    _impl_.payload_variant_.key_verification_number_request_ = key_verification_number_request;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.key_verification_number_request)
}
void ClientNotification::set_allocated_key_verification_final(::meshtastic::KeyVerificationFinal* key_verification_final) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (key_verification_final) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key_verification_final);
    if (message_arena != submessage_arena) {
      key_verification_final = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_verification_final, submessage_arena);
    }
    set_has_key_verification_final();
    _impl_.payload_variant_.key_verification_final_ = key_verification_final;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.key_verification_final)
}
void ClientNotification::set_allocated_duplicated_public_key(::meshtastic::DuplicatedPublicKey* duplicated_public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (duplicated_public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(duplicated_public_key);
    if (message_arena != submessage_arena) {
      duplicated_public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duplicated_public_key, submessage_arena);
    }
    set_has_duplicated_public_key();
    _impl_.payload_variant_.duplicated_public_key_ = duplicated_public_key;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.duplicated_public_key)
}
void ClientNotification::set_allocated_low_entropy_key(::meshtastic::LowEntropyKey* low_entropy_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (low_entropy_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(low_entropy_key);
    if (message_arena != submessage_arena) {
      low_entropy_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, low_entropy_key, submessage_arena);
    }
    set_has_low_entropy_key();
    _impl_.payload_variant_.low_entropy_key_ = low_entropy_key;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.low_entropy_key)
}
ClientNotification::ClientNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ClientNotification)
}
ClientNotification::ClientNotification(const ClientNotification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClientNotification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.reply_id_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.reply_id_, &from._impl_.reply_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.level_) -
    reinterpret_cast<char*>(&_impl_.reply_id_)) + sizeof(_impl_.level_));
  clear_has_payload_variant();
  switch (from.payload_variant_case()) {
    case kKeyVerificationNumberInform: {
      _this->_internal_mutable_key_verification_number_inform()->::meshtastic::KeyVerificationNumberInform::MergeFrom(
          from._internal_key_verification_number_inform());
      break;
    }
    case kKeyVerificationNumberRequest: {
      _this->_internal_mutable_key_verification_number_request()->::meshtastic::KeyVerificationNumberRequest::MergeFrom(
          from._internal_key_verification_number_request());
      break;
    }
    case kKeyVerificationFinal: {
      _this->_internal_mutable_key_verification_final()->::meshtastic::KeyVerificationFinal::MergeFrom(
          from._internal_key_verification_final());
      break;
    }
    case kDuplicatedPublicKey: {
      _this->_internal_mutable_duplicated_public_key()->::meshtastic::DuplicatedPublicKey::MergeFrom(
          from._internal_duplicated_public_key());
      break;
    }
    case kLowEntropyKey: {
      _this->_internal_mutable_low_entropy_key()->::meshtastic::LowEntropyKey::MergeFrom(
          from._internal_low_entropy_key());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:meshtastic.ClientNotification)
}

inline void ClientNotification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.reply_id_){0u}
    , decltype(_impl_.time_){0u}
    , decltype(_impl_.level_){0}
    , decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_payload_variant();
}

ClientNotification::~ClientNotification() {
  // @@protoc_insertion_point(destructor:meshtastic.ClientNotification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientNotification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  if (has_payload_variant()) {
    clear_payload_variant();
  }
}

void ClientNotification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientNotification::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.ClientNotification)
  switch (payload_variant_case()) {
    case kKeyVerificationNumberInform: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.key_verification_number_inform_;
      }
      break;
    }
    case kKeyVerificationNumberRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.key_verification_number_request_;
      }
      break;
    }
    case kKeyVerificationFinal: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.key_verification_final_;
      }
      break;
    }
    case kDuplicatedPublicKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.duplicated_public_key_;
      }
      break;
    }
    case kLowEntropyKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.low_entropy_key_;
      }
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


void ClientNotification::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ClientNotification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.reply_id_ = 0u;
  ::memset(&_impl_.time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.level_) -
      reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.level_));
  clear_payload_variant();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClientNotification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 reply_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reply_id(&has_bits);
          _impl_.reply_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // fixed32 time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.LogRecord.Level level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::meshtastic::LogRecord_Level>(val));
        } else
          goto handle_unusual;
        continue;
      // string message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.ClientNotification.message"));
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.KeyVerificationNumberInform key_verification_number_inform = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_key_verification_number_inform(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.KeyVerificationNumberRequest key_verification_number_request = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_key_verification_number_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.KeyVerificationFinal key_verification_final = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_key_verification_final(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.DuplicatedPublicKey duplicated_public_key = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_duplicated_public_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.LowEntropyKey low_entropy_key = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_low_entropy_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientNotification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ClientNotification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 reply_id = 1;
  if (_internal_has_reply_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_reply_id(), target);
  }

  // fixed32 time = 2;
  if (this->_internal_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_time(), target);
  }

  // .meshtastic.LogRecord.Level level = 3;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_level(), target);
  }

  // string message = 4;
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.ClientNotification.message");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_message(), target);
  }

  // .meshtastic.KeyVerificationNumberInform key_verification_number_inform = 11;
  if (_internal_has_key_verification_number_inform()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::key_verification_number_inform(this),
        _Internal::key_verification_number_inform(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.KeyVerificationNumberRequest key_verification_number_request = 12;
  if (_internal_has_key_verification_number_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::key_verification_number_request(this),
        _Internal::key_verification_number_request(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.KeyVerificationFinal key_verification_final = 13;
  if (_internal_has_key_verification_final()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::key_verification_final(this),
        _Internal::key_verification_final(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.DuplicatedPublicKey duplicated_public_key = 14;
  if (_internal_has_duplicated_public_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::duplicated_public_key(this),
        _Internal::duplicated_public_key(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.LowEntropyKey low_entropy_key = 15;
  if (_internal_has_low_entropy_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::low_entropy_key(this),
        _Internal::low_entropy_key(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ClientNotification)
  return target;
}

size_t ClientNotification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ClientNotification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 4;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  // optional uint32 reply_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reply_id());
  }

  // fixed32 time = 2;
  if (this->_internal_time() != 0) {
    total_size += 1 + 4;
  }

  // .meshtastic.LogRecord.Level level = 3;
  if (this->_internal_level() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  switch (payload_variant_case()) {
    // .meshtastic.KeyVerificationNumberInform key_verification_number_inform = 11;
    case kKeyVerificationNumberInform: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.key_verification_number_inform_);
      break;
    }
    // .meshtastic.KeyVerificationNumberRequest key_verification_number_request = 12;
    case kKeyVerificationNumberRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.key_verification_number_request_);
      break;
    }
    // .meshtastic.KeyVerificationFinal key_verification_final = 13;
    case kKeyVerificationFinal: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.key_verification_final_);
      break;
    }
    // .meshtastic.DuplicatedPublicKey duplicated_public_key = 14;
    case kDuplicatedPublicKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.duplicated_public_key_);
      break;
    }
    // .meshtastic.LowEntropyKey low_entropy_key = 15;
    case kLowEntropyKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.low_entropy_key_);
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClientNotification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClientNotification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClientNotification::GetClassData() const { return &_class_data_; }


void ClientNotification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClientNotification*>(&to_msg);
  auto& from = static_cast<const ClientNotification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ClientNotification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (from._internal_has_reply_id()) {
    _this->_internal_set_reply_id(from._internal_reply_id());
  }
  if (from._internal_time() != 0) {
    _this->_internal_set_time(from._internal_time());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  switch (from.payload_variant_case()) {
    case kKeyVerificationNumberInform: {
      _this->_internal_mutable_key_verification_number_inform()->::meshtastic::KeyVerificationNumberInform::MergeFrom(
          from._internal_key_verification_number_inform());
      break;
    }
    case kKeyVerificationNumberRequest: {
      _this->_internal_mutable_key_verification_number_request()->::meshtastic::KeyVerificationNumberRequest::MergeFrom(
          from._internal_key_verification_number_request());
      break;
    }
    case kKeyVerificationFinal: {
      _this->_internal_mutable_key_verification_final()->::meshtastic::KeyVerificationFinal::MergeFrom(
          from._internal_key_verification_final());
      break;
    }
    case kDuplicatedPublicKey: {
      _this->_internal_mutable_duplicated_public_key()->::meshtastic::DuplicatedPublicKey::MergeFrom(
          from._internal_duplicated_public_key());
      break;
    }
    case kLowEntropyKey: {
      _this->_internal_mutable_low_entropy_key()->::meshtastic::LowEntropyKey::MergeFrom(
          from._internal_low_entropy_key());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClientNotification::CopyFrom(const ClientNotification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ClientNotification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientNotification::IsInitialized() const {
  return true;
}

void ClientNotification::InternalSwap(ClientNotification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.level_)
      + sizeof(ClientNotification::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.reply_id_)>(
          reinterpret_cast<char*>(&_impl_.reply_id_),
          reinterpret_cast<char*>(&other->_impl_.reply_id_));
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ClientNotification::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[14]);
}

// ===================================================================

class KeyVerificationNumberInform::_Internal {
 public:
};

KeyVerificationNumberInform::KeyVerificationNumberInform(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.KeyVerificationNumberInform)
}
KeyVerificationNumberInform::KeyVerificationNumberInform(const KeyVerificationNumberInform& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyVerificationNumberInform* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.remote_longname_){}
    , decltype(_impl_.nonce_){}
    , decltype(_impl_.security_number_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.remote_longname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_longname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_remote_longname().empty()) {
    _this->_impl_.remote_longname_.Set(from._internal_remote_longname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.nonce_, &from._impl_.nonce_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.security_number_) -
    reinterpret_cast<char*>(&_impl_.nonce_)) + sizeof(_impl_.security_number_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.KeyVerificationNumberInform)
}

inline void KeyVerificationNumberInform::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.remote_longname_){}
    , decltype(_impl_.nonce_){uint64_t{0u}}
    , decltype(_impl_.security_number_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.remote_longname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_longname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyVerificationNumberInform::~KeyVerificationNumberInform() {
  // @@protoc_insertion_point(destructor:meshtastic.KeyVerificationNumberInform)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyVerificationNumberInform::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.remote_longname_.Destroy();
}

void KeyVerificationNumberInform::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyVerificationNumberInform::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.KeyVerificationNumberInform)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.remote_longname_.ClearToEmpty();
  ::memset(&_impl_.nonce_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.security_number_) -
      reinterpret_cast<char*>(&_impl_.nonce_)) + sizeof(_impl_.security_number_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyVerificationNumberInform::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 nonce = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string remote_longname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_remote_longname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.KeyVerificationNumberInform.remote_longname"));
        } else
          goto handle_unusual;
        continue;
      // uint32 security_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.security_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyVerificationNumberInform::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.KeyVerificationNumberInform)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 nonce = 1;
  if (this->_internal_nonce() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_nonce(), target);
  }

  // string remote_longname = 2;
  if (!this->_internal_remote_longname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_remote_longname().data(), static_cast<int>(this->_internal_remote_longname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.KeyVerificationNumberInform.remote_longname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_remote_longname(), target);
  }

  // uint32 security_number = 3;
  if (this->_internal_security_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_security_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.KeyVerificationNumberInform)
  return target;
}

size_t KeyVerificationNumberInform::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.KeyVerificationNumberInform)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string remote_longname = 2;
  if (!this->_internal_remote_longname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_remote_longname());
  }

  // uint64 nonce = 1;
  if (this->_internal_nonce() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_nonce());
  }

  // uint32 security_number = 3;
  if (this->_internal_security_number() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_security_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyVerificationNumberInform::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyVerificationNumberInform::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyVerificationNumberInform::GetClassData() const { return &_class_data_; }


void KeyVerificationNumberInform::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyVerificationNumberInform*>(&to_msg);
  auto& from = static_cast<const KeyVerificationNumberInform&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.KeyVerificationNumberInform)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_remote_longname().empty()) {
    _this->_internal_set_remote_longname(from._internal_remote_longname());
  }
  if (from._internal_nonce() != 0) {
    _this->_internal_set_nonce(from._internal_nonce());
  }
  if (from._internal_security_number() != 0) {
    _this->_internal_set_security_number(from._internal_security_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyVerificationNumberInform::CopyFrom(const KeyVerificationNumberInform& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.KeyVerificationNumberInform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyVerificationNumberInform::IsInitialized() const {
  return true;
}

void KeyVerificationNumberInform::InternalSwap(KeyVerificationNumberInform* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.remote_longname_, lhs_arena,
      &other->_impl_.remote_longname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_.security_number_)
      + sizeof(KeyVerificationNumberInform::_impl_.security_number_)
      - PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_.nonce_)>(
          reinterpret_cast<char*>(&_impl_.nonce_),
          reinterpret_cast<char*>(&other->_impl_.nonce_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyVerificationNumberInform::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[15]);
}

// ===================================================================

class KeyVerificationNumberRequest::_Internal {
 public:
};

KeyVerificationNumberRequest::KeyVerificationNumberRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.KeyVerificationNumberRequest)
}
KeyVerificationNumberRequest::KeyVerificationNumberRequest(const KeyVerificationNumberRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyVerificationNumberRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.remote_longname_){}
    , decltype(_impl_.nonce_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.remote_longname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_longname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_remote_longname().empty()) {
    _this->_impl_.remote_longname_.Set(from._internal_remote_longname(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.nonce_ = from._impl_.nonce_;
  // @@protoc_insertion_point(copy_constructor:meshtastic.KeyVerificationNumberRequest)
}

inline void KeyVerificationNumberRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.remote_longname_){}
    , decltype(_impl_.nonce_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.remote_longname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_longname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyVerificationNumberRequest::~KeyVerificationNumberRequest() {
  // @@protoc_insertion_point(destructor:meshtastic.KeyVerificationNumberRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyVerificationNumberRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.remote_longname_.Destroy();
}

void KeyVerificationNumberRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyVerificationNumberRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.KeyVerificationNumberRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.remote_longname_.ClearToEmpty();
  _impl_.nonce_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyVerificationNumberRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 nonce = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string remote_longname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_remote_longname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.KeyVerificationNumberRequest.remote_longname"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyVerificationNumberRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.KeyVerificationNumberRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 nonce = 1;
  if (this->_internal_nonce() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_nonce(), target);
  }

  // string remote_longname = 2;
  if (!this->_internal_remote_longname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_remote_longname().data(), static_cast<int>(this->_internal_remote_longname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.KeyVerificationNumberRequest.remote_longname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_remote_longname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.KeyVerificationNumberRequest)
  return target;
}

size_t KeyVerificationNumberRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.KeyVerificationNumberRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string remote_longname = 2;
  if (!this->_internal_remote_longname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_remote_longname());
  }

  // uint64 nonce = 1;
  if (this->_internal_nonce() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_nonce());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyVerificationNumberRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyVerificationNumberRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyVerificationNumberRequest::GetClassData() const { return &_class_data_; }


void KeyVerificationNumberRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyVerificationNumberRequest*>(&to_msg);
  auto& from = static_cast<const KeyVerificationNumberRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.KeyVerificationNumberRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_remote_longname().empty()) {
    _this->_internal_set_remote_longname(from._internal_remote_longname());
  }
  if (from._internal_nonce() != 0) {
    _this->_internal_set_nonce(from._internal_nonce());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyVerificationNumberRequest::CopyFrom(const KeyVerificationNumberRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.KeyVerificationNumberRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyVerificationNumberRequest::IsInitialized() const {
  return true;
}

void KeyVerificationNumberRequest::InternalSwap(KeyVerificationNumberRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.remote_longname_, lhs_arena,
      &other->_impl_.remote_longname_, rhs_arena
  );
  swap(_impl_.nonce_, other->_impl_.nonce_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyVerificationNumberRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[16]);
}

// ===================================================================

class KeyVerificationFinal::_Internal {
 public:
};

KeyVerificationFinal::KeyVerificationFinal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.KeyVerificationFinal)
}
KeyVerificationFinal::KeyVerificationFinal(const KeyVerificationFinal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyVerificationFinal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.remote_longname_){}
    , decltype(_impl_.verification_characters_){}
    , decltype(_impl_.nonce_){}
    , decltype(_impl_.issender_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.remote_longname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_longname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_remote_longname().empty()) {
    _this->_impl_.remote_longname_.Set(from._internal_remote_longname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.verification_characters_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verification_characters_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_verification_characters().empty()) {
    _this->_impl_.verification_characters_.Set(from._internal_verification_characters(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.nonce_, &from._impl_.nonce_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.issender_) -
    reinterpret_cast<char*>(&_impl_.nonce_)) + sizeof(_impl_.issender_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.KeyVerificationFinal)
}

inline void KeyVerificationFinal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.remote_longname_){}
    , decltype(_impl_.verification_characters_){}
    , decltype(_impl_.nonce_){uint64_t{0u}}
    , decltype(_impl_.issender_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.remote_longname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_longname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.verification_characters_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verification_characters_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyVerificationFinal::~KeyVerificationFinal() {
  // @@protoc_insertion_point(destructor:meshtastic.KeyVerificationFinal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyVerificationFinal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.remote_longname_.Destroy();
  _impl_.verification_characters_.Destroy();
}

void KeyVerificationFinal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyVerificationFinal::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.KeyVerificationFinal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.remote_longname_.ClearToEmpty();
  _impl_.verification_characters_.ClearToEmpty();
  ::memset(&_impl_.nonce_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.issender_) -
      reinterpret_cast<char*>(&_impl_.nonce_)) + sizeof(_impl_.issender_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyVerificationFinal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 nonce = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string remote_longname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_remote_longname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.KeyVerificationFinal.remote_longname"));
        } else
          goto handle_unusual;
        continue;
      // bool isSender = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.issender_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string verification_characters = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_verification_characters();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.KeyVerificationFinal.verification_characters"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyVerificationFinal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.KeyVerificationFinal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 nonce = 1;
  if (this->_internal_nonce() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_nonce(), target);
  }

  // string remote_longname = 2;
  if (!this->_internal_remote_longname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_remote_longname().data(), static_cast<int>(this->_internal_remote_longname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.KeyVerificationFinal.remote_longname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_remote_longname(), target);
  }

  // bool isSender = 3;
  if (this->_internal_issender() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_issender(), target);
  }

  // string verification_characters = 4;
  if (!this->_internal_verification_characters().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_verification_characters().data(), static_cast<int>(this->_internal_verification_characters().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.KeyVerificationFinal.verification_characters");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_verification_characters(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.KeyVerificationFinal)
  return target;
}

size_t KeyVerificationFinal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.KeyVerificationFinal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string remote_longname = 2;
  if (!this->_internal_remote_longname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_remote_longname());
  }

  // string verification_characters = 4;
  if (!this->_internal_verification_characters().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_verification_characters());
  }

  // uint64 nonce = 1;
  if (this->_internal_nonce() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_nonce());
  }

  // bool isSender = 3;
  if (this->_internal_issender() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyVerificationFinal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyVerificationFinal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyVerificationFinal::GetClassData() const { return &_class_data_; }


void KeyVerificationFinal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyVerificationFinal*>(&to_msg);
  auto& from = static_cast<const KeyVerificationFinal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.KeyVerificationFinal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_remote_longname().empty()) {
    _this->_internal_set_remote_longname(from._internal_remote_longname());
  }
  if (!from._internal_verification_characters().empty()) {
    _this->_internal_set_verification_characters(from._internal_verification_characters());
  }
  if (from._internal_nonce() != 0) {
    _this->_internal_set_nonce(from._internal_nonce());
  }
  if (from._internal_issender() != 0) {
    _this->_internal_set_issender(from._internal_issender());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyVerificationFinal::CopyFrom(const KeyVerificationFinal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.KeyVerificationFinal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyVerificationFinal::IsInitialized() const {
  return true;
}

void KeyVerificationFinal::InternalSwap(KeyVerificationFinal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.remote_longname_, lhs_arena,
      &other->_impl_.remote_longname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.verification_characters_, lhs_arena,
      &other->_impl_.verification_characters_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.issender_)
      + sizeof(KeyVerificationFinal::_impl_.issender_)
      - PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.nonce_)>(
          reinterpret_cast<char*>(&_impl_.nonce_),
          reinterpret_cast<char*>(&other->_impl_.nonce_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyVerificationFinal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[17]);
}

// ===================================================================

class DuplicatedPublicKey::_Internal {
 public:
};

DuplicatedPublicKey::DuplicatedPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:meshtastic.DuplicatedPublicKey)
}
DuplicatedPublicKey::DuplicatedPublicKey(const DuplicatedPublicKey& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DuplicatedPublicKey* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:meshtastic.DuplicatedPublicKey)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DuplicatedPublicKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DuplicatedPublicKey::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DuplicatedPublicKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[18]);
}

// ===================================================================

class LowEntropyKey::_Internal {
 public:
};

LowEntropyKey::LowEntropyKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:meshtastic.LowEntropyKey)
}
LowEntropyKey::LowEntropyKey(const LowEntropyKey& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  LowEntropyKey* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:meshtastic.LowEntropyKey)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LowEntropyKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LowEntropyKey::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata LowEntropyKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[19]);
}

// ===================================================================

class FileInfo::_Internal {
 public:
};

FileInfo::FileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.FileInfo)
}
FileInfo::FileInfo(const FileInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FileInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.file_name_){}
    , decltype(_impl_.size_bytes_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_name().empty()) {
    _this->_impl_.file_name_.Set(from._internal_file_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.size_bytes_ = from._impl_.size_bytes_;
  // @@protoc_insertion_point(copy_constructor:meshtastic.FileInfo)
}

inline void FileInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.file_name_){}
    , decltype(_impl_.size_bytes_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FileInfo::~FileInfo() {
  // @@protoc_insertion_point(destructor:meshtastic.FileInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.file_name_.Destroy();
}

void FileInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.FileInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.file_name_.ClearToEmpty();
  _impl_.size_bytes_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string file_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_file_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.FileInfo.file_name"));
        } else
          goto handle_unusual;
        continue;
      // uint32 size_bytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.FileInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string file_name = 1;
  if (!this->_internal_file_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_name().data(), static_cast<int>(this->_internal_file_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.FileInfo.file_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_file_name(), target);
  }

  // uint32 size_bytes = 2;
  if (this->_internal_size_bytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_size_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.FileInfo)
  return target;
}

size_t FileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.FileInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string file_name = 1;
  if (!this->_internal_file_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_name());
  }

  // uint32 size_bytes = 2;
  if (this->_internal_size_bytes() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size_bytes());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FileInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileInfo::GetClassData() const { return &_class_data_; }


void FileInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FileInfo*>(&to_msg);
  auto& from = static_cast<const FileInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.FileInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_file_name().empty()) {
    _this->_internal_set_file_name(from._internal_file_name());
  }
  if (from._internal_size_bytes() != 0) {
    _this->_internal_set_size_bytes(from._internal_size_bytes());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileInfo::CopyFrom(const FileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.FileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileInfo::IsInitialized() const {
  return true;
}

void FileInfo::InternalSwap(FileInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_name_, lhs_arena,
      &other->_impl_.file_name_, rhs_arena
  );
  swap(_impl_.size_bytes_, other->_impl_.size_bytes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[20]);
}

// ===================================================================

class ToRadio::_Internal {
 public:
  static const ::meshtastic::MeshPacket& packet(const ToRadio* msg);
  static const ::meshtastic::XModem& xmodempacket(const ToRadio* msg);
  static const ::meshtastic::MqttClientProxyMessage& mqttclientproxymessage(const ToRadio* msg);
  static const ::meshtastic::Heartbeat& heartbeat(const ToRadio* msg);
};

const ::meshtastic::MeshPacket&
ToRadio::_Internal::packet(const ToRadio* msg) {
  return *msg->_impl_.payload_variant_.packet_;
}
const ::meshtastic::XModem&
ToRadio::_Internal::xmodempacket(const ToRadio* msg) {
  return *msg->_impl_.payload_variant_.xmodempacket_;
}
const ::meshtastic::MqttClientProxyMessage&
ToRadio::_Internal::mqttclientproxymessage(const ToRadio* msg) {
  return *msg->_impl_.payload_variant_.mqttclientproxymessage_;
}
const ::meshtastic::Heartbeat&
ToRadio::_Internal::heartbeat(const ToRadio* msg) {
  return *msg->_impl_.payload_variant_.heartbeat_;
}
void ToRadio::set_allocated_packet(::meshtastic::MeshPacket* packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(packet);
    if (message_arena != submessage_arena) {
      packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet, submessage_arena);
    }
    set_has_packet();
    _impl_.payload_variant_.packet_ = packet;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ToRadio.packet)
}
void ToRadio::set_allocated_xmodempacket(::meshtastic::XModem* xmodempacket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (xmodempacket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(xmodempacket));
    if (message_arena != submessage_arena) {
      xmodempacket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xmodempacket, submessage_arena);
    }
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ = xmodempacket;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ToRadio.xmodemPacket)
}
void ToRadio::clear_xmodempacket() {
  if (_internal_has_xmodempacket()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_variant_.xmodempacket_;
    }
    clear_has_payload_variant();
  }
}
void ToRadio::set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* mqttclientproxymessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (mqttclientproxymessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mqttclientproxymessage);
    if (message_arena != submessage_arena) {
      mqttclientproxymessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mqttclientproxymessage, submessage_arena);
    }
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ = mqttclientproxymessage;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ToRadio.mqttClientProxyMessage)
}
void ToRadio::set_allocated_heartbeat(::meshtastic::Heartbeat* heartbeat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (heartbeat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heartbeat);
    if (message_arena != submessage_arena) {
      heartbeat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heartbeat, submessage_arena);
    }
    set_has_heartbeat();
    _impl_.payload_variant_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ToRadio.heartbeat)
}
ToRadio::ToRadio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ToRadio)
}
ToRadio::ToRadio(const ToRadio& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ToRadio* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_payload_variant();
  switch (from.payload_variant_case()) {
    case kPacket: {
      _this->_internal_mutable_packet()->::meshtastic::MeshPacket::MergeFrom(
          from._internal_packet());
      break;
    }
    case kWantConfigId: {
      _this->_internal_set_want_config_id(from._internal_want_config_id());
      break;
    }
    case kDisconnect: {
      _this->_internal_set_disconnect(from._internal_disconnect());
      break;
    }
    case kXmodemPacket: {
      _this->_internal_mutable_xmodempacket()->::meshtastic::XModem::MergeFrom(
          from._internal_xmodempacket());
      break;
    }
    case kMqttClientProxyMessage: {
      _this->_internal_mutable_mqttclientproxymessage()->::meshtastic::MqttClientProxyMessage::MergeFrom(
          from._internal_mqttclientproxymessage());
      break;
    }
    case kHeartbeat: {
      _this->_internal_mutable_heartbeat()->::meshtastic::Heartbeat::MergeFrom(
          from._internal_heartbeat());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:meshtastic.ToRadio)
}

inline void ToRadio::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload_variant();
}

ToRadio::~ToRadio() {
  // @@protoc_insertion_point(destructor:meshtastic.ToRadio)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ToRadio::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
}

void ToRadio::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ToRadio::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.ToRadio)
  switch (payload_variant_case()) {
    case kPacket: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.packet_;
      }
      break;
    }
    case kWantConfigId: {
      // No need to clear
      break;
    }
    case kDisconnect: {
      // No need to clear
      break;
    }
    case kXmodemPacket: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.xmodempacket_;
      }
      break;
    }
    case kMqttClientProxyMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.mqttclientproxymessage_;
      }
      break;
    }
    case kHeartbeat: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.heartbeat_;
      }
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


void ToRadio::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ToRadio)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_payload_variant();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ToRadio::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .meshtastic.MeshPacket packet = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_packet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 want_config_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_want_config_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool disconnect = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_disconnect(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.XModem xmodemPacket = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_xmodempacket(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_mqttclientproxymessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.Heartbeat heartbeat = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_heartbeat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ToRadio::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ToRadio)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .meshtastic.MeshPacket packet = 1;
  if (_internal_has_packet()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::packet(this),
        _Internal::packet(this).GetCachedSize(), target, stream);
  }

  // uint32 want_config_id = 3;
  if (_internal_has_want_config_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_want_config_id(), target);
  }

  // bool disconnect = 4;
  if (_internal_has_disconnect()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_disconnect(), target);
  }

  // .meshtastic.XModem xmodemPacket = 5;
  if (_internal_has_xmodempacket()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::xmodempacket(this),
        _Internal::xmodempacket(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 6;
  if (_internal_has_mqttclientproxymessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::mqttclientproxymessage(this),
        _Internal::mqttclientproxymessage(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.Heartbeat heartbeat = 7;
  if (_internal_has_heartbeat()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::heartbeat(this),
        _Internal::heartbeat(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ToRadio)
  return target;
}

size_t ToRadio::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ToRadio)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (payload_variant_case()) {
    // .meshtastic.MeshPacket packet = 1;
    case kPacket: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.packet_);
      break;
    }
    // uint32 want_config_id = 3;
    case kWantConfigId: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_want_config_id());
      break;
    }
    // bool disconnect = 4;
    case kDisconnect: {
      total_size += 1 + 1;
      break;
    }
    // .meshtastic.XModem xmodemPacket = 5;
    case kXmodemPacket: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.xmodempacket_);
      break;
    }
    // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 6;
    case kMqttClientProxyMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.mqttclientproxymessage_);
      break;
    }
    // .meshtastic.Heartbeat heartbeat = 7;
    case kHeartbeat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.heartbeat_);
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ToRadio::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ToRadio::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ToRadio::GetClassData() const { return &_class_data_; }


void ToRadio::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ToRadio*>(&to_msg);
  auto& from = static_cast<const ToRadio&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ToRadio)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.payload_variant_case()) {
    case kPacket: {
      _this->_internal_mutable_packet()->::meshtastic::MeshPacket::MergeFrom(
          from._internal_packet());
      break;
    }
    case kWantConfigId: {
      _this->_internal_set_want_config_id(from._internal_want_config_id());
      break;
    }
    case kDisconnect: {
      _this->_internal_set_disconnect(from._internal_disconnect());
      break;
    }
    case kXmodemPacket: {
      _this->_internal_mutable_xmodempacket()->::meshtastic::XModem::MergeFrom(
          from._internal_xmodempacket());
      break;
    }
    case kMqttClientProxyMessage: {
      _this->_internal_mutable_mqttclientproxymessage()->::meshtastic::MqttClientProxyMessage::MergeFrom(
          from._internal_mqttclientproxymessage());
      break;
    }
    case kHeartbeat: {
      _this->_internal_mutable_heartbeat()->::meshtastic::Heartbeat::MergeFrom(
          from._internal_heartbeat());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ToRadio::CopyFrom(const ToRadio& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ToRadio)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ToRadio::IsInitialized() const {
  return true;
}

void ToRadio::InternalSwap(ToRadio* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ToRadio::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[21]);
}

// ===================================================================

class Compressed::_Internal {
 public:
};

Compressed::Compressed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Compressed)
}
Compressed::Compressed(const Compressed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Compressed* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.portnum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.portnum_ = from._impl_.portnum_;
  // @@protoc_insertion_point(copy_constructor:meshtastic.Compressed)
}

inline void Compressed::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.portnum_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Compressed::~Compressed() {
  // @@protoc_insertion_point(destructor:meshtastic.Compressed)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Compressed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void Compressed::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Compressed::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Compressed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  _impl_.portnum_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Compressed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .meshtastic.PortNum portnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_portnum(static_cast<::meshtastic::PortNum>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Compressed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Compressed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .meshtastic.PortNum portnum = 1;
  if (this->_internal_portnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_portnum(), target);
  }

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Compressed)
  return target;
}

size_t Compressed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.Compressed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // .meshtastic.PortNum portnum = 1;
  if (this->_internal_portnum() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_portnum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Compressed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Compressed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Compressed::GetClassData() const { return &_class_data_; }


void Compressed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Compressed*>(&to_msg);
  auto& from = static_cast<const Compressed&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Compressed)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_portnum() != 0) {
    _this->_internal_set_portnum(from._internal_portnum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Compressed::CopyFrom(const Compressed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Compressed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Compressed::IsInitialized() const {
  return true;
}

void Compressed::InternalSwap(Compressed* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.portnum_, other->_impl_.portnum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Compressed::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[22]);
}

// ===================================================================

class NeighborInfo::_Internal {
 public:
};

NeighborInfo::NeighborInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.NeighborInfo)
}
NeighborInfo::NeighborInfo(const NeighborInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NeighborInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.neighbors_){from._impl_.neighbors_}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.last_sent_by_id_){}
    , decltype(_impl_.node_broadcast_interval_secs_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.node_id_, &from._impl_.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.node_broadcast_interval_secs_) -
    reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.node_broadcast_interval_secs_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.NeighborInfo)
}

inline void NeighborInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.neighbors_){arena}
    , decltype(_impl_.node_id_){0u}
    , decltype(_impl_.last_sent_by_id_){0u}
    , decltype(_impl_.node_broadcast_interval_secs_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NeighborInfo::~NeighborInfo() {
  // @@protoc_insertion_point(destructor:meshtastic.NeighborInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NeighborInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.neighbors_.~RepeatedPtrField();
}

void NeighborInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NeighborInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.NeighborInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.neighbors_.Clear();
  ::memset(&_impl_.node_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.node_broadcast_interval_secs_) -
      reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.node_broadcast_interval_secs_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NeighborInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 node_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 last_sent_by_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.last_sent_by_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 node_broadcast_interval_secs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.node_broadcast_interval_secs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .meshtastic.Neighbor neighbors = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_neighbors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NeighborInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.NeighborInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 node_id = 1;
  if (this->_internal_node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_node_id(), target);
  }

  // uint32 last_sent_by_id = 2;
  if (this->_internal_last_sent_by_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_last_sent_by_id(), target);
  }

  // uint32 node_broadcast_interval_secs = 3;
  if (this->_internal_node_broadcast_interval_secs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_node_broadcast_interval_secs(), target);
  }

  // repeated .meshtastic.Neighbor neighbors = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_neighbors_size()); i < n; i++) {
    const auto& repfield = this->_internal_neighbors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.NeighborInfo)
  return target;
}

size_t NeighborInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.NeighborInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .meshtastic.Neighbor neighbors = 4;
  total_size += 1UL * this->_internal_neighbors_size();
  for (const auto& msg : this->_impl_.neighbors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 node_id = 1;
  if (this->_internal_node_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
  }

  // uint32 last_sent_by_id = 2;
  if (this->_internal_last_sent_by_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_sent_by_id());
  }

  // uint32 node_broadcast_interval_secs = 3;
  if (this->_internal_node_broadcast_interval_secs() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_broadcast_interval_secs());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NeighborInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NeighborInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NeighborInfo::GetClassData() const { return &_class_data_; }


void NeighborInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NeighborInfo*>(&to_msg);
  auto& from = static_cast<const NeighborInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.NeighborInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.neighbors_.MergeFrom(from._impl_.neighbors_);
  if (from._internal_node_id() != 0) {
    _this->_internal_set_node_id(from._internal_node_id());
  }
  if (from._internal_last_sent_by_id() != 0) {
    _this->_internal_set_last_sent_by_id(from._internal_last_sent_by_id());
  }
  if (from._internal_node_broadcast_interval_secs() != 0) {
    _this->_internal_set_node_broadcast_interval_secs(from._internal_node_broadcast_interval_secs());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NeighborInfo::CopyFrom(const NeighborInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.NeighborInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NeighborInfo::IsInitialized() const {
  return true;
}

void NeighborInfo::InternalSwap(NeighborInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.neighbors_.InternalSwap(&other->_impl_.neighbors_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.node_broadcast_interval_secs_)
      + sizeof(NeighborInfo::_impl_.node_broadcast_interval_secs_)
      - PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.node_id_)>(
          reinterpret_cast<char*>(&_impl_.node_id_),
          reinterpret_cast<char*>(&other->_impl_.node_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NeighborInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[23]);
}

// ===================================================================

class Neighbor::_Internal {
 public:
};

Neighbor::Neighbor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Neighbor)
}
Neighbor::Neighbor(const Neighbor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Neighbor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.node_id_){}
    , decltype(_impl_.snr_){}
    , decltype(_impl_.last_rx_time_){}
    , decltype(_impl_.node_broadcast_interval_secs_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.node_id_, &from._impl_.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.node_broadcast_interval_secs_) -
    reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.node_broadcast_interval_secs_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.Neighbor)
}

inline void Neighbor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.node_id_){0u}
    , decltype(_impl_.snr_){0}
    , decltype(_impl_.last_rx_time_){0u}
    , decltype(_impl_.node_broadcast_interval_secs_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Neighbor::~Neighbor() {
  // @@protoc_insertion_point(destructor:meshtastic.Neighbor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Neighbor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Neighbor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Neighbor::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Neighbor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.node_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.node_broadcast_interval_secs_) -
      reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.node_broadcast_interval_secs_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Neighbor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 node_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float snr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.snr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // fixed32 last_rx_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.last_rx_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // uint32 node_broadcast_interval_secs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.node_broadcast_interval_secs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Neighbor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Neighbor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 node_id = 1;
  if (this->_internal_node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_node_id(), target);
  }

  // float snr = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_snr = this->_internal_snr();
  uint32_t raw_snr;
  memcpy(&raw_snr, &tmp_snr, sizeof(tmp_snr));
  if (raw_snr != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_snr(), target);
  }

  // fixed32 last_rx_time = 3;
  if (this->_internal_last_rx_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_last_rx_time(), target);
  }

  // uint32 node_broadcast_interval_secs = 4;
  if (this->_internal_node_broadcast_interval_secs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_node_broadcast_interval_secs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Neighbor)
  return target;
}

size_t Neighbor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.Neighbor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 node_id = 1;
  if (this->_internal_node_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
  }

  // float snr = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_snr = this->_internal_snr();
  uint32_t raw_snr;
  memcpy(&raw_snr, &tmp_snr, sizeof(tmp_snr));
  if (raw_snr != 0) {
    total_size += 1 + 4;
  }

  // fixed32 last_rx_time = 3;
  if (this->_internal_last_rx_time() != 0) {
    total_size += 1 + 4;
  }

  // uint32 node_broadcast_interval_secs = 4;
  if (this->_internal_node_broadcast_interval_secs() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_broadcast_interval_secs());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neighbor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Neighbor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neighbor::GetClassData() const { return &_class_data_; }


void Neighbor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Neighbor*>(&to_msg);
  auto& from = static_cast<const Neighbor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Neighbor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_node_id() != 0) {
    _this->_internal_set_node_id(from._internal_node_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_snr = from._internal_snr();
  uint32_t raw_snr;
  memcpy(&raw_snr, &tmp_snr, sizeof(tmp_snr));
  if (raw_snr != 0) {
    _this->_internal_set_snr(from._internal_snr());
  }
  if (from._internal_last_rx_time() != 0) {
    _this->_internal_set_last_rx_time(from._internal_last_rx_time());
  }
  if (from._internal_node_broadcast_interval_secs() != 0) {
    _this->_internal_set_node_broadcast_interval_secs(from._internal_node_broadcast_interval_secs());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Neighbor::CopyFrom(const Neighbor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Neighbor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Neighbor::IsInitialized() const {
  return true;
}

void Neighbor::InternalSwap(Neighbor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.node_broadcast_interval_secs_)
      + sizeof(Neighbor::_impl_.node_broadcast_interval_secs_)
      - PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.node_id_)>(
          reinterpret_cast<char*>(&_impl_.node_id_),
          reinterpret_cast<char*>(&other->_impl_.node_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Neighbor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[24]);
}

// ===================================================================

class DeviceMetadata::_Internal {
 public:
};

DeviceMetadata::DeviceMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.DeviceMetadata)
}
DeviceMetadata::DeviceMetadata(const DeviceMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeviceMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.firmware_version_){}
    , decltype(_impl_.device_state_version_){}
    , decltype(_impl_.canshutdown_){}
    , decltype(_impl_.haswifi_){}
    , decltype(_impl_.hasbluetooth_){}
    , decltype(_impl_.hasethernet_){}
    , decltype(_impl_.role_){}
    , decltype(_impl_.position_flags_){}
    , decltype(_impl_.hw_model_){}
    , decltype(_impl_.hasremotehardware_){}
    , decltype(_impl_.haspkc_){}
    , decltype(_impl_.excluded_modules_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.firmware_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_firmware_version().empty()) {
    _this->_impl_.firmware_version_.Set(from._internal_firmware_version(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.device_state_version_, &from._impl_.device_state_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.excluded_modules_) -
    reinterpret_cast<char*>(&_impl_.device_state_version_)) + sizeof(_impl_.excluded_modules_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.DeviceMetadata)
}

inline void DeviceMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.firmware_version_){}
    , decltype(_impl_.device_state_version_){0u}
    , decltype(_impl_.canshutdown_){false}
    , decltype(_impl_.haswifi_){false}
    , decltype(_impl_.hasbluetooth_){false}
    , decltype(_impl_.hasethernet_){false}
    , decltype(_impl_.role_){0}
    , decltype(_impl_.position_flags_){0u}
    , decltype(_impl_.hw_model_){0}
    , decltype(_impl_.hasremotehardware_){false}
    , decltype(_impl_.haspkc_){false}
    , decltype(_impl_.excluded_modules_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.firmware_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceMetadata::~DeviceMetadata() {
  // @@protoc_insertion_point(destructor:meshtastic.DeviceMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.firmware_version_.Destroy();
}

void DeviceMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.DeviceMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.firmware_version_.ClearToEmpty();
  ::memset(&_impl_.device_state_version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.excluded_modules_) -
      reinterpret_cast<char*>(&_impl_.device_state_version_)) + sizeof(_impl_.excluded_modules_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeviceMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string firmware_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_firmware_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.DeviceMetadata.firmware_version"));
        } else
          goto handle_unusual;
        continue;
      // uint32 device_state_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.device_state_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool canShutdown = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.canshutdown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasWifi = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.haswifi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasBluetooth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.hasbluetooth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasEthernet = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.hasethernet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.Config.DeviceConfig.Role role = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_role(static_cast<::meshtastic::Config_DeviceConfig_Role>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 position_flags = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.position_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.HardwareModel hw_model = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hw_model(static_cast<::meshtastic::HardwareModel>(val));
        } else
          goto handle_unusual;
        continue;
      // bool hasRemoteHardware = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.hasremotehardware_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasPKC = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.haspkc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 excluded_modules = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.excluded_modules_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.DeviceMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string firmware_version = 1;
  if (!this->_internal_firmware_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_firmware_version().data(), static_cast<int>(this->_internal_firmware_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.DeviceMetadata.firmware_version");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_firmware_version(), target);
  }

  // uint32 device_state_version = 2;
  if (this->_internal_device_state_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_device_state_version(), target);
  }

  // bool canShutdown = 3;
  if (this->_internal_canshutdown() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_canshutdown(), target);
  }

  // bool hasWifi = 4;
  if (this->_internal_haswifi() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_haswifi(), target);
  }

  // bool hasBluetooth = 5;
  if (this->_internal_hasbluetooth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_hasbluetooth(), target);
  }

  // bool hasEthernet = 6;
  if (this->_internal_hasethernet() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_hasethernet(), target);
  }

  // .meshtastic.Config.DeviceConfig.Role role = 7;
  if (this->_internal_role() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_role(), target);
  }

  // uint32 position_flags = 8;
  if (this->_internal_position_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_position_flags(), target);
  }

  // .meshtastic.HardwareModel hw_model = 9;
  if (this->_internal_hw_model() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_hw_model(), target);
  }

  // bool hasRemoteHardware = 10;
  if (this->_internal_hasremotehardware() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_hasremotehardware(), target);
  }

  // bool hasPKC = 11;
  if (this->_internal_haspkc() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_haspkc(), target);
  }

  // uint32 excluded_modules = 12;
  if (this->_internal_excluded_modules() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_excluded_modules(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.DeviceMetadata)
  return target;
}

size_t DeviceMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.DeviceMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string firmware_version = 1;
  if (!this->_internal_firmware_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_firmware_version());
  }

  // uint32 device_state_version = 2;
  if (this->_internal_device_state_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_device_state_version());
  }

  // bool canShutdown = 3;
  if (this->_internal_canshutdown() != 0) {
    total_size += 1 + 1;
  }

  // bool hasWifi = 4;
  if (this->_internal_haswifi() != 0) {
    total_size += 1 + 1;
  }

  // bool hasBluetooth = 5;
  if (this->_internal_hasbluetooth() != 0) {
    total_size += 1 + 1;
  }

  // bool hasEthernet = 6;
  if (this->_internal_hasethernet() != 0) {
    total_size += 1 + 1;
  }

  // .meshtastic.Config.DeviceConfig.Role role = 7;
  if (this->_internal_role() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_role());
  }

  // uint32 position_flags = 8;
  if (this->_internal_position_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_position_flags());
  }

  // .meshtastic.HardwareModel hw_model = 9;
  if (this->_internal_hw_model() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_hw_model());
  }

  // bool hasRemoteHardware = 10;
  if (this->_internal_hasremotehardware() != 0) {
    total_size += 1 + 1;
  }

  // bool hasPKC = 11;
  if (this->_internal_haspkc() != 0) {
    total_size += 1 + 1;
  }

  // uint32 excluded_modules = 12;
  if (this->_internal_excluded_modules() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_excluded_modules());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeviceMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeviceMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeviceMetadata::GetClassData() const { return &_class_data_; }


void DeviceMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeviceMetadata*>(&to_msg);
  auto& from = static_cast<const DeviceMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.DeviceMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_firmware_version().empty()) {
    _this->_internal_set_firmware_version(from._internal_firmware_version());
  }
  if (from._internal_device_state_version() != 0) {
    _this->_internal_set_device_state_version(from._internal_device_state_version());
  }
  if (from._internal_canshutdown() != 0) {
    _this->_internal_set_canshutdown(from._internal_canshutdown());
  }
  if (from._internal_haswifi() != 0) {
    _this->_internal_set_haswifi(from._internal_haswifi());
  }
  if (from._internal_hasbluetooth() != 0) {
    _this->_internal_set_hasbluetooth(from._internal_hasbluetooth());
  }
  if (from._internal_hasethernet() != 0) {
    _this->_internal_set_hasethernet(from._internal_hasethernet());
  }
  if (from._internal_role() != 0) {
    _this->_internal_set_role(from._internal_role());
  }
  if (from._internal_position_flags() != 0) {
    _this->_internal_set_position_flags(from._internal_position_flags());
  }
  if (from._internal_hw_model() != 0) {
    _this->_internal_set_hw_model(from._internal_hw_model());
  }
  if (from._internal_hasremotehardware() != 0) {
    _this->_internal_set_hasremotehardware(from._internal_hasremotehardware());
  }
  if (from._internal_haspkc() != 0) {
    _this->_internal_set_haspkc(from._internal_haspkc());
  }
  if (from._internal_excluded_modules() != 0) {
    _this->_internal_set_excluded_modules(from._internal_excluded_modules());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeviceMetadata::CopyFrom(const DeviceMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.DeviceMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceMetadata::IsInitialized() const {
  return true;
}

void DeviceMetadata::InternalSwap(DeviceMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.firmware_version_, lhs_arena,
      &other->_impl_.firmware_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.excluded_modules_)
      + sizeof(DeviceMetadata::_impl_.excluded_modules_)
      - PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.device_state_version_)>(
          reinterpret_cast<char*>(&_impl_.device_state_version_),
          reinterpret_cast<char*>(&other->_impl_.device_state_version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DeviceMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[25]);
}

// ===================================================================

class Heartbeat::_Internal {
 public:
};

Heartbeat::Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Heartbeat)
}
Heartbeat::Heartbeat(const Heartbeat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Heartbeat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nonce_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.nonce_ = from._impl_.nonce_;
  // @@protoc_insertion_point(copy_constructor:meshtastic.Heartbeat)
}

inline void Heartbeat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nonce_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Heartbeat::~Heartbeat() {
  // @@protoc_insertion_point(destructor:meshtastic.Heartbeat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Heartbeat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Heartbeat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Heartbeat::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Heartbeat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nonce_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Heartbeat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 nonce = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Heartbeat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Heartbeat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 nonce = 1;
  if (this->_internal_nonce() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_nonce(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Heartbeat)
  return target;
}

size_t Heartbeat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.Heartbeat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 nonce = 1;
  if (this->_internal_nonce() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nonce());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Heartbeat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Heartbeat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Heartbeat::GetClassData() const { return &_class_data_; }


void Heartbeat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Heartbeat*>(&to_msg);
  auto& from = static_cast<const Heartbeat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Heartbeat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_nonce() != 0) {
    _this->_internal_set_nonce(from._internal_nonce());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Heartbeat::CopyFrom(const Heartbeat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Heartbeat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Heartbeat::IsInitialized() const {
  return true;
}

void Heartbeat::InternalSwap(Heartbeat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.nonce_, other->_impl_.nonce_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Heartbeat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[26]);
}

// ===================================================================

class NodeRemoteHardwarePin::_Internal {
 public:
  static const ::meshtastic::RemoteHardwarePin& pin(const NodeRemoteHardwarePin* msg);
};

const ::meshtastic::RemoteHardwarePin&
NodeRemoteHardwarePin::_Internal::pin(const NodeRemoteHardwarePin* msg) {
  return *msg->_impl_.pin_;
}
void NodeRemoteHardwarePin::clear_pin() {
  if (GetArenaForAllocation() == nullptr && _impl_.pin_ != nullptr) {
    delete _impl_.pin_;
  }
  _impl_.pin_ = nullptr;
}
NodeRemoteHardwarePin::NodeRemoteHardwarePin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.NodeRemoteHardwarePin)
}
NodeRemoteHardwarePin::NodeRemoteHardwarePin(const NodeRemoteHardwarePin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeRemoteHardwarePin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pin_){nullptr}
    , decltype(_impl_.node_num_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pin()) {
    _this->_impl_.pin_ = new ::meshtastic::RemoteHardwarePin(*from._impl_.pin_);
  }
  _this->_impl_.node_num_ = from._impl_.node_num_;
  // @@protoc_insertion_point(copy_constructor:meshtastic.NodeRemoteHardwarePin)
}

inline void NodeRemoteHardwarePin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pin_){nullptr}
    , decltype(_impl_.node_num_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NodeRemoteHardwarePin::~NodeRemoteHardwarePin() {
  // @@protoc_insertion_point(destructor:meshtastic.NodeRemoteHardwarePin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeRemoteHardwarePin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pin_;
}

void NodeRemoteHardwarePin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeRemoteHardwarePin::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.NodeRemoteHardwarePin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pin_ != nullptr) {
    delete _impl_.pin_;
  }
  _impl_.pin_ = nullptr;
  _impl_.node_num_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeRemoteHardwarePin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 node_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.node_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.RemoteHardwarePin pin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeRemoteHardwarePin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.NodeRemoteHardwarePin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 node_num = 1;
  if (this->_internal_node_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_node_num(), target);
  }

  // .meshtastic.RemoteHardwarePin pin = 2;
  if (this->_internal_has_pin()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::pin(this),
        _Internal::pin(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.NodeRemoteHardwarePin)
  return target;
}

size_t NodeRemoteHardwarePin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.NodeRemoteHardwarePin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .meshtastic.RemoteHardwarePin pin = 2;
  if (this->_internal_has_pin()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pin_);
  }

  // uint32 node_num = 1;
  if (this->_internal_node_num() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_num());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeRemoteHardwarePin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeRemoteHardwarePin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeRemoteHardwarePin::GetClassData() const { return &_class_data_; }


void NodeRemoteHardwarePin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeRemoteHardwarePin*>(&to_msg);
  auto& from = static_cast<const NodeRemoteHardwarePin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.NodeRemoteHardwarePin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pin()) {
    _this->_internal_mutable_pin()->::meshtastic::RemoteHardwarePin::MergeFrom(
        from._internal_pin());
  }
  if (from._internal_node_num() != 0) {
    _this->_internal_set_node_num(from._internal_node_num());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeRemoteHardwarePin::CopyFrom(const NodeRemoteHardwarePin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.NodeRemoteHardwarePin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeRemoteHardwarePin::IsInitialized() const {
  return true;
}

void NodeRemoteHardwarePin::InternalSwap(NodeRemoteHardwarePin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeRemoteHardwarePin, _impl_.node_num_)
      + sizeof(NodeRemoteHardwarePin::_impl_.node_num_)
      - PROTOBUF_FIELD_OFFSET(NodeRemoteHardwarePin, _impl_.pin_)>(
          reinterpret_cast<char*>(&_impl_.pin_),
          reinterpret_cast<char*>(&other->_impl_.pin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeRemoteHardwarePin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[27]);
}

// ===================================================================

class ChunkedPayload::_Internal {
 public:
};

ChunkedPayload::ChunkedPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ChunkedPayload)
}
ChunkedPayload::ChunkedPayload(const ChunkedPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChunkedPayload* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_chunk_){}
    , decltype(_impl_.payload_id_){}
    , decltype(_impl_.chunk_count_){}
    , decltype(_impl_.chunk_index_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.payload_chunk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_chunk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_payload_chunk().empty()) {
    _this->_impl_.payload_chunk_.Set(from._internal_payload_chunk(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.payload_id_, &from._impl_.payload_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.chunk_index_) -
    reinterpret_cast<char*>(&_impl_.payload_id_)) + sizeof(_impl_.chunk_index_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ChunkedPayload)
}

inline void ChunkedPayload::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_chunk_){}
    , decltype(_impl_.payload_id_){0u}
    , decltype(_impl_.chunk_count_){0u}
    , decltype(_impl_.chunk_index_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.payload_chunk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_chunk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChunkedPayload::~ChunkedPayload() {
  // @@protoc_insertion_point(destructor:meshtastic.ChunkedPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChunkedPayload::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.payload_chunk_.Destroy();
}

void ChunkedPayload::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChunkedPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ChunkedPayload)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.payload_chunk_.ClearToEmpty();
  ::memset(&_impl_.payload_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.chunk_index_) -
      reinterpret_cast<char*>(&_impl_.payload_id_)) + sizeof(_impl_.chunk_index_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChunkedPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 payload_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.payload_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 chunk_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.chunk_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 chunk_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.chunk_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes payload_chunk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_payload_chunk();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChunkedPayload::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ChunkedPayload)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 payload_id = 1;
  if (this->_internal_payload_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_payload_id(), target);
  }

  // uint32 chunk_count = 2;
  if (this->_internal_chunk_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_chunk_count(), target);
  }

  // uint32 chunk_index = 3;
  if (this->_internal_chunk_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_chunk_index(), target);
  }

  // bytes payload_chunk = 4;
  if (!this->_internal_payload_chunk().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_payload_chunk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ChunkedPayload)
  return target;
}

size_t ChunkedPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ChunkedPayload)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes payload_chunk = 4;
  if (!this->_internal_payload_chunk().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_payload_chunk());
  }

  // uint32 payload_id = 1;
  if (this->_internal_payload_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_payload_id());
  }

  // uint32 chunk_count = 2;
  if (this->_internal_chunk_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_chunk_count());
  }

  // uint32 chunk_index = 3;
  if (this->_internal_chunk_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_chunk_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChunkedPayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChunkedPayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChunkedPayload::GetClassData() const { return &_class_data_; }


void ChunkedPayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChunkedPayload*>(&to_msg);
  auto& from = static_cast<const ChunkedPayload&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ChunkedPayload)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_payload_chunk().empty()) {
    _this->_internal_set_payload_chunk(from._internal_payload_chunk());
  }
  if (from._internal_payload_id() != 0) {
    _this->_internal_set_payload_id(from._internal_payload_id());
  }
  if (from._internal_chunk_count() != 0) {
    _this->_internal_set_chunk_count(from._internal_chunk_count());
  }
  if (from._internal_chunk_index() != 0) {
    _this->_internal_set_chunk_index(from._internal_chunk_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChunkedPayload::CopyFrom(const ChunkedPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ChunkedPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChunkedPayload::IsInitialized() const {
  return true;
}

void ChunkedPayload::InternalSwap(ChunkedPayload* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.payload_chunk_, lhs_arena,
      &other->_impl_.payload_chunk_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.chunk_index_)
      + sizeof(ChunkedPayload::_impl_.chunk_index_)
      - PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.payload_id_)>(
          reinterpret_cast<char*>(&_impl_.payload_id_),
          reinterpret_cast<char*>(&other->_impl_.payload_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChunkedPayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[28]);
}

// ===================================================================

class resend_chunks::_Internal {
 public:
};

resend_chunks::resend_chunks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.resend_chunks)
}
resend_chunks::resend_chunks(const resend_chunks& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  resend_chunks* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.chunks_){from._impl_.chunks_}
    , /*decltype(_impl_._chunks_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:meshtastic.resend_chunks)
}

inline void resend_chunks::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.chunks_){arena}
    , /*decltype(_impl_._chunks_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

resend_chunks::~resend_chunks() {
  // @@protoc_insertion_point(destructor:meshtastic.resend_chunks)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void resend_chunks::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.chunks_.~RepeatedField();
}

void resend_chunks::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void resend_chunks::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.resend_chunks)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.chunks_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* resend_chunks::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 chunks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_chunks(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_chunks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* resend_chunks::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.resend_chunks)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 chunks = 1;
  {
    int byte_size = _impl_._chunks_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_chunks(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.resend_chunks)
  return target;
}

size_t resend_chunks::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.resend_chunks)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 chunks = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.chunks_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._chunks_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData resend_chunks::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    resend_chunks::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*resend_chunks::GetClassData() const { return &_class_data_; }


void resend_chunks::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<resend_chunks*>(&to_msg);
  auto& from = static_cast<const resend_chunks&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.resend_chunks)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.chunks_.MergeFrom(from._impl_.chunks_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void resend_chunks::CopyFrom(const resend_chunks& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.resend_chunks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool resend_chunks::IsInitialized() const {
  return true;
}

void resend_chunks::InternalSwap(resend_chunks* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.chunks_.InternalSwap(&other->_impl_.chunks_);
}

::PROTOBUF_NAMESPACE_ID::Metadata resend_chunks::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[29]);
}

// ===================================================================

class ChunkedPayloadResponse::_Internal {
 public:
  static const ::meshtastic::resend_chunks& resend_chunks(const ChunkedPayloadResponse* msg);
};

const ::meshtastic::resend_chunks&
ChunkedPayloadResponse::_Internal::resend_chunks(const ChunkedPayloadResponse* msg) {
  return *msg->_impl_.payload_variant_.resend_chunks_;
}
void ChunkedPayloadResponse::set_allocated_resend_chunks(::meshtastic::resend_chunks* resend_chunks) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (resend_chunks) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resend_chunks);
    if (message_arena != submessage_arena) {
      resend_chunks = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resend_chunks, submessage_arena);
    }
    set_has_resend_chunks();
    _impl_.payload_variant_.resend_chunks_ = resend_chunks;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ChunkedPayloadResponse.resend_chunks)
}
ChunkedPayloadResponse::ChunkedPayloadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ChunkedPayloadResponse)
}
ChunkedPayloadResponse::ChunkedPayloadResponse(const ChunkedPayloadResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChunkedPayloadResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_id_){}
    , decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.payload_id_ = from._impl_.payload_id_;
  clear_has_payload_variant();
  switch (from.payload_variant_case()) {
    case kRequestTransfer: {
      _this->_internal_set_request_transfer(from._internal_request_transfer());
      break;
    }
    case kAcceptTransfer: {
      _this->_internal_set_accept_transfer(from._internal_accept_transfer());
      break;
    }
    case kResendChunks: {
      _this->_internal_mutable_resend_chunks()->::meshtastic::resend_chunks::MergeFrom(
          from._internal_resend_chunks());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:meshtastic.ChunkedPayloadResponse)
}

inline void ChunkedPayloadResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_id_){0u}
    , decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload_variant();
}

ChunkedPayloadResponse::~ChunkedPayloadResponse() {
  // @@protoc_insertion_point(destructor:meshtastic.ChunkedPayloadResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChunkedPayloadResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
}

void ChunkedPayloadResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChunkedPayloadResponse::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.ChunkedPayloadResponse)
  switch (payload_variant_case()) {
    case kRequestTransfer: {
      // No need to clear
      break;
    }
    case kAcceptTransfer: {
      // No need to clear
      break;
    }
    case kResendChunks: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.resend_chunks_;
      }
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


void ChunkedPayloadResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ChunkedPayloadResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.payload_id_ = 0u;
  clear_payload_variant();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChunkedPayloadResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 payload_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.payload_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool request_transfer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_request_transfer(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool accept_transfer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_accept_transfer(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.resend_chunks resend_chunks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_resend_chunks(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChunkedPayloadResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ChunkedPayloadResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 payload_id = 1;
  if (this->_internal_payload_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_payload_id(), target);
  }

  // bool request_transfer = 2;
  if (_internal_has_request_transfer()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_request_transfer(), target);
  }

  // bool accept_transfer = 3;
  if (_internal_has_accept_transfer()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_accept_transfer(), target);
  }

  // .meshtastic.resend_chunks resend_chunks = 4;
  if (_internal_has_resend_chunks()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::resend_chunks(this),
        _Internal::resend_chunks(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ChunkedPayloadResponse)
  return target;
}

size_t ChunkedPayloadResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ChunkedPayloadResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 payload_id = 1;
  if (this->_internal_payload_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_payload_id());
  }

  switch (payload_variant_case()) {
    // bool request_transfer = 2;
    case kRequestTransfer: {
      total_size += 1 + 1;
      break;
    }
    // bool accept_transfer = 3;
    case kAcceptTransfer: {
      total_size += 1 + 1;
      break;
    }
    // .meshtastic.resend_chunks resend_chunks = 4;
    case kResendChunks: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.resend_chunks_);
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChunkedPayloadResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChunkedPayloadResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChunkedPayloadResponse::GetClassData() const { return &_class_data_; }


void ChunkedPayloadResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChunkedPayloadResponse*>(&to_msg);
  auto& from = static_cast<const ChunkedPayloadResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ChunkedPayloadResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_payload_id() != 0) {
    _this->_internal_set_payload_id(from._internal_payload_id());
  }
  switch (from.payload_variant_case()) {
    case kRequestTransfer: {
      _this->_internal_set_request_transfer(from._internal_request_transfer());
      break;
    }
    case kAcceptTransfer: {
      _this->_internal_set_accept_transfer(from._internal_accept_transfer());
      break;
    }
    case kResendChunks: {
      _this->_internal_mutable_resend_chunks()->::meshtastic::resend_chunks::MergeFrom(
          from._internal_resend_chunks());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChunkedPayloadResponse::CopyFrom(const ChunkedPayloadResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ChunkedPayloadResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChunkedPayloadResponse::IsInitialized() const {
  return true;
}

void ChunkedPayloadResponse::InternalSwap(ChunkedPayloadResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.payload_id_, other->_impl_.payload_id_);
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ChunkedPayloadResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmesh_2eproto_getter, &descriptor_table_meshtastic_2fmesh_2eproto_once,
      file_level_metadata_meshtastic_2fmesh_2eproto[30]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace meshtastic
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::meshtastic::Position*
Arena::CreateMaybeMessage< ::meshtastic::Position >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::Position >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::User*
Arena::CreateMaybeMessage< ::meshtastic::User >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::User >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::RouteDiscovery*
Arena::CreateMaybeMessage< ::meshtastic::RouteDiscovery >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::RouteDiscovery >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::Routing*
Arena::CreateMaybeMessage< ::meshtastic::Routing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::Routing >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::Data*
Arena::CreateMaybeMessage< ::meshtastic::Data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::Data >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::KeyVerification*
Arena::CreateMaybeMessage< ::meshtastic::KeyVerification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::KeyVerification >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::Waypoint*
Arena::CreateMaybeMessage< ::meshtastic::Waypoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::Waypoint >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::MqttClientProxyMessage*
Arena::CreateMaybeMessage< ::meshtastic::MqttClientProxyMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::MqttClientProxyMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::MeshPacket*
Arena::CreateMaybeMessage< ::meshtastic::MeshPacket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::MeshPacket >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::NodeInfo*
Arena::CreateMaybeMessage< ::meshtastic::NodeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::NodeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::MyNodeInfo*
Arena::CreateMaybeMessage< ::meshtastic::MyNodeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::MyNodeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::LogRecord*
Arena::CreateMaybeMessage< ::meshtastic::LogRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::LogRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::QueueStatus*
Arena::CreateMaybeMessage< ::meshtastic::QueueStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::QueueStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::FromRadio*
Arena::CreateMaybeMessage< ::meshtastic::FromRadio >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::FromRadio >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ClientNotification*
Arena::CreateMaybeMessage< ::meshtastic::ClientNotification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ClientNotification >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::KeyVerificationNumberInform*
Arena::CreateMaybeMessage< ::meshtastic::KeyVerificationNumberInform >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::KeyVerificationNumberInform >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::KeyVerificationNumberRequest*
Arena::CreateMaybeMessage< ::meshtastic::KeyVerificationNumberRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::KeyVerificationNumberRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::KeyVerificationFinal*
Arena::CreateMaybeMessage< ::meshtastic::KeyVerificationFinal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::KeyVerificationFinal >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::DuplicatedPublicKey*
Arena::CreateMaybeMessage< ::meshtastic::DuplicatedPublicKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::DuplicatedPublicKey >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::LowEntropyKey*
Arena::CreateMaybeMessage< ::meshtastic::LowEntropyKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::LowEntropyKey >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::FileInfo*
Arena::CreateMaybeMessage< ::meshtastic::FileInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::FileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ToRadio*
Arena::CreateMaybeMessage< ::meshtastic::ToRadio >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ToRadio >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::Compressed*
Arena::CreateMaybeMessage< ::meshtastic::Compressed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::Compressed >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::NeighborInfo*
Arena::CreateMaybeMessage< ::meshtastic::NeighborInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::NeighborInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::Neighbor*
Arena::CreateMaybeMessage< ::meshtastic::Neighbor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::Neighbor >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::DeviceMetadata*
Arena::CreateMaybeMessage< ::meshtastic::DeviceMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::DeviceMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::Heartbeat*
Arena::CreateMaybeMessage< ::meshtastic::Heartbeat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::Heartbeat >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::NodeRemoteHardwarePin*
Arena::CreateMaybeMessage< ::meshtastic::NodeRemoteHardwarePin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::NodeRemoteHardwarePin >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ChunkedPayload*
Arena::CreateMaybeMessage< ::meshtastic::ChunkedPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ChunkedPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::resend_chunks*
Arena::CreateMaybeMessage< ::meshtastic::resend_chunks >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::resend_chunks >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ChunkedPayloadResponse*
Arena::CreateMaybeMessage< ::meshtastic::ChunkedPayloadResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ChunkedPayloadResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
