// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meshtastic/module_config.proto

#include "meshtastic/module_config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace meshtastic {
PROTOBUF_CONSTEXPR ModuleConfig_MQTTConfig::ModuleConfig_MQTTConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.username_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.root_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.map_report_settings_)*/nullptr
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.encryption_enabled_)*/false
  , /*decltype(_impl_.json_enabled_)*/false
  , /*decltype(_impl_.tls_enabled_)*/false
  , /*decltype(_impl_.proxy_to_client_enabled_)*/false
  , /*decltype(_impl_.map_reporting_enabled_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_MQTTConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_MQTTConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_MQTTConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_MQTTConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_MQTTConfigDefaultTypeInternal _ModuleConfig_MQTTConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_MapReportSettings::ModuleConfig_MapReportSettings(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.publish_interval_secs_)*/0u
  , /*decltype(_impl_.position_precision_)*/0u
  , /*decltype(_impl_.should_report_location_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_MapReportSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_MapReportSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_MapReportSettingsDefaultTypeInternal() {}
  union {
    ModuleConfig_MapReportSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_MapReportSettingsDefaultTypeInternal _ModuleConfig_MapReportSettings_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_RemoteHardwareConfig::ModuleConfig_RemoteHardwareConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.available_pins_)*/{}
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.allow_undefined_pin_access_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_RemoteHardwareConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_RemoteHardwareConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_RemoteHardwareConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_RemoteHardwareConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_RemoteHardwareConfigDefaultTypeInternal _ModuleConfig_RemoteHardwareConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_NeighborInfoConfig::ModuleConfig_NeighborInfoConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.update_interval_)*/0u
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.transmit_over_lora_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_NeighborInfoConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_NeighborInfoConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_NeighborInfoConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_NeighborInfoConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_NeighborInfoConfigDefaultTypeInternal _ModuleConfig_NeighborInfoConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_DetectionSensorConfig::ModuleConfig_DetectionSensorConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.minimum_broadcast_secs_)*/0u
  , /*decltype(_impl_.state_broadcast_secs_)*/0u
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.send_bell_)*/false
  , /*decltype(_impl_.use_pullup_)*/false
  , /*decltype(_impl_.monitor_pin_)*/0u
  , /*decltype(_impl_.detection_trigger_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_DetectionSensorConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_DetectionSensorConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_DetectionSensorConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_DetectionSensorConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_DetectionSensorConfigDefaultTypeInternal _ModuleConfig_DetectionSensorConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_AudioConfig::ModuleConfig_AudioConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.codec2_enabled_)*/false
  , /*decltype(_impl_.ptt_pin_)*/0u
  , /*decltype(_impl_.bitrate_)*/0
  , /*decltype(_impl_.i2s_ws_)*/0u
  , /*decltype(_impl_.i2s_sd_)*/0u
  , /*decltype(_impl_.i2s_din_)*/0u
  , /*decltype(_impl_.i2s_sck_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_AudioConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_AudioConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_AudioConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_AudioConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_AudioConfigDefaultTypeInternal _ModuleConfig_AudioConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_PaxcounterConfig::ModuleConfig_PaxcounterConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.paxcounter_update_interval_)*/0u
  , /*decltype(_impl_.wifi_threshold_)*/0
  , /*decltype(_impl_.ble_threshold_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_PaxcounterConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_PaxcounterConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_PaxcounterConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_PaxcounterConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_PaxcounterConfigDefaultTypeInternal _ModuleConfig_PaxcounterConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_SerialConfig::ModuleConfig_SerialConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rxd_)*/0u
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.echo_)*/false
  , /*decltype(_impl_.override_console_serial_port_)*/false
  , /*decltype(_impl_.txd_)*/0u
  , /*decltype(_impl_.baud_)*/0
  , /*decltype(_impl_.timeout_)*/0u
  , /*decltype(_impl_.mode_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_SerialConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_SerialConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_SerialConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_SerialConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_SerialConfigDefaultTypeInternal _ModuleConfig_SerialConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_ExternalNotificationConfig::ModuleConfig_ExternalNotificationConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.output_ms_)*/0u
  , /*decltype(_impl_.output_)*/0u
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.active_)*/false
  , /*decltype(_impl_.alert_message_)*/false
  , /*decltype(_impl_.alert_message_vibra_)*/false
  , /*decltype(_impl_.output_vibra_)*/0u
  , /*decltype(_impl_.output_buzzer_)*/0u
  , /*decltype(_impl_.alert_message_buzzer_)*/false
  , /*decltype(_impl_.alert_bell_)*/false
  , /*decltype(_impl_.alert_bell_vibra_)*/false
  , /*decltype(_impl_.alert_bell_buzzer_)*/false
  , /*decltype(_impl_.use_pwm_)*/false
  , /*decltype(_impl_.use_i2s_as_buzzer_)*/false
  , /*decltype(_impl_.nag_timeout_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_ExternalNotificationConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_ExternalNotificationConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_ExternalNotificationConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_ExternalNotificationConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_ExternalNotificationConfigDefaultTypeInternal _ModuleConfig_ExternalNotificationConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_StoreForwardConfig::ModuleConfig_StoreForwardConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.records_)*/0u
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.heartbeat_)*/false
  , /*decltype(_impl_.is_server_)*/false
  , /*decltype(_impl_.history_return_max_)*/0u
  , /*decltype(_impl_.history_return_window_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_StoreForwardConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_StoreForwardConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_StoreForwardConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_StoreForwardConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_StoreForwardConfigDefaultTypeInternal _ModuleConfig_StoreForwardConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_RangeTestConfig::ModuleConfig_RangeTestConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sender_)*/0u
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.save_)*/false
  , /*decltype(_impl_.clear_on_reboot_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_RangeTestConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_RangeTestConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_RangeTestConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_RangeTestConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_RangeTestConfigDefaultTypeInternal _ModuleConfig_RangeTestConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_TelemetryConfig::ModuleConfig_TelemetryConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.device_update_interval_)*/0u
  , /*decltype(_impl_.environment_update_interval_)*/0u
  , /*decltype(_impl_.environment_measurement_enabled_)*/false
  , /*decltype(_impl_.environment_screen_enabled_)*/false
  , /*decltype(_impl_.environment_display_fahrenheit_)*/false
  , /*decltype(_impl_.air_quality_enabled_)*/false
  , /*decltype(_impl_.air_quality_interval_)*/0u
  , /*decltype(_impl_.power_update_interval_)*/0u
  , /*decltype(_impl_.power_measurement_enabled_)*/false
  , /*decltype(_impl_.power_screen_enabled_)*/false
  , /*decltype(_impl_.health_measurement_enabled_)*/false
  , /*decltype(_impl_.health_screen_enabled_)*/false
  , /*decltype(_impl_.health_update_interval_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_TelemetryConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_TelemetryConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_TelemetryConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_TelemetryConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_TelemetryConfigDefaultTypeInternal _ModuleConfig_TelemetryConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_CannedMessageConfig::ModuleConfig_CannedMessageConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.allow_input_source_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.inputbroker_pin_a_)*/0u
  , /*decltype(_impl_.inputbroker_pin_b_)*/0u
  , /*decltype(_impl_.inputbroker_pin_press_)*/0u
  , /*decltype(_impl_.inputbroker_event_cw_)*/0
  , /*decltype(_impl_.inputbroker_event_ccw_)*/0
  , /*decltype(_impl_.inputbroker_event_press_)*/0
  , /*decltype(_impl_.rotary1_enabled_)*/false
  , /*decltype(_impl_.updown1_enabled_)*/false
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.send_bell_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_CannedMessageConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_CannedMessageConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_CannedMessageConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_CannedMessageConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_CannedMessageConfigDefaultTypeInternal _ModuleConfig_CannedMessageConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig_AmbientLightingConfig::ModuleConfig_AmbientLightingConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.led_state_)*/false
  , /*decltype(_impl_.current_)*/0u
  , /*decltype(_impl_.red_)*/0u
  , /*decltype(_impl_.green_)*/0u
  , /*decltype(_impl_.blue_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModuleConfig_AmbientLightingConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfig_AmbientLightingConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfig_AmbientLightingConfigDefaultTypeInternal() {}
  union {
    ModuleConfig_AmbientLightingConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfig_AmbientLightingConfigDefaultTypeInternal _ModuleConfig_AmbientLightingConfig_default_instance_;
PROTOBUF_CONSTEXPR ModuleConfig::ModuleConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payload_variant_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ModuleConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModuleConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModuleConfigDefaultTypeInternal() {}
  union {
    ModuleConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModuleConfigDefaultTypeInternal _ModuleConfig_default_instance_;
PROTOBUF_CONSTEXPR RemoteHardwarePin::RemoteHardwarePin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gpio_pin_)*/0u
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RemoteHardwarePinDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoteHardwarePinDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoteHardwarePinDefaultTypeInternal() {}
  union {
    RemoteHardwarePin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoteHardwarePinDefaultTypeInternal _RemoteHardwarePin_default_instance_;
}  // namespace meshtastic
static ::_pb::Metadata file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[16];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_meshtastic_2fmodule_5fconfig_2eproto[6];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_meshtastic_2fmodule_5fconfig_2eproto = nullptr;

const uint32_t TableStruct_meshtastic_2fmodule_5fconfig_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _impl_.username_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _impl_.password_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _impl_.encryption_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _impl_.json_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _impl_.tls_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _impl_.root_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _impl_.proxy_to_client_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _impl_.map_reporting_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MQTTConfig, _impl_.map_report_settings_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MapReportSettings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MapReportSettings, _impl_.publish_interval_secs_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MapReportSettings, _impl_.position_precision_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_MapReportSettings, _impl_.should_report_location_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_RemoteHardwareConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_RemoteHardwareConfig, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_RemoteHardwareConfig, _impl_.allow_undefined_pin_access_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_RemoteHardwareConfig, _impl_.available_pins_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_NeighborInfoConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_NeighborInfoConfig, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_NeighborInfoConfig, _impl_.update_interval_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_NeighborInfoConfig, _impl_.transmit_over_lora_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_DetectionSensorConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_DetectionSensorConfig, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_DetectionSensorConfig, _impl_.minimum_broadcast_secs_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_DetectionSensorConfig, _impl_.state_broadcast_secs_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_DetectionSensorConfig, _impl_.send_bell_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_DetectionSensorConfig, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_DetectionSensorConfig, _impl_.monitor_pin_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_DetectionSensorConfig, _impl_.detection_trigger_type_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_DetectionSensorConfig, _impl_.use_pullup_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AudioConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AudioConfig, _impl_.codec2_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AudioConfig, _impl_.ptt_pin_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AudioConfig, _impl_.bitrate_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AudioConfig, _impl_.i2s_ws_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AudioConfig, _impl_.i2s_sd_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AudioConfig, _impl_.i2s_din_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AudioConfig, _impl_.i2s_sck_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_PaxcounterConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_PaxcounterConfig, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_PaxcounterConfig, _impl_.paxcounter_update_interval_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_PaxcounterConfig, _impl_.wifi_threshold_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_PaxcounterConfig, _impl_.ble_threshold_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_SerialConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_SerialConfig, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_SerialConfig, _impl_.echo_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_SerialConfig, _impl_.rxd_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_SerialConfig, _impl_.txd_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_SerialConfig, _impl_.baud_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_SerialConfig, _impl_.timeout_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_SerialConfig, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_SerialConfig, _impl_.override_console_serial_port_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.output_ms_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.output_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.output_vibra_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.output_buzzer_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.active_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.alert_message_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.alert_message_vibra_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.alert_message_buzzer_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.alert_bell_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.alert_bell_vibra_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.alert_bell_buzzer_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.use_pwm_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.nag_timeout_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_ExternalNotificationConfig, _impl_.use_i2s_as_buzzer_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_StoreForwardConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_StoreForwardConfig, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_StoreForwardConfig, _impl_.heartbeat_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_StoreForwardConfig, _impl_.records_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_StoreForwardConfig, _impl_.history_return_max_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_StoreForwardConfig, _impl_.history_return_window_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_StoreForwardConfig, _impl_.is_server_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_RangeTestConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_RangeTestConfig, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_RangeTestConfig, _impl_.sender_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_RangeTestConfig, _impl_.save_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_RangeTestConfig, _impl_.clear_on_reboot_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.device_update_interval_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.environment_update_interval_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.environment_measurement_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.environment_screen_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.environment_display_fahrenheit_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.air_quality_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.air_quality_interval_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.power_measurement_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.power_update_interval_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.power_screen_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.health_measurement_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.health_update_interval_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_TelemetryConfig, _impl_.health_screen_enabled_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _impl_.rotary1_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _impl_.inputbroker_pin_a_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _impl_.inputbroker_pin_b_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _impl_.inputbroker_pin_press_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _impl_.inputbroker_event_cw_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _impl_.inputbroker_event_ccw_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _impl_.inputbroker_event_press_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _impl_.updown1_enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _impl_.allow_input_source_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_CannedMessageConfig, _impl_.send_bell_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AmbientLightingConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AmbientLightingConfig, _impl_.led_state_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AmbientLightingConfig, _impl_.current_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AmbientLightingConfig, _impl_.red_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AmbientLightingConfig, _impl_.green_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig_AmbientLightingConfig, _impl_.blue_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::meshtastic::ModuleConfig, _impl_.payload_variant_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::meshtastic::RemoteHardwarePin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::meshtastic::RemoteHardwarePin, _impl_.gpio_pin_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::RemoteHardwarePin, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::meshtastic::RemoteHardwarePin, _impl_.type_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::meshtastic::ModuleConfig_MQTTConfig)},
  { 17, -1, -1, sizeof(::meshtastic::ModuleConfig_MapReportSettings)},
  { 26, -1, -1, sizeof(::meshtastic::ModuleConfig_RemoteHardwareConfig)},
  { 35, -1, -1, sizeof(::meshtastic::ModuleConfig_NeighborInfoConfig)},
  { 44, -1, -1, sizeof(::meshtastic::ModuleConfig_DetectionSensorConfig)},
  { 58, -1, -1, sizeof(::meshtastic::ModuleConfig_AudioConfig)},
  { 71, -1, -1, sizeof(::meshtastic::ModuleConfig_PaxcounterConfig)},
  { 81, -1, -1, sizeof(::meshtastic::ModuleConfig_SerialConfig)},
  { 95, -1, -1, sizeof(::meshtastic::ModuleConfig_ExternalNotificationConfig)},
  { 116, -1, -1, sizeof(::meshtastic::ModuleConfig_StoreForwardConfig)},
  { 128, -1, -1, sizeof(::meshtastic::ModuleConfig_RangeTestConfig)},
  { 138, -1, -1, sizeof(::meshtastic::ModuleConfig_TelemetryConfig)},
  { 157, -1, -1, sizeof(::meshtastic::ModuleConfig_CannedMessageConfig)},
  { 174, -1, -1, sizeof(::meshtastic::ModuleConfig_AmbientLightingConfig)},
  { 185, -1, -1, sizeof(::meshtastic::ModuleConfig)},
  { 205, -1, -1, sizeof(::meshtastic::RemoteHardwarePin)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::meshtastic::_ModuleConfig_MQTTConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_MapReportSettings_default_instance_._instance,
  &::meshtastic::_ModuleConfig_RemoteHardwareConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_NeighborInfoConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_DetectionSensorConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_AudioConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_PaxcounterConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_SerialConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_ExternalNotificationConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_StoreForwardConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_RangeTestConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_TelemetryConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_CannedMessageConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_AmbientLightingConfig_default_instance_._instance,
  &::meshtastic::_ModuleConfig_default_instance_._instance,
  &::meshtastic::_RemoteHardwarePin_default_instance_._instance,
};

const char descriptor_table_protodef_meshtastic_2fmodule_5fconfig_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\036meshtastic/module_config.proto\022\nmeshta"
  "stic\"\223&\n\014ModuleConfig\0223\n\004mqtt\030\001 \001(\0132#.me"
  "shtastic.ModuleConfig.MQTTConfigH\000\0227\n\006se"
  "rial\030\002 \001(\0132%.meshtastic.ModuleConfig.Ser"
  "ialConfigH\000\022T\n\025external_notification\030\003 \001"
  "(\01323.meshtastic.ModuleConfig.ExternalNot"
  "ificationConfigH\000\022D\n\rstore_forward\030\004 \001(\013"
  "2+.meshtastic.ModuleConfig.StoreForwardC"
  "onfigH\000\022>\n\nrange_test\030\005 \001(\0132(.meshtastic"
  ".ModuleConfig.RangeTestConfigH\000\022=\n\ttelem"
  "etry\030\006 \001(\0132(.meshtastic.ModuleConfig.Tel"
  "emetryConfigH\000\022F\n\016canned_message\030\007 \001(\0132,"
  ".meshtastic.ModuleConfig.CannedMessageCo"
  "nfigH\000\0225\n\005audio\030\010 \001(\0132$.meshtastic.Modul"
  "eConfig.AudioConfigH\000\022H\n\017remote_hardware"
  "\030\t \001(\0132-.meshtastic.ModuleConfig.RemoteH"
  "ardwareConfigH\000\022D\n\rneighbor_info\030\n \001(\0132+"
  ".meshtastic.ModuleConfig.NeighborInfoCon"
  "figH\000\022J\n\020ambient_lighting\030\013 \001(\0132..meshta"
  "stic.ModuleConfig.AmbientLightingConfigH"
  "\000\022J\n\020detection_sensor\030\014 \001(\0132..meshtastic"
  ".ModuleConfig.DetectionSensorConfigH\000\022\?\n"
  "\npaxcounter\030\r \001(\0132).meshtastic.ModuleCon"
  "fig.PaxcounterConfigH\000\032\260\002\n\nMQTTConfig\022\017\n"
  "\007enabled\030\001 \001(\010\022\017\n\007address\030\002 \001(\t\022\020\n\010usern"
  "ame\030\003 \001(\t\022\020\n\010password\030\004 \001(\t\022\032\n\022encryptio"
  "n_enabled\030\005 \001(\010\022\024\n\014json_enabled\030\006 \001(\010\022\023\n"
  "\013tls_enabled\030\007 \001(\010\022\014\n\004root\030\010 \001(\t\022\037\n\027prox"
  "y_to_client_enabled\030\t \001(\010\022\035\n\025map_reporti"
  "ng_enabled\030\n \001(\010\022G\n\023map_report_settings\030"
  "\013 \001(\0132*.meshtastic.ModuleConfig.MapRepor"
  "tSettings\032n\n\021MapReportSettings\022\035\n\025publis"
  "h_interval_secs\030\001 \001(\r\022\032\n\022position_precis"
  "ion\030\002 \001(\r\022\036\n\026should_report_location\030\003 \001("
  "\010\032\202\001\n\024RemoteHardwareConfig\022\017\n\007enabled\030\001 "
  "\001(\010\022\"\n\032allow_undefined_pin_access\030\002 \001(\010\022"
  "5\n\016available_pins\030\003 \003(\0132\035.meshtastic.Rem"
  "oteHardwarePin\032Z\n\022NeighborInfoConfig\022\017\n\007"
  "enabled\030\001 \001(\010\022\027\n\017update_interval\030\002 \001(\r\022\032"
  "\n\022transmit_over_lora\030\003 \001(\010\032\227\003\n\025Detection"
  "SensorConfig\022\017\n\007enabled\030\001 \001(\010\022\036\n\026minimum"
  "_broadcast_secs\030\002 \001(\r\022\034\n\024state_broadcast"
  "_secs\030\003 \001(\r\022\021\n\tsend_bell\030\004 \001(\010\022\014\n\004name\030\005"
  " \001(\t\022\023\n\013monitor_pin\030\006 \001(\r\022Z\n\026detection_t"
  "rigger_type\030\007 \001(\0162:.meshtastic.ModuleCon"
  "fig.DetectionSensorConfig.TriggerType\022\022\n"
  "\nuse_pullup\030\010 \001(\010\"\210\001\n\013TriggerType\022\r\n\tLOG"
  "IC_LOW\020\000\022\016\n\nLOGIC_HIGH\020\001\022\020\n\014FALLING_EDGE"
  "\020\002\022\017\n\013RISING_EDGE\020\003\022\032\n\026EITHER_EDGE_ACTIV"
  "E_LOW\020\004\022\033\n\027EITHER_EDGE_ACTIVE_HIGH\020\005\032\344\002\n"
  "\013AudioConfig\022\026\n\016codec2_enabled\030\001 \001(\010\022\017\n\007"
  "ptt_pin\030\002 \001(\r\022@\n\007bitrate\030\003 \001(\0162/.meshtas"
  "tic.ModuleConfig.AudioConfig.Audio_Baud\022"
  "\016\n\006i2s_ws\030\004 \001(\r\022\016\n\006i2s_sd\030\005 \001(\r\022\017\n\007i2s_d"
  "in\030\006 \001(\r\022\017\n\007i2s_sck\030\007 \001(\r\"\247\001\n\nAudio_Baud"
  "\022\022\n\016CODEC2_DEFAULT\020\000\022\017\n\013CODEC2_3200\020\001\022\017\n"
  "\013CODEC2_2400\020\002\022\017\n\013CODEC2_1600\020\003\022\017\n\013CODEC"
  "2_1400\020\004\022\017\n\013CODEC2_1300\020\005\022\017\n\013CODEC2_1200"
  "\020\006\022\016\n\nCODEC2_700\020\007\022\017\n\013CODEC2_700B\020\010\032v\n\020P"
  "axcounterConfig\022\017\n\007enabled\030\001 \001(\010\022\"\n\032paxc"
  "ounter_update_interval\030\002 \001(\r\022\026\n\016wifi_thr"
  "eshold\030\003 \001(\005\022\025\n\rble_threshold\030\004 \001(\005\032\214\005\n\014"
  "SerialConfig\022\017\n\007enabled\030\001 \001(\010\022\014\n\004echo\030\002 "
  "\001(\010\022\013\n\003rxd\030\003 \001(\r\022\013\n\003txd\030\004 \001(\r\022\?\n\004baud\030\005 "
  "\001(\01621.meshtastic.ModuleConfig.SerialConf"
  "ig.Serial_Baud\022\017\n\007timeout\030\006 \001(\r\022\?\n\004mode\030"
  "\007 \001(\01621.meshtastic.ModuleConfig.SerialCo"
  "nfig.Serial_Mode\022$\n\034override_console_ser"
  "ial_port\030\010 \001(\010\"\212\002\n\013Serial_Baud\022\020\n\014BAUD_D"
  "EFAULT\020\000\022\014\n\010BAUD_110\020\001\022\014\n\010BAUD_300\020\002\022\014\n\010"
  "BAUD_600\020\003\022\r\n\tBAUD_1200\020\004\022\r\n\tBAUD_2400\020\005"
  "\022\r\n\tBAUD_4800\020\006\022\r\n\tBAUD_9600\020\007\022\016\n\nBAUD_1"
  "9200\020\010\022\016\n\nBAUD_38400\020\t\022\016\n\nBAUD_57600\020\n\022\017"
  "\n\013BAUD_115200\020\013\022\017\n\013BAUD_230400\020\014\022\017\n\013BAUD"
  "_460800\020\r\022\017\n\013BAUD_576000\020\016\022\017\n\013BAUD_92160"
  "0\020\017\"}\n\013Serial_Mode\022\013\n\007DEFAULT\020\000\022\n\n\006SIMPL"
  "E\020\001\022\t\n\005PROTO\020\002\022\013\n\007TEXTMSG\020\003\022\010\n\004NMEA\020\004\022\013\n"
  "\007CALTOPO\020\005\022\010\n\004WS85\020\006\022\r\n\tVE_DIRECT\020\007\022\r\n\tM"
  "S_CONFIG\020\010\032\351\002\n\032ExternalNotificationConfi"
  "g\022\017\n\007enabled\030\001 \001(\010\022\021\n\toutput_ms\030\002 \001(\r\022\016\n"
  "\006output\030\003 \001(\r\022\024\n\014output_vibra\030\010 \001(\r\022\025\n\ro"
  "utput_buzzer\030\t \001(\r\022\016\n\006active\030\004 \001(\010\022\025\n\ral"
  "ert_message\030\005 \001(\010\022\033\n\023alert_message_vibra"
  "\030\n \001(\010\022\034\n\024alert_message_buzzer\030\013 \001(\010\022\022\n\n"
  "alert_bell\030\006 \001(\010\022\030\n\020alert_bell_vibra\030\014 \001"
  "(\010\022\031\n\021alert_bell_buzzer\030\r \001(\010\022\017\n\007use_pwm"
  "\030\007 \001(\010\022\023\n\013nag_timeout\030\016 \001(\r\022\031\n\021use_i2s_a"
  "s_buzzer\030\017 \001(\010\032\227\001\n\022StoreForwardConfig\022\017\n"
  "\007enabled\030\001 \001(\010\022\021\n\theartbeat\030\002 \001(\010\022\017\n\007rec"
  "ords\030\003 \001(\r\022\032\n\022history_return_max\030\004 \001(\r\022\035"
  "\n\025history_return_window\030\005 \001(\r\022\021\n\tis_serv"
  "er\030\006 \001(\010\032Y\n\017RangeTestConfig\022\017\n\007enabled\030\001"
  " \001(\010\022\016\n\006sender\030\002 \001(\r\022\014\n\004save\030\003 \001(\010\022\027\n\017cl"
  "ear_on_reboot\030\004 \001(\010\032\311\003\n\017TelemetryConfig\022"
  "\036\n\026device_update_interval\030\001 \001(\r\022#\n\033envir"
  "onment_update_interval\030\002 \001(\r\022\'\n\037environm"
  "ent_measurement_enabled\030\003 \001(\010\022\"\n\032environ"
  "ment_screen_enabled\030\004 \001(\010\022&\n\036environment"
  "_display_fahrenheit\030\005 \001(\010\022\033\n\023air_quality"
  "_enabled\030\006 \001(\010\022\034\n\024air_quality_interval\030\007"
  " \001(\r\022!\n\031power_measurement_enabled\030\010 \001(\010\022"
  "\035\n\025power_update_interval\030\t \001(\r\022\034\n\024power_"
  "screen_enabled\030\n \001(\010\022\"\n\032health_measureme"
  "nt_enabled\030\013 \001(\010\022\036\n\026health_update_interv"
  "al\030\014 \001(\r\022\035\n\025health_screen_enabled\030\r \001(\010\032"
  "\336\004\n\023CannedMessageConfig\022\027\n\017rotary1_enabl"
  "ed\030\001 \001(\010\022\031\n\021inputbroker_pin_a\030\002 \001(\r\022\031\n\021i"
  "nputbroker_pin_b\030\003 \001(\r\022\035\n\025inputbroker_pi"
  "n_press\030\004 \001(\r\022Y\n\024inputbroker_event_cw\030\005 "
  "\001(\0162;.meshtastic.ModuleConfig.CannedMess"
  "ageConfig.InputEventChar\022Z\n\025inputbroker_"
  "event_ccw\030\006 \001(\0162;.meshtastic.ModuleConfi"
  "g.CannedMessageConfig.InputEventChar\022\\\n\027"
  "inputbroker_event_press\030\007 \001(\0162;.meshtast"
  "ic.ModuleConfig.CannedMessageConfig.Inpu"
  "tEventChar\022\027\n\017updown1_enabled\030\010 \001(\010\022\023\n\007e"
  "nabled\030\t \001(\010B\002\030\001\022\036\n\022allow_input_source\030\n"
  " \001(\tB\002\030\001\022\021\n\tsend_bell\030\013 \001(\010\"c\n\016InputEven"
  "tChar\022\010\n\004NONE\020\000\022\006\n\002UP\020\021\022\010\n\004DOWN\020\022\022\010\n\004LEF"
  "T\020\023\022\t\n\005RIGHT\020\024\022\n\n\006SELECT\020\n\022\010\n\004BACK\020\033\022\n\n\006"
  "CANCEL\020\030\032e\n\025AmbientLightingConfig\022\021\n\tled"
  "_state\030\001 \001(\010\022\017\n\007current\030\002 \001(\r\022\013\n\003red\030\003 \001"
  "(\r\022\r\n\005green\030\004 \001(\r\022\014\n\004blue\030\005 \001(\rB\021\n\017paylo"
  "ad_variant\"d\n\021RemoteHardwarePin\022\020\n\010gpio_"
  "pin\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022/\n\004type\030\003 \001(\0162!."
  "meshtastic.RemoteHardwarePinType*I\n\025Remo"
  "teHardwarePinType\022\013\n\007UNKNOWN\020\000\022\020\n\014DIGITA"
  "L_READ\020\001\022\021\n\rDIGITAL_WRITE\020\002Bg\n\023com.geeks"
  "ville.meshB\022ModuleConfigProtosZ\"github.c"
  "om/meshtastic/go/generated\252\002\024Meshtastic."
  "Protobufs\272\002\000b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_meshtastic_2fmodule_5fconfig_2eproto = {
    false, false, 5220, descriptor_table_protodef_meshtastic_2fmodule_5fconfig_2eproto,
    "meshtastic/module_config.proto",
    &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once, nullptr, 0, 16,
    schemas, file_default_instances, TableStruct_meshtastic_2fmodule_5fconfig_2eproto::offsets,
    file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto, file_level_enum_descriptors_meshtastic_2fmodule_5fconfig_2eproto,
    file_level_service_descriptors_meshtastic_2fmodule_5fconfig_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter() {
  return &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_meshtastic_2fmodule_5fconfig_2eproto(&descriptor_table_meshtastic_2fmodule_5fconfig_2eproto);
namespace meshtastic {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleConfig_DetectionSensorConfig_TriggerType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmodule_5fconfig_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmodule_5fconfig_2eproto[0];
}
bool ModuleConfig_DetectionSensorConfig_TriggerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig::LOGIC_LOW;
constexpr ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig::LOGIC_HIGH;
constexpr ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig::FALLING_EDGE;
constexpr ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig::RISING_EDGE;
constexpr ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig::EITHER_EDGE_ACTIVE_LOW;
constexpr ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig::EITHER_EDGE_ACTIVE_HIGH;
constexpr ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig::TriggerType_MIN;
constexpr ModuleConfig_DetectionSensorConfig_TriggerType ModuleConfig_DetectionSensorConfig::TriggerType_MAX;
constexpr int ModuleConfig_DetectionSensorConfig::TriggerType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleConfig_AudioConfig_Audio_Baud_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmodule_5fconfig_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmodule_5fconfig_2eproto[1];
}
bool ModuleConfig_AudioConfig_Audio_Baud_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::CODEC2_DEFAULT;
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::CODEC2_3200;
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::CODEC2_2400;
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::CODEC2_1600;
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::CODEC2_1400;
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::CODEC2_1300;
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::CODEC2_1200;
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::CODEC2_700;
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::CODEC2_700B;
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::Audio_Baud_MIN;
constexpr ModuleConfig_AudioConfig_Audio_Baud ModuleConfig_AudioConfig::Audio_Baud_MAX;
constexpr int ModuleConfig_AudioConfig::Audio_Baud_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleConfig_SerialConfig_Serial_Baud_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmodule_5fconfig_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmodule_5fconfig_2eproto[2];
}
bool ModuleConfig_SerialConfig_Serial_Baud_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_DEFAULT;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_110;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_300;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_600;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_1200;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_2400;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_4800;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_9600;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_19200;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_38400;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_57600;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_115200;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_230400;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_460800;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_576000;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::BAUD_921600;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::Serial_Baud_MIN;
constexpr ModuleConfig_SerialConfig_Serial_Baud ModuleConfig_SerialConfig::Serial_Baud_MAX;
constexpr int ModuleConfig_SerialConfig::Serial_Baud_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleConfig_SerialConfig_Serial_Mode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmodule_5fconfig_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmodule_5fconfig_2eproto[3];
}
bool ModuleConfig_SerialConfig_Serial_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::DEFAULT;
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::SIMPLE;
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::PROTO;
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::TEXTMSG;
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::NMEA;
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::CALTOPO;
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::WS85;
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::VE_DIRECT;
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::MS_CONFIG;
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::Serial_Mode_MIN;
constexpr ModuleConfig_SerialConfig_Serial_Mode ModuleConfig_SerialConfig::Serial_Mode_MAX;
constexpr int ModuleConfig_SerialConfig::Serial_Mode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModuleConfig_CannedMessageConfig_InputEventChar_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmodule_5fconfig_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmodule_5fconfig_2eproto[4];
}
bool ModuleConfig_CannedMessageConfig_InputEventChar_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
    case 17:
    case 18:
    case 19:
    case 20:
    case 24:
    case 27:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::NONE;
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::UP;
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::DOWN;
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::LEFT;
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::RIGHT;
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::SELECT;
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::BACK;
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::CANCEL;
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::InputEventChar_MIN;
constexpr ModuleConfig_CannedMessageConfig_InputEventChar ModuleConfig_CannedMessageConfig::InputEventChar_MAX;
constexpr int ModuleConfig_CannedMessageConfig::InputEventChar_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RemoteHardwarePinType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmodule_5fconfig_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmodule_5fconfig_2eproto[5];
}
bool RemoteHardwarePinType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class ModuleConfig_MQTTConfig::_Internal {
 public:
  static const ::meshtastic::ModuleConfig_MapReportSettings& map_report_settings(const ModuleConfig_MQTTConfig* msg);
};

const ::meshtastic::ModuleConfig_MapReportSettings&
ModuleConfig_MQTTConfig::_Internal::map_report_settings(const ModuleConfig_MQTTConfig* msg) {
  return *msg->_impl_.map_report_settings_;
}
ModuleConfig_MQTTConfig::ModuleConfig_MQTTConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.MQTTConfig)
}
ModuleConfig_MQTTConfig::ModuleConfig_MQTTConfig(const ModuleConfig_MQTTConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_MQTTConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.username_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.root_){}
    , decltype(_impl_.map_report_settings_){nullptr}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.encryption_enabled_){}
    , decltype(_impl_.json_enabled_){}
    , decltype(_impl_.tls_enabled_){}
    , decltype(_impl_.proxy_to_client_enabled_){}
    , decltype(_impl_.map_reporting_enabled_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_username().empty()) {
    _this->_impl_.username_.Set(from._internal_username(), 
      _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), 
      _this->GetArenaForAllocation());
  }
  _impl_.root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_root().empty()) {
    _this->_impl_.root_.Set(from._internal_root(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_map_report_settings()) {
    _this->_impl_.map_report_settings_ = new ::meshtastic::ModuleConfig_MapReportSettings(*from._impl_.map_report_settings_);
  }
  ::memcpy(&_impl_.enabled_, &from._impl_.enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.map_reporting_enabled_) -
    reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.map_reporting_enabled_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.MQTTConfig)
}

inline void ModuleConfig_MQTTConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.username_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.root_){}
    , decltype(_impl_.map_report_settings_){nullptr}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.encryption_enabled_){false}
    , decltype(_impl_.json_enabled_){false}
    , decltype(_impl_.tls_enabled_){false}
    , decltype(_impl_.proxy_to_client_enabled_){false}
    , decltype(_impl_.map_reporting_enabled_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModuleConfig_MQTTConfig::~ModuleConfig_MQTTConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.MQTTConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_MQTTConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
  _impl_.username_.Destroy();
  _impl_.password_.Destroy();
  _impl_.root_.Destroy();
  if (this != internal_default_instance()) delete _impl_.map_report_settings_;
}

void ModuleConfig_MQTTConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_MQTTConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.MQTTConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_.ClearToEmpty();
  _impl_.username_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  _impl_.root_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.map_report_settings_ != nullptr) {
    delete _impl_.map_report_settings_;
  }
  _impl_.map_report_settings_ = nullptr;
  ::memset(&_impl_.enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.map_reporting_enabled_) -
      reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.map_reporting_enabled_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_MQTTConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.ModuleConfig.MQTTConfig.address"));
        } else
          goto handle_unusual;
        continue;
      // string username = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_username();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.ModuleConfig.MQTTConfig.username"));
        } else
          goto handle_unusual;
        continue;
      // string password = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.ModuleConfig.MQTTConfig.password"));
        } else
          goto handle_unusual;
        continue;
      // bool encryption_enabled = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.encryption_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool json_enabled = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.json_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool tls_enabled = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.tls_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string root = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_root();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.ModuleConfig.MQTTConfig.root"));
        } else
          goto handle_unusual;
        continue;
      // bool proxy_to_client_enabled = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.proxy_to_client_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool map_reporting_enabled = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.map_reporting_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.MapReportSettings map_report_settings = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_report_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_MQTTConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.MQTTConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // string address = 2;
  if (!this->_internal_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.ModuleConfig.MQTTConfig.address");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_address(), target);
  }

  // string username = 3;
  if (!this->_internal_username().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_username().data(), static_cast<int>(this->_internal_username().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.ModuleConfig.MQTTConfig.username");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_username(), target);
  }

  // string password = 4;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.ModuleConfig.MQTTConfig.password");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_password(), target);
  }

  // bool encryption_enabled = 5;
  if (this->_internal_encryption_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_encryption_enabled(), target);
  }

  // bool json_enabled = 6;
  if (this->_internal_json_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_json_enabled(), target);
  }

  // bool tls_enabled = 7;
  if (this->_internal_tls_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_tls_enabled(), target);
  }

  // string root = 8;
  if (!this->_internal_root().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_root().data(), static_cast<int>(this->_internal_root().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.ModuleConfig.MQTTConfig.root");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_root(), target);
  }

  // bool proxy_to_client_enabled = 9;
  if (this->_internal_proxy_to_client_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_proxy_to_client_enabled(), target);
  }

  // bool map_reporting_enabled = 10;
  if (this->_internal_map_reporting_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_map_reporting_enabled(), target);
  }

  // .meshtastic.ModuleConfig.MapReportSettings map_report_settings = 11;
  if (this->_internal_has_map_report_settings()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::map_report_settings(this),
        _Internal::map_report_settings(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.MQTTConfig)
  return target;
}

size_t ModuleConfig_MQTTConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.MQTTConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string address = 2;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_address());
  }

  // string username = 3;
  if (!this->_internal_username().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_username());
  }

  // string password = 4;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  // string root = 8;
  if (!this->_internal_root().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_root());
  }

  // .meshtastic.ModuleConfig.MapReportSettings map_report_settings = 11;
  if (this->_internal_has_map_report_settings()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.map_report_settings_);
  }

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool encryption_enabled = 5;
  if (this->_internal_encryption_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool json_enabled = 6;
  if (this->_internal_json_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool tls_enabled = 7;
  if (this->_internal_tls_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool proxy_to_client_enabled = 9;
  if (this->_internal_proxy_to_client_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool map_reporting_enabled = 10;
  if (this->_internal_map_reporting_enabled() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_MQTTConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_MQTTConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_MQTTConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_MQTTConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_MQTTConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_MQTTConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.MQTTConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (!from._internal_username().empty()) {
    _this->_internal_set_username(from._internal_username());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  if (!from._internal_root().empty()) {
    _this->_internal_set_root(from._internal_root());
  }
  if (from._internal_has_map_report_settings()) {
    _this->_internal_mutable_map_report_settings()->::meshtastic::ModuleConfig_MapReportSettings::MergeFrom(
        from._internal_map_report_settings());
  }
  if (from._internal_enabled() != 0) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  if (from._internal_encryption_enabled() != 0) {
    _this->_internal_set_encryption_enabled(from._internal_encryption_enabled());
  }
  if (from._internal_json_enabled() != 0) {
    _this->_internal_set_json_enabled(from._internal_json_enabled());
  }
  if (from._internal_tls_enabled() != 0) {
    _this->_internal_set_tls_enabled(from._internal_tls_enabled());
  }
  if (from._internal_proxy_to_client_enabled() != 0) {
    _this->_internal_set_proxy_to_client_enabled(from._internal_proxy_to_client_enabled());
  }
  if (from._internal_map_reporting_enabled() != 0) {
    _this->_internal_set_map_reporting_enabled(from._internal_map_reporting_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_MQTTConfig::CopyFrom(const ModuleConfig_MQTTConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.MQTTConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_MQTTConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_MQTTConfig::InternalSwap(ModuleConfig_MQTTConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.username_, lhs_arena,
      &other->_impl_.username_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.root_, lhs_arena,
      &other->_impl_.root_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_MQTTConfig, _impl_.map_reporting_enabled_)
      + sizeof(ModuleConfig_MQTTConfig::_impl_.map_reporting_enabled_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_MQTTConfig, _impl_.map_report_settings_)>(
          reinterpret_cast<char*>(&_impl_.map_report_settings_),
          reinterpret_cast<char*>(&other->_impl_.map_report_settings_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_MQTTConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[0]);
}

// ===================================================================

class ModuleConfig_MapReportSettings::_Internal {
 public:
};

ModuleConfig_MapReportSettings::ModuleConfig_MapReportSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.MapReportSettings)
}
ModuleConfig_MapReportSettings::ModuleConfig_MapReportSettings(const ModuleConfig_MapReportSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_MapReportSettings* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.publish_interval_secs_){}
    , decltype(_impl_.position_precision_){}
    , decltype(_impl_.should_report_location_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.publish_interval_secs_, &from._impl_.publish_interval_secs_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.should_report_location_) -
    reinterpret_cast<char*>(&_impl_.publish_interval_secs_)) + sizeof(_impl_.should_report_location_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.MapReportSettings)
}

inline void ModuleConfig_MapReportSettings::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.publish_interval_secs_){0u}
    , decltype(_impl_.position_precision_){0u}
    , decltype(_impl_.should_report_location_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleConfig_MapReportSettings::~ModuleConfig_MapReportSettings() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.MapReportSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_MapReportSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModuleConfig_MapReportSettings::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_MapReportSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.MapReportSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.publish_interval_secs_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.should_report_location_) -
      reinterpret_cast<char*>(&_impl_.publish_interval_secs_)) + sizeof(_impl_.should_report_location_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_MapReportSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 publish_interval_secs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.publish_interval_secs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 position_precision = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.position_precision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool should_report_location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.should_report_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_MapReportSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.MapReportSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 publish_interval_secs = 1;
  if (this->_internal_publish_interval_secs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_publish_interval_secs(), target);
  }

  // uint32 position_precision = 2;
  if (this->_internal_position_precision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_position_precision(), target);
  }

  // bool should_report_location = 3;
  if (this->_internal_should_report_location() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_should_report_location(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.MapReportSettings)
  return target;
}

size_t ModuleConfig_MapReportSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.MapReportSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 publish_interval_secs = 1;
  if (this->_internal_publish_interval_secs() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_publish_interval_secs());
  }

  // uint32 position_precision = 2;
  if (this->_internal_position_precision() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_position_precision());
  }

  // bool should_report_location = 3;
  if (this->_internal_should_report_location() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_MapReportSettings::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_MapReportSettings::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_MapReportSettings::GetClassData() const { return &_class_data_; }


void ModuleConfig_MapReportSettings::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_MapReportSettings*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_MapReportSettings&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.MapReportSettings)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_publish_interval_secs() != 0) {
    _this->_internal_set_publish_interval_secs(from._internal_publish_interval_secs());
  }
  if (from._internal_position_precision() != 0) {
    _this->_internal_set_position_precision(from._internal_position_precision());
  }
  if (from._internal_should_report_location() != 0) {
    _this->_internal_set_should_report_location(from._internal_should_report_location());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_MapReportSettings::CopyFrom(const ModuleConfig_MapReportSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.MapReportSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_MapReportSettings::IsInitialized() const {
  return true;
}

void ModuleConfig_MapReportSettings::InternalSwap(ModuleConfig_MapReportSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_MapReportSettings, _impl_.should_report_location_)
      + sizeof(ModuleConfig_MapReportSettings::_impl_.should_report_location_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_MapReportSettings, _impl_.publish_interval_secs_)>(
          reinterpret_cast<char*>(&_impl_.publish_interval_secs_),
          reinterpret_cast<char*>(&other->_impl_.publish_interval_secs_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_MapReportSettings::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[1]);
}

// ===================================================================

class ModuleConfig_RemoteHardwareConfig::_Internal {
 public:
};

ModuleConfig_RemoteHardwareConfig::ModuleConfig_RemoteHardwareConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.RemoteHardwareConfig)
}
ModuleConfig_RemoteHardwareConfig::ModuleConfig_RemoteHardwareConfig(const ModuleConfig_RemoteHardwareConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_RemoteHardwareConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.available_pins_){from._impl_.available_pins_}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.allow_undefined_pin_access_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.enabled_, &from._impl_.enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.allow_undefined_pin_access_) -
    reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.allow_undefined_pin_access_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.RemoteHardwareConfig)
}

inline void ModuleConfig_RemoteHardwareConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.available_pins_){arena}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.allow_undefined_pin_access_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleConfig_RemoteHardwareConfig::~ModuleConfig_RemoteHardwareConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.RemoteHardwareConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_RemoteHardwareConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.available_pins_.~RepeatedPtrField();
}

void ModuleConfig_RemoteHardwareConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_RemoteHardwareConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.RemoteHardwareConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.available_pins_.Clear();
  ::memset(&_impl_.enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.allow_undefined_pin_access_) -
      reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.allow_undefined_pin_access_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_RemoteHardwareConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_undefined_pin_access = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_undefined_pin_access_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .meshtastic.RemoteHardwarePin available_pins = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_available_pins(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_RemoteHardwareConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.RemoteHardwareConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // bool allow_undefined_pin_access = 2;
  if (this->_internal_allow_undefined_pin_access() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_undefined_pin_access(), target);
  }

  // repeated .meshtastic.RemoteHardwarePin available_pins = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_available_pins_size()); i < n; i++) {
    const auto& repfield = this->_internal_available_pins(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.RemoteHardwareConfig)
  return target;
}

size_t ModuleConfig_RemoteHardwareConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.RemoteHardwareConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .meshtastic.RemoteHardwarePin available_pins = 3;
  total_size += 1UL * this->_internal_available_pins_size();
  for (const auto& msg : this->_impl_.available_pins_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool allow_undefined_pin_access = 2;
  if (this->_internal_allow_undefined_pin_access() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_RemoteHardwareConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_RemoteHardwareConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_RemoteHardwareConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_RemoteHardwareConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_RemoteHardwareConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_RemoteHardwareConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.RemoteHardwareConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.available_pins_.MergeFrom(from._impl_.available_pins_);
  if (from._internal_enabled() != 0) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  if (from._internal_allow_undefined_pin_access() != 0) {
    _this->_internal_set_allow_undefined_pin_access(from._internal_allow_undefined_pin_access());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_RemoteHardwareConfig::CopyFrom(const ModuleConfig_RemoteHardwareConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.RemoteHardwareConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_RemoteHardwareConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_RemoteHardwareConfig::InternalSwap(ModuleConfig_RemoteHardwareConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.available_pins_.InternalSwap(&other->_impl_.available_pins_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_RemoteHardwareConfig, _impl_.allow_undefined_pin_access_)
      + sizeof(ModuleConfig_RemoteHardwareConfig::_impl_.allow_undefined_pin_access_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_RemoteHardwareConfig, _impl_.enabled_)>(
          reinterpret_cast<char*>(&_impl_.enabled_),
          reinterpret_cast<char*>(&other->_impl_.enabled_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_RemoteHardwareConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[2]);
}

// ===================================================================

class ModuleConfig_NeighborInfoConfig::_Internal {
 public:
};

ModuleConfig_NeighborInfoConfig::ModuleConfig_NeighborInfoConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.NeighborInfoConfig)
}
ModuleConfig_NeighborInfoConfig::ModuleConfig_NeighborInfoConfig(const ModuleConfig_NeighborInfoConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_NeighborInfoConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.update_interval_){}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.transmit_over_lora_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.update_interval_, &from._impl_.update_interval_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.transmit_over_lora_) -
    reinterpret_cast<char*>(&_impl_.update_interval_)) + sizeof(_impl_.transmit_over_lora_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.NeighborInfoConfig)
}

inline void ModuleConfig_NeighborInfoConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.update_interval_){0u}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.transmit_over_lora_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleConfig_NeighborInfoConfig::~ModuleConfig_NeighborInfoConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.NeighborInfoConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_NeighborInfoConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModuleConfig_NeighborInfoConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_NeighborInfoConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.NeighborInfoConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.update_interval_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.transmit_over_lora_) -
      reinterpret_cast<char*>(&_impl_.update_interval_)) + sizeof(_impl_.transmit_over_lora_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_NeighborInfoConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 update_interval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.update_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool transmit_over_lora = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.transmit_over_lora_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_NeighborInfoConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.NeighborInfoConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // uint32 update_interval = 2;
  if (this->_internal_update_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_update_interval(), target);
  }

  // bool transmit_over_lora = 3;
  if (this->_internal_transmit_over_lora() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_transmit_over_lora(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.NeighborInfoConfig)
  return target;
}

size_t ModuleConfig_NeighborInfoConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.NeighborInfoConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 update_interval = 2;
  if (this->_internal_update_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_update_interval());
  }

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool transmit_over_lora = 3;
  if (this->_internal_transmit_over_lora() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_NeighborInfoConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_NeighborInfoConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_NeighborInfoConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_NeighborInfoConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_NeighborInfoConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_NeighborInfoConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.NeighborInfoConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_update_interval() != 0) {
    _this->_internal_set_update_interval(from._internal_update_interval());
  }
  if (from._internal_enabled() != 0) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  if (from._internal_transmit_over_lora() != 0) {
    _this->_internal_set_transmit_over_lora(from._internal_transmit_over_lora());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_NeighborInfoConfig::CopyFrom(const ModuleConfig_NeighborInfoConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.NeighborInfoConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_NeighborInfoConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_NeighborInfoConfig::InternalSwap(ModuleConfig_NeighborInfoConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_NeighborInfoConfig, _impl_.transmit_over_lora_)
      + sizeof(ModuleConfig_NeighborInfoConfig::_impl_.transmit_over_lora_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_NeighborInfoConfig, _impl_.update_interval_)>(
          reinterpret_cast<char*>(&_impl_.update_interval_),
          reinterpret_cast<char*>(&other->_impl_.update_interval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_NeighborInfoConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[3]);
}

// ===================================================================

class ModuleConfig_DetectionSensorConfig::_Internal {
 public:
};

ModuleConfig_DetectionSensorConfig::ModuleConfig_DetectionSensorConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.DetectionSensorConfig)
}
ModuleConfig_DetectionSensorConfig::ModuleConfig_DetectionSensorConfig(const ModuleConfig_DetectionSensorConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_DetectionSensorConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.minimum_broadcast_secs_){}
    , decltype(_impl_.state_broadcast_secs_){}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.send_bell_){}
    , decltype(_impl_.use_pullup_){}
    , decltype(_impl_.monitor_pin_){}
    , decltype(_impl_.detection_trigger_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.minimum_broadcast_secs_, &from._impl_.minimum_broadcast_secs_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.detection_trigger_type_) -
    reinterpret_cast<char*>(&_impl_.minimum_broadcast_secs_)) + sizeof(_impl_.detection_trigger_type_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.DetectionSensorConfig)
}

inline void ModuleConfig_DetectionSensorConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.minimum_broadcast_secs_){0u}
    , decltype(_impl_.state_broadcast_secs_){0u}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.send_bell_){false}
    , decltype(_impl_.use_pullup_){false}
    , decltype(_impl_.monitor_pin_){0u}
    , decltype(_impl_.detection_trigger_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModuleConfig_DetectionSensorConfig::~ModuleConfig_DetectionSensorConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.DetectionSensorConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_DetectionSensorConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void ModuleConfig_DetectionSensorConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_DetectionSensorConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.DetectionSensorConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.minimum_broadcast_secs_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.detection_trigger_type_) -
      reinterpret_cast<char*>(&_impl_.minimum_broadcast_secs_)) + sizeof(_impl_.detection_trigger_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_DetectionSensorConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 minimum_broadcast_secs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.minimum_broadcast_secs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 state_broadcast_secs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.state_broadcast_secs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool send_bell = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.send_bell_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.ModuleConfig.DetectionSensorConfig.name"));
        } else
          goto handle_unusual;
        continue;
      // uint32 monitor_pin = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.monitor_pin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType detection_trigger_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_detection_trigger_type(static_cast<::meshtastic::ModuleConfig_DetectionSensorConfig_TriggerType>(val));
        } else
          goto handle_unusual;
        continue;
      // bool use_pullup = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.use_pullup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_DetectionSensorConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.DetectionSensorConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // uint32 minimum_broadcast_secs = 2;
  if (this->_internal_minimum_broadcast_secs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_minimum_broadcast_secs(), target);
  }

  // uint32 state_broadcast_secs = 3;
  if (this->_internal_state_broadcast_secs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_state_broadcast_secs(), target);
  }

  // bool send_bell = 4;
  if (this->_internal_send_bell() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_send_bell(), target);
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.ModuleConfig.DetectionSensorConfig.name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  // uint32 monitor_pin = 6;
  if (this->_internal_monitor_pin() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_monitor_pin(), target);
  }

  // .meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType detection_trigger_type = 7;
  if (this->_internal_detection_trigger_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_detection_trigger_type(), target);
  }

  // bool use_pullup = 8;
  if (this->_internal_use_pullup() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_use_pullup(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.DetectionSensorConfig)
  return target;
}

size_t ModuleConfig_DetectionSensorConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.DetectionSensorConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 5;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // uint32 minimum_broadcast_secs = 2;
  if (this->_internal_minimum_broadcast_secs() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_minimum_broadcast_secs());
  }

  // uint32 state_broadcast_secs = 3;
  if (this->_internal_state_broadcast_secs() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_state_broadcast_secs());
  }

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool send_bell = 4;
  if (this->_internal_send_bell() != 0) {
    total_size += 1 + 1;
  }

  // bool use_pullup = 8;
  if (this->_internal_use_pullup() != 0) {
    total_size += 1 + 1;
  }

  // uint32 monitor_pin = 6;
  if (this->_internal_monitor_pin() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_monitor_pin());
  }

  // .meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType detection_trigger_type = 7;
  if (this->_internal_detection_trigger_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_detection_trigger_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_DetectionSensorConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_DetectionSensorConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_DetectionSensorConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_DetectionSensorConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_DetectionSensorConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_DetectionSensorConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.DetectionSensorConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_minimum_broadcast_secs() != 0) {
    _this->_internal_set_minimum_broadcast_secs(from._internal_minimum_broadcast_secs());
  }
  if (from._internal_state_broadcast_secs() != 0) {
    _this->_internal_set_state_broadcast_secs(from._internal_state_broadcast_secs());
  }
  if (from._internal_enabled() != 0) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  if (from._internal_send_bell() != 0) {
    _this->_internal_set_send_bell(from._internal_send_bell());
  }
  if (from._internal_use_pullup() != 0) {
    _this->_internal_set_use_pullup(from._internal_use_pullup());
  }
  if (from._internal_monitor_pin() != 0) {
    _this->_internal_set_monitor_pin(from._internal_monitor_pin());
  }
  if (from._internal_detection_trigger_type() != 0) {
    _this->_internal_set_detection_trigger_type(from._internal_detection_trigger_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_DetectionSensorConfig::CopyFrom(const ModuleConfig_DetectionSensorConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.DetectionSensorConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_DetectionSensorConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_DetectionSensorConfig::InternalSwap(ModuleConfig_DetectionSensorConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_DetectionSensorConfig, _impl_.detection_trigger_type_)
      + sizeof(ModuleConfig_DetectionSensorConfig::_impl_.detection_trigger_type_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_DetectionSensorConfig, _impl_.minimum_broadcast_secs_)>(
          reinterpret_cast<char*>(&_impl_.minimum_broadcast_secs_),
          reinterpret_cast<char*>(&other->_impl_.minimum_broadcast_secs_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_DetectionSensorConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[4]);
}

// ===================================================================

class ModuleConfig_AudioConfig::_Internal {
 public:
};

ModuleConfig_AudioConfig::ModuleConfig_AudioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.AudioConfig)
}
ModuleConfig_AudioConfig::ModuleConfig_AudioConfig(const ModuleConfig_AudioConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_AudioConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.codec2_enabled_){}
    , decltype(_impl_.ptt_pin_){}
    , decltype(_impl_.bitrate_){}
    , decltype(_impl_.i2s_ws_){}
    , decltype(_impl_.i2s_sd_){}
    , decltype(_impl_.i2s_din_){}
    , decltype(_impl_.i2s_sck_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.codec2_enabled_, &from._impl_.codec2_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.i2s_sck_) -
    reinterpret_cast<char*>(&_impl_.codec2_enabled_)) + sizeof(_impl_.i2s_sck_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.AudioConfig)
}

inline void ModuleConfig_AudioConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.codec2_enabled_){false}
    , decltype(_impl_.ptt_pin_){0u}
    , decltype(_impl_.bitrate_){0}
    , decltype(_impl_.i2s_ws_){0u}
    , decltype(_impl_.i2s_sd_){0u}
    , decltype(_impl_.i2s_din_){0u}
    , decltype(_impl_.i2s_sck_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleConfig_AudioConfig::~ModuleConfig_AudioConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.AudioConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_AudioConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModuleConfig_AudioConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_AudioConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.AudioConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.codec2_enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.i2s_sck_) -
      reinterpret_cast<char*>(&_impl_.codec2_enabled_)) + sizeof(_impl_.i2s_sck_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_AudioConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool codec2_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.codec2_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ptt_pin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.ptt_pin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.AudioConfig.Audio_Baud bitrate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_bitrate(static_cast<::meshtastic::ModuleConfig_AudioConfig_Audio_Baud>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 i2s_ws = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.i2s_ws_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 i2s_sd = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.i2s_sd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 i2s_din = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.i2s_din_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 i2s_sck = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.i2s_sck_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_AudioConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.AudioConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool codec2_enabled = 1;
  if (this->_internal_codec2_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_codec2_enabled(), target);
  }

  // uint32 ptt_pin = 2;
  if (this->_internal_ptt_pin() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ptt_pin(), target);
  }

  // .meshtastic.ModuleConfig.AudioConfig.Audio_Baud bitrate = 3;
  if (this->_internal_bitrate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_bitrate(), target);
  }

  // uint32 i2s_ws = 4;
  if (this->_internal_i2s_ws() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_i2s_ws(), target);
  }

  // uint32 i2s_sd = 5;
  if (this->_internal_i2s_sd() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_i2s_sd(), target);
  }

  // uint32 i2s_din = 6;
  if (this->_internal_i2s_din() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_i2s_din(), target);
  }

  // uint32 i2s_sck = 7;
  if (this->_internal_i2s_sck() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_i2s_sck(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.AudioConfig)
  return target;
}

size_t ModuleConfig_AudioConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.AudioConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool codec2_enabled = 1;
  if (this->_internal_codec2_enabled() != 0) {
    total_size += 1 + 1;
  }

  // uint32 ptt_pin = 2;
  if (this->_internal_ptt_pin() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ptt_pin());
  }

  // .meshtastic.ModuleConfig.AudioConfig.Audio_Baud bitrate = 3;
  if (this->_internal_bitrate() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_bitrate());
  }

  // uint32 i2s_ws = 4;
  if (this->_internal_i2s_ws() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i2s_ws());
  }

  // uint32 i2s_sd = 5;
  if (this->_internal_i2s_sd() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i2s_sd());
  }

  // uint32 i2s_din = 6;
  if (this->_internal_i2s_din() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i2s_din());
  }

  // uint32 i2s_sck = 7;
  if (this->_internal_i2s_sck() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i2s_sck());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_AudioConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_AudioConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_AudioConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_AudioConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_AudioConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_AudioConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.AudioConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_codec2_enabled() != 0) {
    _this->_internal_set_codec2_enabled(from._internal_codec2_enabled());
  }
  if (from._internal_ptt_pin() != 0) {
    _this->_internal_set_ptt_pin(from._internal_ptt_pin());
  }
  if (from._internal_bitrate() != 0) {
    _this->_internal_set_bitrate(from._internal_bitrate());
  }
  if (from._internal_i2s_ws() != 0) {
    _this->_internal_set_i2s_ws(from._internal_i2s_ws());
  }
  if (from._internal_i2s_sd() != 0) {
    _this->_internal_set_i2s_sd(from._internal_i2s_sd());
  }
  if (from._internal_i2s_din() != 0) {
    _this->_internal_set_i2s_din(from._internal_i2s_din());
  }
  if (from._internal_i2s_sck() != 0) {
    _this->_internal_set_i2s_sck(from._internal_i2s_sck());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_AudioConfig::CopyFrom(const ModuleConfig_AudioConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.AudioConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_AudioConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_AudioConfig::InternalSwap(ModuleConfig_AudioConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_AudioConfig, _impl_.i2s_sck_)
      + sizeof(ModuleConfig_AudioConfig::_impl_.i2s_sck_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_AudioConfig, _impl_.codec2_enabled_)>(
          reinterpret_cast<char*>(&_impl_.codec2_enabled_),
          reinterpret_cast<char*>(&other->_impl_.codec2_enabled_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_AudioConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[5]);
}

// ===================================================================

class ModuleConfig_PaxcounterConfig::_Internal {
 public:
};

ModuleConfig_PaxcounterConfig::ModuleConfig_PaxcounterConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.PaxcounterConfig)
}
ModuleConfig_PaxcounterConfig::ModuleConfig_PaxcounterConfig(const ModuleConfig_PaxcounterConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_PaxcounterConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.enabled_){}
    , decltype(_impl_.paxcounter_update_interval_){}
    , decltype(_impl_.wifi_threshold_){}
    , decltype(_impl_.ble_threshold_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.enabled_, &from._impl_.enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ble_threshold_) -
    reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.ble_threshold_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.PaxcounterConfig)
}

inline void ModuleConfig_PaxcounterConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.enabled_){false}
    , decltype(_impl_.paxcounter_update_interval_){0u}
    , decltype(_impl_.wifi_threshold_){0}
    , decltype(_impl_.ble_threshold_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleConfig_PaxcounterConfig::~ModuleConfig_PaxcounterConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.PaxcounterConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_PaxcounterConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModuleConfig_PaxcounterConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_PaxcounterConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.PaxcounterConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ble_threshold_) -
      reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.ble_threshold_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_PaxcounterConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 paxcounter_update_interval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.paxcounter_update_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 wifi_threshold = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.wifi_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 ble_threshold = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.ble_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_PaxcounterConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.PaxcounterConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // uint32 paxcounter_update_interval = 2;
  if (this->_internal_paxcounter_update_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_paxcounter_update_interval(), target);
  }

  // int32 wifi_threshold = 3;
  if (this->_internal_wifi_threshold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_wifi_threshold(), target);
  }

  // int32 ble_threshold = 4;
  if (this->_internal_ble_threshold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_ble_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.PaxcounterConfig)
  return target;
}

size_t ModuleConfig_PaxcounterConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.PaxcounterConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    total_size += 1 + 1;
  }

  // uint32 paxcounter_update_interval = 2;
  if (this->_internal_paxcounter_update_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_paxcounter_update_interval());
  }

  // int32 wifi_threshold = 3;
  if (this->_internal_wifi_threshold() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_wifi_threshold());
  }

  // int32 ble_threshold = 4;
  if (this->_internal_ble_threshold() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ble_threshold());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_PaxcounterConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_PaxcounterConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_PaxcounterConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_PaxcounterConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_PaxcounterConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_PaxcounterConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.PaxcounterConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_enabled() != 0) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  if (from._internal_paxcounter_update_interval() != 0) {
    _this->_internal_set_paxcounter_update_interval(from._internal_paxcounter_update_interval());
  }
  if (from._internal_wifi_threshold() != 0) {
    _this->_internal_set_wifi_threshold(from._internal_wifi_threshold());
  }
  if (from._internal_ble_threshold() != 0) {
    _this->_internal_set_ble_threshold(from._internal_ble_threshold());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_PaxcounterConfig::CopyFrom(const ModuleConfig_PaxcounterConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.PaxcounterConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_PaxcounterConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_PaxcounterConfig::InternalSwap(ModuleConfig_PaxcounterConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_PaxcounterConfig, _impl_.ble_threshold_)
      + sizeof(ModuleConfig_PaxcounterConfig::_impl_.ble_threshold_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_PaxcounterConfig, _impl_.enabled_)>(
          reinterpret_cast<char*>(&_impl_.enabled_),
          reinterpret_cast<char*>(&other->_impl_.enabled_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_PaxcounterConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[6]);
}

// ===================================================================

class ModuleConfig_SerialConfig::_Internal {
 public:
};

ModuleConfig_SerialConfig::ModuleConfig_SerialConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.SerialConfig)
}
ModuleConfig_SerialConfig::ModuleConfig_SerialConfig(const ModuleConfig_SerialConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_SerialConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rxd_){}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.echo_){}
    , decltype(_impl_.override_console_serial_port_){}
    , decltype(_impl_.txd_){}
    , decltype(_impl_.baud_){}
    , decltype(_impl_.timeout_){}
    , decltype(_impl_.mode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.rxd_, &from._impl_.rxd_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mode_) -
    reinterpret_cast<char*>(&_impl_.rxd_)) + sizeof(_impl_.mode_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.SerialConfig)
}

inline void ModuleConfig_SerialConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.rxd_){0u}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.echo_){false}
    , decltype(_impl_.override_console_serial_port_){false}
    , decltype(_impl_.txd_){0u}
    , decltype(_impl_.baud_){0}
    , decltype(_impl_.timeout_){0u}
    , decltype(_impl_.mode_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleConfig_SerialConfig::~ModuleConfig_SerialConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.SerialConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_SerialConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModuleConfig_SerialConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_SerialConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.SerialConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.rxd_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.mode_) -
      reinterpret_cast<char*>(&_impl_.rxd_)) + sizeof(_impl_.mode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_SerialConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool echo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.echo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 rxd = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.rxd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 txd = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.txd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.SerialConfig.Serial_Baud baud = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_baud(static_cast<::meshtastic::ModuleConfig_SerialConfig_Serial_Baud>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 timeout = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.SerialConfig.Serial_Mode mode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::meshtastic::ModuleConfig_SerialConfig_Serial_Mode>(val));
        } else
          goto handle_unusual;
        continue;
      // bool override_console_serial_port = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.override_console_serial_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_SerialConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.SerialConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // bool echo = 2;
  if (this->_internal_echo() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_echo(), target);
  }

  // uint32 rxd = 3;
  if (this->_internal_rxd() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rxd(), target);
  }

  // uint32 txd = 4;
  if (this->_internal_txd() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_txd(), target);
  }

  // .meshtastic.ModuleConfig.SerialConfig.Serial_Baud baud = 5;
  if (this->_internal_baud() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_baud(), target);
  }

  // uint32 timeout = 6;
  if (this->_internal_timeout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_timeout(), target);
  }

  // .meshtastic.ModuleConfig.SerialConfig.Serial_Mode mode = 7;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_mode(), target);
  }

  // bool override_console_serial_port = 8;
  if (this->_internal_override_console_serial_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_override_console_serial_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.SerialConfig)
  return target;
}

size_t ModuleConfig_SerialConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.SerialConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 rxd = 3;
  if (this->_internal_rxd() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rxd());
  }

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool echo = 2;
  if (this->_internal_echo() != 0) {
    total_size += 1 + 1;
  }

  // bool override_console_serial_port = 8;
  if (this->_internal_override_console_serial_port() != 0) {
    total_size += 1 + 1;
  }

  // uint32 txd = 4;
  if (this->_internal_txd() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_txd());
  }

  // .meshtastic.ModuleConfig.SerialConfig.Serial_Baud baud = 5;
  if (this->_internal_baud() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_baud());
  }

  // uint32 timeout = 6;
  if (this->_internal_timeout() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timeout());
  }

  // .meshtastic.ModuleConfig.SerialConfig.Serial_Mode mode = 7;
  if (this->_internal_mode() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_SerialConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_SerialConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_SerialConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_SerialConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_SerialConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_SerialConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.SerialConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_rxd() != 0) {
    _this->_internal_set_rxd(from._internal_rxd());
  }
  if (from._internal_enabled() != 0) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  if (from._internal_echo() != 0) {
    _this->_internal_set_echo(from._internal_echo());
  }
  if (from._internal_override_console_serial_port() != 0) {
    _this->_internal_set_override_console_serial_port(from._internal_override_console_serial_port());
  }
  if (from._internal_txd() != 0) {
    _this->_internal_set_txd(from._internal_txd());
  }
  if (from._internal_baud() != 0) {
    _this->_internal_set_baud(from._internal_baud());
  }
  if (from._internal_timeout() != 0) {
    _this->_internal_set_timeout(from._internal_timeout());
  }
  if (from._internal_mode() != 0) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_SerialConfig::CopyFrom(const ModuleConfig_SerialConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.SerialConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_SerialConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_SerialConfig::InternalSwap(ModuleConfig_SerialConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_SerialConfig, _impl_.mode_)
      + sizeof(ModuleConfig_SerialConfig::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_SerialConfig, _impl_.rxd_)>(
          reinterpret_cast<char*>(&_impl_.rxd_),
          reinterpret_cast<char*>(&other->_impl_.rxd_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_SerialConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[7]);
}

// ===================================================================

class ModuleConfig_ExternalNotificationConfig::_Internal {
 public:
};

ModuleConfig_ExternalNotificationConfig::ModuleConfig_ExternalNotificationConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.ExternalNotificationConfig)
}
ModuleConfig_ExternalNotificationConfig::ModuleConfig_ExternalNotificationConfig(const ModuleConfig_ExternalNotificationConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_ExternalNotificationConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.output_ms_){}
    , decltype(_impl_.output_){}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.active_){}
    , decltype(_impl_.alert_message_){}
    , decltype(_impl_.alert_message_vibra_){}
    , decltype(_impl_.output_vibra_){}
    , decltype(_impl_.output_buzzer_){}
    , decltype(_impl_.alert_message_buzzer_){}
    , decltype(_impl_.alert_bell_){}
    , decltype(_impl_.alert_bell_vibra_){}
    , decltype(_impl_.alert_bell_buzzer_){}
    , decltype(_impl_.use_pwm_){}
    , decltype(_impl_.use_i2s_as_buzzer_){}
    , decltype(_impl_.nag_timeout_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.output_ms_, &from._impl_.output_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nag_timeout_) -
    reinterpret_cast<char*>(&_impl_.output_ms_)) + sizeof(_impl_.nag_timeout_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.ExternalNotificationConfig)
}

inline void ModuleConfig_ExternalNotificationConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.output_ms_){0u}
    , decltype(_impl_.output_){0u}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.active_){false}
    , decltype(_impl_.alert_message_){false}
    , decltype(_impl_.alert_message_vibra_){false}
    , decltype(_impl_.output_vibra_){0u}
    , decltype(_impl_.output_buzzer_){0u}
    , decltype(_impl_.alert_message_buzzer_){false}
    , decltype(_impl_.alert_bell_){false}
    , decltype(_impl_.alert_bell_vibra_){false}
    , decltype(_impl_.alert_bell_buzzer_){false}
    , decltype(_impl_.use_pwm_){false}
    , decltype(_impl_.use_i2s_as_buzzer_){false}
    , decltype(_impl_.nag_timeout_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleConfig_ExternalNotificationConfig::~ModuleConfig_ExternalNotificationConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.ExternalNotificationConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_ExternalNotificationConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModuleConfig_ExternalNotificationConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_ExternalNotificationConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.ExternalNotificationConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.output_ms_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nag_timeout_) -
      reinterpret_cast<char*>(&_impl_.output_ms_)) + sizeof(_impl_.nag_timeout_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_ExternalNotificationConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 output_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.output_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 output = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.output_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool active = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool alert_message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.alert_message_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool alert_bell = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.alert_bell_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool use_pwm = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.use_pwm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 output_vibra = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.output_vibra_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 output_buzzer = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.output_buzzer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool alert_message_vibra = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.alert_message_vibra_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool alert_message_buzzer = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.alert_message_buzzer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool alert_bell_vibra = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.alert_bell_vibra_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool alert_bell_buzzer = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.alert_bell_buzzer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nag_timeout = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.nag_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool use_i2s_as_buzzer = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.use_i2s_as_buzzer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_ExternalNotificationConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.ExternalNotificationConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // uint32 output_ms = 2;
  if (this->_internal_output_ms() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_output_ms(), target);
  }

  // uint32 output = 3;
  if (this->_internal_output() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_output(), target);
  }

  // bool active = 4;
  if (this->_internal_active() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_active(), target);
  }

  // bool alert_message = 5;
  if (this->_internal_alert_message() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_alert_message(), target);
  }

  // bool alert_bell = 6;
  if (this->_internal_alert_bell() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_alert_bell(), target);
  }

  // bool use_pwm = 7;
  if (this->_internal_use_pwm() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_use_pwm(), target);
  }

  // uint32 output_vibra = 8;
  if (this->_internal_output_vibra() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_output_vibra(), target);
  }

  // uint32 output_buzzer = 9;
  if (this->_internal_output_buzzer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_output_buzzer(), target);
  }

  // bool alert_message_vibra = 10;
  if (this->_internal_alert_message_vibra() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_alert_message_vibra(), target);
  }

  // bool alert_message_buzzer = 11;
  if (this->_internal_alert_message_buzzer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_alert_message_buzzer(), target);
  }

  // bool alert_bell_vibra = 12;
  if (this->_internal_alert_bell_vibra() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_alert_bell_vibra(), target);
  }

  // bool alert_bell_buzzer = 13;
  if (this->_internal_alert_bell_buzzer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_alert_bell_buzzer(), target);
  }

  // uint32 nag_timeout = 14;
  if (this->_internal_nag_timeout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_nag_timeout(), target);
  }

  // bool use_i2s_as_buzzer = 15;
  if (this->_internal_use_i2s_as_buzzer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_use_i2s_as_buzzer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.ExternalNotificationConfig)
  return target;
}

size_t ModuleConfig_ExternalNotificationConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.ExternalNotificationConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 output_ms = 2;
  if (this->_internal_output_ms() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_output_ms());
  }

  // uint32 output = 3;
  if (this->_internal_output() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_output());
  }

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool active = 4;
  if (this->_internal_active() != 0) {
    total_size += 1 + 1;
  }

  // bool alert_message = 5;
  if (this->_internal_alert_message() != 0) {
    total_size += 1 + 1;
  }

  // bool alert_message_vibra = 10;
  if (this->_internal_alert_message_vibra() != 0) {
    total_size += 1 + 1;
  }

  // uint32 output_vibra = 8;
  if (this->_internal_output_vibra() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_output_vibra());
  }

  // uint32 output_buzzer = 9;
  if (this->_internal_output_buzzer() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_output_buzzer());
  }

  // bool alert_message_buzzer = 11;
  if (this->_internal_alert_message_buzzer() != 0) {
    total_size += 1 + 1;
  }

  // bool alert_bell = 6;
  if (this->_internal_alert_bell() != 0) {
    total_size += 1 + 1;
  }

  // bool alert_bell_vibra = 12;
  if (this->_internal_alert_bell_vibra() != 0) {
    total_size += 1 + 1;
  }

  // bool alert_bell_buzzer = 13;
  if (this->_internal_alert_bell_buzzer() != 0) {
    total_size += 1 + 1;
  }

  // bool use_pwm = 7;
  if (this->_internal_use_pwm() != 0) {
    total_size += 1 + 1;
  }

  // bool use_i2s_as_buzzer = 15;
  if (this->_internal_use_i2s_as_buzzer() != 0) {
    total_size += 1 + 1;
  }

  // uint32 nag_timeout = 14;
  if (this->_internal_nag_timeout() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nag_timeout());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_ExternalNotificationConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_ExternalNotificationConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_ExternalNotificationConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_ExternalNotificationConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_ExternalNotificationConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_ExternalNotificationConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.ExternalNotificationConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_output_ms() != 0) {
    _this->_internal_set_output_ms(from._internal_output_ms());
  }
  if (from._internal_output() != 0) {
    _this->_internal_set_output(from._internal_output());
  }
  if (from._internal_enabled() != 0) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  if (from._internal_active() != 0) {
    _this->_internal_set_active(from._internal_active());
  }
  if (from._internal_alert_message() != 0) {
    _this->_internal_set_alert_message(from._internal_alert_message());
  }
  if (from._internal_alert_message_vibra() != 0) {
    _this->_internal_set_alert_message_vibra(from._internal_alert_message_vibra());
  }
  if (from._internal_output_vibra() != 0) {
    _this->_internal_set_output_vibra(from._internal_output_vibra());
  }
  if (from._internal_output_buzzer() != 0) {
    _this->_internal_set_output_buzzer(from._internal_output_buzzer());
  }
  if (from._internal_alert_message_buzzer() != 0) {
    _this->_internal_set_alert_message_buzzer(from._internal_alert_message_buzzer());
  }
  if (from._internal_alert_bell() != 0) {
    _this->_internal_set_alert_bell(from._internal_alert_bell());
  }
  if (from._internal_alert_bell_vibra() != 0) {
    _this->_internal_set_alert_bell_vibra(from._internal_alert_bell_vibra());
  }
  if (from._internal_alert_bell_buzzer() != 0) {
    _this->_internal_set_alert_bell_buzzer(from._internal_alert_bell_buzzer());
  }
  if (from._internal_use_pwm() != 0) {
    _this->_internal_set_use_pwm(from._internal_use_pwm());
  }
  if (from._internal_use_i2s_as_buzzer() != 0) {
    _this->_internal_set_use_i2s_as_buzzer(from._internal_use_i2s_as_buzzer());
  }
  if (from._internal_nag_timeout() != 0) {
    _this->_internal_set_nag_timeout(from._internal_nag_timeout());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_ExternalNotificationConfig::CopyFrom(const ModuleConfig_ExternalNotificationConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.ExternalNotificationConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_ExternalNotificationConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_ExternalNotificationConfig::InternalSwap(ModuleConfig_ExternalNotificationConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_ExternalNotificationConfig, _impl_.nag_timeout_)
      + sizeof(ModuleConfig_ExternalNotificationConfig::_impl_.nag_timeout_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_ExternalNotificationConfig, _impl_.output_ms_)>(
          reinterpret_cast<char*>(&_impl_.output_ms_),
          reinterpret_cast<char*>(&other->_impl_.output_ms_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_ExternalNotificationConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[8]);
}

// ===================================================================

class ModuleConfig_StoreForwardConfig::_Internal {
 public:
};

ModuleConfig_StoreForwardConfig::ModuleConfig_StoreForwardConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.StoreForwardConfig)
}
ModuleConfig_StoreForwardConfig::ModuleConfig_StoreForwardConfig(const ModuleConfig_StoreForwardConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_StoreForwardConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.records_){}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.heartbeat_){}
    , decltype(_impl_.is_server_){}
    , decltype(_impl_.history_return_max_){}
    , decltype(_impl_.history_return_window_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.records_, &from._impl_.records_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.history_return_window_) -
    reinterpret_cast<char*>(&_impl_.records_)) + sizeof(_impl_.history_return_window_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.StoreForwardConfig)
}

inline void ModuleConfig_StoreForwardConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.records_){0u}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.heartbeat_){false}
    , decltype(_impl_.is_server_){false}
    , decltype(_impl_.history_return_max_){0u}
    , decltype(_impl_.history_return_window_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleConfig_StoreForwardConfig::~ModuleConfig_StoreForwardConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.StoreForwardConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_StoreForwardConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModuleConfig_StoreForwardConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_StoreForwardConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.StoreForwardConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.records_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.history_return_window_) -
      reinterpret_cast<char*>(&_impl_.records_)) + sizeof(_impl_.history_return_window_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_StoreForwardConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool heartbeat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.heartbeat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 records = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.records_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 history_return_max = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.history_return_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 history_return_window = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.history_return_window_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_server = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.is_server_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_StoreForwardConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.StoreForwardConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // bool heartbeat = 2;
  if (this->_internal_heartbeat() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_heartbeat(), target);
  }

  // uint32 records = 3;
  if (this->_internal_records() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_records(), target);
  }

  // uint32 history_return_max = 4;
  if (this->_internal_history_return_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_history_return_max(), target);
  }

  // uint32 history_return_window = 5;
  if (this->_internal_history_return_window() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_history_return_window(), target);
  }

  // bool is_server = 6;
  if (this->_internal_is_server() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_server(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.StoreForwardConfig)
  return target;
}

size_t ModuleConfig_StoreForwardConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.StoreForwardConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 records = 3;
  if (this->_internal_records() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_records());
  }

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool heartbeat = 2;
  if (this->_internal_heartbeat() != 0) {
    total_size += 1 + 1;
  }

  // bool is_server = 6;
  if (this->_internal_is_server() != 0) {
    total_size += 1 + 1;
  }

  // uint32 history_return_max = 4;
  if (this->_internal_history_return_max() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_history_return_max());
  }

  // uint32 history_return_window = 5;
  if (this->_internal_history_return_window() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_history_return_window());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_StoreForwardConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_StoreForwardConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_StoreForwardConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_StoreForwardConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_StoreForwardConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_StoreForwardConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.StoreForwardConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_records() != 0) {
    _this->_internal_set_records(from._internal_records());
  }
  if (from._internal_enabled() != 0) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  if (from._internal_heartbeat() != 0) {
    _this->_internal_set_heartbeat(from._internal_heartbeat());
  }
  if (from._internal_is_server() != 0) {
    _this->_internal_set_is_server(from._internal_is_server());
  }
  if (from._internal_history_return_max() != 0) {
    _this->_internal_set_history_return_max(from._internal_history_return_max());
  }
  if (from._internal_history_return_window() != 0) {
    _this->_internal_set_history_return_window(from._internal_history_return_window());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_StoreForwardConfig::CopyFrom(const ModuleConfig_StoreForwardConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.StoreForwardConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_StoreForwardConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_StoreForwardConfig::InternalSwap(ModuleConfig_StoreForwardConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_StoreForwardConfig, _impl_.history_return_window_)
      + sizeof(ModuleConfig_StoreForwardConfig::_impl_.history_return_window_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_StoreForwardConfig, _impl_.records_)>(
          reinterpret_cast<char*>(&_impl_.records_),
          reinterpret_cast<char*>(&other->_impl_.records_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_StoreForwardConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[9]);
}

// ===================================================================

class ModuleConfig_RangeTestConfig::_Internal {
 public:
};

ModuleConfig_RangeTestConfig::ModuleConfig_RangeTestConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.RangeTestConfig)
}
ModuleConfig_RangeTestConfig::ModuleConfig_RangeTestConfig(const ModuleConfig_RangeTestConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_RangeTestConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sender_){}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.save_){}
    , decltype(_impl_.clear_on_reboot_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.sender_, &from._impl_.sender_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clear_on_reboot_) -
    reinterpret_cast<char*>(&_impl_.sender_)) + sizeof(_impl_.clear_on_reboot_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.RangeTestConfig)
}

inline void ModuleConfig_RangeTestConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sender_){0u}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.save_){false}
    , decltype(_impl_.clear_on_reboot_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleConfig_RangeTestConfig::~ModuleConfig_RangeTestConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.RangeTestConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_RangeTestConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModuleConfig_RangeTestConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_RangeTestConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.RangeTestConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.sender_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.clear_on_reboot_) -
      reinterpret_cast<char*>(&_impl_.sender_)) + sizeof(_impl_.clear_on_reboot_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_RangeTestConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sender = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.sender_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool save = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.save_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool clear_on_reboot = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.clear_on_reboot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_RangeTestConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.RangeTestConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // uint32 sender = 2;
  if (this->_internal_sender() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sender(), target);
  }

  // bool save = 3;
  if (this->_internal_save() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_save(), target);
  }

  // bool clear_on_reboot = 4;
  if (this->_internal_clear_on_reboot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_clear_on_reboot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.RangeTestConfig)
  return target;
}

size_t ModuleConfig_RangeTestConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.RangeTestConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 sender = 2;
  if (this->_internal_sender() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sender());
  }

  // bool enabled = 1;
  if (this->_internal_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool save = 3;
  if (this->_internal_save() != 0) {
    total_size += 1 + 1;
  }

  // bool clear_on_reboot = 4;
  if (this->_internal_clear_on_reboot() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_RangeTestConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_RangeTestConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_RangeTestConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_RangeTestConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_RangeTestConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_RangeTestConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.RangeTestConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_sender() != 0) {
    _this->_internal_set_sender(from._internal_sender());
  }
  if (from._internal_enabled() != 0) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  if (from._internal_save() != 0) {
    _this->_internal_set_save(from._internal_save());
  }
  if (from._internal_clear_on_reboot() != 0) {
    _this->_internal_set_clear_on_reboot(from._internal_clear_on_reboot());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_RangeTestConfig::CopyFrom(const ModuleConfig_RangeTestConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.RangeTestConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_RangeTestConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_RangeTestConfig::InternalSwap(ModuleConfig_RangeTestConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_RangeTestConfig, _impl_.clear_on_reboot_)
      + sizeof(ModuleConfig_RangeTestConfig::_impl_.clear_on_reboot_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_RangeTestConfig, _impl_.sender_)>(
          reinterpret_cast<char*>(&_impl_.sender_),
          reinterpret_cast<char*>(&other->_impl_.sender_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_RangeTestConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[10]);
}

// ===================================================================

class ModuleConfig_TelemetryConfig::_Internal {
 public:
};

ModuleConfig_TelemetryConfig::ModuleConfig_TelemetryConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.TelemetryConfig)
}
ModuleConfig_TelemetryConfig::ModuleConfig_TelemetryConfig(const ModuleConfig_TelemetryConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_TelemetryConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.device_update_interval_){}
    , decltype(_impl_.environment_update_interval_){}
    , decltype(_impl_.environment_measurement_enabled_){}
    , decltype(_impl_.environment_screen_enabled_){}
    , decltype(_impl_.environment_display_fahrenheit_){}
    , decltype(_impl_.air_quality_enabled_){}
    , decltype(_impl_.air_quality_interval_){}
    , decltype(_impl_.power_update_interval_){}
    , decltype(_impl_.power_measurement_enabled_){}
    , decltype(_impl_.power_screen_enabled_){}
    , decltype(_impl_.health_measurement_enabled_){}
    , decltype(_impl_.health_screen_enabled_){}
    , decltype(_impl_.health_update_interval_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.device_update_interval_, &from._impl_.device_update_interval_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.health_update_interval_) -
    reinterpret_cast<char*>(&_impl_.device_update_interval_)) + sizeof(_impl_.health_update_interval_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.TelemetryConfig)
}

inline void ModuleConfig_TelemetryConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.device_update_interval_){0u}
    , decltype(_impl_.environment_update_interval_){0u}
    , decltype(_impl_.environment_measurement_enabled_){false}
    , decltype(_impl_.environment_screen_enabled_){false}
    , decltype(_impl_.environment_display_fahrenheit_){false}
    , decltype(_impl_.air_quality_enabled_){false}
    , decltype(_impl_.air_quality_interval_){0u}
    , decltype(_impl_.power_update_interval_){0u}
    , decltype(_impl_.power_measurement_enabled_){false}
    , decltype(_impl_.power_screen_enabled_){false}
    , decltype(_impl_.health_measurement_enabled_){false}
    , decltype(_impl_.health_screen_enabled_){false}
    , decltype(_impl_.health_update_interval_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleConfig_TelemetryConfig::~ModuleConfig_TelemetryConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.TelemetryConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_TelemetryConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModuleConfig_TelemetryConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_TelemetryConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.TelemetryConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.device_update_interval_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.health_update_interval_) -
      reinterpret_cast<char*>(&_impl_.device_update_interval_)) + sizeof(_impl_.health_update_interval_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_TelemetryConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 device_update_interval = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.device_update_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 environment_update_interval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.environment_update_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool environment_measurement_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.environment_measurement_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool environment_screen_enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.environment_screen_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool environment_display_fahrenheit = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.environment_display_fahrenheit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool air_quality_enabled = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.air_quality_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 air_quality_interval = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.air_quality_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool power_measurement_enabled = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.power_measurement_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 power_update_interval = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.power_update_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool power_screen_enabled = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.power_screen_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool health_measurement_enabled = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.health_measurement_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 health_update_interval = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.health_update_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool health_screen_enabled = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.health_screen_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_TelemetryConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.TelemetryConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 device_update_interval = 1;
  if (this->_internal_device_update_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_device_update_interval(), target);
  }

  // uint32 environment_update_interval = 2;
  if (this->_internal_environment_update_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_environment_update_interval(), target);
  }

  // bool environment_measurement_enabled = 3;
  if (this->_internal_environment_measurement_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_environment_measurement_enabled(), target);
  }

  // bool environment_screen_enabled = 4;
  if (this->_internal_environment_screen_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_environment_screen_enabled(), target);
  }

  // bool environment_display_fahrenheit = 5;
  if (this->_internal_environment_display_fahrenheit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_environment_display_fahrenheit(), target);
  }

  // bool air_quality_enabled = 6;
  if (this->_internal_air_quality_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_air_quality_enabled(), target);
  }

  // uint32 air_quality_interval = 7;
  if (this->_internal_air_quality_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_air_quality_interval(), target);
  }

  // bool power_measurement_enabled = 8;
  if (this->_internal_power_measurement_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_power_measurement_enabled(), target);
  }

  // uint32 power_update_interval = 9;
  if (this->_internal_power_update_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_power_update_interval(), target);
  }

  // bool power_screen_enabled = 10;
  if (this->_internal_power_screen_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_power_screen_enabled(), target);
  }

  // bool health_measurement_enabled = 11;
  if (this->_internal_health_measurement_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_health_measurement_enabled(), target);
  }

  // uint32 health_update_interval = 12;
  if (this->_internal_health_update_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_health_update_interval(), target);
  }

  // bool health_screen_enabled = 13;
  if (this->_internal_health_screen_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_health_screen_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.TelemetryConfig)
  return target;
}

size_t ModuleConfig_TelemetryConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.TelemetryConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 device_update_interval = 1;
  if (this->_internal_device_update_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_device_update_interval());
  }

  // uint32 environment_update_interval = 2;
  if (this->_internal_environment_update_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_environment_update_interval());
  }

  // bool environment_measurement_enabled = 3;
  if (this->_internal_environment_measurement_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool environment_screen_enabled = 4;
  if (this->_internal_environment_screen_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool environment_display_fahrenheit = 5;
  if (this->_internal_environment_display_fahrenheit() != 0) {
    total_size += 1 + 1;
  }

  // bool air_quality_enabled = 6;
  if (this->_internal_air_quality_enabled() != 0) {
    total_size += 1 + 1;
  }

  // uint32 air_quality_interval = 7;
  if (this->_internal_air_quality_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_air_quality_interval());
  }

  // uint32 power_update_interval = 9;
  if (this->_internal_power_update_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_power_update_interval());
  }

  // bool power_measurement_enabled = 8;
  if (this->_internal_power_measurement_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool power_screen_enabled = 10;
  if (this->_internal_power_screen_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool health_measurement_enabled = 11;
  if (this->_internal_health_measurement_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool health_screen_enabled = 13;
  if (this->_internal_health_screen_enabled() != 0) {
    total_size += 1 + 1;
  }

  // uint32 health_update_interval = 12;
  if (this->_internal_health_update_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_health_update_interval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_TelemetryConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_TelemetryConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_TelemetryConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_TelemetryConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_TelemetryConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_TelemetryConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.TelemetryConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_device_update_interval() != 0) {
    _this->_internal_set_device_update_interval(from._internal_device_update_interval());
  }
  if (from._internal_environment_update_interval() != 0) {
    _this->_internal_set_environment_update_interval(from._internal_environment_update_interval());
  }
  if (from._internal_environment_measurement_enabled() != 0) {
    _this->_internal_set_environment_measurement_enabled(from._internal_environment_measurement_enabled());
  }
  if (from._internal_environment_screen_enabled() != 0) {
    _this->_internal_set_environment_screen_enabled(from._internal_environment_screen_enabled());
  }
  if (from._internal_environment_display_fahrenheit() != 0) {
    _this->_internal_set_environment_display_fahrenheit(from._internal_environment_display_fahrenheit());
  }
  if (from._internal_air_quality_enabled() != 0) {
    _this->_internal_set_air_quality_enabled(from._internal_air_quality_enabled());
  }
  if (from._internal_air_quality_interval() != 0) {
    _this->_internal_set_air_quality_interval(from._internal_air_quality_interval());
  }
  if (from._internal_power_update_interval() != 0) {
    _this->_internal_set_power_update_interval(from._internal_power_update_interval());
  }
  if (from._internal_power_measurement_enabled() != 0) {
    _this->_internal_set_power_measurement_enabled(from._internal_power_measurement_enabled());
  }
  if (from._internal_power_screen_enabled() != 0) {
    _this->_internal_set_power_screen_enabled(from._internal_power_screen_enabled());
  }
  if (from._internal_health_measurement_enabled() != 0) {
    _this->_internal_set_health_measurement_enabled(from._internal_health_measurement_enabled());
  }
  if (from._internal_health_screen_enabled() != 0) {
    _this->_internal_set_health_screen_enabled(from._internal_health_screen_enabled());
  }
  if (from._internal_health_update_interval() != 0) {
    _this->_internal_set_health_update_interval(from._internal_health_update_interval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_TelemetryConfig::CopyFrom(const ModuleConfig_TelemetryConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.TelemetryConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_TelemetryConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_TelemetryConfig::InternalSwap(ModuleConfig_TelemetryConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_TelemetryConfig, _impl_.health_update_interval_)
      + sizeof(ModuleConfig_TelemetryConfig::_impl_.health_update_interval_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_TelemetryConfig, _impl_.device_update_interval_)>(
          reinterpret_cast<char*>(&_impl_.device_update_interval_),
          reinterpret_cast<char*>(&other->_impl_.device_update_interval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_TelemetryConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[11]);
}

// ===================================================================

class ModuleConfig_CannedMessageConfig::_Internal {
 public:
};

ModuleConfig_CannedMessageConfig::ModuleConfig_CannedMessageConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.CannedMessageConfig)
}
ModuleConfig_CannedMessageConfig::ModuleConfig_CannedMessageConfig(const ModuleConfig_CannedMessageConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_CannedMessageConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.allow_input_source_){}
    , decltype(_impl_.inputbroker_pin_a_){}
    , decltype(_impl_.inputbroker_pin_b_){}
    , decltype(_impl_.inputbroker_pin_press_){}
    , decltype(_impl_.inputbroker_event_cw_){}
    , decltype(_impl_.inputbroker_event_ccw_){}
    , decltype(_impl_.inputbroker_event_press_){}
    , decltype(_impl_.rotary1_enabled_){}
    , decltype(_impl_.updown1_enabled_){}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.send_bell_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.allow_input_source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allow_input_source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_allow_input_source().empty()) {
    _this->_impl_.allow_input_source_.Set(from._internal_allow_input_source(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.inputbroker_pin_a_, &from._impl_.inputbroker_pin_a_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.send_bell_) -
    reinterpret_cast<char*>(&_impl_.inputbroker_pin_a_)) + sizeof(_impl_.send_bell_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.CannedMessageConfig)
}

inline void ModuleConfig_CannedMessageConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.allow_input_source_){}
    , decltype(_impl_.inputbroker_pin_a_){0u}
    , decltype(_impl_.inputbroker_pin_b_){0u}
    , decltype(_impl_.inputbroker_pin_press_){0u}
    , decltype(_impl_.inputbroker_event_cw_){0}
    , decltype(_impl_.inputbroker_event_ccw_){0}
    , decltype(_impl_.inputbroker_event_press_){0}
    , decltype(_impl_.rotary1_enabled_){false}
    , decltype(_impl_.updown1_enabled_){false}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.send_bell_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.allow_input_source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allow_input_source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModuleConfig_CannedMessageConfig::~ModuleConfig_CannedMessageConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.CannedMessageConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_CannedMessageConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allow_input_source_.Destroy();
}

void ModuleConfig_CannedMessageConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_CannedMessageConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.CannedMessageConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allow_input_source_.ClearToEmpty();
  ::memset(&_impl_.inputbroker_pin_a_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.send_bell_) -
      reinterpret_cast<char*>(&_impl_.inputbroker_pin_a_)) + sizeof(_impl_.send_bell_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_CannedMessageConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool rotary1_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.rotary1_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 inputbroker_pin_a = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.inputbroker_pin_a_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 inputbroker_pin_b = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.inputbroker_pin_b_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 inputbroker_pin_press = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.inputbroker_pin_press_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_cw = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_inputbroker_event_cw(static_cast<::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar>(val));
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_ccw = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_inputbroker_event_ccw(static_cast<::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar>(val));
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_press = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_inputbroker_event_press(static_cast<::meshtastic::ModuleConfig_CannedMessageConfig_InputEventChar>(val));
        } else
          goto handle_unusual;
        continue;
      // bool updown1_enabled = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.updown1_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool enabled = 9 [deprecated = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string allow_input_source = 10 [deprecated = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_allow_input_source();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.ModuleConfig.CannedMessageConfig.allow_input_source"));
        } else
          goto handle_unusual;
        continue;
      // bool send_bell = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.send_bell_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_CannedMessageConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.CannedMessageConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool rotary1_enabled = 1;
  if (this->_internal_rotary1_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_rotary1_enabled(), target);
  }

  // uint32 inputbroker_pin_a = 2;
  if (this->_internal_inputbroker_pin_a() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_inputbroker_pin_a(), target);
  }

  // uint32 inputbroker_pin_b = 3;
  if (this->_internal_inputbroker_pin_b() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_inputbroker_pin_b(), target);
  }

  // uint32 inputbroker_pin_press = 4;
  if (this->_internal_inputbroker_pin_press() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_inputbroker_pin_press(), target);
  }

  // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_cw = 5;
  if (this->_internal_inputbroker_event_cw() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_inputbroker_event_cw(), target);
  }

  // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_ccw = 6;
  if (this->_internal_inputbroker_event_ccw() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_inputbroker_event_ccw(), target);
  }

  // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_press = 7;
  if (this->_internal_inputbroker_event_press() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_inputbroker_event_press(), target);
  }

  // bool updown1_enabled = 8;
  if (this->_internal_updown1_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_updown1_enabled(), target);
  }

  // bool enabled = 9 [deprecated = true];
  if (this->_internal_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_enabled(), target);
  }

  // string allow_input_source = 10 [deprecated = true];
  if (!this->_internal_allow_input_source().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_allow_input_source().data(), static_cast<int>(this->_internal_allow_input_source().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.ModuleConfig.CannedMessageConfig.allow_input_source");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_allow_input_source(), target);
  }

  // bool send_bell = 11;
  if (this->_internal_send_bell() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_send_bell(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.CannedMessageConfig)
  return target;
}

size_t ModuleConfig_CannedMessageConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.CannedMessageConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string allow_input_source = 10 [deprecated = true];
  if (!this->_internal_allow_input_source().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_allow_input_source());
  }

  // uint32 inputbroker_pin_a = 2;
  if (this->_internal_inputbroker_pin_a() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_inputbroker_pin_a());
  }

  // uint32 inputbroker_pin_b = 3;
  if (this->_internal_inputbroker_pin_b() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_inputbroker_pin_b());
  }

  // uint32 inputbroker_pin_press = 4;
  if (this->_internal_inputbroker_pin_press() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_inputbroker_pin_press());
  }

  // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_cw = 5;
  if (this->_internal_inputbroker_event_cw() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_inputbroker_event_cw());
  }

  // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_ccw = 6;
  if (this->_internal_inputbroker_event_ccw() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_inputbroker_event_ccw());
  }

  // .meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar inputbroker_event_press = 7;
  if (this->_internal_inputbroker_event_press() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_inputbroker_event_press());
  }

  // bool rotary1_enabled = 1;
  if (this->_internal_rotary1_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool updown1_enabled = 8;
  if (this->_internal_updown1_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool enabled = 9 [deprecated = true];
  if (this->_internal_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool send_bell = 11;
  if (this->_internal_send_bell() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_CannedMessageConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_CannedMessageConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_CannedMessageConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_CannedMessageConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_CannedMessageConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_CannedMessageConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.CannedMessageConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_allow_input_source().empty()) {
    _this->_internal_set_allow_input_source(from._internal_allow_input_source());
  }
  if (from._internal_inputbroker_pin_a() != 0) {
    _this->_internal_set_inputbroker_pin_a(from._internal_inputbroker_pin_a());
  }
  if (from._internal_inputbroker_pin_b() != 0) {
    _this->_internal_set_inputbroker_pin_b(from._internal_inputbroker_pin_b());
  }
  if (from._internal_inputbroker_pin_press() != 0) {
    _this->_internal_set_inputbroker_pin_press(from._internal_inputbroker_pin_press());
  }
  if (from._internal_inputbroker_event_cw() != 0) {
    _this->_internal_set_inputbroker_event_cw(from._internal_inputbroker_event_cw());
  }
  if (from._internal_inputbroker_event_ccw() != 0) {
    _this->_internal_set_inputbroker_event_ccw(from._internal_inputbroker_event_ccw());
  }
  if (from._internal_inputbroker_event_press() != 0) {
    _this->_internal_set_inputbroker_event_press(from._internal_inputbroker_event_press());
  }
  if (from._internal_rotary1_enabled() != 0) {
    _this->_internal_set_rotary1_enabled(from._internal_rotary1_enabled());
  }
  if (from._internal_updown1_enabled() != 0) {
    _this->_internal_set_updown1_enabled(from._internal_updown1_enabled());
  }
  if (from._internal_enabled() != 0) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  if (from._internal_send_bell() != 0) {
    _this->_internal_set_send_bell(from._internal_send_bell());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_CannedMessageConfig::CopyFrom(const ModuleConfig_CannedMessageConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.CannedMessageConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_CannedMessageConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_CannedMessageConfig::InternalSwap(ModuleConfig_CannedMessageConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.allow_input_source_, lhs_arena,
      &other->_impl_.allow_input_source_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_CannedMessageConfig, _impl_.send_bell_)
      + sizeof(ModuleConfig_CannedMessageConfig::_impl_.send_bell_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_CannedMessageConfig, _impl_.inputbroker_pin_a_)>(
          reinterpret_cast<char*>(&_impl_.inputbroker_pin_a_),
          reinterpret_cast<char*>(&other->_impl_.inputbroker_pin_a_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_CannedMessageConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[12]);
}

// ===================================================================

class ModuleConfig_AmbientLightingConfig::_Internal {
 public:
};

ModuleConfig_AmbientLightingConfig::ModuleConfig_AmbientLightingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig.AmbientLightingConfig)
}
ModuleConfig_AmbientLightingConfig::ModuleConfig_AmbientLightingConfig(const ModuleConfig_AmbientLightingConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig_AmbientLightingConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.led_state_){}
    , decltype(_impl_.current_){}
    , decltype(_impl_.red_){}
    , decltype(_impl_.green_){}
    , decltype(_impl_.blue_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.led_state_, &from._impl_.led_state_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blue_) -
    reinterpret_cast<char*>(&_impl_.led_state_)) + sizeof(_impl_.blue_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig.AmbientLightingConfig)
}

inline void ModuleConfig_AmbientLightingConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.led_state_){false}
    , decltype(_impl_.current_){0u}
    , decltype(_impl_.red_){0u}
    , decltype(_impl_.green_){0u}
    , decltype(_impl_.blue_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModuleConfig_AmbientLightingConfig::~ModuleConfig_AmbientLightingConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig.AmbientLightingConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig_AmbientLightingConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModuleConfig_AmbientLightingConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig_AmbientLightingConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig.AmbientLightingConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.led_state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.blue_) -
      reinterpret_cast<char*>(&_impl_.led_state_)) + sizeof(_impl_.blue_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig_AmbientLightingConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool led_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.led_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 current = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.current_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 red = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.red_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 green = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.green_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 blue = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.blue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig_AmbientLightingConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig.AmbientLightingConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool led_state = 1;
  if (this->_internal_led_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_led_state(), target);
  }

  // uint32 current = 2;
  if (this->_internal_current() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_current(), target);
  }

  // uint32 red = 3;
  if (this->_internal_red() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_red(), target);
  }

  // uint32 green = 4;
  if (this->_internal_green() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_green(), target);
  }

  // uint32 blue = 5;
  if (this->_internal_blue() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_blue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig.AmbientLightingConfig)
  return target;
}

size_t ModuleConfig_AmbientLightingConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig.AmbientLightingConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool led_state = 1;
  if (this->_internal_led_state() != 0) {
    total_size += 1 + 1;
  }

  // uint32 current = 2;
  if (this->_internal_current() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current());
  }

  // uint32 red = 3;
  if (this->_internal_red() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_red());
  }

  // uint32 green = 4;
  if (this->_internal_green() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_green());
  }

  // uint32 blue = 5;
  if (this->_internal_blue() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blue());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig_AmbientLightingConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig_AmbientLightingConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig_AmbientLightingConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig_AmbientLightingConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig_AmbientLightingConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig_AmbientLightingConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig.AmbientLightingConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_led_state() != 0) {
    _this->_internal_set_led_state(from._internal_led_state());
  }
  if (from._internal_current() != 0) {
    _this->_internal_set_current(from._internal_current());
  }
  if (from._internal_red() != 0) {
    _this->_internal_set_red(from._internal_red());
  }
  if (from._internal_green() != 0) {
    _this->_internal_set_green(from._internal_green());
  }
  if (from._internal_blue() != 0) {
    _this->_internal_set_blue(from._internal_blue());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig_AmbientLightingConfig::CopyFrom(const ModuleConfig_AmbientLightingConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig.AmbientLightingConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig_AmbientLightingConfig::IsInitialized() const {
  return true;
}

void ModuleConfig_AmbientLightingConfig::InternalSwap(ModuleConfig_AmbientLightingConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModuleConfig_AmbientLightingConfig, _impl_.blue_)
      + sizeof(ModuleConfig_AmbientLightingConfig::_impl_.blue_)
      - PROTOBUF_FIELD_OFFSET(ModuleConfig_AmbientLightingConfig, _impl_.led_state_)>(
          reinterpret_cast<char*>(&_impl_.led_state_),
          reinterpret_cast<char*>(&other->_impl_.led_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig_AmbientLightingConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[13]);
}

// ===================================================================

class ModuleConfig::_Internal {
 public:
  static const ::meshtastic::ModuleConfig_MQTTConfig& mqtt(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_SerialConfig& serial(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_ExternalNotificationConfig& external_notification(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_StoreForwardConfig& store_forward(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_RangeTestConfig& range_test(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_TelemetryConfig& telemetry(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_CannedMessageConfig& canned_message(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_AudioConfig& audio(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_RemoteHardwareConfig& remote_hardware(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_NeighborInfoConfig& neighbor_info(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_AmbientLightingConfig& ambient_lighting(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_DetectionSensorConfig& detection_sensor(const ModuleConfig* msg);
  static const ::meshtastic::ModuleConfig_PaxcounterConfig& paxcounter(const ModuleConfig* msg);
};

const ::meshtastic::ModuleConfig_MQTTConfig&
ModuleConfig::_Internal::mqtt(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.mqtt_;
}
const ::meshtastic::ModuleConfig_SerialConfig&
ModuleConfig::_Internal::serial(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.serial_;
}
const ::meshtastic::ModuleConfig_ExternalNotificationConfig&
ModuleConfig::_Internal::external_notification(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.external_notification_;
}
const ::meshtastic::ModuleConfig_StoreForwardConfig&
ModuleConfig::_Internal::store_forward(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.store_forward_;
}
const ::meshtastic::ModuleConfig_RangeTestConfig&
ModuleConfig::_Internal::range_test(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.range_test_;
}
const ::meshtastic::ModuleConfig_TelemetryConfig&
ModuleConfig::_Internal::telemetry(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.telemetry_;
}
const ::meshtastic::ModuleConfig_CannedMessageConfig&
ModuleConfig::_Internal::canned_message(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.canned_message_;
}
const ::meshtastic::ModuleConfig_AudioConfig&
ModuleConfig::_Internal::audio(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.audio_;
}
const ::meshtastic::ModuleConfig_RemoteHardwareConfig&
ModuleConfig::_Internal::remote_hardware(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.remote_hardware_;
}
const ::meshtastic::ModuleConfig_NeighborInfoConfig&
ModuleConfig::_Internal::neighbor_info(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.neighbor_info_;
}
const ::meshtastic::ModuleConfig_AmbientLightingConfig&
ModuleConfig::_Internal::ambient_lighting(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.ambient_lighting_;
}
const ::meshtastic::ModuleConfig_DetectionSensorConfig&
ModuleConfig::_Internal::detection_sensor(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.detection_sensor_;
}
const ::meshtastic::ModuleConfig_PaxcounterConfig&
ModuleConfig::_Internal::paxcounter(const ModuleConfig* msg) {
  return *msg->_impl_.payload_variant_.paxcounter_;
}
void ModuleConfig::set_allocated_mqtt(::meshtastic::ModuleConfig_MQTTConfig* mqtt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (mqtt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mqtt);
    if (message_arena != submessage_arena) {
      mqtt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mqtt, submessage_arena);
    }
    set_has_mqtt();
    _impl_.payload_variant_.mqtt_ = mqtt;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.mqtt)
}
void ModuleConfig::set_allocated_serial(::meshtastic::ModuleConfig_SerialConfig* serial) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (serial) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(serial);
    if (message_arena != submessage_arena) {
      serial = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, serial, submessage_arena);
    }
    set_has_serial();
    _impl_.payload_variant_.serial_ = serial;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.serial)
}
void ModuleConfig::set_allocated_external_notification(::meshtastic::ModuleConfig_ExternalNotificationConfig* external_notification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (external_notification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_notification);
    if (message_arena != submessage_arena) {
      external_notification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_notification, submessage_arena);
    }
    set_has_external_notification();
    _impl_.payload_variant_.external_notification_ = external_notification;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.external_notification)
}
void ModuleConfig::set_allocated_store_forward(::meshtastic::ModuleConfig_StoreForwardConfig* store_forward) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (store_forward) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(store_forward);
    if (message_arena != submessage_arena) {
      store_forward = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store_forward, submessage_arena);
    }
    set_has_store_forward();
    _impl_.payload_variant_.store_forward_ = store_forward;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.store_forward)
}
void ModuleConfig::set_allocated_range_test(::meshtastic::ModuleConfig_RangeTestConfig* range_test) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (range_test) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(range_test);
    if (message_arena != submessage_arena) {
      range_test = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range_test, submessage_arena);
    }
    set_has_range_test();
    _impl_.payload_variant_.range_test_ = range_test;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.range_test)
}
void ModuleConfig::set_allocated_telemetry(::meshtastic::ModuleConfig_TelemetryConfig* telemetry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (telemetry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(telemetry);
    if (message_arena != submessage_arena) {
      telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, telemetry, submessage_arena);
    }
    set_has_telemetry();
    _impl_.payload_variant_.telemetry_ = telemetry;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.telemetry)
}
void ModuleConfig::set_allocated_canned_message(::meshtastic::ModuleConfig_CannedMessageConfig* canned_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (canned_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(canned_message);
    if (message_arena != submessage_arena) {
      canned_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, canned_message, submessage_arena);
    }
    set_has_canned_message();
    _impl_.payload_variant_.canned_message_ = canned_message;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.canned_message)
}
void ModuleConfig::set_allocated_audio(::meshtastic::ModuleConfig_AudioConfig* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    set_has_audio();
    _impl_.payload_variant_.audio_ = audio;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.audio)
}
void ModuleConfig::set_allocated_remote_hardware(::meshtastic::ModuleConfig_RemoteHardwareConfig* remote_hardware) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (remote_hardware) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remote_hardware);
    if (message_arena != submessage_arena) {
      remote_hardware = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remote_hardware, submessage_arena);
    }
    set_has_remote_hardware();
    _impl_.payload_variant_.remote_hardware_ = remote_hardware;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.remote_hardware)
}
void ModuleConfig::set_allocated_neighbor_info(::meshtastic::ModuleConfig_NeighborInfoConfig* neighbor_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (neighbor_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neighbor_info);
    if (message_arena != submessage_arena) {
      neighbor_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neighbor_info, submessage_arena);
    }
    set_has_neighbor_info();
    _impl_.payload_variant_.neighbor_info_ = neighbor_info;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.neighbor_info)
}
void ModuleConfig::set_allocated_ambient_lighting(::meshtastic::ModuleConfig_AmbientLightingConfig* ambient_lighting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (ambient_lighting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ambient_lighting);
    if (message_arena != submessage_arena) {
      ambient_lighting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ambient_lighting, submessage_arena);
    }
    set_has_ambient_lighting();
    _impl_.payload_variant_.ambient_lighting_ = ambient_lighting;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.ambient_lighting)
}
void ModuleConfig::set_allocated_detection_sensor(::meshtastic::ModuleConfig_DetectionSensorConfig* detection_sensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (detection_sensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(detection_sensor);
    if (message_arena != submessage_arena) {
      detection_sensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detection_sensor, submessage_arena);
    }
    set_has_detection_sensor();
    _impl_.payload_variant_.detection_sensor_ = detection_sensor;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.detection_sensor)
}
void ModuleConfig::set_allocated_paxcounter(::meshtastic::ModuleConfig_PaxcounterConfig* paxcounter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_variant();
  if (paxcounter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paxcounter);
    if (message_arena != submessage_arena) {
      paxcounter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paxcounter, submessage_arena);
    }
    set_has_paxcounter();
    _impl_.payload_variant_.paxcounter_ = paxcounter;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ModuleConfig.paxcounter)
}
ModuleConfig::ModuleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ModuleConfig)
}
ModuleConfig::ModuleConfig(const ModuleConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModuleConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_payload_variant();
  switch (from.payload_variant_case()) {
    case kMqtt: {
      _this->_internal_mutable_mqtt()->::meshtastic::ModuleConfig_MQTTConfig::MergeFrom(
          from._internal_mqtt());
      break;
    }
    case kSerial: {
      _this->_internal_mutable_serial()->::meshtastic::ModuleConfig_SerialConfig::MergeFrom(
          from._internal_serial());
      break;
    }
    case kExternalNotification: {
      _this->_internal_mutable_external_notification()->::meshtastic::ModuleConfig_ExternalNotificationConfig::MergeFrom(
          from._internal_external_notification());
      break;
    }
    case kStoreForward: {
      _this->_internal_mutable_store_forward()->::meshtastic::ModuleConfig_StoreForwardConfig::MergeFrom(
          from._internal_store_forward());
      break;
    }
    case kRangeTest: {
      _this->_internal_mutable_range_test()->::meshtastic::ModuleConfig_RangeTestConfig::MergeFrom(
          from._internal_range_test());
      break;
    }
    case kTelemetry: {
      _this->_internal_mutable_telemetry()->::meshtastic::ModuleConfig_TelemetryConfig::MergeFrom(
          from._internal_telemetry());
      break;
    }
    case kCannedMessage: {
      _this->_internal_mutable_canned_message()->::meshtastic::ModuleConfig_CannedMessageConfig::MergeFrom(
          from._internal_canned_message());
      break;
    }
    case kAudio: {
      _this->_internal_mutable_audio()->::meshtastic::ModuleConfig_AudioConfig::MergeFrom(
          from._internal_audio());
      break;
    }
    case kRemoteHardware: {
      _this->_internal_mutable_remote_hardware()->::meshtastic::ModuleConfig_RemoteHardwareConfig::MergeFrom(
          from._internal_remote_hardware());
      break;
    }
    case kNeighborInfo: {
      _this->_internal_mutable_neighbor_info()->::meshtastic::ModuleConfig_NeighborInfoConfig::MergeFrom(
          from._internal_neighbor_info());
      break;
    }
    case kAmbientLighting: {
      _this->_internal_mutable_ambient_lighting()->::meshtastic::ModuleConfig_AmbientLightingConfig::MergeFrom(
          from._internal_ambient_lighting());
      break;
    }
    case kDetectionSensor: {
      _this->_internal_mutable_detection_sensor()->::meshtastic::ModuleConfig_DetectionSensorConfig::MergeFrom(
          from._internal_detection_sensor());
      break;
    }
    case kPaxcounter: {
      _this->_internal_mutable_paxcounter()->::meshtastic::ModuleConfig_PaxcounterConfig::MergeFrom(
          from._internal_paxcounter());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:meshtastic.ModuleConfig)
}

inline void ModuleConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_variant_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload_variant();
}

ModuleConfig::~ModuleConfig() {
  // @@protoc_insertion_point(destructor:meshtastic.ModuleConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModuleConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload_variant()) {
    clear_payload_variant();
  }
}

void ModuleConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModuleConfig::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.ModuleConfig)
  switch (payload_variant_case()) {
    case kMqtt: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.mqtt_;
      }
      break;
    }
    case kSerial: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.serial_;
      }
      break;
    }
    case kExternalNotification: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.external_notification_;
      }
      break;
    }
    case kStoreForward: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.store_forward_;
      }
      break;
    }
    case kRangeTest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.range_test_;
      }
      break;
    }
    case kTelemetry: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.telemetry_;
      }
      break;
    }
    case kCannedMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.canned_message_;
      }
      break;
    }
    case kAudio: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.audio_;
      }
      break;
    }
    case kRemoteHardware: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.remote_hardware_;
      }
      break;
    }
    case kNeighborInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.neighbor_info_;
      }
      break;
    }
    case kAmbientLighting: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.ambient_lighting_;
      }
      break;
    }
    case kDetectionSensor: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.detection_sensor_;
      }
      break;
    }
    case kPaxcounter: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_variant_.paxcounter_;
      }
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


void ModuleConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ModuleConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_payload_variant();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModuleConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .meshtastic.ModuleConfig.MQTTConfig mqtt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_mqtt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.SerialConfig serial = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_serial(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.ExternalNotificationConfig external_notification = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_external_notification(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.StoreForwardConfig store_forward = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_store_forward(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.RangeTestConfig range_test = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_range_test(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.TelemetryConfig telemetry = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_telemetry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.CannedMessageConfig canned_message = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_canned_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.AudioConfig audio = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.RemoteHardwareConfig remote_hardware = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_remote_hardware(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.NeighborInfoConfig neighbor_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_neighbor_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.AmbientLightingConfig ambient_lighting = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_ambient_lighting(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.DetectionSensorConfig detection_sensor = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_detection_sensor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.ModuleConfig.PaxcounterConfig paxcounter = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_paxcounter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModuleConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ModuleConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .meshtastic.ModuleConfig.MQTTConfig mqtt = 1;
  if (_internal_has_mqtt()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::mqtt(this),
        _Internal::mqtt(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.SerialConfig serial = 2;
  if (_internal_has_serial()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::serial(this),
        _Internal::serial(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.ExternalNotificationConfig external_notification = 3;
  if (_internal_has_external_notification()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::external_notification(this),
        _Internal::external_notification(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.StoreForwardConfig store_forward = 4;
  if (_internal_has_store_forward()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::store_forward(this),
        _Internal::store_forward(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.RangeTestConfig range_test = 5;
  if (_internal_has_range_test()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::range_test(this),
        _Internal::range_test(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.TelemetryConfig telemetry = 6;
  if (_internal_has_telemetry()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::telemetry(this),
        _Internal::telemetry(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.CannedMessageConfig canned_message = 7;
  if (_internal_has_canned_message()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::canned_message(this),
        _Internal::canned_message(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.AudioConfig audio = 8;
  if (_internal_has_audio()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::audio(this),
        _Internal::audio(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.RemoteHardwareConfig remote_hardware = 9;
  if (_internal_has_remote_hardware()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::remote_hardware(this),
        _Internal::remote_hardware(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.NeighborInfoConfig neighbor_info = 10;
  if (_internal_has_neighbor_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::neighbor_info(this),
        _Internal::neighbor_info(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.AmbientLightingConfig ambient_lighting = 11;
  if (_internal_has_ambient_lighting()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::ambient_lighting(this),
        _Internal::ambient_lighting(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.DetectionSensorConfig detection_sensor = 12;
  if (_internal_has_detection_sensor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::detection_sensor(this),
        _Internal::detection_sensor(this).GetCachedSize(), target, stream);
  }

  // .meshtastic.ModuleConfig.PaxcounterConfig paxcounter = 13;
  if (_internal_has_paxcounter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::paxcounter(this),
        _Internal::paxcounter(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ModuleConfig)
  return target;
}

size_t ModuleConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.ModuleConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (payload_variant_case()) {
    // .meshtastic.ModuleConfig.MQTTConfig mqtt = 1;
    case kMqtt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.mqtt_);
      break;
    }
    // .meshtastic.ModuleConfig.SerialConfig serial = 2;
    case kSerial: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.serial_);
      break;
    }
    // .meshtastic.ModuleConfig.ExternalNotificationConfig external_notification = 3;
    case kExternalNotification: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.external_notification_);
      break;
    }
    // .meshtastic.ModuleConfig.StoreForwardConfig store_forward = 4;
    case kStoreForward: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.store_forward_);
      break;
    }
    // .meshtastic.ModuleConfig.RangeTestConfig range_test = 5;
    case kRangeTest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.range_test_);
      break;
    }
    // .meshtastic.ModuleConfig.TelemetryConfig telemetry = 6;
    case kTelemetry: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.telemetry_);
      break;
    }
    // .meshtastic.ModuleConfig.CannedMessageConfig canned_message = 7;
    case kCannedMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.canned_message_);
      break;
    }
    // .meshtastic.ModuleConfig.AudioConfig audio = 8;
    case kAudio: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.audio_);
      break;
    }
    // .meshtastic.ModuleConfig.RemoteHardwareConfig remote_hardware = 9;
    case kRemoteHardware: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.remote_hardware_);
      break;
    }
    // .meshtastic.ModuleConfig.NeighborInfoConfig neighbor_info = 10;
    case kNeighborInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.neighbor_info_);
      break;
    }
    // .meshtastic.ModuleConfig.AmbientLightingConfig ambient_lighting = 11;
    case kAmbientLighting: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.ambient_lighting_);
      break;
    }
    // .meshtastic.ModuleConfig.DetectionSensorConfig detection_sensor = 12;
    case kDetectionSensor: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.detection_sensor_);
      break;
    }
    // .meshtastic.ModuleConfig.PaxcounterConfig paxcounter = 13;
    case kPaxcounter: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_variant_.paxcounter_);
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModuleConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModuleConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModuleConfig::GetClassData() const { return &_class_data_; }


void ModuleConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModuleConfig*>(&to_msg);
  auto& from = static_cast<const ModuleConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ModuleConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.payload_variant_case()) {
    case kMqtt: {
      _this->_internal_mutable_mqtt()->::meshtastic::ModuleConfig_MQTTConfig::MergeFrom(
          from._internal_mqtt());
      break;
    }
    case kSerial: {
      _this->_internal_mutable_serial()->::meshtastic::ModuleConfig_SerialConfig::MergeFrom(
          from._internal_serial());
      break;
    }
    case kExternalNotification: {
      _this->_internal_mutable_external_notification()->::meshtastic::ModuleConfig_ExternalNotificationConfig::MergeFrom(
          from._internal_external_notification());
      break;
    }
    case kStoreForward: {
      _this->_internal_mutable_store_forward()->::meshtastic::ModuleConfig_StoreForwardConfig::MergeFrom(
          from._internal_store_forward());
      break;
    }
    case kRangeTest: {
      _this->_internal_mutable_range_test()->::meshtastic::ModuleConfig_RangeTestConfig::MergeFrom(
          from._internal_range_test());
      break;
    }
    case kTelemetry: {
      _this->_internal_mutable_telemetry()->::meshtastic::ModuleConfig_TelemetryConfig::MergeFrom(
          from._internal_telemetry());
      break;
    }
    case kCannedMessage: {
      _this->_internal_mutable_canned_message()->::meshtastic::ModuleConfig_CannedMessageConfig::MergeFrom(
          from._internal_canned_message());
      break;
    }
    case kAudio: {
      _this->_internal_mutable_audio()->::meshtastic::ModuleConfig_AudioConfig::MergeFrom(
          from._internal_audio());
      break;
    }
    case kRemoteHardware: {
      _this->_internal_mutable_remote_hardware()->::meshtastic::ModuleConfig_RemoteHardwareConfig::MergeFrom(
          from._internal_remote_hardware());
      break;
    }
    case kNeighborInfo: {
      _this->_internal_mutable_neighbor_info()->::meshtastic::ModuleConfig_NeighborInfoConfig::MergeFrom(
          from._internal_neighbor_info());
      break;
    }
    case kAmbientLighting: {
      _this->_internal_mutable_ambient_lighting()->::meshtastic::ModuleConfig_AmbientLightingConfig::MergeFrom(
          from._internal_ambient_lighting());
      break;
    }
    case kDetectionSensor: {
      _this->_internal_mutable_detection_sensor()->::meshtastic::ModuleConfig_DetectionSensorConfig::MergeFrom(
          from._internal_detection_sensor());
      break;
    }
    case kPaxcounter: {
      _this->_internal_mutable_paxcounter()->::meshtastic::ModuleConfig_PaxcounterConfig::MergeFrom(
          from._internal_paxcounter());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModuleConfig::CopyFrom(const ModuleConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ModuleConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleConfig::IsInitialized() const {
  return true;
}

void ModuleConfig::InternalSwap(ModuleConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModuleConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[14]);
}

// ===================================================================

class RemoteHardwarePin::_Internal {
 public:
};

RemoteHardwarePin::RemoteHardwarePin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:meshtastic.RemoteHardwarePin)
}
RemoteHardwarePin::RemoteHardwarePin(const RemoteHardwarePin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoteHardwarePin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.gpio_pin_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.gpio_pin_, &from._impl_.gpio_pin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.gpio_pin_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:meshtastic.RemoteHardwarePin)
}

inline void RemoteHardwarePin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.gpio_pin_){0u}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RemoteHardwarePin::~RemoteHardwarePin() {
  // @@protoc_insertion_point(destructor:meshtastic.RemoteHardwarePin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoteHardwarePin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void RemoteHardwarePin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoteHardwarePin::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.RemoteHardwarePin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.gpio_pin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.gpio_pin_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoteHardwarePin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 gpio_pin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.gpio_pin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "meshtastic.RemoteHardwarePin.name"));
        } else
          goto handle_unusual;
        continue;
      // .meshtastic.RemoteHardwarePinType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::meshtastic::RemoteHardwarePinType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoteHardwarePin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.RemoteHardwarePin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 gpio_pin = 1;
  if (this->_internal_gpio_pin() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gpio_pin(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "meshtastic.RemoteHardwarePin.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // .meshtastic.RemoteHardwarePinType type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.RemoteHardwarePin)
  return target;
}

size_t RemoteHardwarePin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:meshtastic.RemoteHardwarePin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // uint32 gpio_pin = 1;
  if (this->_internal_gpio_pin() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gpio_pin());
  }

  // .meshtastic.RemoteHardwarePinType type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoteHardwarePin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoteHardwarePin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoteHardwarePin::GetClassData() const { return &_class_data_; }


void RemoteHardwarePin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoteHardwarePin*>(&to_msg);
  auto& from = static_cast<const RemoteHardwarePin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.RemoteHardwarePin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_gpio_pin() != 0) {
    _this->_internal_set_gpio_pin(from._internal_gpio_pin());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoteHardwarePin::CopyFrom(const RemoteHardwarePin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.RemoteHardwarePin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteHardwarePin::IsInitialized() const {
  return true;
}

void RemoteHardwarePin::InternalSwap(RemoteHardwarePin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoteHardwarePin, _impl_.type_)
      + sizeof(RemoteHardwarePin::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(RemoteHardwarePin, _impl_.gpio_pin_)>(
          reinterpret_cast<char*>(&_impl_.gpio_pin_),
          reinterpret_cast<char*>(&other->_impl_.gpio_pin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoteHardwarePin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_getter, &descriptor_table_meshtastic_2fmodule_5fconfig_2eproto_once,
      file_level_metadata_meshtastic_2fmodule_5fconfig_2eproto[15]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace meshtastic
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_MQTTConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_MQTTConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_MQTTConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_MapReportSettings*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_MapReportSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_MapReportSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_RemoteHardwareConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_RemoteHardwareConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_RemoteHardwareConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_NeighborInfoConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_NeighborInfoConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_NeighborInfoConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_DetectionSensorConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_DetectionSensorConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_DetectionSensorConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_AudioConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_AudioConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_AudioConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_PaxcounterConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_PaxcounterConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_PaxcounterConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_SerialConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_SerialConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_SerialConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_ExternalNotificationConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_ExternalNotificationConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_ExternalNotificationConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_StoreForwardConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_StoreForwardConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_StoreForwardConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_RangeTestConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_RangeTestConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_RangeTestConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_TelemetryConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_TelemetryConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_TelemetryConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_CannedMessageConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_CannedMessageConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_CannedMessageConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig_AmbientLightingConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig_AmbientLightingConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig_AmbientLightingConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::ModuleConfig*
Arena::CreateMaybeMessage< ::meshtastic::ModuleConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::ModuleConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::meshtastic::RemoteHardwarePin*
Arena::CreateMaybeMessage< ::meshtastic::RemoteHardwarePin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::meshtastic::RemoteHardwarePin >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
